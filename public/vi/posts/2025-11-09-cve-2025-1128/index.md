# CVE-2025-1128 Analysis & POC


<!--more-->

## CVE & Basic Info
Plugin **Everest Forms – Contact Forms, Quiz, Survey, Newsletter & Payment Form Builder** cho **WordPress** dễ bị tấn công **arbitrary file upload, read, and deletion** do thiếu **file type** và **path validation** trong phương thức `format` của class `EVF_Form_Fields_Upload` ở tất cả các phiên bản đến và bao gồm **3.0.9.4**. Điều này cho phép **unauthenticated attackers** có thể **upload, read, và delete arbitrary files** trên server của site bị ảnh hưởng, dẫn đến khả năng **remote code execution**, **sensitive information disclosure**, hoặc **site takeover**.

* **CVE ID**: [CVE-2025-1128](https://www.cve.org/CVERecord?id=CVE-2025-1128)
* **Vulnerability Type**: Arbitrary File Upload
* **Affected Versions**: <= 3.0.9.4
* **Patched Versions**: 3.0.9.5
* **CVSS severity**: High (9.8)
* **Required Privilege**: Unauthenticated
* **Product**: [WordPress Everest Forms Plugin](https://wordpress.org/plugins/everest-forms/)

## Requirements

* **Local WordPress & Debugging**
    * [Virtual Machine](https://w41bu1.github.io/posts/2025-08-21-wordpress-local-and-debugging/)
    * [Docker](https://w41bu1.github.io/posts/2025-10-22-wordpress-local-and-debugging-docker/)
* **Plugin Version** - **Everest Forms**:  
    * `3.0.9.4` – **vulnerable**  
    * `3.0.9.5` – **patched**
* **Diff Tool (diff)** → [**Meld**](https://meldmerge.org/) hoặc bất kỳ công cụ diff nào.

## Cause

Lỗ hổng này do việc kiểm tra kiểu tệp và đường dẫn tệp chưa đủ nghiêm ngặt trong hàm `format` của lớp `EVF _Form_Fields_Upload`. Ngay cả khi tệp có định dạng không hợp lệ, quá trình tải lên vẫn có thể thành công, nên bằng cách sửa một vài nội dung trong dữ liệu/giao tiếp gửi lên, có thể né được việc xác thực phía máy chủ.

```php {title="class-evf-form-fields-upload.php - v3.0.9.4" hl_lines=[3,7,8,9,10] data-open=true}
public function format( $field_id, $field_submit, $form_data, $meta_key ) {
    ...
    $wp_filetype = wp_check_filetype_and_ext( $file['tmp_path'], $file['name'] );
    $ext             = empty( $wp_filetype['ext'] ) ? '' : $wp_filetype['ext'];
    $type            = empty( $wp_filetype['type'] ) ? '' : $wp_filetype['type'];
    $proper_filename = empty( $wp_filetype['proper_filename'] ) ? '' : $wp_filetype['proper_filename'];
    if ( $proper_filename || ! $ext || ! $type ) {
        evf()->task->errors[ $form_data['id'] ][ $field_id ] = esc_html__( 'File type is not allowed.', 'everest-forms' );
        update_option( 'evf_validation_error', 'yes' );
    }
    ...
    // upload file handler
}
```

Hàm `wp_check_filetype_and_ext()` sẽ trả về `$ext` và `$type` **rỗng** nếu file upload không hợp lệ (không nằm trong [whilelist](https://developer.wordpress.org/reference/functions/wp_get_mime_types/) của WordPress).

Sau khi dòng `8-9` được thực thi, không có cơ chế nào để dừng chương trình khiến chương trình tiếp tục thực thi upload file.

Bản vá đã thực hiện điều này bằng cách gọi hàm [wp_die()](https://developer.wordpress.org/reference/functions/wp_die/)

```php {title="class-evf-form-fields-upload.php - v3.0.9.5" hl_lines=[10] data-open=true}
public function format( $field_id, $field_submit, $form_data, $meta_key ) {
    ...
    $wp_filetype = wp_check_filetype_and_ext( $file['tmp_path'], $file['name'] );
    $ext             = empty( $wp_filetype['ext'] ) ? '' : $wp_filetype['ext'];
    $type            = empty( $wp_filetype['type'] ) ? '' : $wp_filetype['type'];
    $proper_filename = empty( $wp_filetype['proper_filename'] ) ? '' : $wp_filetype['proper_filename'];
    if ( $proper_filename || ! $ext || ! $type ) {
        evf()->task->errors[ $form_data['id'] ][ $field_id ] = esc_html__( 'File type is not allowed.', 'everest-forms' );
        update_option( 'evf_validation_error', 'yes' );
        wp_die( 'File type is not allowed' );
    }
    ...
    // upload file handler
}
```

## Code Analysis

```php {title="class-evf-form-fields-upload.php - v3.0.9.4" hl_lines=[6] data-open=true}
public function format( $field_id, $field_submit, $form_data, $meta_key ) {
    // Setup class properties to reuse everywhere.
    $this->form_data  = (array) $form_data;
    $this->form_id    = absint( $this->form_data['id'] );
    $this->field_id   = $field_id;
    $this->field_data = $this->form_data['form_fields'][ $this->field_id ];

    $field_label = ! empty( $this->form_data['form_fields'][ $this->field_id ]['label'] ) ? $this->form_data['form_fields'][ $this->field_id ]['label'] : '';
    $input_name  = sprintf( 'everest_forms_%d_%s', $this->form_id, $this->field_id );
    // Make sure json_decode() doesn't fail on newer PHP.
    try {
        $raw_files = json_decode( wp_unslash( $_POST[ $input_name ] ), true ); // phpcs:ignore WordPress.Security
    } catch ( Exception $e ) {
        evf()->task->form_fields[ $this->field_id ] = $processed;
        return;
    }

    // Make sure we process only submitted files with the expected structure and keys.
    $files = array_filter(
        $raw_files,
        static function ( $file ) {
            return ( is_array( $file ) || is_object( $file ) && count( $file ) === 2 ) && ! empty( $file['file'] ) && ! empty( $file['name'] );
        }
    );

    if ( empty( $files ) ) {
        evf()->task->form_fields[ $this->field_id ] = $processed;
        return;
    }

    $data = array();

    foreach ( $files as $file ) {
        $file = $this->generate_file_info( $file );

        $wp_filetype = wp_check_filetype_and_ext( $file['tmp_path'], $file['name'] );

        $ext             = empty( $wp_filetype['ext'] ) ? '' : $wp_filetype['ext'];
        $type            = empty( $wp_filetype['type'] ) ? '' : $wp_filetype['type'];
        $proper_filename = empty( $wp_filetype['proper_filename'] ) ? '' : $wp_filetype['proper_filename'];

        if ( $proper_filename || ! $ext || ! $type ) {
            evf()->task->errors[ $form_data['id'] ][ $field_id ] = esc_html__( 'File type is not allowed.', 'everest-forms' );
            update_option( 'evf_validation_error', 'yes' );
        }

        // Allow third-party integrations.
        if ( has_filter( 'everest_forms_integration_uploads' ) ) {
            $file = apply_filters( 'everest_forms_integration_uploads', $file, $this->form_data );
        }

        if ( $this->is_media_integrated() ) {
            $file['path'] = $file['tmp_path'];

            $file = $this->generate_file_attachment( $file );
        } elseif (
                ! isset( $file['external'] )
                && file_exists( $file['tmp_path'] )
            ) {

                $this->create_dir( dirname( $file['path'] ) );
                @rename( $file['tmp_path'] , $file['path'] ); // phpcs:ignore WordPress.PHP.NoSilencedErrors.Discouraged
                $this->set_file_fs_permissions( $file['path'] );
        }

        $data[] = $this->generate_file_data( $file );
    }
    ...
}
```

Plugin này được tạo ra nhằm mục địch tạo form template và sử dụng chúng trong post/page. Vì lỗ hổng liên quan đến việc **upload file**, nên ta tạo form với field **File Upload** và nhúng nó vào post

![Create Form](create_form.png "Tạo form với field **File Upload**")

Upload file file bất kì và bắt lại bằng BurpSuite (Việc upload file cũng dành cho anonymous user khi truy cập post/page được nhúng form)

![Snap Request](snap_request.png "Bắt request fileupload bằng BurpSuite")

Đặt break point đến hàm `format()` và quan sát

![Input Name](input_name.png "$input_name trong debugger")

Theo kết quả debug `$input_name` là tên trường ánh xạ đến mảng chứa JSON data `file` và `name`

Dữ liệu này được decode JSON và gán cho mảng `$raw_files`

```php
try {
    $raw_files = json_decode( wp_unslash( $_POST[ $input_name ] ), true ); // phpcs:ignore WordPress.Security
} catch ( Exception $e ) {
    evf()->task->form_fields[ $this->field_id ] = $processed;
    return;
}
```

![Raw Files](raw_files.png "$raw_files trong debugger")

```php
$files = array_filter(
    $raw_files,
    static function ( $file ) {
        return ( is_array( $file ) || is_object( $file ) && count( $file ) === 2 ) && ! empty( $file['file'] ) && ! empty( $file['name'] );
    }
);
```

Filter này trả về dữ liệu gán vào mảng `$files`, đảm bảo chỉ xử lý các tệp được gửi có cấu trúc và khóa mong đợi, nếu lỗi sẽ trả về rỗng.

![Files](files.png "$files trong debugger")

Duyệt mảng file, plugin gọi đến hàm `generate_file_info()` để tạo thông tin tạm cho mỗi file, sau đó mới kiểm tra loại file bằng `wp_check_filetype_and_ext()`.

```php
foreach ( $files as $file ) {
    $file = $this->generate_file_info( $file );
    $wp_filetype = wp_check_filetype_and_ext( $file['tmp_path'], $file['name'] );
    ...
}
```

```php {title="class-evf-form-fields-upload.php - v3.0.9.4" hl_lines=[13] data-open=true}
protected function generate_file_info( $file ) {
    $dir = $this->get_form_files_dir();
    $file['tmp_path'] = trailingslashit( $this->get_tmp_dir() ) . sanitize_file_name($file['file']);
    $file['type']     = 'application/octet-stream';
    if ( is_file( $file['tmp_path'] ) ) {
        $filetype     = wp_check_filetype( $file['tmp_path'] );
        $file['type'] = $filetype['type'];
    }

    // Data for no media case.
    $file_ext              = pathinfo( $file['name'], PATHINFO_EXTENSION );
    $file_base             = wp_basename( $file['name'], ".$file_ext" );
    $file['file_name_new'] = sprintf( '%s-%s.%s', $file_base, wp_hash( $dir['path'] . $this->form_data['id'] . $this->field_id ), strtolower( $file_ext ) );
    $file['file_name_new'] = wp_unique_filename( trailingslashit( $dir['path'] ), sanitize_file_name( $file['file_name_new'] ) );
    $file['file_url']      = trailingslashit( $dir['url'] ) . $file['file_name_new'];
    $file['path']          = trailingslashit( $dir['path'] ) . $file['file_name_new'];
    $file['attachment_id'] = 0;

    return $file;
}
```

Điều đáng chú ý là hàm sử dụng `wp_hash()` để tạo `$file['file_name_new']` sau đó concat vào `$dir['path']` để gán giá trị cho `$file['path']`, tức giá trị này được tạo ra kết hợp sử dụng **salt** được thiết lập trong `wp-config.php` => ta chỉ biết được có **salt**

> [!INFO]
> `$file_ext` được concat vào cuối `file['path']`, ta có thể kiểm soát nó thông qua trường `name` được truyền trong request. 
> 
> ```diff
> - _690888869ea291.55135482.txt
> + _690888869ea291.55135482.php
> ```

![File](file.png "$file trong debugger")

Ở đây ta chỉ cần chú ý đến 3 trường `tmp_path`, `name`, `path`

* `tmp_path` - `name` được đặt làm đối số trong hàm `wp_check_filetype_and_ext()`
* `tmp_path` - `path` được đặt làm đối số trong hàm `rename()`

Như phân tích trước đó, logic vẫn chạy mặc dù file upload không được phép. `rename($file['tmp_path'] , $file['path'])` được gọi để di chuyển file từ đường dẫn tạm sang đường dẫn chính.

---

Hàm `format()` được đăng ký làm callback cho action hook

```php {title="class-evf-form-fields.php - v3.0.9.4"}
add_action( 'everest_forms_process_format_' . $this->type, array( $this, 'format' ), 10, 4 );
```

Khi type là `file-upload`

![Type](type.png "Type cần thiết để gọi format")

Khi search với từ khóa `everest_forms_process_format_`

![Action](action.png "Hook everest_forms_process_format_file-upload được gọi") 
Hook này sẽ được gọi trong hàm `do_task()` thông quan `do_action()` với `$field_type` được truyền động

```php {title="class-evf-form-task.php - v3.0.9.4"}
public function listen_task() {
    ...
    if ( ! empty( $_POST['everest_forms']['id'] ) ) { // phpcs:ignore WordPress.Security.NonceVerification
        $this->do_task( evf_sanitize_entry( wp_unslash( $_POST['everest_forms'] ) ) ); // phpcs:ignore WordPress.Security.NonceVerification, WordPress.Security.ValidatedSanitizedInput.InputNotSanitized
    }
    ...
}
```

`do_task()` được gọi trong `listen_task()` khi everest forms `id` được truyền vào POST request

`listen_task()` được đăng ký làm callback cho action hook
```php
add_action( 'wp', array( $this, 'listen_task' ) );
```

Hook này sẽ được xử lý trên mỗi request

## Flow
{{< mermaid >}}
graph TD
A["User submits form (file)"] --> B["Browser sends POST to page with form"]
B --> C["WP hook triggered - listen_task()"]
C --> D["do_task() calls do_action() with field type"]
D --> E["everest_forms_process_format_file-upload calls format()"]
E --> F["generate_file_info() creates tmp_path, name, path"]
E --> G["wp_check_filetype_and_ext(tmp_path, name)"]
G --> H{"File type check result"}
H -->|Valid| I["rename(tmp_path → path) moves file to uploads"]
H -->|Invalid| J["Set error but continue execution"]
J --> I
I --> K["File accessible in uploads → potential executable upload"]
{{< /mermaid >}}

## Proof of Concept (PoC)
1. Tạo file `.txt` chứa code php

```txt
TEXT
<?php phpinfo();?>
```
2. Bật Burp Intercept và bắt file upload
3. Sửa extension trong `name` thành `.php` và gửi request.

![File Uploaded](fileuploaded.png "File upload thành công")

4. Truy cập file đã upload

![Result](result.png "phpinfo() với file upload")

## Conclusion

Lỗ hổng trong `EVF_Form_Fields_Upload::format()` cho phép tải lên, đọc và xóa tệp tùy ý do thiếu kiểm tra kiểu tệp và đường dẫn đúng cách. Mặc dù plugin có cảnh báo lỗi khi phát hiện tệp không hợp lệ, luồng xử lý không dừng và vẫn gọi `rename()` để di chuyển tệp vào thư mục public — dẫn đến khả năng đưa mã thực thi lên server (RCE), tiết lộ dữ liệu nhạy cảm hoặc chiếm quyền quản trị site. Bản vá (≥ 3.0.9.5) đã khắc phục bằng cách dừng luồng khi phát hiện tệp không hợp lệ, nhưng các site chưa cập nhật vẫn rất dễ bị lợi dụng.

## Key Takeaway

* Thiếu kiểm tra chặt chẽ kiểu/đuôi file dẫn đến nguy cơ upload file thực thi.
* Phát hiện file không hợp lệ nhưng không dừng luồng xử lý cho phép kẻ tấn công bypass.
* Validation vô nghĩa nếu không kèm hành động chặn (stop/exit/wp_die) trước khi thao tác filesystem.
* Cần kiểm tra cả nội dung (MIME/content), không chỉ dựa vào tên/extension do client cung cấp.
* Ngăn thực thi PHP trong thư mục `uploads` và dùng API upload an toàn (ví dụ `wp_handle_upload()`).

## References

[Arbitrary File Upload](https://book.hacktricks.wiki/en/pentesting-web/file-upload/index.html)

[WordPress Everest Forms Plugin <= 3.0.9.4 is vulnerable to Arbitrary File Upload](https://patchstack.com/database/wordpress/plugin/everest-forms/vulnerability/wordpress-everest-forms-plugin-3-0-9-4-unauthenticated-arbitrary-file-upload-read-and-deletion-vulnerability)  


---

> Tác giả: [Bui Van Y](github.com/w41bu1)  
> URL: http://localhost:1313/vi/posts/2025-11-09-cve-2025-1128/  

