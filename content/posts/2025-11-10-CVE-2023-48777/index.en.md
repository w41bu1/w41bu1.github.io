---
title: CVE-2023-48777 Analysis & POC
description: Security Vulnerability in WordPress Elementor Website Builder Plugin
date: 2025-11-10 19:00:00 +0700
categories: [CVE Analyst]
tags: [analyst, plugin, arbitrary file upload]
images: ["app.png"]
featuredImage: "app.png"

lightgallery: true

toc:
    auto: false
---

<!--more-->

## CVE & Basic Info

An **Arbitrary File Upload** vulnerability in the **Elementor Website Builder** plugin for WordPress. This issue affects **Elementor Website Builder** versions from **3.3.0** to **3.18.1**.

* **CVE ID**: [CVE-2023-48777](https://www.cve.org/CVERecord?id=CVE-2023-48777)
* **Vulnerability Type**: Arbitrary File Upload
* **Affected Versions**: <= 3.3.0-3.18.1
* **Patched Versions**: 3.18.2
* **CVSS severity**: High (9.9)
* **Required Privilege**: Contributor
* **Product**: [WordPress Elementor Website Builder Plugin](https://wordpress.org/plugins/elementor/)

## Requirements

* **Local WordPress & Debugging**

  * [Virtual Machine](https://w41bu1.github.io/posts/2025-08-21-wordpress-local-and-debugging/)
  * [Docker](https://w41bu1.github.io/posts/2025-10-22-wordpress-local-and-debugging-docker/)
* **Plugin Version** - **Elementor Website Builder**:

  * `3.3.0` – **vulnerable**
  * `3.18.2` – **patched**
* **Diff Tool (diff)** → [**Meld**](https://meldmerge.org/) or any diff tool.

## Cause

The vulnerability stems from **not validating the file type** before saving to the **server**, allowing an attacker to upload files with dangerous formats.

In version **3.18.1**, the function `handle_elementor_upload()` does not verify the `file type` when processing upload data from the `fileData` parameter:

```php {title="uploads-manager.php - v3.18.1" hl_lines=[3] data-open=true}
public function handle_elementor_upload( array $file, $allowed_file_extensions = null ) {
    if ( isset( $file['fileData'] ) ) {
        $file = $this->save_base64_to_tmp_file( $file );
    }

    $validation_result = $this->validate_file( $file, $allowed_file_extensions );

    if ( is_wp_error( $validation_result ) ) {
        return $validation_result;
    }

    return $file;
}
```

```php {title="uploads-manager.php - v3.18.1" hl_lines=[9] data-open=true}
private function save_base64_to_tmp_file( $file ) {
    $file_content = base64_decode( $file['fileData'] ); // phpcs:ignore

    // If the decode fails
    if ( ! $file_content ) {
        return new \WP_Error( 'file_error', self::INVALID_FILE_CONTENT );
    }

    $temp_filename = $this->create_temp_file( $file_content, $file['fileName'] );

    if ( is_wp_error( $temp_filename ) ) {
        return $temp_filename;
    }

    return [
        // the original uploaded file name
        'name' => $file['fileName'],
        // The path to the temporary file
        'tmp_name' => $temp_filename,
    ];
}
```

In the patch **3.18.2**, the developer **added a valid file type check** before saving by passing an extra parameter `$allowed_file_extensions` into `save_base64_to_tmp_file()`, preventing uploads of malicious files:

```php {title="uploads-manager.php - v3.18.2" hl_lines=[3] data-open=true}
public function handle_elementor_upload( array $file, $allowed_file_extensions = null ) {
    if ( isset( $file['fileData'] ) ) {
        $file = $this->save_base64_to_tmp_file( $file, $allowed_file_extensions );
    }

    $validation_result = $this->validate_file( $file, $allowed_file_extensions );

    if ( is_wp_error( $validation_result ) ) {
        return $validation_result;
    }

    return $file;
}
```

```php {title="uploads-manager.php - v3.18.2" hl_lines=[2,3,5,6,7,16] data-open=true}
private function save_base64_to_tmp_file( $file, $allowed_file_extensions = null ) {
    $file_extension = pathinfo( $file['fileName'], PATHINFO_EXTENSION );
    $is_file_type_allowed = $this->is_file_type_allowed( $file_extension, $allowed_file_extensions );

    if ( is_wp_error( $is_file_type_allowed ) ) {
        return $is_file_type_allowed;
    }

    $file_content = base64_decode( $file['fileData'] ); // phpcs:ignore

    // If the decode fails
    if ( ! $file_content ) {
        return new \WP_Error( 'file_error', self::INVALID_FILE_CONTENT );
    }

    $temp_filename = $this->create_temp_file( $file_content, $file['fileName'] );

    if ( is_wp_error( $temp_filename ) ) {
        return $temp_filename;
    }

    return [
        // the original uploaded file name
        'name' => $file['fileName'],
        // The path to the temporary file
        'tmp_name' => $temp_filename,
    ];
}
```

## Code Analysis

The template upload process uses **Base64** content: the data in `$file['fileData']` is **decoded with** `base64_decode` and assigned to `$file_content`:

```php
$file_content = base64_decode( $file['fileData'] );
```

After decoding, `save_base64_to_tmp_file()` calls `create_temp_file()` to **save this content as a template file** on the server:

```php {title="uploads-manager.php - v3.18.1" hl_lines=[] data-open=true}
public function create_temp_file( $file_content, $file_name ) {
    $temp_filename = $this->create_unique_dir() . $file_name;

    file_put_contents( $temp_filename, $file_content ); // phpcs:ignore

    return $temp_filename;
}
```

The file path is constructed by concatenating `$file_name` with the return value of `create_unique_dir()` — this function creates the **temporary template** storage path:

```php {title="uploads-manager.php - v3.18.1" hl_lines=[] data-open=true}
public function create_unique_dir() {
    $unique_dir_path = $this->get_temp_dir() . uniqid() . DIRECTORY_SEPARATOR;

    wp_mkdir_p( $unique_dir_path );

    return $unique_dir_path;
}
```

`create_unique_dir()` is responsible for **creating the temporary template directory**, with a structure like:

```
wp-content/uploads/elementor/tmp/<filename>
```

Where `<uniqueId>` is generated automatically by [uniqid()](https://www.php.net/manual/en/function.uniqid.php) to ensure the path is unique. `wp_mkdir_p()` will create the physical directory on the server to store the template.

Finally `create_temp_file()` calls `file_put_contents( $temp_filename, $file_content )` to write the contents of `$file_content` to `$temp_filename`.

> [!BUG]
> By abusing the lack of filename sanitization here, we combine it with a path traversal attack so the file can be written to an accessible location, bypassing the randomness of `uniqid()`

---

```php {title="manager.php - v3.18.1" hl_lines=[2,3,7] data-open=true}
public function import_template( array $data ) {
    // If the template is a JSON file, allow uploading it.
    add_filter( 'elementor/files/allow-file-type/json', [ $this, 'enable_json_template_upload' ] );
    add_filter( 'elementor/files/allow_unfiltered_upload', [ $this, 'enable_json_template_upload' ] );

    // Imported templates can be either JSON files, or Zip files containing multiple JSON files
    $upload_result = Plugin::$instance->uploads_manager->handle_elementor_upload( $data, [ 'zip', 'json' ] );
    ...
}
```

`handle_elementor_upload()` is called inside `import_template()`. According to the developer comment, if the template is a JSON file it is allowed to upload. We set a debugger and perform an upload of a JSON template:

1. Create a post using Elementor
2. Click the folder icon

![Folder icon](folder_icon.png "Folder icon location")

3. Click the upload icon

![Upload icon](upload_icon.png "Upload icon location")

![Upload board](upload_board.png "Upload interface")

4. Select a JSON file and upload

![Debug](debug.gif "Debugger jumps to import_template after uploading the JSON file")

## Flow

{{< mermaid >}}
graph TD
A["User uploads JSON file"] --> B["import_template()"]
B --> C["handle_elementor_upload()"]
C --> D["save_base64_to_tmp_file()"]
D --> E["create_temp_file()"]
E --> G["create_unique_dir()"]
G --> H["file_put_contents()"]
H --> I["File stored without proper type validation → Arbitrary File Upload"]
{{< /mermaid >}}

## Proof of Concept (PoC)

1. Create a JSON file containing a web shell
   PHP

```php
<?php system($_REQUEST["cmd"])?>
```

2. Upload and intercept the request using BurpSuite
3. Change the file extension to PHP combined with path traversal and send the request

![Request](request.png "Request with path traversal and .php")

**Result**
![Result](result.png "RCE via file upload")

## Conclusion

The **CVE-2023-48777** vulnerability allows users with **Contributor** privileges to upload malicious files due to the lack of file type validation before saving. This can lead to **Arbitrary File Upload** and **Remote Code Execution (RCE)** if the server allows execution of uploaded files. The issue was patched in version **3.18.2** by adding a check for allowed file extensions before writing to disk.

## Key Takeaway

* Always **validate file type before saving**.
* **Do not trust Base64 data or file names** from the client.
* **Restrict upload permissions** and separate upload storage from executable locations.

## References

[Arbitrary File Upload](https://book.hacktricks.wiki/en/pentesting-web/file-upload/index.html)

[WordPress Elementor Website Builder Plugin 3.3.0-3.18.1 Plugin <= 3.3.0-3.18.1 is vulnerable to Arbitrary File Upload](https://patchstack.com/database/wordpress/plugin/elementor/vulnerability/wordpress-elementor-plugin-3-18-0-arbitrary-file-upload-vulnerability)
