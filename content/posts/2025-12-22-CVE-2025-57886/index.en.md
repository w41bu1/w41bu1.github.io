---
title: CVE-2025-57886 Analysis & POC
description: Security Vulnerability in WordPress Accessibility Checker by Equalize Digital Plugin.
date: 2025-12-22 19:00:00 +0700
categories: [CVE Analysis]
tags: [analyst, plugin, idor]
images: ["app.png"]
featuredImage: "app.png"

lightgallery: true

toc:
  auto: false
---

## CVE & Basic Info
The **Authorization Bypass via User-Controlled Key** vulnerability in the **Equalize Digital Accessibility Checker** plugin by **Equalize Digital** allows exploitation of **misconfigured access control levels**. This vulnerability affects **Accessibility Checker by Equalize Digital** from an **unspecified** version up to **1.30.0**.

* **CVE ID**: [CVE-2025-57886](https://www.cve.org/CVERecord?id=CVE-2025-57886)
* **Vulnerability Type**: Insecure Direct Object References (IDOR)
* **Affected Versions**: <= 1.30.0
* **Patched Versions**: 1.30.1
* **CVSS severity**: Low (5.4)
* **Required Privilege**: Contributor
* **Product**: [WordPress Accessibility Checker by Equalize Digital Plugin](https://wordpress.org/plugins/accessibility-checker/)

## Requirements
* **Local WordPress & Debugging**
    * [Virtual Machine](https://w41bu1.github.io/posts/2025-08-21-wordpress-local-and-debugging/)
    * [Docker](https://w41bu1.github.io/posts/2025-10-22-wordpress-local-and-debugging-docker/)
* **Plugin Version** - **Accessibility Checker by Equalize Digital**:  
    * `1.30.0` – **vulnerable** * `1.30.1` – **patched**
* **Diff Tool (diff)** → [**Meld**](https://meldmerge.org/) or any diff tool.

## Analysis 
The plugin registered a REST API:

```php {title="wclass-rest-api.php v1.30.0" data-open=true hl_lines=[22]}
public function init_rest_routes() {
    $ns      = 'accessibility-checker/';
    $version = 'v1';

    add_action(
        'rest_api_init',
        function () use ( $ns, $version ) {
            register_rest_route(
                $ns . $version,
                '/post-scan-results/(?P<id>\d+)',
                [
                    'methods'             => 'POST',
                    'callback'            => [ $this, 'set_post_scan_results' ],
                    'args'                => [
                        'id' => [
                            'validate_callback' => function ( $param ) {
                                return is_numeric( $param );
                            },
                        ],
                    ],
                    'permission_callback' => function () {
                        return current_user_can( 'edit_posts' );
                    },
                ]
            );
        }
    );
}
```

Looking at the logic of the code, we can draw several important points:

1. **Namespace and route**
The endpoint is located under `accessibility-checker/v1` with the route `/post-scan-results/{id}`. The `id` parameter is defined as a **number**, thanks to the regex `\d+` and `validate_callback`. This is a basic check, but it does not verify if the `id` exists or belongs to a specific post type.
2. **HTTP Method**
The route only accepts `POST`, suggesting that this is an endpoint for **writing or updating data**, not just reading.
3. **Permission Check**
The `permission_callback` only checks for the general capability `edit_posts` (Contributor+). The decision to allow or deny the request **is not based on a specific post**, meaning **a user with general permissions will be allowed to manipulate any `id**`.
4. **Processing Callback**
If permissions are bypassed, WordPress calls `set_post_scan_results` with the `$id` provided by the client. Here, the entire data processing logic completely **trusts the `id` value controlled by the client**.

```php {title="wclass-rest-api.php v1.30.0" data-open=true hl_lines=[22]}
public function set_post_scan_results( $request ) {
    if ( ! isset( $request['violations'] ) ) {
        return new \WP_REST_Response( [ 'message' => 'A required parameter is missing.' ], 400 );
    }

    $post_id = (int) $request['id'];
    $post    = get_post( $post_id );
    if ( ! is_object( $post ) ) {
        return new \WP_REST_Response( [ 'message' => 'The post is not valid.' ], 400 );
    }

    $post_type  = get_post_type( $post );
    $post_types = Helpers::get_option_as_array( 'edac_post_types' );
    if ( empty( $post_types ) || ! in_array( $post_type, $post_types, true ) ) {
        return new \WP_REST_Response( [ 'message' => 'The post type is not set to be scanned.' ], 400 );
    }

    $rules = edac_register_rules();
    $js_rule_ids = [];
    $combined_rule_ids = [];
    ...

    try {
        do_action( 'edac_before_validate', $post_id, 'js' );

        $violations = $request['violations'];
        edac_remove_corrected_posts( $post_id, $post->post_type, 1, 'js' );

        if ( is_array( $violations ) && count( $violations ) > 0 ) {
            foreach ( $violations as $violation ) {
                $rule_id = $violation['ruleId'];
                $actual_rule_id = $combined_rule_ids[ $rule_id ] ?? $rule_id;
                if ( in_array( $actual_rule_id, $js_rule_ids, true ) ) {
                    ...
                    ( new Insert_Rule_Data() )->insert( $post, $actual_rule_id, $impact, $html, $landmark, $landmark_selector, $selectors );
                    ...
                }
            }
        }

        do_action( 'edac_after_validate', $post_id, 'js' );
        edac_remove_corrected_posts( $post_id, $post->post_type, 2, 'js' );

        $metrics = $request['densityMetrics'] ?? [ 0, 0 ];
        update_post_meta( $post_id, '_edac_density_data', [ $metrics['elementCount'] ?? 0, $metrics['contentLength'] ?? 0 ] );

        ( new Summary_Generator( $post_id ) )->generate_summary();
        update_post_meta( $post_id, '_edac_post_checked_js', time() );

        do_action( 'edac_validate_before_sending_rest_response', $post_id, 'js', $request );

        return new \WP_REST_Response( [ 'success' => true, 'id' => $post_id, 'timestamp' => time() ] );

    } catch ( \Exception $ex ) {
        return new \WP_REST_Response( [ 'message' => $ex->getMessage() ], 500 );
    }
}
```

The function receives a request from the REST API and processes the accessibility scan results for a post. The main logic flow includes:

1. **Input Validation**
```php
if ( ! isset( $request['violations'] ) ) {
    return new \WP_REST_Response([ 'message' => 'Missing violations' ], 400);
}
$post_id = (int) $request['id'];
$post = get_post( $post_id );
if ( ! is_object( $post ) ) {
    return new \WP_REST_Response([ 'message' => 'Invalid post' ], 400);
}
```

2. **Post Type Check**
```php
$post_type  = get_post_type( $post );
$post_types = Helpers::get_option_as_array( 'edac_post_types' );
if ( empty( $post_types ) || ! in_array( $post_type, $post_types, true ) ) {
    return new \WP_REST_Response([ 'message' => 'Post type not allowed' ], 400);
}
```

3. **Violation Processing**
```php
$rules = edac_register_rules();
foreach ( $request['violations'] as $violation ) {
    $rule_id = $violation['ruleId'];
    // Filter valid rules and save to the database
    (new Insert_Rule_Data())->insert( $post, $rule_id, $impact, $html, $landmark, $landmark_selector, $selectors );
}
```

4. **Update Post Meta and Summary**
```php
update_post_meta( $post_id, '_edac_density_data', [ $metrics['elementCount'] ?? 0, $metrics['contentLength'] ?? 0 ] );
( new Summary_Generator( $post_id ) )->generate_summary();
update_post_meta( $post_id, '_edac_post_checked_js', time() );
```

5. **Return Response**
```php
return new \WP_REST_Response([
    'success' => true,
    'id' => $post_id,
    'timestamp' => time()
]);
```

> [!BUG]
> An attacker with a **Contributor account** can **arbitrarily manipulate the client-controlled `id` parameter**, pointing to **any post**, while the permission check relies solely on `edit_posts`. This allows the attacker to **write or overwrite `violations` data on posts they do not own**, leading to **unauthorized modification of other users' data (IDOR)**.

When creating a post with a Contributor user, you will see the **Accessibility Checker** statistics appear directly on the post editing page.

![Post](post.png "Thống kê của Accessibility Checker")

By filtering requests with the phrase `post-scan-results` in Burp History, you can capture a valid request provided by the plugin:

![Request](request.png "Filter request trong Burp History")

Simply by modifying the `id` value, one can **unauthorizedly modify data** in another person's post.

Version **v1.30.1** fixed the vulnerability by changing the **permission callback**:

```php
'permission_callback' => function ( $request ) {
    return $this->user_can_edit_passed_post_id( $request );
}

public function user_can_edit_passed_post_id( $request ) {
    $post_id = (int) $request['id'];
    return current_user_can( 'edit_post', $post_id );
}
```

* The callback now receives `$request` to check a **specific post**.
* Uses `current_user_can('edit_post', $post_id)` → WordPress verifies:
* Whether the user has permission to edit this post.
* Whether the post is owned by the user.
* Whether the post status (draft, published, private) allows the operation.

## Flow

{{< mermaid >}}
flowchart TD
A["Authenticated attacker (Contributor+)"]
--> B["Craft POST request to REST API"]
B --> C["POST /wp-json/accessibility-checker/v1/post-scan-results/{id}"]
C --> D["Manipulate {id} to target post_id"]
D --> E["permission_callback: current_user_can('edit_posts')"]
E --> F["Permission granted"]
F --> G["set_post_scan_results()"]
G --> H["get_post(target_post_id)"]
H --> I["Process violations data"]
I --> J["update_post_meta(target_post_id, *edac**)"]
J --> K["Target post data modified"]

{{< /mermaid >}}

## Proof of Concept (PoC)

1. Create/edit a post with a **Contributor** account.
2. Capture the request to `/wp-json/accessibility-checker/v1/post-scan-results/{id}`.
3. Resend the request with the `id` of another user's post and arbitrary `violations`.

## Conclusion

CVE-2025-57886 is an **IDOR vulnerability in the REST API** caused by the **Accessibility Checker by Equalize Digital** plugin only checking permissions at a **general capability level (`edit_posts`)** without validating **editing permissions on a specific post**. This allows an attacker with Contributor privileges to **arbitrarily manipulate the `id` parameter** in the REST API request to **write or overwrite accessibility data** on posts they do not own, leading to **unauthorized data modification**. Version 1.30.1 fixed this by applying **post-level authorization** via `current_user_can('edit_post', $post_id)`.

## Key Takeaways

* REST APIs using **client-controlled object identifiers** must always include **permission checks on the specific object**.
* A **Global capability check** (`edit_posts`) is insufficient to protect data-writing operations based on `post_id`.
* IDOR can occur even when the request is generated from **valid client-side logic**.
* In WordPress, **`current_user_can('edit_post', $post_id)`** is the standard measure to prevent post-level IDOR.
* REST endpoints that **write data** should be considered priority attack surfaces during plugin audits.

## References

[IDOR](https://book.hacktricks.wiki/en/pentesting-web/idor.html)

[WordPress Accessibility Checker by Equalize Digital Plugin <= 1.30.0 is vulnerable to Insecure Direct Object References (IDOR)](https://patchstack.com/database/wordpress/plugin/accessibility-checker/vulnerability/wordpress-accessibility-checker-by-equalize-digital-plugin-1-30-0-insecure-direct-object-references-idor-vulnerability)
