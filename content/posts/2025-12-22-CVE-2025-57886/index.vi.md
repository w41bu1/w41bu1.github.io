---
title: CVE-2025-57886 Analysis & POC
description: Security Vulnerability in WordPress Accessibility Checker by Equalize Digital Plugin.
date: 2025-12-22 19:00:00 +0700
categories: [CVE Analysis]
tags: [analyst, plugin, idor]
images: ["app.png"]
featuredImage: "app.png"

lightgallery: true

toc:
  auto: false
---

<!--more-->

## CVE & Basic Info
Lỗ hổng **bỏ qua cơ chế phân quyền (Authorization Bypass) thông qua khóa do người dùng kiểm soát** trong plugin **Equalize Digital Accessibility Checker** của **Equalize Digital** cho phép khai thác việc **cấu hình sai các mức kiểm soát truy cập**. Lỗ hổng này ảnh hưởng đến **Accessibility Checker by Equalize Digital** từ phiên bản **không xác định** đến **1.30.0**.

* **CVE ID**: [CVE-2025-57886](https://www.cve.org/CVERecord?id=CVE-2025-57886)
* **Vulnerability Type**: Insecure Direct Object References (IDOR)
* **Affected Versions**: <= 1.30.0
* **Patched Versions**: 1.30.1
* **CVSS severity**: Low (5.4)
* **Required Privilege**: Contributor
* **Product**: [WordPress Accessibility Checker by Equalize Digital Plugin](https://wordpress.org/plugins/accessibility-checker/)

## Requirements
* **Local WordPress & Debugging**
    * [Virtual Machine](https://w41bu1.github.io/posts/2025-08-21-wordpress-local-and-debugging/)
    * [Docker](https://w41bu1.github.io/posts/2025-10-22-wordpress-local-and-debugging-docker/)
* **Plugin Version** - **Accessibility Checker by Equalize Digital**:  
    * `1.30.0` – **vulnerable**  
    * `1.30.1` – **patched**
* **Diff Tool (diff)** → [**Meld**](https://meldmerge.org/) hoặc bất kỳ công cụ diff nào.

## Analysis 
Plugin đã đăng ký REST API:

```php {title="wclass-rest-api.php v1.30.0" data-open=true hl_lines=[22]}
public function init_rest_routes() {
    $ns      = 'accessibility-checker/';
    $version = 'v1';

    add_action(
        'rest_api_init',
        function () use ( $ns, $version ) {
            register_rest_route(
                $ns . $version,
                '/post-scan-results/(?P<id>\d+)',
                [
                    'methods'             => 'POST',
                    'callback'            => [ $this, 'set_post_scan_results' ],
                    'args'                => [
                        'id' => [
                            'validate_callback' => function ( $param ) {
                                return is_numeric( $param );
                            },
                        ],
                    ],
                    'permission_callback' => function () {
                        return current_user_can( 'edit_posts' );
                    },
                ]
            );
        }
    );
}
```

Nhìn vào logic của đoạn code, chúng ta có thể rút ra một số điểm quan trọng:

1. **Namespace và route**
   Endpoint được đặt dưới `accessibility-checker/v1` với route `/post-scan-results/{id}`. Tham số `id` được định nghĩa là **số**, nhờ regex `\d+` và `validate_callback`. Đây là một bước kiểm tra cơ bản, nhưng chưa hề kiểm tra xem `id` có tồn tại hay thuộc post type nào.

2. **Phương thức HTTP**
   Route chỉ chấp nhận `POST`, gợi ý rằng đây là endpoint **ghi hoặc cập nhật dữ liệu**, không phải chỉ đọc.

3. **Kiểm tra quyền**
   `permission_callback` chỉ kiểm tra capability tổng quát `edit_posts` (Contributor+). Quyết định cho phép hay từ chối request **không dựa vào post cụ thể**, tức là **user có quyền tổng quát sẽ được phép thao tác với bất kỳ `id` nào**.

4. **Callback xử lý**
   Nếu vượt qua permission, WordPress gọi `set_post_scan_results` với `$id` do client cung cấp. Tại đây, toàn bộ logic xử lý dữ liệu hoàn toàn **tin vào giá trị `id` mà client kiểm soát**.

```php {title="wclass-rest-api.php v1.30.0" data-open=true hl_lines=[22]}
public function set_post_scan_results( $request ) {
    if ( ! isset( $request['violations'] ) ) {
        return new \WP_REST_Response( [ 'message' => 'A required parameter is missing.' ], 400 );
    }

    $post_id = (int) $request['id'];
    $post    = get_post( $post_id );
    if ( ! is_object( $post ) ) {
        return new \WP_REST_Response( [ 'message' => 'The post is not valid.' ], 400 );
    }

    $post_type  = get_post_type( $post );
    $post_types = Helpers::get_option_as_array( 'edac_post_types' );
    if ( empty( $post_types ) || ! in_array( $post_type, $post_types, true ) ) {
        return new \WP_REST_Response( [ 'message' => 'The post type is not set to be scanned.' ], 400 );
    }

    $rules = edac_register_rules();
    $js_rule_ids = [];
    $combined_rule_ids = [];
    ...

    try {
        do_action( 'edac_before_validate', $post_id, 'js' );

        $violations = $request['violations'];
        edac_remove_corrected_posts( $post_id, $post->post_type, 1, 'js' );

        if ( is_array( $violations ) && count( $violations ) > 0 ) {
            foreach ( $violations as $violation ) {
                $rule_id = $violation['ruleId'];
                $actual_rule_id = $combined_rule_ids[ $rule_id ] ?? $rule_id;
                if ( in_array( $actual_rule_id, $js_rule_ids, true ) ) {
                    ...
                    ( new Insert_Rule_Data() )->insert( $post, $actual_rule_id, $impact, $html, $landmark, $landmark_selector, $selectors );
                    ...
                }
            }
        }

        do_action( 'edac_after_validate', $post_id, 'js' );
        edac_remove_corrected_posts( $post_id, $post->post_type, 2, 'js' );

        $metrics = $request['densityMetrics'] ?? [ 0, 0 ];
        update_post_meta( $post_id, '_edac_density_data', [ $metrics['elementCount'] ?? 0, $metrics['contentLength'] ?? 0 ] );

        ( new Summary_Generator( $post_id ) )->generate_summary();
        update_post_meta( $post_id, '_edac_post_checked_js', time() );

        do_action( 'edac_validate_before_sending_rest_response', $post_id, 'js', $request );

        return new \WP_REST_Response( [ 'success' => true, 'id' => $post_id, 'timestamp' => time() ] );

    } catch ( \Exception $ex ) {
        return new \WP_REST_Response( [ 'message' => $ex->getMessage() ], 500 );
    }
}
```

Hàm nhận request từ REST API và xử lý kết quả quét accessibility cho một bài viết. Luồng logic chính gồm:

1. **Kiểm tra đầu vào**

   ```php
   if ( ! isset( $request['violations'] ) ) {
       return new \WP_REST_Response([ 'message' => 'Missing violations' ], 400);
   }
   $post_id = (int) $request['id'];
   $post = get_post( $post_id );
   if ( ! is_object( $post ) ) {
       return new \WP_REST_Response([ 'message' => 'Invalid post' ], 400);
   }
   ```

2. **Kiểm tra post type**

   ```php
   $post_type  = get_post_type( $post );
   $post_types = Helpers::get_option_as_array( 'edac_post_types' );
   if ( empty( $post_types ) || ! in_array( $post_type, $post_types, true ) ) {
       return new \WP_REST_Response([ 'message' => 'Post type not allowed' ], 400);
   }
   ```

3. **Xử lý violations**

   ```php
   $rules = edac_register_rules();
   foreach ( $request['violations'] as $violation ) {
       $rule_id = $violation['ruleId'];
       // Lọc rule hợp lệ và lưu vào cơ sở dữ liệu
       (new Insert_Rule_Data())->insert( $post, $rule_id, $impact, $html, $landmark, $landmark_selector, $selectors );
   }
   ```

4. **Cập nhật post meta và summary**

   ```php
   update_post_meta( $post_id, '_edac_density_data', [ $metrics['elementCount'] ?? 0, $metrics['contentLength'] ?? 0 ] );
   ( new Summary_Generator( $post_id ) )->generate_summary();
   update_post_meta( $post_id, '_edac_post_checked_js', time() );
   ```

5. **Trả response**

   ```php
   return new \WP_REST_Response([
       'success' => true,
       'id' => $post_id,
       'timestamp' => time()
   ]);
   ```

> [!BUG]
> Attacker có **Contributor account** có thể **tùy ý thao túng tham số `id` do client kiểm soát**, trỏ tới **bất kỳ post nào**, trong khi kiểm tra quyền chỉ dựa trên `edit_posts`. Điều này cho phép attacker **ghi hoặc ghi đè dữ liệu `violations` vào post không thuộc quyền sở hữu**, dẫn đến **thay đổi trái phép dữ liệu của người dùng khác (IDOR)**.

Khi tạo post bằng Contributor user, bạn sẽ thấy phần thống kê của **Accessibility Checker** xuất hiện ngay trong trang chỉnh sửa bài viết.

![Post](post.png "Thống kê của Accessibility Checker")

Thử filter request bằng cụm từ `post-scan-results` trong Burp History, bạn sẽ bắt được request hợp lệ do plugin cung cấp sẵn:

![Request](request.png "Filter request trong Burp History")

Chỉ cần sửa đối giá trị `id`, ta có thể **thay đổi trái phép dữ liệu** trong post của người khác.

Phiên bản **v1.30.1** đã sửa lỗ hổng bằng cách thay đổi **permission callback**:

```php
'permission_callback' => function ( $request ) {
    return $this->user_can_edit_passed_post_id( $request );
}

public function user_can_edit_passed_post_id( $request ) {
    $post_id = (int) $request['id'];
    return current_user_can( 'edit_post', $post_id );
}
```

* Callback giờ nhận `$request` để kiểm tra **post cụ thể**.
* Sử dụng `current_user_can('edit_post', $post_id)` → WordPress xác minh:

  * User có quyền chỉnh sửa post này hay không.
  * Post có thuộc sở hữu của user hay không.
  * Trạng thái post (draft, published, private) có cho phép thao tác không.

## Flow
{{< mermaid >}}
flowchart TD
A["Authenticated attacker (Contributor+)"]
--> B["Craft POST request to REST API"]
B --> C["POST /wp-json/accessibility-checker/v1/post-scan-results/{id}"]
C --> D["Manipulate {id} to target post_id"]
D --> E["permission_callback: current_user_can('edit_posts')"]
E --> F["Permission granted"]
F --> G["set_post_scan_results()"]
G --> H["get_post(target_post_id)"]
H --> I["Process violations data"]
I --> J["update_post_meta(target_post_id, _edac_*)"]
J --> K["Target post data modified"]

{{< /mermaid >}}

## Proof of Concept (PoC)
1. Tạo/edit post bằng **Contributor** account
2. Bắt request đến `/wp-json/accessibility-checker/v1/post-scan-results/{id}`
3. Gửi lại request với `id` post của user khác với `violations` tùy ý.

## Conclusion

CVE-2025-57886 là một lỗ hổng **IDOR trong REST API** do plugin **Accessibility Checker by Equalize Digital** chỉ kiểm tra quyền ở mức **capability tổng quát (`edit_posts`)** mà không xác thực **quyền chỉnh sửa trên post cụ thể**. Điều này cho phép attacker có quyền Contributor **tùy ý thao túng tham số `id`** trong request REST API để **ghi hoặc ghi đè dữ liệu accessibility** lên các bài viết không thuộc quyền sở hữu, dẫn đến **thay đổi trái phép dữ liệu**. Phiên bản 1.30.1 đã khắc phục bằng cách áp dụng **post-level authorization** thông qua `current_user_can('edit_post', $post_id)`.

## Key Takeaways

* REST API sử dụng **object identifier do client kiểm soát** phải luôn đi kèm **kiểm tra quyền trên object cụ thể**.
* **Global capability check** (`edit_posts`) không đủ để bảo vệ các thao tác ghi dữ liệu theo `post_id`.
* IDOR có thể xảy ra ngay cả khi request được tạo từ **logic hợp lệ phía client**.
* Trong WordPress, **`current_user_can('edit_post', $post_id)`** là biện pháp chuẩn để ngăn chặn IDOR ở mức post.
* Các endpoint REST **ghi dữ liệu** cần được xem là bề mặt tấn công ưu tiên khi audit plugin.

## References
[IDOR](https://book.hacktricks.wiki/en/pentesting-web/idor.html)

[WordPress Accessibility Checker by Equalize Digital Plugin <= 1.30.0 is vulnerable to Insecure Direct Object References (IDOR)](https://patchstack.com/database/wordpress/plugin/accessibility-checker/vulnerability/wordpress-accessibility-checker-by-equalize-digital-plugin-1-30-0-insecure-direct-object-references-idor-vulnerability)  