---
title: CVE-2025-12954 Analysis & POC
description: Security Vulnerability in WordPress Timetable and Event Schedule Plugin.
date: 2025-12-21 19:00:00 +0700
categories: [CVE Analysis]
tags: [analyst, plugin, idor]
images: ["app.png"]
featuredImage: "app.png"

lightgallery: true

toc:
  auto: false
---

## CVE & Basic Info
The **Timetable and Event Schedule by MotoPress** WordPress plugin prior to version **2.4.16** does not verify whether a user has permission to access a specific event when performing the duplicate action, allowing users with roles as low as **Contributor** to arbitrarily disclose events.

* **CVE ID**: [CVE-2025-12954](https://www.cve.org/CVERecord?id=CVE-2025-12954)
* **Vulnerability Type**: Insecure Direct Object References (IDOR)
* **Affected Versions**: <= 2.4.15
* **Patched Versions**: 2.4.16
* **CVSS severity**: Low (4.3)
* **Required Privilege**: Contributor
* **Product**: [WordPress Timetable and Event Schedule Plugin](https://wordpress.org/plugins/mp-timetable/)

## Requirements
* **Local WordPress & Debugging**
    * [Virtual Machine](https://w41bu1.github.io/posts/2025-08-21-wordpress-local-and-debugging/)
    * [Docker](https://w41bu1.github.io/posts/2025-10-22-wordpress-local-and-debugging-docker/)
* **Plugin Version** - **Timetable and Event Schedule**:  
    * `2.4.15` – **vulnerable** * `2.4.16` – **patched**
* **Diff Tool (diff)** → [**Meld**](https://meldmerge.org/) or any diff tool.

## Analysis 
The plugin has registered an action hook:

```php {title="class-hooks.php v2.4.15" data-open=true hl_lines=[]}
add_action( 'post_action_mptt_duplicate_event', array( $this->get( 'events' ), 'post_action_mptt_duplicate_event' ) );
```

In **WordPress**, hooks with the `post_action_` prefix are special hooks used to handle actions passed via the `action` parameter when accessing the `post.php` file.
Specifically, when a user accesses a URL like:

```
/wp-admin/post.php?post=post_id&action=mptt_duplicate_event
```

WordPress will call the `post_action_mptt_duplicate_event` callback to process the **duplicate event** logic.

In addition to registering the action hook, the plugin also **proactively creates a URL to trigger this action** by adding a "Duplicate" link to the action list of each post in the admin dashboard.

```php {title="class-events.php v2.4.15" data-open=true hl_lines=[]}
public function post_row_actions( $actions, $post ) {
    if ( $post->post_type == $this->post_type && current_user_can('edit_posts') ) {

        $action_url = add_query_arg(
            array(
                'post' => $post->ID,
                'action' => 'mptt_duplicate_event',
                '_wpnonce' => wp_create_nonce( 'mptt_duplicate_event' )
            ),
            admin_url( 'post.php' )
        );

        $actions['duplicate'] = '<a href="' . $action_url . '" aria-label="' .
            __('Duplicate', 'mp-timetable') . '" rel="permalink">' . __('Duplicate', 'mp-timetable') . '</a>';
    }

    return $actions;
}
```

This function uses the `post_row_actions` hook to **add a Duplicate link** to the action list of each post in the admin.

The link is only displayed when the post matches the correct `post_type` and the user has `edit_posts` permissions (Contributor+).
The generated URL points to `post.php` with `post` (Post ID), `action` (`mptt_duplicate_event`), and `_wpnonce`.

When a user clicks **Duplicate**, WordPress will trigger the `post_action_mptt_duplicate_event` hook to process post duplication.

Callback `post_action_mptt_duplicate_event`:

```php {title="class-events.php v2.4.15" data-open=true hl_lines=[20]}
public function post_action_mptt_duplicate_event( $post_id ) {
    global $wpdb;

    $post_type = '';

    if ( $post_id ) {
        $post = get_post( $post_id );
    }

    if ( $post ) {
        $post_type = $post->post_type;
    }

    if ( $post_type !== $this->post_type ) {
        wp_die( __( 'A post type mismatch has been detected.', 'mp-timetable' ), __( 'Sorry, you are not allowed to edit this item.', 'mp-timetable' ), 400 );
    }

    $nonce = sanitize_key( $_REQUEST['_wpnonce'] );

    if ( wp_verify_nonce( $nonce, 'mptt_duplicate_event' ) && current_user_can('edit_posts') ) {

        $current_user = wp_get_current_user();
        $new_post_author = $current_user->ID;

        /*
            * new post data array
            */
        $args = array(
            'comment_status' => $post->comment_status,
            'ping_status'    => $post->ping_status,
            'post_author'    => $new_post_author,
            'post_content'   => $post->post_content,
            'post_excerpt'   => $post->post_excerpt,
            'post_name'      => $post->post_name,
            'post_parent'    => $post->post_parent,
            'post_password'  => $post->post_password,
            'post_status'    => 'draft',
            // translators: New post title of the duplicated post
            'post_title'     => sprintf( __('%s - Copy', 'mp-timetable'), $post->post_title ),
            'post_type'      => $post->post_type,
            'to_ping'        => $post->to_ping,
            'menu_order'     => $post->menu_order
        );

        /*
            * insert the post by wp_insert_post() function
            */
        $new_post_id = wp_insert_post( $args );

        if( is_wp_error($new_post_id) ) {
            wp_die( $post_id->get_error_message() );
        }

        /*
            * get all current post terms and set them to the new post draft
            */
        $taxonomies = get_object_taxonomies($post->post_type);
        foreach ($taxonomies as $taxonomy) {
            $post_terms = wp_get_object_terms($post_id, $taxonomy, array('fields' => 'slugs'));
            wp_set_object_terms($new_post_id, $post_terms, $taxonomy, false);
        }

        /*
            * duplicate all post meta
            */
        $post_meta_keys = \get_post_custom_keys( $post_id );

        if ( ! empty( $post_meta_keys ) ) {

            $meta_excludelist = [
                '_edit_lock',
                '_edit_last',
                '_wp_old_slug'
            ];

            $meta_keys = \array_diff( $post_meta_keys, $meta_excludelist );

            foreach ( $meta_keys as $meta_key ) {
                $meta_values = \get_post_custom_values( $meta_key, $post_id );

                // Clear existing meta data
                \delete_post_meta( $new_post_id, $meta_key );

                foreach ( $meta_values as $meta_value ) {
                    $meta_value = \maybe_unserialize( $meta_value );
                    \add_post_meta( $new_post_id, $meta_key, addslashes( $meta_value ) );
                }
            }

        }

        /*
            * duplicate timeslots in custom BD
            */
        $timeslots = $this->wpdb->get_results( 
            $this->wpdb->prepare("SELECT * FROM {$this->table_name} WHERE event_id = %d", $post_id ), 
        OBJECT );

        if ( !empty($timeslots) ) {

            foreach ( $timeslots as $timeslot ) {
                $wpdb->insert(
                    $this->table_name,
                    array(
                        'column_id'   => $timeslot->column_id,
                        'event_id'    => $new_post_id,
                        'event_start' => date( 'H:i', strtotime( $timeslot->event_start ) ),
                        'event_end'   => date( 'H:i', strtotime( $timeslot->event_end ) ),
                        'user_id'     => $timeslot->user_id,
                        'description' => $timeslot->description
                    )
                );
            }
        }

        /*
            * redirect to the edit post screen for the new draft
            */
        wp_safe_redirect( get_edit_post_link( $new_post_id, '' ) );
        exit();

    } else {
        wp_die( __( 'Sorry, you are not allowed to edit this item.' ) );
    }
}
```

This function performs the duplication of the post with ID `$post_id`, however:

```php
if ( wp_verify_nonce( $nonce, 'mptt_duplicate_event' ) && current_user_can('edit_posts') ) {
```

This is the main cause leading to IDOR (Insecure Direct Object Reference).

* `edit_posts` is a **generic** permission, not attached to a **specific post**.
* Contributors and above all have this permission.
* There is no check for:
* whether the post belongs to the current user
* whether the user has permission to edit the **specific post_id**

```php
$post = get_post( $post_id );
```

The post is retrieved directly from `$post_id` passed via URL **without ownership restrictions**.

```php
post.php?action=mptt_duplicate_event&post=123
```

Just by guessing or changing the `post` ID in the URL, a user with `edit_posts` can still:

* duplicate someone else's post
* duplicate a published post

Because WordPress **does not automatically check permissions in the `post_action_*` hook**, the entire access control depends on the `current_user_can()` snippet in the plugin.

Instead of using `edit_posts`, the patch switched to checking permissions on each specific object using meta capability:

```php
current_user_can( 'edit_post', $post_id )
```

This check forces WordPress to verify:

* Whether the user has permission to edit the post referenced by `$post_id`
* Whether the post belongs to the current user
* The post status (draft, pending, published, private)

Thanks to this, users can no longer arbitrarily change the post ID in the URL to duplicate someone else's post, and the **IDOR** vulnerability is fixed.

## Flow

{{< mermaid >}}
flowchart TD

A["Authenticated user (Contributor+)"]
--> B["Click Duplicate link or craft URL manually"]
B --> C["Request: /wp-admin/post.php?action=mptt_duplicate_event&post={target_post_id}"]
C --> D["WordPress loads post.php"]
D --> E["do_action('post_action_mptt_duplicate_event', post_id)"]
E --> F["post_action_mptt_duplicate_event(post_id)"]
F --> G["get_post(post_id) without ownership check"]
G --> H["Check nonce + current_user_can('edit_posts')"]
H --> I["Permission granted (generic capability)"]
I --> J["Duplicate target post (content, meta, taxonomy, custom table)"]
J --> K["Create new draft owned by attacker"]
K --> L["Redirect to edit screen of duplicated post"]

{{< /mermaid >}}

## Proof of Concept (PoC)

1. Login with a Contributor account
2. Access `Timetable` > `Events` and click `Duplicate` on any event

## Conclusion

The vulnerability stems from the plugin only checking the general `edit_posts` permission when duplicating an event, instead of checking permissions on the **specific post**. Since the `post_action_*` hook is not automatically protected by WordPress, low-privileged users (Contributors) can change the `post` ID in the URL to duplicate events they do not own, leading to IDOR. The patch fixes this by using the `edit_post` meta capability, forcing WordPress to verify permissions on each post.

## Key Takeaways

* `edit_posts` is not suitable for protecting operations on specific posts
* Nonce is not a substitute for permission checks
* IDs taken from requests are always user-controlled
* Always use `current_user_can( 'edit_post', $post_id )` when operating on a post
* The `post_action_*` hook requires the plugin to control authorization itself

## References

[IDOR](https://book.hacktricks.wiki/en/pentesting-web/idor.html)

[WordPress Timetable and Event Schedule Plugin <= 2.4.15 is vulnerable to Insecure Direct Object References (IDOR)](https://patchstack.com/database/wordpress/plugin/mp-timetable/vulnerability/wordpress-timetable-and-event-schedule-plugin-2-4-16-contributor-event-disclosure-via-idor-vulnerability)
